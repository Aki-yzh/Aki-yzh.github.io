<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>应用层-DNS,电子邮件</title>
    <link href="/2023/09/26/%E5%BA%94%E7%94%A8%E5%B1%82-DNS%EF%BC%8C%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6/"/>
    <url>/2023/09/26/%E5%BA%94%E7%94%A8%E5%B1%82-DNS%EF%BC%8C%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p> 对应 北京大学计算机网络课程第二讲第二部分<br> 参考教材计算机网络-自顶向下方法</p><span id="more"></span><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="应用层-DNS-电子邮件"><a href="#应用层-DNS-电子邮件" class="headerlink" title="应用层-DNS,电子邮件"></a>应用层-DNS,电子邮件</h2><h3 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h3><h3 id="电子邮件服务"><a href="#电子邮件服务" class="headerlink" title="电子邮件服务"></a>电子邮件服务</h3><p>$\quad$·电子邮件（E-mail）是自早期Internet出现以来最广泛的应用，是一种异步通讯媒介<br>$\quad$·优越性<br>$\quad$$\quad$·比纸质信件更快更便宜<br>$\quad$$\quad$·使用门槛低<br>$\quad$$\quad$·收件人可随时上网到自己邮箱读取邮件<br>$\quad$$\quad$·电子邮件不仅可传送文字信息，而且还可附上声音和图像等</p><h4 id="电子邮件体系结构"><a href="#电子邮件体系结构" class="headerlink" title="电子邮件体系结构"></a>电子邮件体系结构</h4><p>$\quad$·采用客户&#x2F;服务器工作模式<br>$\quad$$\quad$·用户代理（user agent）——邮件客户端：编辑和发送邮件，接收、读取和管理邮件，管理地址簿；无统一标准<br>$\quad$$\quad$·传送代理（message transfer agent）——邮件服务器：邮箱：保存用户收到的邮件，邮件输出队列：存储等待发送的邮件；运行电子邮件协议<br>$\quad$$\quad$$\quad$·邮箱是邮件服务器中的一块内存区域，其标识即为电子邮件地址（邮箱名）<br>$\quad$$\quad$$\quad$·电子邮件地址是一个字符串，用于指定邮件接收者<br>$\quad$$\quad$·简单邮件传输协议SMTP（Simple Mail Transfer  Protocol）——邮件服务器之间传递邮件使用的协议：smtp客户: 发送邮件端；smtp服务器: 接收邮件端<br>$\quad$$\quad$$\quad$·SMTP利用TCP可靠地从客户向服务器传递邮件，使用端口25<br>$\quad$$\quad$$\quad$·直接投递: 发送端直接到接收端<br>$\quad$$\quad$$\quad$·SMTP的3个阶段：连接建立、邮件传送、连接关闭<br>$\quad$$\quad$$\quad$·SMTP是一个简单的ASCII协议，邮件必须为7位ASCII<br><img src="/../CNP/CN201.png"><br>$\quad$$\quad$·命令&#x2F;响应<br>$\quad$$\quad$$\quad$·命令: ASCII字符串<br>$\quad$$\quad$$\quad$·响应: 状态码+短语</p><h4 id="相关协议"><a href="#相关协议" class="headerlink" title="相关协议"></a>相关协议</h4><h5 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h5><p>$\quad$·客户端发送的行用”C:”标识，服务发送的行用”S:”标识<br>$\quad$·来自客户的第一条命令HELO<br>$\quad$·RCPT命令可以将一个邮件发送给多个收件人，此处只有一个收件人，只使用一个RCPT命令</p><h6 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h6><p>$\quad$·Alice使用用户代理撰写发送给 Bob的邮件<br>$\quad$·Alice的用户代理发送邮件到她的邮件服务器；邮件存放在邮件队列<br>$\quad$·SMTP客户端建立与SMTP邮件服务器的TCP连接<br>$\quad$·SMTP客户端通过TCP连接发送Alice的邮件<br>$\quad$·Bob的邮件服务器把邮件存放在Bob的邮箱<br>$\quad$·Bob调用他的用户代理来读取邮件</p><h6 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h6><p>$\quad$·不包括认证<br>$\quad$·传输ASCII而不是二进制数据<br>$\quad$·邮件以明文形式出现</p><h5 id="邮件格式"><a href="#邮件格式" class="headerlink" title="邮件格式"></a>邮件格式</h5><p>$\quad$·SMTP定义了如何传输邮件，但邮件本身也需遵循特定格式<br>$\quad$$\quad$·SMTP类似HTTP，定义如何传输邮件<br>$\quad$$\quad$·邮件格式类似HTML，定义如何描述邮件<br>$\quad$·首部（header）必须含有一个From:首部行和一个To:首部行，还可以包含 Subject: 等其他可选的首部行<br>$\quad$·消息体（body）指邮件正文<br>$\quad$·MIME(Multipurpose Internet Mail Extensions)—多用途Internet邮件扩展<br>$\quad$$\quad$·基本格式的多媒体扩展<br>$\quad$$\quad$·可传输多媒体消息和二进制文件</p><h5 id="最后传递协议"><a href="#最后传递协议" class="headerlink" title="最后传递协议"></a>最后传递协议</h5><p>$\quad$·邮件已经到达Bob的邮箱，接下来的工作就是将邮件的一个副本传送到Bob的用户代理以便显示<br>$\quad$·最终交付（邮件访问）协议: 从邮件服务器的邮箱中获取邮件<br>$\quad$$\quad$·POP3：Post Office Protocol-Version 3，第三版邮局协议<br>$\quad$$\quad$·IMAP：Internet Message Access Protocol，Internet邮件访问协议<br>$\quad$$\quad$·Webmail（HTTP）：基于Web的电子邮件<br>$\quad$$\quad$·为什么不能使用SMTP获取邮件？<br>$\quad$$\quad$$\quad$·接收方的用户代理不能使用 SMTP 从传输代理获取邮件，因为取邮件是一个拉操作<br>$\quad$$\quad$$\quad$·而 SMTP 是一个推协议，需要推送目标在线<br>$\quad$$\quad$$\quad$·通过引入最终交付（邮件访问）协议来解决这个问题。</p><h6 id="POP3协议"><a href="#POP3协议" class="headerlink" title="POP3协议"></a>POP3协议</h6><p>$\quad$·POP3由RFC1939定义，是一个非常简单的最终交付协议<br>$\quad$·当用户代理打开一个到端口110上的TCP连接后，客户&#x2F;服务器开始工作<br>$\quad$·POP3的三个阶段：<br>$\quad$$\quad$·认证(Authorization)：处理用户登录的过程<br>$\quad$$\quad$·事务处理(Trnsactions)：用户收取电子邮件，并将邮件标记为删除<br>$\quad$$\quad$·更新(Update)：将标为删除的电子邮件删除<br>$\quad$·POP3使用客户&#x2F;服务器工作方式，在接收邮件的用户PC机中必须运行POP客户程序，而在用户所连接的ISP的邮件服务器中则运行POP服务器程序</p><h6 id="IMAP"><a href="#IMAP" class="headerlink" title="IMAP"></a>IMAP</h6><p>$\quad$·IMAP—Internet邮件访问协议[RFC 2060]<br>$\quad$·用于最终交付的主要协议<br>$\quad$·IMAP是较早使用的最终交付协议—POP3(邮局协议，版本3)的改进版<br>$\quad$·邮件服务器运行侦听端口143的IMAP服务器<br>$\quad$·用户代理运行一个IMAP客户端<br>$\quad$·客户端连接到服务器并开始发出命令<br>Ø$\quad$·MAP允许用户在不同的地方使用不同的计算机随时上网阅读和处理自己的邮件<br>$\quad$·IMAP服务器把每个邮件与一个文件夹联系起来，<br>$\quad$$\quad$·当邮件第一次到达服务器时，它与收件人的INBOX文件夹相关联<br>$\quad$$\quad$·收件人能够把邮件移到一个新的、用户创建的文件夹中，阅读邮件，删除邮件等<br>$\quad$·IMAP还为用户提供了在远程文件夹中查询邮件的命令，按指定条件去查询匹配的邮件<br>$\quad$·与POP3不同，IMAP服务器维护了用户状态信息<br>$\quad$$\quad$·例如，文件夹的名字以及哪些邮件与哪些文件夹相关联<br>$\quad$·IMAP具有允许用户代理获取邮件某些部分的命令<br>$\quad$$\quad$·例如，一个用户代理可以只读取一个邮件的首部，或只是一个多部分MIME邮件的一部分<br>$\quad$·用户代理和其邮件服务器之间使用低带宽连接（如一个低速调制解调器链路）的时候，用户可能并不想取回邮箱中的所有邮件，其要避免可能包含如音频或视频片断的大邮件<br>$\quad$·IMAP的缺点是如果用户没有将邮件复制到自己的PC上，则邮件一直是存放在IMAP服务器上。因此用户需要经常与IMAP服务器建立连接</p><h6 id="Webmail"><a href="#Webmail" class="headerlink" title="Webmail"></a>Webmail</h6><p>$\quad$·Webmail——基于Web的电子邮件<br>$\quad$$\quad$·提供电子邮件服务的IMAP和SMTP替代方案<br>$\quad$$\quad$·使用Web作为界面，用户代理就是普通的浏览器<br>$\quad$$\quad$·用户及其远程邮箱之间的通信通过HTTP进行<br><img src="/../CNP/CN202.png"></p><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>CN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CN</tag>
      
      <tag>应用层</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器人学部分</title>
    <link href="/2023/09/24/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E9%83%A8%E5%88%86/"/>
    <url>/2023/09/24/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p>利用正运动学以及空间变换控制舵机</p><span id="more"></span><h1 id="机器人学基础"><a href="#机器人学基础" class="headerlink" title="机器人学基础"></a>机器人学基础</h1><h2 id="空间描述和变换"><a href="#空间描述和变换" class="headerlink" title="空间描述和变换"></a>空间描述和变换</h2><p>$\quad$·存在一个世界坐标系,讨论任何问题都是基于这个坐标系<br>$\quad$·一旦建立了坐标系,我们就能用一个3x1的位置矢量给世界坐标系中的任何点定位<br>旋转矩阵：</p><p><img src="/../FMCWmg/UCS1.png"></p><p>舵机的旋转即为Z-X-Y欧拉角</p><p>$\quad$ 首先将坐标系{B}和一个已知参考坐标系{A}重合。先将{B}绕$Z_B$转$\alpha$角度，再<br>绕$Y_B$旋转$\beta$ 角，最后绕着$X_B$ 旋转y角<br><img src="/../FMCWmg/UCS2.png"><br>matlab中可以通过rotx()，roty()，rotz()函数计算旋转矩阵</p><h2 id="实物坐标系建立"><a href="#实物坐标系建立" class="headerlink" title="实物坐标系建立"></a>实物坐标系建立</h2><p><img src="/../FMCWmg/UCS3.png"><br><img src="/../FMCWmg/UCS4.png"><br>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><br>%坐标系变换<br><br>%R为雷达测出的距离，angle_PSI,angle_THETA为雷达测出的角度<br><br>%angle_1，angle_2为舵机目前的角度<br><br>%L为舵机<span class="hljs-number">1</span>转轴的长度<br><br>%P_A=Rotate*（P_B+P） 先平移再旋转<br><br>%%<br><br>L = <span class="hljs-number">50</span>;<br><br>Rotate = rotz(angle_2)*roty(<span class="hljs-number">0</span>)*rotx(angle_1);%Z-Y-X欧拉角<br><br>P_MOVE1= [<span class="hljs-number">0</span>;<span class="hljs-number">0</span>;L];<br><br>P_B_x = R * <span class="hljs-built_in">cos</span>(angle_PSI) * <span class="hljs-built_in">sin</span>(angle_THETA);<br><br>P_B_y = R * <span class="hljs-built_in">cos</span>(angle_PSI) * <span class="hljs-built_in">cos</span>(angle_THETA);<br><br>P_B_z = R * <span class="hljs-built_in">sin</span>(angle_PSI);<br><br>P_B = [P_B_x;P_B_y;P_B_z];%<span class="hljs-number">3</span>号（雷达）坐标系下的坐标<br><br>%%<br><br>P_A = Rotate * (P_B - P_MOVE1);%得到<span class="hljs-number">2</span>号坐标系下的坐标<br><br>%%<br><br>P_MOVE2=[<span class="hljs-number">-45</span>;<span class="hljs-number">-75</span>;<span class="hljs-number">-100</span>];<br><br>P_0 = P_A + P_MOVE2;% <span class="hljs-number">1</span>号坐标系下的坐标<br><br>%%<br><br>% P_A = ;<br><br>angle_2_new = <span class="hljs-built_in">atan</span>(P_A(<span class="hljs-number">1</span>)/P_A(<span class="hljs-number">2</span>));%舵机<span class="hljs-number">2</span>要调整到的角度<br><br>temp = <span class="hljs-built_in">sqrt</span>(P_A(<span class="hljs-number">1</span>)*P_A(<span class="hljs-number">1</span>)+P_A(<span class="hljs-number">2</span>)+P_A(<span class="hljs-number">2</span>));<br><br>angle_1_new = <span class="hljs-built_in">atan</span>(P_A(<span class="hljs-number">3</span>)/temp);%舵机<span class="hljs-number">1</span>要调整到的角度<br><br>disp(angle_1_new);<br><br>disp(angle_2_new);<br><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>CS科研</category>
      
      <category>树莓派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树莓派</tag>
      
      <tag>机器人学</tag>
      
      <tag>舵机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>应用层-Web与HTTP</title>
    <link href="/2023/09/22/%E5%BA%94%E7%94%A8%E5%B1%82-Web%E4%B8%8EHTTP/"/>
    <url>/2023/09/22/%E5%BA%94%E7%94%A8%E5%B1%82-Web%E4%B8%8EHTTP/</url>
    
    <content type="html"><![CDATA[<p> 对应 北京大学计算机网络课程第二讲第一部分<br> 参考教材计算机网络-自顶向下方法</p><span id="more"></span><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="应用层-Web与HTTP"><a href="#应用层-Web与HTTP" class="headerlink" title="应用层-Web与HTTP"></a>应用层-Web与HTTP</h2><p>$\quad$·不同主机上的程序之间通过网络应用层完成交互<br>$\quad$·典型的应用层服务：语音通话，在线会议，社交网络，搜索引擎，信息推送Web访问，文件传输，电子邮件，即时通讯，远程登陆，P2P文件共享，在线游戏，流媒体。。。。。。。</p><h5 id="应用层与下层网络（传输层）接口"><a href="#应用层与下层网络（传输层）接口" class="headerlink" title="应用层与下层网络（传输层）接口"></a>应用层与下层网络（传输层）接口</h5><p>$\quad$·应用程序在端系统上以进程的形式呈现<br>$\quad$·进程利用socket（套接字）发送&#x2F;接收消息（通过传输层）<br>$\quad$·socket类似一扇门：从门中向外发送消息，从其他进程收到的消息堆积在门口等待接收<br>$\quad$·希望传输层提供的服务：可靠传输，高吞吐，低时延，安全</p><h6 id="实际传输层提供的服务"><a href="#实际传输层提供的服务" class="headerlink" title="实际传输层提供的服务"></a>实际传输层提供的服务</h6><p>$\quad$·TCP服务<br>$\quad$$\quad$·面向连接：传输前建立连接<br>$\quad$$\quad$·可靠传输：丢包重传<br>$\quad$$\quad$·有序传输<br>$\quad$$\quad$·流量控制：防止接收端过载<br>$\quad$$\quad$· 拥塞控制：防止网络核心过载<br>$\quad$$\quad$·无法保证：延迟，吞吐，安全<br>$\quad$·UDP服务<br>$\quad$$\quad$·无连接<br>$\quad$$\quad$· 不可靠传输：可能丢包，丢包也无法回复<br>$\quad$$\quad$· 无法保证：可靠性，顺序，流量控制，拥塞控制，延迟，吞吐量，安全<br>$\quad$$\quad$· 问：为什么还有UDP：简单，性能好</p><h4 id="网络应用层的好处："><a href="#网络应用层的好处：" class="headerlink" title="网络应用层的好处："></a>网络应用层的好处：</h4><p>$\quad$·屏蔽底层细节<br>$\quad$$\quad$·设计应用层程序时，需要考虑到TCP与UDP的性质<br>$\quad$$\quad$·应用程序无需为下层网络设备编写代码<br>$\quad$·抽象：许多网络应用有相同的通信模式，网络应用层封装这些共同模式<br>$\quad$·提供额外的功能：如安全性<br>·总之网络应用层极大简化了网络应用开发，使得互联网可以快速发展</p><h4 id="应用层的通信实体"><a href="#应用层的通信实体" class="headerlink" title="应用层的通信实体"></a>应用层的通信实体</h4><p>$\quad$·应用层的实体就是应用程序<br>$\quad$·我们可以给网络中的每台主机命名<br>$\quad$$\quad$·网卡MAC地址<br>$\quad$$\quad$·IP地址<br>$\quad$$\quad$·主机名<br>$\quad$·每个主机的命名仍然不够<br>$\quad$·对于接收到的消息，需要区分是发给哪个应用程序<br>$\quad$$\quad$·单个主机上可能运行多个应用程序<br>$\quad$$\quad$·单个应用程序也可能创建多个连接（socket）<br>$\quad$·解决方案：为每个应用以IP地址+端口号命名<br>$\quad$$\quad$·HTTP服务器：80<br>$\quad$$\quad$·邮件服务器：25</p><h4 id="应用层的组织架构"><a href="#应用层的组织架构" class="headerlink" title="应用层的组织架构"></a>应用层的组织架构</h4><p>$\quad$·应用程序以两种方法组织:</p><h5 id="客户-x2F-服务器方式（C-x2F-S）"><a href="#客户-x2F-服务器方式（C-x2F-S）" class="headerlink" title="客户&#x2F;服务器方式（C&#x2F;S）"></a>客户&#x2F;服务器方式（C&#x2F;S）</h5><p>$\quad$·应用层的许多协议是基于C&#x2F;S方式<br>$\quad$·客户端与服务器是指通信中所涉及的两个应用进程<br>$\quad$·客户、服务器方式描述的是应用进程之间服务与被服务之间的关系<br>$\quad$·客户是服务请求方，服务器是服务提供方<br><img src="/../CNP/CN101.png"><br>$\quad$·分层视角：<br><img src="/CNP/CN102.png"></p><h6 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h6><p>$\quad$·根据是否建立连接：<br>$\quad$$\quad$·可以是面向连接的，也可以是无连接的<br>$\quad$$\quad$·面向连接时，C&#x2F;S通信关系一旦建立，通信就是双向的，都可发送和接收数据<br>$\quad$·根据服务器进程的实现方式<br>$\quad$$\quad$·服务器采用<strong>循环方式(iterative mode)</strong><br>$\quad$$\quad$$\quad$·一次只运行一个服务进程<br>$\quad$$\quad$$\quad$·一个服务进程在同一时间只能向一个客户端提供服务<br>$\quad$$\quad$$\quad$·服务进程收到客户进程的请求后，对其他客户进程发来的请求则暂时不予理睬，这些请求都在服务端的队列中排队等候服务进程的处理当服务进程处理完毕一个请求时，就从队列中读取来自下一个客户进程的请求，然后继续处理<br>$\quad$$\quad$$\quad$·当有多个客户进程请求服务时，服务进程就按请求的先后顺序依次做出响应 (阻塞方式)<br>$\quad$$\quad$$\quad$·面向连接的TCP与无连接的UDP都可以用<br><img src="/../CNP/CN103.png"></p><p><img src="/../CNP/CN104.png"></p><p>$\quad$$\quad$·服务器采用<strong>并发方式(concurrent mode)</strong><br>$\quad$$\quad$$\quad$·可以同时运行多个服务进程<br>$\quad$$\quad$$\quad$·每一个服务进程都对某个特定的客户进程做出响应 (非阻塞方式)<br>$\quad$$\quad$$\quad$·通常只有面向连接的TCP使用<br>$\quad$$\quad$$\quad$·面向连接的TCP服务进程通常都工作在并发服务方式（尽管也可以使用循环方式）<br>$\quad$$\quad$$\quad$·服务进程在同一时间可同时向多个客户进程提供服务(并发服务)<br>$\quad$$\quad$$\quad$·在TCP服务进程与多个客户进程之间建立多条TCP连接，每条TCP连接在其数据传送完毕后释放<br>$\quad$$\quad$$\quad$·具体流程<br>$\quad$$\quad$$\quad$$\quad$·服务器监听一个（熟知）服务端口，如HTTP的80端口<br>$\quad$$\quad$$\quad$$\quad$·主服务进程在熟知端口等待客户进程发出的请求<br>$\quad$$\quad$$\quad$$\quad$·一旦收到客户的请求，就创建一个从属服务进程，并指明从属服务进程使用临时套接字（又称连接套接字）与该客户建立TCP连接<br>$\quad$$\quad$$\quad$$\quad$·然后主服务进程继续在原来的熟知端口等待向其他客户提供服务<br><img src="/../CNP/CN105.png"></p><p>$\quad$·为什么无连接的UDP只能采用循环方式，无法采用并发方式<br>$\quad$·原因：无连接UDP只有一个套接字，无法被多个从属进程同时访问</p><p>$\quad$·对比：<br><img src="/../CNP/CN106.png"></p><h6 id="特例：浏览器-x2F-服务模式："><a href="#特例：浏览器-x2F-服务模式：" class="headerlink" title="特例：浏览器&#x2F;服务模式："></a>特例：浏览器&#x2F;服务模式：</h6><p>$\quad$·浏览器&#x2F;服务器(B&#x2F;S，Browser&#x2F;Server) 方式可以看做C&#x2F;S方式的特例，即客户软件改为浏览器了<br>$\quad$·B&#x2F;S方式采取浏览器请求、服务器响应的工作模式<br>$\quad$·在B&#x2F;S方式下，用户界面完全通过Web浏览器实现，一部分事务逻辑在服务器前端实现，但主要的事务逻辑在服务器后端实现<br><img src="/../CNP/CN107.png"><br>$\quad$·B&#x2F;S方式通常采取3层架构实现<br>$\quad$$\quad$·数据层：由数据库服务器承担数据处理逻辑，其任务是接受Web服务器对数据库服务器提出的数据操作请求，然后由数据库服务器进行数据处理并把处理结果返回给web服务器<br>$\quad$$\quad$·处理层：由Web服务器承担业务处理逻辑和页面存储管理，接受客户浏览器的任务请求，执行相应的事务处理<br>$\quad$$\quad$·表现层：浏览器仅承担网页信息的浏览功能, 以超文本格式实现信息的输入和浏览<br><img src="/../CNP/CN108.png"></p><h5 id="对等方式（P2P）"><a href="#对等方式（P2P）" class="headerlink" title="对等方式（P2P）"></a>对等方式（P2P）</h5><p>$\quad$·对等方式是指两个进程在通信时并不区分服务的请求方和服务的提供方<br>$\quad$$\quad$·只要两个主机都运行P2P软件，它们就可以进行平等、对等的通信<br>$\quad$$\quad$·双方都可以下载对方存储在硬盘中的共享文档，如果权限允许的话<br>$\quad$·应用<br>$\quad$$\quad$·音频&#x2F;视频应用推动了P2P对等通信方式的发展<br>$\quad$$\quad$·音频&#x2F;视频流量已占主要比例<br>$\quad$·P2P方式从本质上看仍然是使用了C&#x2F;S方式，但强调的是通信过程中的对等，这时每一个P2P进程既是客户同时也是服务器<br><img src="/../CNP/CN109.png"></p><h6 id="P2P实体的特征"><a href="#P2P实体的特征" class="headerlink" title="P2P实体的特征"></a>P2P实体的特征</h6><p>$\quad$·不需要总是在线<br>$\quad$$\quad$·虽然每个程序也扮演服务器角色，但与“客户端-服务器”中不同，不需要始终在线<br>$\quad$·实体可以随时进入与退出<br>$\quad$$\quad$·可以动态改变IP地址<br>$\quad$$\quad$·需要额外的管理开销<br>$\quad$·任意两个实体之间可以直接通信<br>$\quad$·易于扩展<br>$\quad$$\quad$·每个结点都贡献自己的计算资源，也消耗一部分资源</p><h4 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h4><p>$\quad$·应用层的实体就是应用协议<br>$\quad$$\quad$·通信内容：某个约定好的应用层协议<br>$\quad$·每个应用层协议都是为了解决某一应用问题，通过位于不同主机中的多个应用程序之间的通信和协同工作来完成<br><img src="/../CNP/CN110.png"></p><h5 id="Web基本协议"><a href="#Web基本协议" class="headerlink" title="Web基本协议"></a>Web基本协议</h5><p>$\quad$·WWW&#x3D;World Wide Web<br>$\quad$·构成：Web对象（网页，多媒体资源，动态对象与服务），通过URLs定位；HTTP服务器和客户端；服务器与客户端之间执行的HTTP协议<br><img src="/../CNP/CN111.png"></p><h6 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h6><p>$\quad$·Web页面（HTML文档）：包含到多种对象或链接<br>$\quad$·Web对象（包括静态对象和动态对象）：可以是HTML文档，图像文件，视频文件，声音文件，脚本文件等<br>$\quad$·对象用URL（统一资源定位符）编址：协议类型:&#x2F;&#x2F;主机名：端口&#x2F;&#x2F;路径和文件名<br><img src="/../CNP/CN113.png"></p><h6 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h6><p>$\quad$·发出请求，接收响应，解释HTML文档并显示<br>$\quad$·有些对象需要浏览器安装插件<br><img src="/../CNP/CN112.png"></p><h6 id="Web对象"><a href="#Web对象" class="headerlink" title="Web对象"></a>Web对象</h6><p>$\quad$·静态对象与静态网页<br>$\quad$$\quad$·文本，表格，图片，图像和视频等多媒体类型的信息（实现语言：标记语言，如：HTML，XML，PHP等）<br>$\quad$$\quad$·字体、颜色和布局等风格类型的信息（实现语言：层叠样式表CSS）<br>$\quad$·动态对象与动态网页<br>$\quad$$\quad$·交互信息，比如，用户注册信息、登录信息等（实现：PHP&#x2F;JSP等语言+MySQL等数据库）<br>$\quad$·链接：<br>$\quad$$\quad$·超链接（HyperLinks）：指向其他对象的URLs<br><img src="/../CNP/CN114.png"><br>$\quad$·动态Web<br>$\quad$$\quad$·通用网关接口CGI<br>$\quad$$\quad$$\quad$·CGI (Common Gateway Interface) 是一种标准<br>$\quad$$\quad$$\quad$$\quad$·在服务器创建动态文档<br>$\quad$$\quad$$\quad$$\quad$·定义了动态文档应如何创建<br>$\quad$$\quad$$\quad$$\quad$·输入数据应如何提供给应用程序<br>$\quad$$\quad$$\quad$$\quad$·输出结果应如何使用<br><img src="/../CNP/CN115.png"><br>$\quad$$\quad$·脚本语言+数据库技术<br>$\quad$$\quad$$\quad$·更好的服务器逻辑表示“脚本”指的是一个程序，它被另一个程序（即解释程序，如Web浏览器）解释执行，而不是由计算机的处理器来解释或执行<br>$\quad$$\quad$$\quad$·数据库：更好的数据交换方式<br>$\quad$$\quad$·动态页面的创建，可以在浏览器or &#x2F;and 服务器进行</p><p><img src="/../CNP/CN116.png"><br>$\quad$$\quad$·动态Web的执行:Web内容展示（前端）和服务逻辑（后端）相分离；脚本程序可以在服务器或客户端创建Web文档<br>$\quad$$\quad$·AJAX技术（Asynchronous JavaScript and XML）：超文本标记语言HTML+CSS：用于Web网页内容的显示<br>$\quad$$\quad$$\quad$·文档对象模型DOM:是HTML和XML文档的编程接口，本质上是页面的API，采用树形结构组织。<br>$\quad$$\quad$$\quad$·扩展标记语言XML：用于程序和服务器交换应用数据<br>$\quad$$\quad$$\quad$·异步式工作方式：用于发送和检索XML数据<br>$\quad$$\quad$$\quad$·JavaScript：用于将以上功能进行组合并协同工作<br>$\quad$$\quad$·AJAX不是新的编程语言，而是一种使用现有标准的新方法<br>$\quad$$\quad$·LAMP&#x3D;Linux+Apache+MySQL+PHP<br>$\quad$$\quad$·LAMP不是新的工具，而是一套Web服务器软件集合</p><h5 id="HTTP协议："><a href="#HTTP协议：" class="headerlink" title="HTTP协议："></a>HTTP协议：</h5><p>$\quad$·超文本传输协议HTTP（HyperText Transfer Protocol）在传输层通常使用TCP协议，缺省使用TCP的80端口<br>$\quad$·HTTP为无状态协议，服务器端不保留之前请求的状态信息<br>$\quad$$\quad$·无状态协议：效率低，但简单<br>$\quad$$\quad$·有状态协议：维护状态相对复杂，需要维护历史信息，在客户端或服务器出现故障时，需要保持状态的一致性等。</p><h6 id="HTTP发展现状"><a href="#HTTP发展现状" class="headerlink" title="HTTP发展现状"></a>HTTP发展现状</h6><p><img src="/../CNP/(1)CN111.png"></p><h6 id="HTTP1-0"><a href="#HTTP1-0" class="headerlink" title="HTTP1.0"></a>HTTP1.0</h6><p><img src="/../CNP/(1)CN112.png"></p><h6 id="非持久连接和持久连接"><a href="#非持久连接和持久连接" class="headerlink" title="非持久连接和持久连接"></a>非持久连接和持久连接</h6><p>$\quad$·非持久连接<br>$\quad$$\quad$·HTTP&#x2F;1.0缺省为非持久连接<br>$\quad$$\quad$$\quad$·服务器接收请求、响应、关闭TCP连接<br>$\quad$$\quad$·获取每个对象需要三个阶段<br>$\quad$$\quad$$\quad$·建立TCP连接<br>$\quad$$\quad$$\quad$·对象请求和传输<br>$\quad$$\quad$$\quad$·关闭TCP连接<br>$\quad$$\quad$·每次连接需要经历TCP慢启动阶段<br>$\quad$·持久连接<br>$\quad$$\quad$·HTTP&#x2F;1.1缺省为持久连接<br>$\quad$$\quad$$\quad$·在相同的TCP连接上，服务器接收请求、响应；再接收请求、响应；响应后保持连接<br>$\quad$$\quad$·HTTP&#x2F;1.1-pipeline 支持流水线机制<br>$\quad$$\quad$$\quad$·需要按序响应<br>$\quad$$\quad$·经历较少的慢启动过程，减少往返时间<br>$\quad$$\quad$$\quad$·降低响应时间</p><h6 id="HTTP1-x"><a href="#HTTP1-x" class="headerlink" title="HTTP1.x"></a>HTTP1.x</h6><p><img src="/../CNP/(1)CN113.png"></p><h6 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h6><p>$\quad$·2015年5月，以RFC 7540正式发布<br>$\quad$·多路复用<br>$\quad$$\quad$·HTTP 1.1：一个请求的响应收到后，才能发送下一个请求<br>$\quad$$\quad$·HTTP 1.1-pipeline：可以同时发送多个请求，但要按顺序响应<br>$\quad$$\quad$·HTTP 2：请求&#x2F;响应允许交错，还可以自定义优先级<br>$\quad$·压缩<br>$\quad$·HTTP 2：服务器可以主动推送消息<br>$\quad$$\quad$·确认客户端存活<br>$\quad$$\quad$·预测资源请求<br>$\quad$·流量控制<br>$\quad$$\quad$·HTTP 1.1：完全依赖TCP<br>$\quad$$\quad$·HTTP 2：允许应用层进行控制</p><h6 id="HTTP3"><a href="#HTTP3" class="headerlink" title="HTTP3"></a>HTTP3</h6><p>$\quad$·2022年6月以RFC 9114发布<br>$\quad$$\quad$·同时，HTTP 2更新至RFC 9113<br>$\quad$·主要是传输层变化，与应用层关系不大<br>$\quad$$\quad$·将TCP替换为UDP + QUIC<br>$\quad$$\quad$·（将在传输层章节介绍）</p><h6 id="HTTP请求报文结构"><a href="#HTTP请求报文结构" class="headerlink" title="HTTP请求报文结构"></a>HTTP请求报文结构</h6><p>$\quad$·请求报文由三个部分组成，即开始行、首部行和实体主体<br>$\quad$·在请求报文中，开始行又称请求行<br>$\quad$·方法是对所请求的对象进行的操作，实际上也就是一些命令<br>$\quad$·请求报文的类型是由它所采用的方法决定的<br>$\quad$·URL是所请求资源的URL（有时URL会带一些参数，参数以“?”开始，每个参数的形式为“name&#x3D;value”，参数之间以“&amp;”隔开）<br><img src="/../CNP/(1)CN114.png"><br><img src="/../CNP/(1)CN115.png"><br><img src="/../CNP/(1)CN116.png"></p><h6 id="HTTP响应报文结构"><a href="#HTTP响应报文结构" class="headerlink" title="HTTP响应报文结构"></a>HTTP响应报文结构</h6><p>$\quad$·与请求报文类似，由三个部分组成，即开始行、首部行和实体主体<br>$\quad$·在响应报文中，开始行又称状态行<br>$\quad$·状态码都是三位数字<br>$\quad$$\quad$·1xx 表示通知信息的，如请求收到了或正在进行处理。<br>$\quad$$\quad$·2xx 表示成功，如接受或知道了。<br>$\quad$$\quad$·3xx 表示重定向，表示要完成请求还必须采取进一步的行动。<br>$\quad$$\quad$·4xx 表示客户的差错，如请求中有错误的语法或不能完成。<br>$\quad$$\quad$·5xx 表示服务器的差错，如服务器失效无法完成请求。<br>$\quad$$\quad$·典型的状态码<br>$\quad$$\quad$$\quad$·200 OK<br>$\quad$$\quad$$\quad$$\quad$·请求成功，被请求的对象包含在该响应的数据部分<br>$\quad$$\quad$$\quad$·301 Moved Permanently<br>$\quad$$\quad$$\quad$$\quad$·请求的对象被移走，新的位置在响应中通过Location: 给出<br>$\quad$$\quad$$\quad$·400 Bad Request<br>$\quad$$\quad$$\quad$$\quad$·服务器不能解释请求报文<br>$\quad$$\quad$$\quad$·404 Not Found<br>$\quad$$\quad$$\quad$$\quad$·服务器中找不到请求的文档<br>$\quad$$\quad$$\quad$·505 HTTP Version Not Supported<br>$\quad$$\quad$$\quad$$\quad$·服务器不支持相应的HTTP版本<br><img src="/../CNP/CN117.png"></p><h6 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h6><p>$\quad$·浏览器缓存<br>$\quad$$\quad$·在浏览器主机保存用户访问过的服务器Web页副本<br>$\quad$$\quad$·再次访问该页，不必从服务器再次传输，提高访问效率<br><img src="/../CNP/CN118.png"><br>$\quad$·代理服务器缓存<br>$\quad$$\quad$·目标：代理服务器缓存已访问过的Web页副本，满足用户浏览器从代理服务器提取Web页，尽量减少原始服务器参与<br>$\quad$$\quad$·设置用户浏览器，通过代理服务器进行Web访问<br>$\quad$$\quad$·浏览器将所有的HTTP请求发送到代理服务器<br>$\quad$$\quad$$\quad$·如果缓存中有被请求的对象，则直接返回对象<br>$\quad$$\quad$$\quad$·否则，代理服务器向原始服务器请求对象，再将对象返回给客户端<br>$\quad$$\quad$·性能分析：<br><img src="/../CNP/CN119.png"><br><img src="/../CNP/CN120.png"><br>$\quad$$\quad$·Web缓存存在的困难，即Web缓存与原始服务器Web页一致性问题<br>$\quad$$\quad$$\quad$·启发式策略（较少使用）：服务器响应Web页的Last-Modified头和Expires头<br>$\quad$$\quad$$\quad$·询问式策略（常用）：通过特殊的关键字头询问原始服务器，Web副本是否已更新<br><img src="/../CNP/CN121.png"></p><h6 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h6><p><img src="/../CNP/CN122.png"><br><img src="/../CNP/CN123.png"><br>$\quad$·Cookies一般包含5个字段<br>$\quad$$\quad$·域指明Cookie来自何方，每个域为每个客户分配Cookie有数量限制<br>$\quad$$\quad$·路径标明服务器的文件树中哪些部分可以使用该Cookie<br>$\quad$$\quad$·内容采用“名字&#x3D;值”的形式，是Cookie存放内容的地方，可以达到4K容量，内容只是字符串，不是可执行程序<br>$\quad$$\quad$·安全指示浏览器只向使用安全传输连接的服务器返回Cookie<br><img src="/../CNP/CN124.png"><br>$\quad$$\quad$·Cookie文件保存的只是文本串，没有可执行程序</p><h6 id="访问安全"><a href="#访问安全" class="headerlink" title="访问安全"></a>访问安全</h6><p>$\quad$·Web访问安全<br>$\quad$$\quad$·并非所有Web页都会向公众开放<br>$\quad$$\quad$·Web服务器可以限定客户端访问的IP地址空间，比如限制只向公司内部员工开放<br>$\quad$$\quad$·Apache服务器将设置限制访问规则的文件.htaccess放置在被限制访问的页面所在的目录，客户端访问时进行规则匹配<br>$\quad$$\quad$·无状态：客户端需要在每个请求中携带认证信息<br>$\quad$$\quad$·认证方法：通常在HTTP请求中使用“用户名-密码”<br>$\quad$$\quad$·每个请求头中包含关键字authorization:<br>$\quad$$\quad$·如果请求头中无authorization: ，则服务器拒绝访问，并在响应头中包含WWW authenticate：<br><img src="/../CNP/CN125.png"></p><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>CN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CN</tag>
      
      <tag>应用层</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派PVM的使用</title>
    <link href="/2023/09/19/%E6%A0%91%E8%8E%93%E6%B4%BEPVM%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/09/19/%E6%A0%91%E8%8E%93%E6%B4%BEPVM%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>利用树莓派中python GPIO库实现</p><span id="more"></span><p>上方舵机角度范围为0～180<br>下方为0～270（角度高了点线会缠绕）<br>(可以为负数，但是超过了某范围会自动复位)<br>以下为代码</p><h4 id="RPI-GPIO"><a href="#RPI-GPIO" class="headerlink" title="RPI.GPIO"></a>RPI.GPIO</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs python">  <br><br><span class="hljs-keyword">import</span> RPi.GPIO <span class="hljs-keyword">as</span> GPIO<br><br><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> sleep<br><br>  <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">tonum1</span>(<span class="hljs-params">degree</span>): <span class="hljs-comment"># 用于处理角度转换的函数</span><br><br>dc = <span class="hljs-built_in">float</span>(degree)/<span class="hljs-number">18</span>+<span class="hljs-number">2.5</span><br><br><span class="hljs-keyword">return</span> dc<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">tonum</span>(<span class="hljs-params">degree</span>): <span class="hljs-comment"># 用于处理角度转换的函数</span><br><br>dc = <span class="hljs-built_in">float</span>(degree)/<span class="hljs-number">27</span>+<span class="hljs-number">2.5</span><br><br><span class="hljs-keyword">return</span> dc<br><br><span class="hljs-comment"># dc = 1/27*角度 + 2.5</span><br><br>  <br><br>servopin1 = <span class="hljs-number">17</span> <span class="hljs-comment">#舵机1,方向为左右转</span><br><br>servopin2 = <span class="hljs-number">18</span> <span class="hljs-comment">#舵机2,方向为上下转</span><br><br>  <br><br>GPIO.setmode(GPIO.BCM)<br><br>GPIO.setup(servopin1, GPIO.OUT, initial=<span class="hljs-literal">False</span>)<br><br>GPIO.setup(servopin2, GPIO.OUT, initial=<span class="hljs-literal">False</span>)<br><br>p1 = GPIO.PWM(servopin1,<span class="hljs-number">50</span>) <span class="hljs-comment">#50HZ</span><br><br>p2 = GPIO.PWM(servopin2,<span class="hljs-number">50</span>) <span class="hljs-comment">#50HZ</span><br><br>  <br><br>p1.start(tonum1(<span class="hljs-number">90</span>)) <span class="hljs-comment">#初始化角度</span><br><br>p2.start(tonum(<span class="hljs-number">40</span>)) <span class="hljs-comment">#初始化角度</span><br><br>sleep(<span class="hljs-number">0.5</span>)<br><br>p1.ChangeDutyCycle(<span class="hljs-number">0</span>) <span class="hljs-comment">#清除当前占空比，使舵机停止抖动</span><br><br>p2.ChangeDutyCycle(<span class="hljs-number">0</span>) <span class="hljs-comment">#清除当前占空比，使舵机停止抖动</span><br><br>sleep(<span class="hljs-number">0.1</span>)<br><br>  <br>  <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">left</span>(<span class="hljs-params">r</span>):<br><br><span class="hljs-comment"># if r &gt;= 0:</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前角度为&#x27;</span>,r)<br><br>p1.ChangeDutyCycle(tonum1(r)) <span class="hljs-comment">#执行角度变化</span><br><br>sleep(<span class="hljs-number">0.1</span>)<br><br>p1.ChangeDutyCycle(<span class="hljs-number">0</span>) <span class="hljs-comment">#清除当前占空比，使舵机停止抖动</span><br><br>sleep(<span class="hljs-number">0.01</span>)<br><br><span class="hljs-comment">#else:</span><br><br><span class="hljs-comment"># print(&#x27;\n**超出范围**\n&#x27;)</span><br><br><span class="hljs-comment"># r = 90</span><br><br><span class="hljs-comment"># p1.ChangeDutyCycle(tonum(r)) #执行角度变化</span><br><br><span class="hljs-comment"># sleep(0.1)</span><br><br><span class="hljs-comment"># p1.ChangeDutyCycle(0) #清除当前占空比，使舵机停止抖动</span><br><br><span class="hljs-comment"># sleep(0.01)</span><br><br>  <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">up</span>(<span class="hljs-params">l</span>):<br><br><span class="hljs-comment">#if l &gt; 0:</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前角度为&#x27;</span>,l)<br><br>p2.ChangeDutyCycle(tonum(l)) <span class="hljs-comment">#执行角度变化，</span><br><br>sleep(<span class="hljs-number">0.1</span>)<br><br>p2.ChangeDutyCycle(<span class="hljs-number">0</span>) <span class="hljs-comment">#清除当前占空比，使舵机停止抖动</span><br><br>sleep(<span class="hljs-number">0.01</span>)<br><br><span class="hljs-comment"># else:</span><br><br><span class="hljs-comment">#print(&#x27;\n**超出范围**\n&#x27;)</span><br><br><span class="hljs-comment">#l=45</span><br><br><span class="hljs-comment">#p2.ChangeDutyCycle(tonum(l)) #执行角度变化</span><br><br><span class="hljs-comment">#sleep(0.1)</span><br><br><span class="hljs-comment">#p2.ChangeDutyCycle(0) #清除当前占空比，使舵机停止抖动</span><br><br><span class="hljs-comment"># sleep(0.01)</span><br><br>  <br>  <br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br><br>r = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;input 1 angle:&#x27;</span>))<br><br>l = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;input 2 angle:&#x27;</span>))<br><br>left(r)<br><br>up(l)<br><br><span class="hljs-comment">#1 is 180,2 is 270</span><br><br></code></pre></td></tr></table></figure><h4 id="pigpio"><a href="#pigpio" class="headerlink" title="pigpio"></a>pigpio</h4><p>$\quad$ 因为RPI.GPIO库无法实现remote GPIO，修改为pigpio</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#coding=UTF-8</span><br><br><span class="hljs-keyword">import</span> pigpio<br><br><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> sleep<br><br>  <br><br>pi = pigpio.pi(<span class="hljs-string">&#x27;10.6.28.31&#x27;</span>)<br><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> pi.connected:<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;connect fail&#x27;</span>)<br><br>  <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">tonum1</span>(<span class="hljs-params">degree</span>): <span class="hljs-comment"># 用于上方舵机处理角度转换的函数0~180</span><br><br>dc = <span class="hljs-built_in">float</span>(degree)*<span class="hljs-number">1000</span>/<span class="hljs-number">90</span>+<span class="hljs-number">500</span><br><br><span class="hljs-keyword">return</span> dc<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">tonum2</span>(<span class="hljs-params">degree</span>): <span class="hljs-comment"># 用于下方舵机处理角度转换的函数0~270</span><br><br>dc = <span class="hljs-built_in">float</span>(degree)*<span class="hljs-number">1000</span>/(<span class="hljs-number">45</span>*<span class="hljs-number">3</span>)+<span class="hljs-number">500</span><br><br><span class="hljs-keyword">return</span> dc<br><br>  <br>  <br><br>servopin1 = <span class="hljs-number">17</span> <span class="hljs-comment">#舵机1,方向为左右转</span><br><br>servopin2 = <span class="hljs-number">18</span> <span class="hljs-comment">#舵机2,方向为上下转</span><br><br>  <br><br>pi.set_PWM_frequency(servopin1,<span class="hljs-number">50</span>)<br><br>pi.set_PWM_frequency(servopin2,<span class="hljs-number">50</span>)<span class="hljs-comment"># frequency = 50Hz</span><br><br>  <br><br>sleep(<span class="hljs-number">0.5</span>)<br><br>  <br>  <br><br>pi.set_servo_pulsewidth(servopin1, tonum1(<span class="hljs-number">0</span>))<br><br>pi.set_servo_pulsewidth(servopin2, tonum2(<span class="hljs-number">0</span>))<span class="hljs-comment">#初始角度两个0</span><br><br>sleep(<span class="hljs-number">0.5</span>)<br><br>  <br>  <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">left</span>(<span class="hljs-params">r</span>):<br><br><span class="hljs-keyword">if</span> r &lt;= <span class="hljs-number">180</span>:<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前角度为&#x27;</span>,r)<br><br>pi.set_servo_pulsewidth(servopin1,tonum1(r)) <span class="hljs-comment">#执行角度变化</span><br><br>sleep(<span class="hljs-number">0.1</span>)<br><br><span class="hljs-keyword">else</span>:<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\n**超出范围**\n&#x27;</span>)<br><br>pi.set_servo_pulsewidth(servopin1,tonum1(<span class="hljs-number">0</span>))<br><br>sleep(<span class="hljs-number">0.01</span>)<br><br>  <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">up</span>(<span class="hljs-params">l</span>):<br><br><span class="hljs-keyword">if</span> l &lt;= <span class="hljs-number">270</span>:<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前角度为&#x27;</span>,l)<br><br>pi.set_servo_pulsewidth(servopin2,tonum2(l))<span class="hljs-comment">#执行角度变化，</span><br><br>sleep(<span class="hljs-number">0.1</span>)<br><br><span class="hljs-keyword">else</span>:<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\n**超出范围**\n&#x27;</span>)<br><br>pi.set_servo_pulsewidth(servopin2,tonum2(<span class="hljs-number">0</span>))<br><br>sleep(<span class="hljs-number">0.01</span>)<br><br>  <br>  <br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br><br>r = <span class="hljs-built_in">float</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;input 1 angle:&#x27;</span>))<br><br>l = <span class="hljs-built_in">float</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;input 2 angle:&#x27;</span>))<br><br>up(l)<br><br>left(r)<br><br><span class="hljs-comment">#1 is 180,2 is 270</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>CS科研</category>
      
      <category>树莓派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树莓派</tag>
      
      <tag>舵机</tag>
      
      <tag>PVM</tag>
      
      <tag>云台</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络基础知识</title>
    <link href="/2023/09/18/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/09/18/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p> 对应 北京大学计算机网络课程第一讲<br> 参考教材计算机网络-自顶向下方法</p><span id="more"></span><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="网络基础知识"><a href="#网络基础知识" class="headerlink" title="网络基础知识"></a>网络基础知识</h2><p>$\quad$ <strong>学习内容：</strong></p><hr><p>网络实体如何通过协议，实现各类网络功能&#x2F;服务</p><hr><p>$\quad$·<strong>主要内容：</strong><br><img src="/../CNP/CN012.png"></p><h3 id="计算机网络中的主要问题："><a href="#计算机网络中的主要问题：" class="headerlink" title="计算机网络中的主要问题："></a>计算机网络中的主要问题：</h3><h5 id="对等实体"><a href="#对等实体" class="headerlink" title="对等实体"></a>对等实体</h5><p>$\quad$·实体的识别和命名<br>$\quad$·实体的组织形式</p><h5 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h5><p>$\quad$ ·传输接口<br>$\quad$ ·服务性能<br>$\quad$ ·是否具有可靠性，安全性等保障</p><h5 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h5><p>$\quad$ ·传输内容的格式，语义，顺序</p><h5 id="实现与管理"><a href="#实现与管理" class="headerlink" title="实现与管理"></a>实现与管理</h5><p>$\quad$ ·功能、协议-&gt;实体的映射<br>$\quad$ ·资源分配与调度</p><h3 id="实体：计算机网络的组成"><a href="#实体：计算机网络的组成" class="headerlink" title="实体：计算机网络的组成"></a>实体：计算机网络的组成</h3><h4 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h4><h5 id="个域网PAN"><a href="#个域网PAN" class="headerlink" title="个域网PAN"></a>个域网PAN</h5><p>$\quad$ ·能在便携式消费电器与通信设备之间进行短距离通信的网络<br>$\quad$ ·覆盖范围一般在10米半径以内，如蓝牙耳机等</p><h5 id="局域网LAN"><a href="#局域网LAN" class="headerlink" title="局域网LAN"></a>局域网LAN</h5><p>$\quad$ ·局部地区形成的区域网络，如企业网络<br>$\quad$ ·分布地区范围有限，可大可小<br>$\quad$ ·电脑WLAN接入，打印机共享等</p><h5 id="城域网MAN"><a href="#城域网MAN" class="headerlink" title="城域网MAN"></a>城域网MAN</h5><p>$\quad$ ·覆盖一整个城市的网络</p><h5 id="广域网WAN"><a href="#广域网WAN" class="headerlink" title="广域网WAN"></a>广域网WAN</h5><p>$\quad$ ·覆盖很大地理区域，乃至覆盖国家和地区</p><h4 id="今天的互联网：网络的网络"><a href="#今天的互联网：网络的网络" class="headerlink" title="今天的互联网：网络的网络"></a>今天的互联网：网络的网络</h4><p>$\quad$ ·由多个子网络构成<br>$\quad$ ·每个子网络又可进一步划分<br>$\quad$ ·直到每个公司、家庭甚至房间内的小网络</p><h5 id="ISP（Internet-service-provider）"><a href="#ISP（Internet-service-provider）" class="headerlink" title="ISP（Internet service provider）"></a>ISP（Internet service provider）</h5><p>提供网络接入与互联服务<br><img src="/CNP/CN01.png"></p><h5 id="网络边缘："><a href="#网络边缘：" class="headerlink" title="网络边缘："></a>网络边缘：</h5><p>$\quad$ ·端系统：位于互联网边缘与互联网相连的计算机和其他设备<br>$\quad$ ·端系统由各类主机（host）构成:桌面计算机，移动计算机，服务器，其他智能终端设备</p><h6 id="主机Host"><a href="#主机Host" class="headerlink" title="主机Host"></a>主机Host</h6><p>$\quad$ ·客户端：各类智能终端<br>$\quad$ ·服务器<br>$\quad$ ·功能：容纳（运行）应用程序，将用户程序产生的数据向接入网发送，从网络接收数据并提供给应用程序。<br>$\quad$ ·内部结构：<br>$\quad$ $\quad$ ·网络设备硬件（网卡）：对外通信<br>$\quad$ $\quad$ ·内核软件：内核驱动：网卡管理与访问（为特定网卡开发）；网络协议栈：网络数据处理（与网卡无关）<br>$\quad$ $\quad$ ·用户软件：调用内存提供接口(socket)进行数据发送&#x2F;接收<br>$\quad$ ·命名：<br>$\quad$ $\quad$ ·唯一设备ID（48位mac地址）：全球唯一，不可修改（IEEE将命名空间分给各个厂商，厂商自行保证出厂设备不重名）<br>$\quad$ $\quad$ ·IP地址：一组数字构成（IPv4 32位，IPv6 128位）<br>$\quad$ $\quad$ ·主机名：字符串（方便记忆）<br><img src="/../CNP/CN02.png"></p><h5 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h5><p>$\quad$ ·连接边缘端系统与网络核心<br>$\quad$ ·通信链路（光纤、铜缆、无线电、激光链路）</p><h6 id="接入网目标"><a href="#接入网目标" class="headerlink" title="接入网目标"></a>接入网目标</h6><p>$\quad$ ·将主机连接到边缘路由器上<br>$\quad$ ·边缘路由器是将端系统Host去往任何远程端系统的路程上的第一台路由器<br>$\quad$ ·各种异构网络是通过边缘路由器接入</p><h6 id="如何将终端系统连接到边缘路由器"><a href="#如何将终端系统连接到边缘路由器" class="headerlink" title="如何将终端系统连接到边缘路由器"></a>如何将终端系统连接到边缘路由器</h6><p>$\quad$ ·通过各种物理介质（引导性介质：双绞线，同轴电缆(两根同心铜导线)，光纤；非引导性介质：无线电，无线链路）<br>$\quad$ ·有线网络接入技术：拨号上网（数字用户线DSL），同轴电路，光纤到户，以太网<br>$\quad$ ·无线网络接入技术：WiFi，4G、5G，卫星广域覆盖</p><p>$\quad$ ·传输单位：位（bit）1B&#x3D;8b K&#x2F;M&#x2F;G层级为10^3进制</p><h5 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h5><p>$\quad$ ·由互联网端系统的分组交换设备和通信链路构成的网状网<br>$\quad$ ·目标：将海量的端系统互联起来<br>$\quad$ ·关键技术：分组交换<br>$\quad$ $\quad$ ·主机将数据分成分组（Packet），发送到网络<br>$\quad$ $\quad$ ·网络将数据分组从一个路由器转发到下一个路由器，通过从源到目标的路径上的链路，逐跳传输抵达目的地</p><h6 id="两大功能"><a href="#两大功能" class="headerlink" title="两大功能"></a>两大功能</h6><p>$\quad$ · 功能1：路由<br>$\quad$ $\quad$ ·全局操作：确定数据分组从源到目标所使用的路径<br>$\quad$ $\quad$ ·需要路由协议与路由算法，产生路由表<br>$\quad$ ·功能2：转发<br>$\quad$ $\quad$ ·本地操作：路由器或交换机将收到的数据分组转发出去（即移动到该设备的某个输出接口）<br>$\quad$ $\quad$ ·确定转发出去的接口&#x2F;链路，根据从“入接口”收到分组头中的目的地址，查找本地路由表，确定”出接口”<br><img src="/../CNP/CN03.png"></p><h6 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h6><p>$\quad$ ·将大消息（message）拆分成多个小分组（packet)<br>$\quad$ ·以分组作为数据传输单元<br>$\quad$ ·每个分组的首部都含有地址（目的地址和源地址）等控制信息<br>$\quad$ ·支持灵活的统计多路复用<br>$\quad$ ·使用存储-转发机制，实现数据交互的通信方式<br>$\quad$ $\quad$ ·路由器需要接收到完整的整个数据包后，才能开始向下一跳发送<br>$\quad$ $\quad$ ·存储转发带来额外的报文的传输延迟<br>$\quad$ $\quad$ $\quad$ ·正常的链路传播延迟：将L位数据包，以R bps的速率发送到链路中，需要L&#x2F;R秒<br>$\quad$ ·每个分组在互联网中独立地选择传输路径<br>$\quad$ $\quad$ ·不同分组可以共享使用同一节点或链路<br>$\quad$ $\quad$ ·如果某段链路上，分组到达速率超过链路传输速率<br>$\quad$ $\quad$ $\quad$ ·分组在一个缓冲区中排队，等到链路可用<br>$\quad$ $\quad$ $\quad$ ·若队列被填满，后续分组就被抛弃（丢包）</p><h6 id="另一种选择：电路交换"><a href="#另一种选择：电路交换" class="headerlink" title="另一种选择：电路交换"></a>另一种选择：电路交换</h6><p>$\quad$ ·先呼叫建立连接，实现端到端的资源预留（链路带宽资源，交换机的交换能力）<br>$\quad$ ·电路交换连接建立后，物理通路被通信双方独占，资源专用，既不空闲也不与其他连接共享<br>$\quad$ ·由于建立连接并预留资源，因此传输性好，但如果有设备故障则传输中断</p><h6 id="交换方式的比较"><a href="#交换方式的比较" class="headerlink" title="交换方式的比较"></a>交换方式的比较</h6><p>$\quad$ ·分组交换随时发送无需连接；电路交换需要建立连接<br>$\quad$ ·分组交换没有预留资源，但较灵活；电路交换为每个连接预留资源<br>$\quad$ ·分组交换适合有大量突发资源，简单，不需要建立连接<br>$\quad$ $\quad$ ·缺点1：分组交换容易拥塞，引起排队延迟甚至丢包<br>$\quad$ $\quad$ $\quad$ ·需要设计可靠性机制与拥塞控制机制<br>$\quad$ $\quad$ ·缺点2:分组交换无法提供类似电路交换的服务<br>$\quad$ $\quad$ $\quad$ ·折中方法：虚电路（目前仍然没有公认解决方案）</p><h5 id="Internet架构"><a href="#Internet架构" class="headerlink" title="Internet架构"></a>Internet架构</h5><p>$\quad$ ·端系统通过本地网络提供商（access ISP）接入Internet<br>$\quad$ ·本地网络提供商之间也需要相互连接,产生了以恶搞结构极度复杂的当今Internet</p><h6 id="Access-ISP如何建立连接？"><a href="#Access-ISP如何建立连接？" class="headerlink" title="Access ISP如何建立连接？"></a>Access ISP如何建立连接？</h6><p>$\quad$ ·选择1：两两建立链路：可拓展性问题（O（N^2）链路）<br>$\quad$ ·选择2：每个Access ISP接入一个全局ISP （ISP之间签署服务协议）<br>$\quad$ $\quad$ ·单个ISP可能无法满足传输要求，其他全局ISP出现<br>$\quad$ $\quad$ ·全局ISP之间也需要互连<br>$\quad$ $\quad$ ·互联网公司也组建自己网络，使得数据中心与用户距离更近，这种网络通常称为CDN</p><p><img src="/../CNP/CN04.png"></p><h3 id="服务：网络的功能，接口，质量"><a href="#服务：网络的功能，接口，质量" class="headerlink" title="服务：网络的功能，接口，质量"></a>服务：网络的功能，接口，质量</h3><p>$\quad$ ·从应用程序角度：与网络上的其他应用程序交互（发送&#x2F;接收消息）<br>$\quad$ ·按调用方式：分为“面向连接”和”无连接“两大类<br>$\quad$ ·按服务质量：可靠性，性能，安全<br>$\quad$ ·服务由一组可用于用户进程以访问服务的原语（操作）形式指定<br>$\quad$ ·原语告诉服务执行某些操作或报告对等实体所采取的操作<br>$\quad$ ·六个核心服务原语：<br><img src="/../CNP/CN05.png"></p><h6 id="面向连接的网络服务"><a href="#面向连接的网络服务" class="headerlink" title="面向连接的网络服务"></a>面向连接的网络服务</h6><p>$\quad$ ·传输数据之前，先建立对话链接</p><h6 id="无连接的网络服务"><a href="#无连接的网络服务" class="headerlink" title="无连接的网络服务"></a>无连接的网络服务</h6><p>$\quad$ ·数据传输前不需要事先建立连接<br>$\quad$ ·传输过程不需要应答</p><h4 id="网络服务的性能指标"><a href="#网络服务的性能指标" class="headerlink" title="网络服务的性能指标"></a>网络服务的性能指标</h4><h5 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h5><p>$\quad$ ·网络中某通道传输数据的能力，即单位时间内网络的某信道所能通过的最高数据率<br>$\quad$ ·单位是bit&#x2F;s，也可以写为bps</p><h5 id="包转发率"><a href="#包转发率" class="headerlink" title="包转发率"></a>包转发率</h5><p>$\quad$ ·全称是Packet Per Second，表示交换机或路由器等网络设备以包为单位的转发速率<br>$\quad$ ·线速转发：交换机在满负荷的情况下，对帧进行转发时能够达到该端口线路的最高速度（在交换机上，大包更容易实现线速）</p><h5 id="比特率（bit-rate）"><a href="#比特率（bit-rate）" class="headerlink" title="比特率（bit rate）"></a>比特率（bit rate）</h5><p>$\quad$ ·单位时间内，主机往数据信道上传输数据的数据量，也称为数据率或传输速率，单位是bps</p><h5 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h5><p>$\quad$ ·单位时间内，通过某个网络位置（或信道，接口）的数据量，单位是bps<br>$\quad$ ·有效吞吐量：正确地接收到的有用信息的数目，单位bps</p><h5 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h5><p>$\quad$ ·信道利用率指出某信道百分之几的时间是被利用的<br>$\quad$ ·网络利用率是全网络的信道利用率的加权平均<br><img src="/../CNP/CN06.png"></p><h5 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h5><p>$\quad$ ·所丢失的数据包的数量占所发送数据包的比率</p><h5 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h5><p>$\quad$ ·时延是指数据（一个报文或分组）从网络(或链路)的一端传送到另一端所需的时间，也称为延迟</p><h6 id="传输时延"><a href="#传输时延" class="headerlink" title="传输时延"></a>传输时延</h6><p>$\quad$ ·数据从结点进入到传输媒体所需要的时间，又称为发送时延（与设备有关）</p><h6 id="传播时延"><a href="#传播时延" class="headerlink" title="传播时延"></a>传播时延</h6><p>$\quad$ ·电磁波在信道中需要传输一定距离而花费的时间（与介质有关)</p><h6 id="处理时延"><a href="#处理时延" class="headerlink" title="处理时延"></a>处理时延</h6><p>$\quad$ ·主机或路由器在收到分组时，为处理分组（如分析首部，提取数据，差错校验或查找路由）所花费的时间（与设备有关）</p><h6 id="排队时延"><a href="#排队时延" class="headerlink" title="排队时延"></a>排队时延</h6><p>$\quad$ ·分组在路由器输入输出队列中排队等待处理所经历的时延<br>$\quad$ ·最不确定因素：L&#x3D;AxW （L：平均队列长度，A平均到达速率，W平均等待时间，A和W相对困难得到）</p><h6 id="总时延"><a href="#总时延" class="headerlink" title="总时延"></a>总时延</h6><p>$\quad$ ·通用方法：将一个大问题分解成多个小问题<br>$\quad$ ·总时延&#x3D;传输时延+传播时延+处理时延+排队时延<br><img src="/../CNP/CN07.png"><br>$\quad$ ·优化：设计专用芯片，开发系统系统模块（处理+传输），光纤等（排队+传播）</p><h6 id="往返时延-RTT"><a href="#往返时延-RTT" class="headerlink" title="往返时延 RTT"></a>往返时延 RTT</h6><p>$\quad$ ·从发送方发送数据开始，到发送方收到来自接收方的确认经历的总时间<br>$\quad$ ·可用于判断网络的通断性，测试网络时延，计算数据丢包率（PING）</p><h6 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h6><p>$\quad$ ·时延带宽积&#x3D;传播时延x带宽<br>$\quad$ ·若发送端连续发送数据，则在发送的第一个bit即将达到终点时，发送端就已经发送了时延带宽积个bit，而这些bit都在链路上向前移动</p><h6 id="时延抖动"><a href="#时延抖动" class="headerlink" title="时延抖动"></a>时延抖动</h6><p>$\quad$ ·变化的时延称为抖动<br>$\quad$ ·起源于网络中的个队列或缓冲，难以精确预测<br>$\quad$ ·在语音，视频多媒体业务中，抖动往往会严重影响用户的体验</p><h5 id="延迟丢包"><a href="#延迟丢包" class="headerlink" title="延迟丢包"></a>延迟丢包</h5><p>$\quad$ ·在多媒体应用中，由于数据包延迟到达，在接收端需要丢弃失去使用价值的包</p><h5 id="其他指标"><a href="#其他指标" class="headerlink" title="其他指标"></a>其他指标</h5><p>$\quad$ ·可靠性：发送的每个消息，接收方收到一次且仅收到一次<br>$\quad$ ·完整性：发送的数据无法篡改<br>$\quad$ ·隐私性：数据不被第三方截获（有时包含发送方身份不暴露）<br>$\quad$ ·可审计性：可追溯用户的传输行为</p><h3 id="协议：通信的内容"><a href="#协议：通信的内容" class="headerlink" title="协议：通信的内容"></a>协议：通信的内容</h3><p>$\quad$ ·网络协议：为进行网络中的数据交换而建立的规则、标准或规定<br>$\quad$ ·通信双方需要共同遵守，相互理解<br>$\quad$ ·发送方：发送某个消息时，应满足特定条件<br>$\quad$ ·接收方：收到某个消息后，要完成特定的工作<br>$\quad$ ·三要素:<br>$\quad$ $\quad$ ·语法：规定传输数据的格式<br>$\quad$ $\quad$ ·语义：规定所要完成的功能<br>$\quad$ $\quad$ ·时序：规定各种操作的顺序<br>$\quad$ ·设计目的：表明身份，可靠性，资源分配，拥塞问题，自适应性，安全问题<br>$\quad$ ·通信双方要说的事情多种多样，导致网络协议异常复杂</p><h4 id="协议封装"><a href="#协议封装" class="headerlink" title="协议封装"></a>协议封装</h4><p>$\quad$ ·网络协议以头部封装的形式定义<br>$\quad$ ·每个协议定义自己头部信息，数据被封装为协议载荷<br>$\quad$ ·头部定义了如何处理分组<br><img src="/../CNP/CN08.png"></p><h3 id="网络实现与管理"><a href="#网络实现与管理" class="headerlink" title="网络实现与管理"></a>网络实现与管理</h3><p>$\quad$ ·将网络分为多个层次，每层提供功能与服务保障，层与层之间有接口调用，同层实体通过该层协议进行对话，屏蔽各层实现细节<br><img src="/../CNP/CN09.png"></p><p>$\quad$ ·统一标准，模块独立<br>$\quad$ ·分层的好处：降低复杂度，增加灵活性<br>$\quad$ ·坏处：引入额外开销，跨层信息有时候也很重要</p><h4 id="计算机网络中的经典分层"><a href="#计算机网络中的经典分层" class="headerlink" title="计算机网络中的经典分层"></a>计算机网络中的经典分层</h4><p><img src="/../CNP/CN010.png"></p><h5 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h5><h6 id="物理层（Physical-Layer）"><a href="#物理层（Physical-Layer）" class="headerlink" title="物理层（Physical Layer）"></a>物理层（Physical Layer）</h6><p>$\quad$ ·定义如何在信道上传输0，1<br>$\quad$ ·机械接口：网线接口大小，形状，线缆排列等<br>$\quad$ ·电子信号：电压、电流等<br>$\quad$ ·时序接口：采样频率，波特率，比特率等<br>$\quad$ ·介质：各种线缆，无线频谱等</p><h6 id="数据链路层-Data-Link-Layer"><a href="#数据链路层-Data-Link-Layer" class="headerlink" title="数据链路层 (Data Link Layer)"></a>数据链路层 (Data Link Layer)</h6><p>$\quad$ •实现相邻（Neighboring）网络实体间的数据传输<br>$\quad$ •成帧（Framing）：从物理层的比特流中提取出完整的帧<br>$\quad$ •错误检测与纠正：为提供可靠数据通信提供可能<br>$\quad$ •物理地址（MAC address）：48位，理论上唯一网络标识，烧录在网卡，不便更改<br>$\quad$ •共享信道上的访问控制（MAC）：同一个信道，同时传输信号。<br>$\quad$ •流量控制，避免“淹没”（overwhelming）:当快速的发送端遇上慢速的接收端，接收端缓存溢出</p><h6 id="网络层-Network-Layer"><a href="#网络层-Network-Layer" class="headerlink" title="网络层 (Network Layer)"></a>网络层 (Network Layer)</h6><p>$\quad$ •将数据包跨越网络从源设备发送到目的设备（host to host）<br>$\quad$ •路由（Routing）：在网络中选取从源端到目的端转发路径，常常会根据网络可达性动态选取最佳路径，也可以使用静态路由<br>$\quad$ •路由协议：路由器之间交互路由信息所遵循的协议规范，使得单个路由器能够获取网络的可达性等信息<br>$\quad$ •服务质量（QoS）控制：处理网络拥塞、负载均衡、准入控制、保障延迟<br>$\quad$ •异构网络互联：在异构编址和异构网络中路由寻址和转发</p><h6 id="传输层-Transport-Layer"><a href="#传输层-Transport-Layer" class="headerlink" title="传输层 (Transport Layer)"></a>传输层 (Transport Layer)</h6><p>$\quad$ •将数据从源端口发送到目的端口（进程到进程）<br>$\quad$ •网络层定位到一台主机（host），传输层的作用域具体到主机上的某一个进程<br>$\quad$ •网络层的控制主要面向运营商，传输层为终端用户提供端到端的数据传输控制<br>$\quad$ •两类模式：可靠的传输模式，或不可靠传输模式<br>$\quad$ •可靠传输：可靠的端到端数据传输，适合于对通信质量有要求的应用场景，如文件传输等<br>$\quad$ •不可靠传输：更快捷、更轻量的端到端数据传输，适合于对通信质量要求不高，对通信响应速度要求高的应用场景，如语音对话、视频会议等</p><h6 id="会话层-Session-Layer"><a href="#会话层-Session-Layer" class="headerlink" title="会话层 (Session Layer)"></a>会话层 (Session Layer)</h6><p>$\quad$ •利用传输层提供的服务，在应用程序之间建立和维持会话，并能使会话获得同步</p><h6 id="表示层（Presentation-Layer）"><a href="#表示层（Presentation-Layer）" class="headerlink" title="表示层（Presentation Layer）"></a>表示层（Presentation Layer）</h6><p>$\quad$ •关注所传递信息的语法和语义，管理数据的表示方法，传输的数据结构</p><h6 id="应用层（Application-Layer）"><a href="#应用层（Application-Layer）" class="headerlink" title="应用层（Application Layer）"></a>应用层（Application Layer）</h6><p>$\quad$ •通过应用层协议，提供应用程序便捷的网络服务调用</p><h5 id="TCP-x2F-IP参考模型"><a href="#TCP-x2F-IP参考模型" class="headerlink" title="TCP&#x2F;IP参考模型"></a>TCP&#x2F;IP参考模型</h5><p>$\quad$ ·ARPNET  最终采用TCP和IP为主要协议<br>$\quad$ ·先有TCP&#x2F;IP协议栈，然后有TCP&#x2F;IP参考模型，参考模型只是用来描述协议栈的</p><h6 id="网络接口层（Host-to-network-Layer）"><a href="#网络接口层（Host-to-network-Layer）" class="headerlink" title="网络接口层（Host-to-network Layer）"></a>网络接口层（Host-to-network Layer）</h6><p>$\quad$ ·描述了为满足无连接的互联网络层需求，单跳链路必须具备的功能</p><h6 id="互联网层（Internet-Layer）"><a href="#互联网层（Internet-Layer）" class="headerlink" title="互联网层（Internet Layer）"></a>互联网层（Internet Layer）</h6><p>$\quad$ ·通过多跳连接，将数据包独立的传输至目的地，并定义了数据包格式和协议（IPv4协议和IPv6协议）</p><h6 id="传输层（Transport-Layer）"><a href="#传输层（Transport-Layer）" class="headerlink" title="传输层（Transport Layer）"></a>传输层（Transport Layer）</h6><p>$\quad$ ·允许源主机与目标主机上的对等实体，进行端到端的数据传输：TCP，UDP</p><h6 id="应用层（Application-Layer）-1"><a href="#应用层（Application-Layer）-1" class="headerlink" title="应用层（Application Layer）"></a>应用层（Application Layer）</h6><p>$\quad$ ·传输层之上的所有高层协议：DNS、HTTP、FTP、SMTP…</p><h5 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h5><p><img src="/../CNP/CN011.png"><br>$\quad$ ·网络分层没有对与错，只有是否符合需要</p><h4 id="接口与协议的关系"><a href="#接口与协议的关系" class="headerlink" title="接口与协议的关系"></a>接口与协议的关系</h4><p>$\quad$ · 协议是“水平”的，接口是“垂直”的<br>$\quad$ ·实体使用协议来实现其定义的接口<br>$\quad$ ·上层实体通过接口调用下层实体<br><img src="/../CNP/CN013.png"><br>$\quad$ ·发送端层层封装头部数据，接收端：层层解封装头部数据</p><h4 id="网络分层的实现"><a href="#网络分层的实现" class="headerlink" title="网络分层的实现"></a>网络分层的实现</h4><p>$\quad$·端系统：实现所有分层(用户程序运行在端系统，比特流进入系统，要一直传输给用户程序)<br>$\quad$·边缘网与网络核心：实现第一层到第三层功能<br>$\quad$$\quad$·交换机：物理层与数据链路层功能<br>$\quad$$\quad$·路由器：实现前三层功能<br>$\quad$$\quad$·传统路由器支持多跳传输，传统交互机不支持多跳传输，现代路由器和交换机已经不做区分</p><h6 id="特征1-复杂系统由端系统实现"><a href="#特征1-复杂系统由端系统实现" class="headerlink" title="特征1:复杂系统由端系统实现"></a>特征1:复杂系统由端系统实现</h6><p>$\quad$·兵器电话系统中“笨终端，聪明网络”的设计思路<br>$\quad$·端对端原则：采用”聪明终端，简单网络“，用端系统负责丢失恢复等复杂共功能<br>$\quad$·实现了建立在简单的，不可靠部件上的可靠系统<br>$\quad$·好处：简单的网络大大提升了可拓展性</p><h6 id="特征2：以IP协议为核心"><a href="#特征2：以IP协议为核心" class="headerlink" title="特征2：以IP协议为核心"></a>特征2：以IP协议为核心</h6><p>$\quad$·可在各种底层物理网络上运行<br>$\quad$·支持各类上层应用<br>$\quad$·好处：IP分组独立处理，网络核心功能简单，适应爆炸性增长；容易实现多个网络互连（只要都支持IP）；屏蔽上层应用与底层通信</p><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>CN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FMCW点云与深度学习</title>
    <link href="/2023/09/13/FMCW%20%E7%82%B9%E4%BA%91%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/09/13/FMCW%20%E7%82%B9%E4%BA%91%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>对毫米波雷达采集到的点云进行处理</p><span id="more"></span>]]></content>
    
    
    <categories>
      
      <category>CS科研</category>
      
      <category>FMCW</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FMCW</tag>
      
      <tag>ai</tag>
      
      <tag>deep</tag>
      
      <tag>learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FMCW测距测速测角</title>
    <link href="/2023/09/12/FMCW%20%E6%B5%8B%E8%B7%9D%E6%B5%8B%E9%80%9F%E6%B5%8B%E8%A7%92/"/>
    <url>/2023/09/12/FMCW%20%E6%B5%8B%E8%B7%9D%E6%B5%8B%E9%80%9F%E6%B5%8B%E8%A7%92/</url>
    
    <content type="html"><![CDATA[<p>利用毫米波雷达测距测速测角度</p><span id="more"></span><h4 id="距离测量"><a href="#距离测量" class="headerlink" title="距离测量"></a>距离测量</h4><h5 id="距离计算"><a href="#距离计算" class="headerlink" title="距离计算"></a>距离计算</h5><p>$\quad$ 由于中频信号是一余弦信号，因此对中频信号做傅立叶变换（FFT）即可得到频率和相位。需要注意，在此处均是对一个chirp周期T内的中频信号做处理，由于周期T很短，可将一个周期内的时间t称为快时间（Fast Time）。根据傅立叶变换的性质，对一个中频信号s(t)做FFT，可以得到一列复数。每个复数对应于一个频率分量，其幅值和相位分别代表该频率分量的振幅和相位<br><img src="/../FMCWmg/F3.png"></p><blockquote><p>$R&#x3D;(c&#x2F;2k )f_b &#x3D;f_b(cT&#x2F;2B)$ </p></blockquote><h6 id="相关参数"><a href="#相关参数" class="headerlink" title="相关参数"></a>相关参数</h6><p>$\quad$ (a).距离分辨率。距离分辨率的意义是，仅当两个物体的距离大于分辨率$\Delta$R 时，他们才能在距离谱上被分辨出来。假设FMCW雷达的ADC采样率为$F_s$ ，对周期T的chirp信号做FFT，则FFT的频率分辨率为$\Delta f_b&#x3D;1&#x2F;T$ 。根据测距公式得到测距的分辨率为：$\Delta R &#x3D;cT&#x2F;(2B) \Delta f_b$ &#x3D;c&#x2F;2B .  可见距离分辨率仅与雷达信号的带宽.<br>$\quad$(b).测距精度。测距精度的意义是：一个物体距离测量的准确度，并不等同于雷达的距离分辨率。在雷达测距的实际应用中，测距精度是评定雷达和算法性能的重要指标。主要有两种方法提高测距精度：一是提高雷达接收机的ADC采样率，即以更多的采样点数采样中频信号，从而更好地估计周期性不完整的中频信号频率；二是在做FFT时应用补零或插值的方法。<br>$\quad$ (c).理论最远可测距离。根据采样定理，当雷达的采样率为$F_s$ 时，FFT可测的最大频率为$f_{max}&#x3D;F_s&#x2F;2$ 。因此，根据测距公式，雷达的理论最远可测距离为：$R_{max} &#x3D; cTF_s&#x2F;4B$ 与一个chirp的周期、带宽和系统采样率有关。假定雷达的采样率可以无限大，为了采样带宽为B的chirp信号，根据采样定理，采样率至少为2B，则此时最远可测距离为cT&#x2F;2。</p><p>$\quad$ (d).实际最远可测距离。在实际应用中，雷达的实际最远可测距离往往无法达到理论值，这是因为对于一些较远的物体，中频信号的振幅很小，使得信号的信噪比很低，导致物体无法被检测到。<br><img src="/../FMCWmg/F4.png"></p><h5 id="距离计算代码"><a href="#距离计算代码" class="headerlink" title="距离计算代码"></a>距离计算代码</h5><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs m">function [fft_data_all_frames] <span class="hljs-built_in">=</span> readRawDataAnd1DFFT(file_name, frame_num)<br><br>global N_CHIRP;<br><br>global RX_NUM;<br><br>global FFTR_SIZE;<br><br>global FRAME_SIZE;<br><br>global TX_NUM;<br><br>global RANGE_RESERVED_DOTS;<br><br>global FFTV_SIZE;<br><br>global CHIRPS_PER_FRAME;<br><br>global TX_ENABLE;<br><br>global RX_ENABLE;<br><br><span class="hljs-comment">%参数定义</span><br><br><span class="hljs-comment">% 包括N_CHIRP（每个Frame里chrip数）、RX_NUM（接收通道数）、FFTR_SIZE（FFT点数:每个chrip数据量）、FRAME_SIZE（每帧的样本数）、TX_NUM（发送通道数）、RANGE_RESERVED_DOTS（保留的距离向量长度）、FFTV_SIZE（FFT点数*速度点数）、CHIRPS_PER_FRAME（每帧的扫频数）、TX_ENABLE（启用的发送通道数）、RX_ENABLE（启用的接收通道数）。</span><br><br>file <span class="hljs-built_in">=</span> fopen(file_name);<span class="hljs-comment">%打开文件</span><br><br><span class="hljs-comment">% disp(&#x27;begin read&#x27;)</span><br><br>raw_data_array <span class="hljs-built_in">=</span> fread(file,<span class="hljs-string">&#x27;short=&gt;short&#x27;</span>);<br><br><span class="hljs-comment">%short=&gt;short 是source=&gt;output,raw_data_array意为原始数据向量</span><br><br><span class="hljs-comment">% disp(&#x27;finish read&#x27;)</span><br><br>raw_data_array <span class="hljs-built_in">=</span> single(raw_data_array);<br><br><span class="hljs-comment">% disp(&#x27;finish convert to single&#x27;)</span><br><br>raw_data_array <span class="hljs-built_in">=</span> raw_data_array / <span class="hljs-number">4</span>;<br><br>raw_data_array <span class="hljs-built_in">=</span> raw_data_array(<span class="hljs-number">1</span>:frame_num*FRAME_SIZE/<span class="hljs-number">2</span>);<br><br>raw_data_array <span class="hljs-built_in">=</span> reshape(raw_data_array, [FFTR_SIZE, RX_NUM * N_CHIRP * frame_num]);<br><br><span class="hljs-comment">%转为单精度浮点并缩放</span><br><br><span class="hljs-comment">% disp(&#x27;begin fft&#x27;)</span><br><br>window <span class="hljs-built_in">=</span> hamming(FFTR_SIZE);<br><br>raw_data_array <span class="hljs-built_in">=</span> raw_data_array .* window;<br><br>raw_data_array <span class="hljs-built_in">=</span> fft(raw_data_array);<br><br><span class="hljs-comment">% disp(&#x27;finish fft&#x27;)</span><br><br><span class="hljs-comment">% data_array_fft = data_array_fft(1:(RANGE_RESERVED_DOTS+1),:);</span><br><br><span class="hljs-comment">% data_array_fft = reshape(data_array_fft,[RANGE_RESERVED_DOTS+1, RX_NUM, N_CHIRP, frame_num]);</span><br><br>raw_data_array <span class="hljs-built_in">=</span> reshape(raw_data_array,[FFTR_SIZE, RX_NUM, N_CHIRP, frame_num]);<br><br>raw_data_array <span class="hljs-built_in">=</span> permute(raw_data_array, [<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]);<br><br><span class="hljs-comment">%这些行将FFT数据重塑为一个大小为frame_num * RX_NUM * N_CHIRP * FFTR_SIZE的数组，并对维度进行重新排列。</span><br><br><span class="hljs-comment">% disp(&#x27;begin TX&#x27;)</span><br><br>fft_data_all_frames <span class="hljs-built_in">=</span> zeros(frame_num,TX_NUM,CHIRPS_PER_FRAME,RX_NUM,RANGE_RESERVED_DOTS+<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;single&#x27;</span>);<br><br>for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:TX_NUM<br><br>fft_data_all_frames(:,i,:,:,:) <span class="hljs-built_in">=</span> raw_data_array(:, i:TX_NUM:N_CHIRP, :, <span class="hljs-number">1</span>:RANGE_RESERVED_DOTS+<span class="hljs-number">1</span>);<br><br>end<br><br><span class="hljs-comment">% disp(&#x27;finish TX&#x27;)</span><br><br>fft_data_all_frames <span class="hljs-built_in">=</span> permute(fft_data_all_frames,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>]);<br><br>disp(<span class="hljs-string">&#x27;finish read and 1d FFT&#x27;</span>)<br><br>end<br><br></code></pre></td></tr></table></figure><p>$\quad$ 实际距离谱：<br><img src="/../FMCWmg/F5.png"></p><h4 id="速度测量"><a href="#速度测量" class="headerlink" title="速度测量"></a>速度测量</h4><h5 id="速度计算"><a href="#速度计算" class="headerlink" title="速度计算"></a>速度计算</h5><p>$\quad$ 物体速度是距离变化的体现，因此在获得了距离计算方法后可以进一步计算物体的运动速度<br>$\quad$ （1）距离谱法。在获得了距离谱之后，一个很直观的计算物体运动速度的方法是，对于慢时间的多个chirp<br>$\quad$ （2）相位改变法:基于相位的微小运动计算方法，计算步骤为：<br>$\quad$ $\quad$ a. 随着慢时间的改变共有N个chirp被发送，对每个chirp做傅立叶变换得到N个距离谱。由于物体位置变化远小于距离分辨率，因此计算得到的N个距离谱相同。<br>$\quad$ $\quad$ b. 在每个距离谱上均可以观察到该物体，选定该物体的距离域，对N个chirp中该物体的距离域均取相位，可以得到N个相位值。<br>$\quad$ $\quad$ c. 对这N个相位值取解绕，得到连续的相位变化。<br>$\quad$ $\quad$ d. 根据公式换算得到物体连续的距离变化。<br><img src="/../FMCWmg/F6.png"><br>$\quad$ $\quad$ (3).2Dfft 法<br>$\quad$ 可以选择连续的多个chirp计算相位变化。考虑$T_{tot}$时间（如0.01s）内连续的N个（如10个）chirp，先做FFT得到N个距离谱。在$T_{tot}$时间内物体距离的改变不超过一个距离域，因此这些距离谱中该物体对应的距离域相同。根据前文分析，任意两个chirp之间，该距离域的相位改变均为$\Delta \psi &#x3D; 4\pi f_c vT_c&#x2F;c$ ，因此在全部N个距离谱中该物体对应距离域的复数以为此为角速度在复平面上转动。进而，对于这一列复数做FFT，可以得到一个新的能量分布谱。对应物体速度为</p><blockquote><p>$v&#x3D;\varpi c &#x2F;(4 \pi f_c T_c)$<br><img src="/../FMCWmg/F0.png"></p></blockquote><h6 id="相关参数："><a href="#相关参数：" class="headerlink" title="相关参数："></a>相关参数：</h6><p>$\quad$ （a）速度测量的分辨率。由于共有N&#x3D;$T_{tot}&#x2F;T_c$ 个chrip，则FFT时共有N个采样点，则频率分辨率为$\Delta \varpi &#x3D; 2\pi&#x2F;N$ ，根据测速公式,速度分辨率计算为<br>$\Delta v &#x3D; \Delta \varpi c &#x2F;(4 \pi f_c T_c)&#x3D;c&#x2F;(2F_cT_{tot})$<br>$\quad$ （b）最大可测速度。考虑相邻两个chirp，即$T_c$ 内，一个向量最多只能旋转$\pm \pi$ ，否则会在FFT出现歧义，根据测速公式，最大可测速度为：$|v_{max}|&#x3D;c&#x2F;(4f_cT_c)$ </p><h5 id="速度计算代码"><a href="#速度计算代码" class="headerlink" title="速度计算代码"></a>速度计算代码</h5><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs m">fft_data_all_frames_static_elimi <span class="hljs-built_in">=</span> fft_data_all_frames - mean(fft_data_all_frames,<span class="hljs-number">4</span>);<br><br>fft2D_data_all_frames <span class="hljs-built_in">=</span> fftshift(fft(fft_data_all_frames_static_elimi,[],<span class="hljs-number">4</span>),<span class="hljs-number">4</span>);<br><br><span class="hljs-comment">%从每个帧中减去所有帧的平均值并作二维傅里叶变换， fftshift(X) 将零频分量移动到数组中心重新排列fft</span><br><br>figure();<br><br>frame_data <span class="hljs-built_in">=</span> double(squeeze(fft2D_data_all_frames(<span class="hljs-number">130</span>,:,:,:,:))); <span class="hljs-comment">% frame_index needs to be assigned a suitable value</span><br><br>rd_map <span class="hljs-built_in">=</span> squeeze(abs(frame_data(FOCUS_TX,FOCUS_RX,:,:))).<span class="hljs-string">&#x27;;%这行代码计算了距离-多普勒图。</span><br><span class="hljs-string"></span><br><span class="hljs-string">s_rd = mesh(velocity_seq,distance_seq,rd_map / max(max(rd_map)));</span><br><span class="hljs-string"></span><br><span class="hljs-string">axis([-5.2083 5.2083 0 11.2957] ); % The line needs to be adjusted according to the parameters or deleted</span><br><span class="hljs-string"></span><br><span class="hljs-string">view(2);</span><br><span class="hljs-string"></span><br><span class="hljs-string">s_rd.FaceColor = &#x27;</span>flat<span class="hljs-string">&#x27;;</span><br><span class="hljs-string"></span><br><span class="hljs-string">xlabel(&#x27;</span>Velocity(m/s)<span class="hljs-string">&#x27;)</span><br><span class="hljs-string"></span><br><span class="hljs-string">ylabel(&#x27;</span>Range(m)<span class="hljs-string">&#x27;)</span><br><span class="hljs-string"></span><br><span class="hljs-string">set(gca,&#x27;</span>FontName<span class="hljs-string">&#x27;,&#x27;</span>Helvetica<span class="hljs-string">&#x27;,&quot;FontSize&quot;,18);</span><br><span class="hljs-string"></span><br><span class="hljs-string">c_res = colorbar;</span><br><span class="hljs-string"></span><br><span class="hljs-string">c_res.Label.String = &#x27;</span>Normalized power<span class="hljs-string">&#x27;;</span><br><span class="hljs-string"></span><br><span class="hljs-string">c_res.Label.FontSize = 16;</span><br><span class="hljs-string"></span><br><span class="hljs-string">title(&quot;range-doppler spectrum&quot;)</span><br></code></pre></td></tr></table></figure><p>$\quad$ 实际速度谱：<br><img src="/../FMCWmg/F7.png"></p><h4 id="角度测量"><a href="#角度测量" class="headerlink" title="角度测量"></a>角度测量</h4><h5 id="角度计算"><a href="#角度计算" class="headerlink" title="角度计算"></a>角度计算</h5><p>$\quad$ <strong>普遍</strong>：<br><img src="/../FMCWmg/F10.png"><br>$\quad$ 距离为r，角度为$\theta$ ，雷达两个接收天线之间的距离为d。此时，信号经物体反射到达天线1和天线2的时延分别为$\tau_1 &#x3D; 2R&#x2F;c$ 和 $\tau_2 &#x3D; ( 2R+ \Delta R )&#x2F;c$ ,其中$\Delta R &#x3D; d sin\theta$ 为该信号到达两个天线的路径差.对物体所在的距离域分别取相位并计算两根天线的相位差为$\Delta \psi &#x3D; 2\pi d sin \theta &#x2F; \lambda$ ，则物体的角度可以计算为：</p><blockquote><p>$\theta &#x3D; arcsin(\lambda \Delta \psi&#x2F;(2 \pi d))$ </p></blockquote><p>$\quad$ <strong>3DFFT</strong><br>$\quad$ 为了区分速度和距离均相同的物体，需要增加天线数量。假设有M根等距离分布的天线，则相邻两根天线上同一物体导致的相位差是相同的，为∆φ&#x3D;2π∆R&#x2F;λ&#x3D;2πdsinθ&#x2F;λ，因此在全部M个速度谱中该物体对应速度域的复数以2πdsinθ&#x2F;λ  rad&#x2F;1为角速度在复平面上转动。如果此速度域存在多个物体，则该速度域为多个旋转复数的叠加。因此，对这一系列速度域做FFT可以计算出这两个旋转复数的频率，从而换算对应物体的角度。<br><img src="/../FMCWmg/F11.png"><br>$\quad$ <strong>DBF</strong>(数字波束成形)<br>$\qquad$ 1维<br><img src="/../FMCWmg/F12.png"><br>$\qquad$ 2维：<br><img src="/../FMCWmg/F13.png"></p><h5 id="角度计算代码"><a href="#角度计算代码" class="headerlink" title="角度计算代码"></a>角度计算代码</h5><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs m">search_range<span class="hljs-built_in">=</span> [-<span class="hljs-number">90</span>:<span class="hljs-number">0.01</span>:<span class="hljs-number">90</span>];<br><br>tx1<span class="hljs-built_in">=</span>squeeze(fft_data_all_frames(<span class="hljs-number">8</span>,<span class="hljs-number">1</span>,:,<span class="hljs-number">1</span>,<span class="hljs-number">25</span>));<br><br>tx4<span class="hljs-built_in">=</span> squeeze(fft_data_all_frames(<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,:,<span class="hljs-number">1</span>,<span class="hljs-number">25</span>));<br><br>signal_in<span class="hljs-built_in">=</span>[tx1;tx4]; <span class="hljs-comment">%取出不同天线阵列对应的物体的信号向量并转化为信号向量数组</span><br><br>Wave_length <span class="hljs-built_in">=</span> <span class="hljs-number">3</span>e8/fc;<br><br>att_array<span class="hljs-built_in">=</span><span class="hljs-number">0</span>:<span class="hljs-number">7</span> ;<br><br>att_array<span class="hljs-built_in">=</span>att_array*Wave_length/<span class="hljs-number">2</span>;<br><br>[spectrum,doas] <span class="hljs-built_in">=</span> dbf(signal_in,att_array,fc,<span class="hljs-number">1</span>,search_range);<br><br>figure();<br><br>plot(-search_range,spectrum/<span class="hljs-number">10</span>);<br><br>disp(doas);<br><br>function [spectrum,doas] <span class="hljs-built_in">=</span> dbf(signal_in,antenna_array,fc,numOfSignal,search_range)<br><br><span class="hljs-comment">% 参数：输入信号signal_in、天线阵列antenna_array、中心频率fc、信号数量numOfSignal和搜索范围search_range</span><br><br>c <span class="hljs-built_in">=</span> <span class="hljs-number">3</span>e8;<br><br>signal_in <span class="hljs-built_in">=</span> reshape(signal_in,[],<span class="hljs-number">1</span>);<br><br>antenna_array <span class="hljs-built_in">=</span> reshape(antenna_array,<span class="hljs-number">1</span>,[]);<br><br>wave_length <span class="hljs-built_in">=</span> c / fc;<br><br><span class="hljs-comment">% 将输入信号signal_in和天线阵列antenna_array进行reshape操作，使其变为列向量和行向量。然后，根据光速c和中心频率fc计算波长wave_length</span><br><br>angle <span class="hljs-built_in">=</span> search_range / <span class="hljs-number">180</span> * pi;<br><br>angle <span class="hljs-built_in">=</span> reshape(angle,[],<span class="hljs-number">1</span>);<br><br>phase_shift_matrix <span class="hljs-built_in">=</span> exp(-<span class="hljs-number">1</span>i * <span class="hljs-number">2</span> * pi / wave_length * sin(angle) * antenna_array);<br><br><span class="hljs-comment">% 将搜索范围search_range转换为弧度，并将其reshape为列向量。然后，计算相移矩阵</span><br><br>spectrum <span class="hljs-built_in">=</span> abs(phase_shift_matrix*signal_in);<br><br><span class="hljs-comment">% find object in spectrum</span><br><br>[pks, locs] <span class="hljs-built_in">=</span> findpeaks(spectrum);<br><br><span class="hljs-comment">%在spectrum中找到峰值pks和对应的位置locs。将峰值按降序排序，选取前numOfSignal个峰值的位置max_index。</span><br><br>[~, pos] <span class="hljs-built_in">=</span> sort(pks,<span class="hljs-string">&#x27;descend&#x27;</span>);<br><br>max_index <span class="hljs-built_in">=</span> locs(pos(<span class="hljs-number">1</span>:numOfSignal));<br><br><span class="hljs-comment">% 最后，根据位置max_index在搜索范围search_range中找到对应的方向角doas。</span><br><br>doas <span class="hljs-built_in">=</span> search_range(max_index);<br><br><span class="hljs-comment">% % end</span><br>二位只需要把输入改成二位输入二维遍历即可<br></code></pre></td></tr></table></figure><h2 id="quad-一维测角角度谱-quad-二维测角角度谱："><a href="#quad-一维测角角度谱-quad-二维测角角度谱：" class="headerlink" title="$\quad$ 一维测角角度谱$\quad$ 二维测角角度谱："></a>$\quad$ 一维测角角度谱<br><img src="/../FMCWmg/F8.png"><br>$\quad$ 二维测角角度谱：<br><img src="/../FMCWmg/F9.png"></h2>]]></content>
    
    
    <categories>
      
      <category>CS科研</category>
      
      <category>FMCW</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FMCW</tag>
      
      <tag>测量</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FMCW基础</title>
    <link href="/2023/09/11/FMCW%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/09/11/FMCW%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>毫米波雷达基础知识</p><span id="more"></span><h1 id="FMCW基础"><a href="#FMCW基础" class="headerlink" title="FMCW基础"></a>FMCW基础</h1><h5 id="FMCW-雷达"><a href="#FMCW-雷达" class="headerlink" title="FMCW 雷达"></a>FMCW 雷达</h5><p>$\quad$ CW雷达不能提供距离信息的原因是缺乏一种能够计算距离的时延测量方法。利用脉冲进行测距是通过从发射脉冲和回波之间的时延计算来实现的，因此，可以通过诸如锯齿、三角形等的频率调制信号来实现两者的组合。<br>$\quad$ 一种最简单的频率调制波形是锯齿波信号，即频率随时间线性增加的信号。每个chirp的基本参数为起始频率$f_c$ ，带宽B和周期T。如图展示了回波和发送信号的时延关系。由于一个chirp的频率随时间变化，因此可以计算发送信号与反射回波信号的时延，从而计算物体的距离。这是使用FMCW雷达测距的基本思想。<br><img src="/../FMCWmg/F2.png"></p><h5 id="FMCW-雷达构成"><a href="#FMCW-雷达构成" class="headerlink" title="FMCW 雷达构成"></a>FMCW 雷达构成</h5><p><img src="/../FMCWmg/F1.png"></p><p>$\quad$ 一个FMCW雷达的基本结构主要由四部分组成：FM信号发生器(1)、发送天线(2)、接收天线(3)和混频器(4)。</p><p> $\quad$$\quad$ FM信号发生器生成调频信号（锯齿波或者三角波）</p><p>$\quad$ $\quad$ 混频器的输入分别是信号发生器和接收信号，<br>$\quad$ 混频器将发送信号和接受信号进行混频从而生成中频信号，输出一个频率为两个输入信号频率之差、相位也为两个输入信号相位之差的信号</p><blockquote><p>$x_{output}&#x3D;|x_1 (t)∙x_2 (t)|_{LPF}&#x3D;sin⁡[(ω_1-ω_2 )t+(φ_1-φ_2 )]$ </p></blockquote><h5 id="FMCW-信号收发流程："><a href="#FMCW-信号收发流程：" class="headerlink" title="FMCW 信号收发流程："></a>FMCW 信号收发流程：</h5><p>$\quad$（1）FM信号发生器生成调频信号（锯齿波或者三角波），该信号被分为相同的两路，其中一路连接混频器，另一路连接到发送天线；<br>$\quad$（2）发送天线向环境中发送信号；<br>$\quad$（3）信号在环境中沿不同路径传播，遇到物体后被反射回到雷达并被接收天线捕获。接收天线将接收信号发送到混频器；<br>$\quad$（4）混频器将发送信号和接受信号进行混频从而生成中频（Intermediate Frequency， IF）信号。<br>$\quad$基于以上FMCW雷达信号收发的流程，可以给出FMCW雷达收发信号的数学表达式：<br>$\quad$$\quad$（1）FM信号发生器生成连续的锯齿（chirp）波，设每个chirp的起始频率为$f_c$，周期为T，则该FMCW雷达发送的信号波长为$\lambda&#x3D;c&#x2F;T$ ，chirp斜率为$k&#x3D;B&#x2F;T$，其中c是光速。该信号每个chirp内的频率为$f_t&#x3D;f_c+kt$ ，相位为：$u(t)&#x3D;2\pi \int_0^t f(t)dt &#x3D; 2\pi (f_ct+\pi t^2&#x2F;2)$ ，则每个chirp时间内发送信号的表达式为：$x_{tx}(t) &#x3D;A cos (\mu (t))&#x3D;Acos(2 \pi (f_ct+kt^2&#x2F;2))$<br>$\quad$$\quad$(2）发送天线将以上信号发送，信号在空间中沿不同路径传播，并在遇到物体后被反射，回到雷达。为了简化推导而又不失一般性，假设环境中只有一个反射物体，其到雷达到距离为R<br>$\quad$$\quad$(3）反射信号到达接收天线，由于该反射信号在空间中传播的距离为2R，因此其传播时延为$\tau&#x3D;2R&#x2F;c$ ，则接收信号为：$x_{rx}(t)&#x3D;Bcos(\mu(t-\tau))$<br>$\quad$$\quad$ (4）混频器将接收信号与发送信号混频得到中频信号。中频信号的表达式为:$s(t)&#x3D;A’cos(2\pi (f_c\tau +k\tau t-k\tau ^2&#x2F;2)$ 其中，A’是中频信号的信号强度，与发送信号的强度、反射物体的性质、接收天线的增益等参数有关。由于$k\tau ^2&#x2F;2$ 项与为一高阶小量，因此可以忽略，则中频信号的最终表达式为：$s(t)&#x3D;A’cos(2\pi f_b t+\psi_b)$<br>$\quad$$\quad$假设空间中存在m个反射物体且每个物体的造成的信号时延为$\tau_m$ 则雷达的中频信号为：$s(t)&#x3D;\sum^M_{m&#x3D;1}A_m’(2\pi k \tau _m t+f_c\tau _m)$    </p><hr>]]></content>
    
    
    <categories>
      
      <category>CS科研</category>
      
      <category>FMCW</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FMCW</tag>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成与体系结构</title>
    <link href="/2023/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <url>/2023/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>北京大学计算机组成与体系结构总复习<br> 参考教材COD（计算机组成与设计-硬件&#x2F;软件接口）</p><span id="more"></span><h1 id="计算机组成与体系结构"><a href="#计算机组成与体系结构" class="headerlink" title="计算机组成与体系结构"></a>计算机组成与体系结构</h1><h2 id="线下内容"><a href="#线下内容" class="headerlink" title="线下内容"></a>线下内容</h2><h3 id="1-课程概述"><a href="#1-课程概述" class="headerlink" title="1-课程概述"></a><a href="https://aki-yzh.github.io/2023/03/19/1-%E8%AF%BE%E7%A8%8B%E6%A6%82%E8%BF%B0/">1-课程概述</a></h3><p>$\quad$ 世界上第一台电子计算机：ENIAC<br>$\quad$ 现代电子计算机之父：冯·诺伊曼</p><p>$\quad$ EDVAC：存储程序计算机<br>$\quad$ $\quad$ 特点：由五个基本部分组成（运算器，存储器，控制器，输入设备，输出设备）；指令和数据采用二进制，极大简化了逻辑线路；实现了存储程序概念，大幅提升任务效率。<br>$\quad$ 计算机的主要类别：<br>$\quad$ $\quad$ 1. 大型计算机<br>$\quad$ $\quad$ $\quad$ 强调高速输入与输出，海量存储空间和并行事务处理<br>$\quad$ $\quad$ $\quad$ 以面向大容量数据的事务处理为主，兼顾科学计算<br>$\quad$ $\quad$ 2.  超级计算机<br>$\quad$ $\quad$ $\quad$ 运算速度最快、性能最高、技术最复杂，代表该时期处理能力巅峰<br>$\quad$ $\quad$ $\quad$ 用于高度密集型的科学计算<br>$\quad$ $\quad$ $\quad$ 500强大部分分布于美国，中国，日本，主体为Intel x86架构，处理器主要为Intel，加速器主要为NVIDIA<br>$\quad$ $\quad$ 3. 小型计算机<br>$\quad$ $\quad$ $\quad$ 涉及事务处理和科学计算，逐渐被服务器替代<br>$\quad$ $\quad$ 4.  微型计算机<br>$\quad$ $\quad$ $\quad$ 以CPU为中央处理单元，主要以个人计算机和微控制器的形式出现。<br>$\quad$ $\quad$ $\quad$ 用于个人用途和仪器仪表</p><h3 id="2-计算机基本结构"><a href="#2-计算机基本结构" class="headerlink" title="2-计算机基本结构"></a><a href="https://aki-yzh.github.io/2023/03/19/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/">2-计算机基本结构</a></h3><p>$\quad$ 冯诺依曼结构的特点：<br>$\quad$ $\quad$ 1.  计算机由运算器（CA）、控制器（CC），存储器（M）、输入设备（I）和输出设备（O）五部分组成。<br>$\quad$ $\quad$ 2. 数据和程序均以二进制编码形式不加区别地存放在存储器中，存放位置由存储器的地址制定。<br>$\quad$ $\quad$ 3. 计算机在工作时能自动地从存储器中取出指令加以执行。<br>$\quad$  实现中，CC和CA对应CPU，M对应主存，I&#x2F;O对应外接设备，R（外部记录设备）对应硬盘</p><p>$\quad$ 指令运行的步骤：取指、译码，执行，访存</p><p> $\quad$ Intel 8086 （IA-16）<br> $\quad$ $\quad$ 特点：<br>$\quad$ $\quad$ $\quad$  1. 内部通用寄存器为16位<br> $\quad$ $\quad$ $\quad$ 2. 对外有16根数据线和20根地址线，可寻址的内存空间为1MByte<br> $\quad$ $\quad$ $\quad$ 3. 物理地址的形成采用“段加偏移”的方式<br> $\quad$  Intel 80386（IA-32）<br> $\quad$ $\quad$ 特点：<br> $\quad$ $\quad$ $\quad$ 1. 第一款32位微处理器<br> $\quad$ $\quad$ $\quad$ 2. 地址总线扩展到32位，可寻址4GB的内存空间<br> $\quad$ $\quad$ $\quad$ 3. 改进了“保护模式”<br> $\quad$ $\quad$ $\quad$ 4. 增加了“虚拟8086模式”</p><p> $\quad$ 寻址<br><img src="/../txmg/tx0001.png"><br> $\quad$ 指令指针寄存器：IP<br>  $\quad$ $\quad$ 保存一个内存地址，指向当前需要取出的指令<br>$\quad$  $\quad$   当CPU从内存中取出一个指令后，IP会自动增加指向下一个指令地址，程序员不能直接对IP进行存取操作，转移指令、过程调用&#x2F;返回指令等会改变IP的内容。<br> $\quad$ 段寄存器：CS（代码段），DS（数据段），ES（附加段），SS（堆栈段）。（FS，GS）<br>  $\quad$ $\quad$ 地址生成：段加偏移：物理地址&#x3D;段基值 X 16+偏移量（X16在16进制下即为左移1位）<br>   $\quad$  $\quad$ 开始时要把DS，SS，SP赋初值<br>  <img src="/../txmg/tx0002.png"><br>  汇编语言：<br> $\quad$  $\quad$ Intel格式：<br>  $\quad$  $\quad$  $\quad$ 寄存器和立即数没有前缀，整数有后缀<br>   $\quad$  $\quad$  $\quad$ 第一个是目的操作数，第二个是源操作数<br>   $\quad$  $\quad$  $\quad$ 基寄存器用【】<br>$\quad$ $\quad$ $\quad$ $\quad$ 间接寻址segreg【base+index x scale+disp】<br>  $\quad$  $\quad$ AT&amp;T格式：<br>   $\quad$  $\quad$  $\quad$ 寄存器使用前缀%，立即数使用前缀 “$” ,16进制数还要有前缀0x<br>  $\quad$  $\quad$  $\quad$ 第一个是源操作数，第二个是目的操作数<br>   $\quad$  $\quad$  $\quad$ 基寄存器用（）<br>   $\quad$ $\quad$ $\quad$ 间接寻址%segreg：disp（base，index，scale）<br>   $\quad$ $\quad$ $\quad$ 操作码带后缀以指出操作数的大小</p><h3 id="3-CISC-RISC-X86-MIPS指令"><a href="#3-CISC-RISC-X86-MIPS指令" class="headerlink" title="3-CISC,RISC,X86,MIPS指令"></a><a href="https://aki-yzh.github.io/2023/03/19/3-CISC,X86,RISC,MIPS%E6%8C%87%E4%BB%A4/">3-CISC,RISC,X86,MIPS指令</a></h3><p>$\quad$ CISC和RISC差别：<br>$\quad$ $\quad$ CISC指令丰富、功能强大、寻址方式灵活，但是指令使用率不均衡、结构复杂<br>$\quad$ $\quad$ RISC结构简单易于设计、指令精简程序执行效率高，但是指令数较少且寻址方式不灵活。</p><p>$\quad$ X86指令：变长<br>$\quad$ $\quad$ 最长指令15字节，最短指令1字节<br><img src="/../txmg/tx0003.png"><br><img src="/../txmg/tx0010.png"><br><img src="/../txmg/tx0009.png"><br><img src="/../txmg/tx0008.png"><br><img src="/../txmg/tx0007.png"><br><img src="/../txmg/tx0006.png"><br><img src="/../txmg/tx0005.png"><br><img src="/../txmg/tx0004.png"><br>$\quad$ MIPS<br>$\quad$ $\quad$ 减少指令类型，降低指令复杂度，属于上述的AT&amp;T格式<br>$\quad$ $\quad$ 指令定长（简化了从存储器取指令）、寻址模式简单（只有load和store可以访问存储器：简化了从存储器取操作数）、指令数量少、功能简单（简化了指令的执行过程)<br><img src="/../txmg/tx0011.png"><br>$\quad$ R型指令<br>$\quad$ $\quad$ opcode：用于指定指令的类型，对于所有R型指，该域的值均为0<br>$\quad$$\quad$  funct：与opcode域结合，精确指定指令的类型<br>$\quad$ $\quad$ rs（Source Register）：指定第一个源操作数所在的寄存器编号<br>$\quad$ $\quad$ rt（Target Register）：指定第二个源操作数所在的寄存器编号<br>$\quad$ $\quad$ rd（Destination Register）：指定目的操作数（保存运算结果）的寄存器编号<br>$\quad$ $\quad$ shamt（shift amount）：用于指定移位指令进行移位操作的位数，非移位指令设为0<br>$\quad$ $\quad$ 5-bit的域可表示0~31，对应32个通用寄存器<br>$\quad$ I型指令<br>$\quad$ $\quad$ 大部分域与R指令相同<br>$\quad$  $\quad$ opcode：用于指定指令的类型<br>$\quad$ $\quad$ rs：指定第一个源操作数所在的寄存器编号<br>$\quad$ $\quad$ rt：一般指定用于目的操作数的寄存器编号；对于某些指令指定第二个源操作数所在的寄存器编号<br>$\quad$ $\quad$ immediate：16-bit的立即数，可以表示$2^{16}$ 个不同数值</p><h3 id="4-数字电路设计"><a href="#4-数字电路设计" class="headerlink" title="4-数字电路设计"></a><a href="https://aki-yzh.github.io/2023/03/30/4-%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/">4-数字电路设计</a></h3><p><img src="/../txmg/tx0013.png"><br>$\quad$ NMOS晶体管：Gate为高电压时导通<br>$\quad$ PMOS晶体管：Gate为低电压时导通<br><img src="/../txmg/tx0012.png"><br><img src="/../txmg/tx0014.png"><br><img src="/../txmg/tx0015.png"><br><img src="/../txmg/tx0016.png"><br><img src="/../txmg/tx0019.png"><br><img src="/../txmg/tx0018.png"><br><img src="/../txmg/tx0017.png"></p><h3 id="5-控制器的原理和分类"><a href="#5-控制器的原理和分类" class="headerlink" title="5-控制器的原理和分类"></a><a href="https://aki-yzh.github.io/2023/05/01/5-%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%88%86%E7%B1%BB/">5-控制器的原理和分类</a></h3><p>$\quad$ 主要分为硬布线控制器和微程序控制器<br>$\quad$ $\quad$ 硬布线控制器用逻辑表达式来控制信号<br>$\quad$ $\quad$ $\quad$ 优点：指令执行速度快<br>$\quad$ $\quad$ $\quad$ 缺点：电路复杂，设计和验证难度大，修改困难<br><img src="/../txmg/tx0021.png"><br>$\quad$ $\quad$ 微程序控制器用微指令控制信号，发出为1，不发为0<br>$\quad$ $\quad$ $\quad$ 优点：规整灵活<br>$\quad$ $\quad$ $\quad$ 缺点：速度较慢<br><img src="/../txmg/tx0020.png"></p><h3 id="6-流水线优化技术"><a href="#6-流水线优化技术" class="headerlink" title="6-流水线优化技术"></a><a href="https://aki-yzh.github.io/2023/05/01/6-%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF/">6-流水线优化技术</a></h3><p>$\quad$ 五级流水线：取指——译码——地址生成——执行——写回(现在是4发射16级流水线)<br>$\quad$ 转移指令：改变指令流向，破坏流水模式<br>$\quad$ $\quad$ 占比：每4～7条指令就有一条转移指令，所占比例大约为15～25%<br>$\quad$ $\quad$ 损失：Alpha：7个，Pentium：10～15，AMD：10；<br>$\quad$ $\quad$ 总损失等于占比x损失<br>$\quad$ 转移开销：<br>$\quad$ $\quad$ 当转移指令被执行，并确实发生转移时，产生的开销称为“转移开销”，如将按顺序预取的指令废除，从 转移目标地址重新获取指令。<br>$\quad$ $\quad$ 构成：要不要转移（转移条件判定）？转移到哪里？（生成目标地址）<br>$\quad$ $\quad$ 减少开销：<br>$\quad$ $\quad$ $\quad$ 转移延迟<br>$\quad$ $\quad$ $\quad$ 转移预测：<br>$\quad$ $\quad$ $\quad$ $\quad$ 转移条件预测：固定预测、编译制导、基于偏移预测，基于历史信息预测（普遍采用）<br><img src="/../txmg/tx0021%201.png"><br>$\quad$ $\quad$ $\quad$ $\quad$ 转移地址预测:<br>$\quad$ $\quad$ $\quad$ $\quad$ $\quad$ BTB（转移目标缓冲器）：保存之前若干次转移指令执行时的目标地址。<br><img src="/../txmg/tx602.png"><br>$\quad$ $\quad$ $\quad$ 操作<br>$\quad$ $\quad$ $\quad$ $\quad$ 1. 分配BTB表项：转移目标第一次执行分配一个表项，自身地址保存在转移指令地址，转移目标地址保存在转移目标地址<br>$\quad$ $\quad$ $\quad$ $\quad$ 2. BTB表项比较：将需要预测的指令地址与BTB的转移指令地址进行比较，若命中则被执行过且为转移指令<br>$\quad$ $\quad$ $\quad$ $\quad$ 3. 产生转移目标地址：若命中则读出转移目标地址作为下一条指令地址<br>$\quad$ $\quad$ $\quad$ $\quad$ 4. 更新BTB<br><img src="/../txmg/tx603.png"><br><img src="/../txmg/tx604.png"><br><img src="/../txmg/tx605.png"><br>$\quad$ $\quad$ $\quad$ 返回地址栈：<br>$\quad$ $\quad$ $\quad$ $\quad$ 优点：<br>$\quad$ $\quad$ $\quad$ $\quad$ $\quad$ 1. 无需判定转移条件<br>$\quad$ $\quad$ $\quad$ $\quad$ $\quad$ 2. 转移目标地址已生成<br>$\quad$ $\quad$ $\quad$ $\quad$ $\quad$ 3. 出现可预期<br>$\quad$ $\quad$ $\quad$ $\quad$ 缺点：<br>$\quad$ $\quad$ $\quad$ $\quad$ $\quad$ 1. 同一条指令地址不同<br>$\quad$ $\quad$ $\quad$ $\quad$ $\quad$ 2. 转移目标地址访问时间较长<br>$\quad$ $\quad$ $\quad$ $\quad$ $\quad$ 3. 在流水线晚期才访问存储器获得转移目标地址</p><h3 id="7-输入输出接口"><a href="#7-输入输出接口" class="headerlink" title="7-输入输出接口"></a><a href="https://aki-yzh.github.io/2023/05/10/7-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8E%A5%E5%8F%A3/">7-输入输出接口</a></h3><p>$\quad$ 产生原因：CPU和外设间速度差距，外设处理的信息格式和接口信号形式多样<br>$\quad$ 基本功能：数据缓冲、提供联络信息、信号与信息格式的转换、设备选择、中断管理、可编程功能<br>$\quad$ 基本结构<br><img src="/../txmg/tx0023.png"><br>$\quad$ 两种编址方式：I&#x2F;O和存储器分开编址，I&#x2F;O端口和存储器统一编址<br>$\quad$ $\quad$ 统一编址：优点：1.可以用访问存储器的指令来访问I&#x2F;O端口，功能齐全2.可以将CPU中的I&#x2F;O操作设为同一套控制逻辑，简化内部结构；缺点：1. 使得存储地址相对减小2.指令更长，使得执行时间变长，译码不方便，指令更难理解<br>$\quad$ $\quad$ 分开编址：反过来即可<br>$\quad$ 简单外设字节0～7bit连接，复杂外设增加握手信号（准备好输入输出信号）<br>$\quad$ 数据输入过程：<br>$\quad$ $\quad$ 1. 系统初始化时，CPU执行OUT指令，将控制字写入接口的“控制寄存器”，从而设置接口的工作模式<br>$\quad$ $\quad$ 2. 外设将数据发到“并行数据输入”信号，并将“输入准备好”信号置为有效<br>$\quad$ $\quad$ 3. 接口发现“输入准备好”信号有效后，从“并行数据输入”信号接收数据，放入“输入缓冲寄存器”，并将“输入回答”信号置为有效，阻止外设输入新数据<br>$\quad$ $\quad$ 4. 接口将状态寄存器中的状态位“输入缓存器满”置为有效<br>$\quad$ $\quad$ 5. 在上述过程中，CPU反复执行IN指令从“状态寄存器“中读出状态字，直到发现”输入缓冲器满“，然后执行IN指令，从“输入缓冲寄存器”中读出数据<br>$\quad$ $\quad$ 6. 接口将“输入回答”信号置为无效，等待外设输入新数据<br> $\quad$ $\quad$ （此为程序控制方式，还可以采用终端控制方式）<br> $\quad$ 数据输出过程：<br>$\quad$  $\quad$ 1. CPU执行OUT指令，将控制字写入接口的“控制寄存器”，从而设置接口的工作模式<br>$\quad$  $\quad$ 2. CPU执行OUT指令，将数据写到接口的“输出缓冲寄存器”<br>$\quad$  $\quad$ 3. 接口将数据发到“并行数据输出”信号，并将“输出准备好”信号置为己有（亦可由CPU写控制字将该信息置为有效）<br>$\quad$  $\quad$ 4. 外设发现“输出准备好信号”后，从“并行数据输出”信号接收数据，并将“输出回答信号”置为有效<br>$\quad$  $\quad$ 5. 接口发现“输出回答”信号有效后，将“状态寄存器”中的状态位“输出缓存器空”置为有效<br>$\quad$  $\quad$ 6. 在这个过程中，CPU反复执行IN指令从“状态寄存”器中读出状态字，直到发现“输出缓冲器空”，然后开始下一个输出过程，继续输出新数据<br>$\quad$  $\quad$ （此为程序控制方式，还可以采用终端控制方式）<br> $\quad$  串&#x2F;并行通信<br>  $\quad$  $\quad$ 串行通信传输线数量少，需要通过复杂的串并转换，同频率下数据传输率低，但是避免了信号线间的窜扰。并行通信反过来。<br>   $\quad$  $\quad$ 差分信号传输时串行兴起的原因，优点是抗干扰能力强，能有效抑制电磁干扰，时序定位准确，缺点是布线难度高。</p><h3 id="8-中断和异常"><a href="#8-中断和异常" class="headerlink" title="8-中断和异常"></a><a href="https://aki-yzh.github.io/2023/05/18/8-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/">8-中断和异常</a></h3><p>$\quad$ 异常处理的起源：UNIAC（1951年）算术运算溢出时，转向地址0执行两条修复指令或者停机<br>$\quad$ 中断处理的起源：DYSEAC（1954年），有两个程序计数器根据I&#x2F;O信号进行切换</p><p>$\quad$ 外部中断优先级：<br>$\quad$ $\quad$ 1. 软件查询确定中断优先级（只需要少量硬件电路）<br>$\quad$ $\quad$ 2. 硬件终端优先级编码电路<br>$\quad$ $\quad$ 3. 可编程中断控制器（如8259A）：管理和控制CPU的外部中断请求，实现中断优先级的判决，为CPU提供中断类型码，选择屏蔽设备的中断请求<br><img src="/../txmg/tx0024.png"><br><img src="/../txmg/tx0025.png"><br>$\quad$ 可编程计数器&#x2F;定时器（8253）<br>$\quad$ $\quad$ 功能灵活使用方便<br><img src="/../txmg/tx812.png"></p><h3 id="9-总线"><a href="#9-总线" class="headerlink" title="9-总线"></a><a href="https://aki-yzh.github.io/2023/05/28/9-%E6%80%BB%E7%BA%BF/">9-总线</a></h3><p>$\quad$ 在多于两个模块（设备或子系统）间传送信息的公共通路<br>$\quad$ 由传输信息的电路和管理信息传输的协议组成<br>$\quad$  分类<br>$\quad$ $\quad$ 片上总线：中央处理器芯片内部的总线<br>$\quad$ $\quad$ 内总线：各插板之间的信息传输的通路<br>$\quad$ $\quad$ 外总线：计算机系统间的通路<br>$\quad$ 译码器：根据当前控制总线的主模块提供的地址，选择作为本次总线传输目标的从模块<br>$\quad$ 仲裁器：在总线上有多个主模块同时请求使用总线时，决定哪个主模块获得控制权<br><img src="/../txmg/tx906.png"><br>$\quad$ 总线标准的内容<br>$\quad$ $\quad$ 1- 机械特性： 规定模块插件的机械尺寸，总线插头、插座的规格及位置等。<br>$\quad$ $\quad$ 2- 电气特性： 规定总线信号的逻辑电平、噪声容限以及负载能力等<br>$\quad$ $\quad$ 3-功能特性：给出各总线信号的名称及功能定义<br>$\quad$ $\quad$ 4-规程特性：对各总线信号的动作过程及时序关系进行说明<br>$\quad$ 总线协议实例：<br>$\quad$ $\quad$ 会画时序图:HREADY两根线表示没关系，低电平表示没好，高电平表示好了</p><h3 id="10-计算机系统先进技术"><a href="#10-计算机系统先进技术" class="headerlink" title="10-计算机系统先进技术"></a><a href="https://aki-yzh.github.io/2023/05/30/10-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%85%88%E8%BF%9B%E6%8A%80%E6%9C%AF/">10-计算机系统先进技术</a></h3><p>$\quad$ 片上总线难以满足需求：长时间等待返回读数据时，大量与此无关的传输无法发起<br>$\quad$ PCI中断方案：1. PCI设备保证在数据到达目的地之后再提交中断请求；（硬件开销大，不容易实现，还会增加中断请求的延时）2. 中端服务程序使用读刷新方法（绝大数处理器采用）<br>$\quad$ MSI中断机制：<br><img src="/../txmg/tx0022.png"><br>$\quad$ $\quad$ 优点：解决了多个设备共享中断信号的问题，解决了每个功能设备只支持一个中断的问题，“异步”中断的数据完整性问题。<br>$\quad$ $\quad$ 缺点：要占用总线带宽</p><h2 id="线上内容"><a href="#线上内容" class="headerlink" title="线上内容"></a>线上内容</h2><p>$\quad$ 加法器：<br>$\quad$ 门延迟：通过一次门电路计为1<br>$\quad$ 关键路径：延迟最长的路径<br>$\quad$ $G_i &#x3D; A_i<em>B_i,P_i&#x3D;A_i+B_i$<br>$\quad$ 由$C_{i+1}&#x3D;G_i+P_i</em>C_i$ 提前计算进位信号，总延迟为4级门延迟<br>$\quad$ 乘法器<br><img src="/../txmg/tx608.png"><br><img src="/../txmg/tx609.png"><br><img src="/../txmg/tx610.png"><br>$\quad$ 除法器：<br><img src="/../txmg/tx611.png"><br><img src="/../txmg/tx612.png"><br><img src="/../txmg/tx613.png"><br><img src="/../txmg/tx0028.png"></p>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>COD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>目录</tag>
      
      <tag>COD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10-计算机系统先进技术</title>
    <link href="/2023/05/30/10-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%85%88%E8%BF%9B%E6%8A%80%E6%9C%AF/"/>
    <url>/2023/05/30/10-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%85%88%E8%BF%9B%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<p> 对应 北京大学计算机组成与体系结构第十讲<br> 参考教材COD（计算机组成与设计-硬件&#x2F;软件接口）</p><span id="more"></span><h1 id="计算机组成与体系结构"><a href="#计算机组成与体系结构" class="headerlink" title="计算机组成与体系结构"></a>计算机组成与体系结构</h1><hr><h2 id="计算机系统先进技术"><a href="#计算机系统先进技术" class="headerlink" title="计算机系统先进技术"></a>计算机系统先进技术</h2><h3 id="片上互连结构"><a href="#片上互连结构" class="headerlink" title="片上互连结构"></a>片上互连结构</h3><p>$\quad$ 未来单个芯片内将集成几百上千处理单元和存储单元</p><h3 id="内存技术的发展"><a href="#内存技术的发展" class="headerlink" title="内存技术的发展"></a>内存技术的发展</h3><p>$\quad$ 更低电压，更低功耗</p><h3 id="中断机制的发展"><a href="#中断机制的发展" class="headerlink" title="中断机制的发展"></a>中断机制的发展</h3><h4 id="PCI"><a href="#PCI" class="headerlink" title="PCI"></a>PCI</h4><p><img src="/../txmg/tx1002.png"><br>$\quad$ 当PCI设备使用DMA方式写存储器时。该设备在最后一个数据离开其发送FIFO时，会认为DMA写操作已经完成。此时这个设备将通过INTx信号通知处理器。但是当处理器收到中断信号时，并不意味着PCI设备已经将数据写入存储器中</p><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><h6 id="1-PCI设备保证在数据到达目的地之后，再提交中断请求"><a href="#1-PCI设备保证在数据到达目的地之后，再提交中断请求" class="headerlink" title="1. PCI设备保证在数据到达目的地之后，再提交中断请求"></a>1. PCI设备保证在数据到达目的地之后，再提交中断请求</h6><p>$\quad$PCI设备无法单纯通过硬件逻辑判断数据什么时候写入到存储器，需要使用“读刷新”的方法。PCI设备在提交中断请求之前，向DMA写的数据区域发出一个读请求，当PCI设备完成这个总线传输后，再向处理器提交中断请求。<br>$\quad$ 该方法硬件开销大，不容易实现，还将增加中断请求的延时</p><h6 id="中断服务程序使用“读刷新”方法"><a href="#中断服务程序使用“读刷新”方法" class="headerlink" title="中断服务程序使用“读刷新”方法"></a>中断服务程序使用“读刷新”方法</h6><p>$\quad$中断服务程序在使用“PCI设备写入存储器”的这些数据之前，对该设备进行读操作。该方法利用PCI总线的传送序规则，从而保证数据写入存储器。<br>$\quad$ 绝大多数处理器系统采用该方法<br>$\quad$<strong>操作</strong>：中断服务程序先读取PCI设备中断状态寄存器，判断中断产生原因后，才对PCI设备写入的数据进行操作<br>$\quad$<strong>作用</strong>：一方面可以获得设备的中断状态，另一方面是保证DMA写的数据最终到达存储器。如果不这样做，就可能产生数据完整性问题</p><h4 id="“异步”中断所带来的数据完整性问题"><a href="#“异步”中断所带来的数据完整性问题" class="headerlink" title="“异步”中断所带来的数据完整性问题"></a>“异步”中断所带来的数据完整性问题</h4><p>$\quad$ <strong>现实情况：</strong><br>$\quad$ $\quad$ 在操作系统中，即便中断服务程序没有先读取PCI设备的寄存器，一般<br>不会出现问题<br>$\quad$ <strong>原因：</strong><br>$\quad$ $\quad$ 在操作系统中，一个PCI设备从提交中断到处理器开始执行设备的中断服务程序，所需时间较长，基本上可以保证此时数据已经写入存储器<br>$\quad$ <strong>隐患：</strong><br>$\quad$ $\quad$ 虽然绝大多数时候不会出错，但是这个驱动程序依然有Bug存在，一旦出错则难以定位</p><h4 id="MSI中断机制"><a href="#MSI中断机制" class="headerlink" title="MSI中断机制"></a>MSI中断机制</h4><p>$\quad$ Message Signaled Interrupt<br>$\quad$ 当设备向一个特殊地址写入时，会向CPU产生一个中断，即MSI中断<br>$\quad$ PCI 2.2中定义了MSI，PCI 3.0中引入MSI-X<br><img src="/../txmg/tx1001.png"></p><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><p>$\quad$ 1. 解决了多个设备共享中中断信号的问题<br>$\quad$ 2. 解决了每个功能设备只能支持一个中断的问题<br>$\quad$ 3. “异步”中断的数据完整性问题</p><h5 id="缺点：要占用总线带宽"><a href="#缺点：要占用总线带宽" class="headerlink" title="缺点：要占用总线带宽"></a>缺点：要占用总线带宽</h5><h3 id="芯片封装技术"><a href="#芯片封装技术" class="headerlink" title="芯片封装技术"></a>芯片封装技术</h3><p>$\quad$ ·引线键合（Wire-bonding）<br>$\quad$ ·倒装片（Flip-chip）<br>$\quad$ ·双列直插式封装DIP(Dual Inline-pin Package)<br>$\quad$ ·薄型小尺寸封装TSOP(Thin Small Outline Package)<br>$\quad$ ·四侧引脚扁平封装QFP(Quad Flat Package)<br>$\quad$ ·引脚网格阵列PGA(Pin Grid Array)<br>$\quad$ ·球栅阵列BGA(Ball Grid Array)</p><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>COD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>COD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9-总线</title>
    <link href="/2023/05/28/9-%E6%80%BB%E7%BA%BF/"/>
    <url>/2023/05/28/9-%E6%80%BB%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<p> 对应 北京大学计算机组成与体系结构第九讲<br> 参考教材COD（计算机组成与设计-硬件&#x2F;软件接口）</p><span id="more"></span><h1 id="计算机组成与体系结构"><a href="#计算机组成与体系结构" class="headerlink" title="计算机组成与体系结构"></a>计算机组成与体系结构</h1><hr><h2 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h2><p>$\quad$ 在多于两个模块（设备或子系统）间传送信息的公共通路<br>$\quad$ 组成：传输信息的电路和管理信息传输的协议</p><h3 id="总线的分类"><a href="#总线的分类" class="headerlink" title="总线的分类"></a>总线的分类</h3><h4 id="1-片总线"><a href="#1-片总线" class="headerlink" title="1. 片总线"></a>1. 片总线</h4><p>$\quad$ 又称器件级总线——”片上总线“，是中央处理器芯片内部的总线</p><h4 id="2-内总线"><a href="#2-内总线" class="headerlink" title="2. 内总线"></a>2. 内总线</h4><p>$\quad$ 又称系统总线或板级总线，是计算机系统各插件版之间信息传输的通路，通常称为微型计算机总线的即指内总线。</p><h4 id="3-外总线"><a href="#3-外总线" class="headerlink" title="3. 外总线"></a>3. 外总线</h4><p>$\quad$ 又称通信总线，是计算机系统之间，或者计算机系统与其他系统之间信息传输的通路</p><h3 id="总线的基本结构"><a href="#总线的基本结构" class="headerlink" title="总线的基本结构"></a>总线的基本结构</h3><p><img src="/../txmg/tx901.png"></p><h4 id="总线模块"><a href="#总线模块" class="headerlink" title="总线模块"></a>总线模块</h4><h5 id="总线主模块（Bus-Master"><a href="#总线主模块（Bus-Master" class="headerlink" title="总线主模块（Bus Master)"></a>总线主模块（Bus Master)</h5><p>$\quad$ 具有总线控制能力，在获得总线控制权之后能启动总线传输（读数据或写数据）<br>$\quad$ 示例： CPU，DMA控制器</p><h5 id="总线从模块-（Bus-Slave）"><a href="#总线从模块-（Bus-Slave）" class="headerlink" title="总线从模块 （Bus Slave）"></a>总线从模块 （Bus Slave）</h5><p>$\quad$ 能够对总线传输作出响应（接收写数据、返回读数据、返回“错误”响应等），但本身不具备总线控制能力<br>$\quad$ 示例：存储器</p><h4 id="总线译码器"><a href="#总线译码器" class="headerlink" title="总线译码器"></a>总线译码器</h4><p>$\quad$ 功能：根据当前控制总线的主模块提供的地址，选择作为本次总线传输目标的从模块<br><img src="/../txmg/tx902.png"></p><h4 id="总线仲裁器"><a href="#总线仲裁器" class="headerlink" title="总线仲裁器"></a>总线仲裁器</h4><p>$\quad$ 功能：在总线上有多个主模块同时请求使用总线时，决定由哪个主模块获得总线控制权<br>$\quad$ 目的：让总线得到合理、高效地使用<br><img src="/../txmg/tx904.png"></p><h4 id="总线示意图"><a href="#总线示意图" class="headerlink" title="总线示意图"></a>总线示意图</h4><p><img src="/../txmg/tx905.png"><br><img src="/../txmg/tx906.png"><br><img src="/../txmg/tx907.png"><br><img src="/../txmg/tx903.png"></p><h3 id="总线协议"><a href="#总线协议" class="headerlink" title="总线协议"></a>总线协议</h3><h4 id="总线标准"><a href="#总线标准" class="headerlink" title="总线标准"></a>总线标准</h4><h5 id="产生途径"><a href="#产生途径" class="headerlink" title="产生途径"></a>产生途径</h5><p><strong>事实标准</strong><br>$\quad$ 计算机系统厂家所采用的一种总线，由于其性能优越，逐渐形 成一种被业界广泛支持和承认的事实总线标准<br><strong>国际标准</strong><br>$\quad$ 在国际标准组织或机构主持下开发和制定的总线标准，公布后由厂家和用户使用</p><h5 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h5><p>$\quad$ <strong>1- 机械特性</strong>： 规定模块插件的机械尺寸，总线插头、插座的规格及位置等。<br>$\quad$ <strong>2- 电气特性</strong>： 规定总线信号的逻辑电平、噪声容限以及负载能力等<br>$\quad$ <strong>3-功能特性</strong>：给出各总线信号的名称及功能定义<br>$\quad$ <strong>4-规程特性</strong>：对各总线信号的动作过程及时序关系进行说明</p><h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><p><img src="/../txmg/tx908.png"><br>$\quad$ 2000年前后EISA逐渐退出市场</p><h6 id="PCI-Express"><a href="#PCI-Express" class="headerlink" title="PCI Express"></a>PCI Express</h6><p>$\quad$ ◦ 串行方式传输数据，依靠高频率获得高性能<br>$\quad$ ◦ 全双工运作模式，同时进行数据发送和接收<br>$\quad$ ◦ 点对点连接结构，而非传统的共享结构<br>$\quad$ ◦ 使用“端到端的数据传送方式” ，两端都含有TX(发送逻辑)和RX(接收逻辑)<br>$\quad$ ◦ PCIe总线物理层采用差分信号传输<br>$\quad$ $\quad$ $\quad$ 优点：抗干扰能力强，能有效抑制电磁干扰，时序定位准确<br>$\quad$ $\quad$ $\quad$ 缺点：在电路板上，差分信号一定要走 两根等长、等宽、紧密靠近且在 同一层面的线，布线难度高</p><h4 id="协议实例-AMBA"><a href="#协议实例-AMBA" class="headerlink" title="协议实例-AMBA"></a>协议实例-AMBA</h4><p><img src="/../txmg/tx909.png"></p><h5 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h5><p><img src="/../txmg/tx910.png"></p><h5 id="场景一：最简单的传输"><a href="#场景一：最简单的传输" class="headerlink" title="场景一：最简单的传输"></a>场景一：最简单的传输</h5><h6 id="主模块读一个数据"><a href="#主模块读一个数据" class="headerlink" title="主模块读一个数据"></a>主模块读一个数据</h6><p><img src="/../txmg/tx911.png"><br><img src="/../txmg/tx912.png"></p><h6 id="主模块写一个数据"><a href="#主模块写一个数据" class="headerlink" title="主模块写一个数据"></a>主模块写一个数据</h6><p><img src="/../txmg/tx913.png"></p><h6 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h6><p>$\quad$ 1.在第一个时钟上升沿之后，主模块驱动HADDR和 Control信号<br>$\quad$ 2.在第二个时钟上升沿，从模块采样HADDR和Control信 号<br>$\quad$ 3. 在第二个时钟上升沿之后,写传输：主模块驱动HWDATA信号 ;   读传输：从模块驱动HRDATA信号<br>$\quad$ 4. 在第三个时钟上升沿 ,写传输：从模块采样HWDATA信号，完成传输;读传输：主模块采样HRDATA信号，完成传输</p><h5 id="场景二：主模块发起传输时，从模块未准备好"><a href="#场景二：主模块发起传输时，从模块未准备好" class="headerlink" title="场景二：主模块发起传输时，从模块未准备好"></a>场景二：主模块发起传输时，从模块未准备好</h5><p>$\quad$ 从模块无法提供读数据或从模块无法接收写数据<br><img src="/../txmg/tx914.png"><br><img src="/../txmg/tx915.png"></p><h6 id="要点："><a href="#要点：" class="headerlink" title="要点："></a>要点：</h6><p>$\quad$ 从模块可以在传输过程中插入等待周期，以便获得额外的时间 ，如暂存写数据的缓冲已满、读数据未准备好等<br>$\quad$ 在等待周期中，主模块必须保持地址、控制和写数据等信号的稳定。</p><h5 id="场景三：多个连续的传输"><a href="#场景三：多个连续的传输" class="headerlink" title="场景三：多个连续的传输"></a>场景三：多个连续的传输</h5><p>$\quad$ 一个主模块连续发起多个的传输或多个不同的主模块先后发起传输<br><img src="/../txmg/tx916.png"></p><h6 id="要点-1"><a href="#要点-1" class="headerlink" title="要点"></a>要点</h6><p>$\quad$ 1.时间重叠（overlap）<br>$\quad$ $\quad$ ◦ 不同传输的地址和数据在时间上存在重叠<br>$\quad$ $\quad$ ◦ 充分利用地址总线和数据总线<br>$\quad$ 2.等待周期<br>$\quad$ $\quad$ ◦ 地址A和C的传输中没有等待周期<br>$\quad$ $\quad$ ◦ 地址B的传输中有一个等待周期，该传输的数据阶段扩展了一个周期<br>$\quad$ 3.等待周期的副作用<br>$\quad$ $\quad$ ◦ 因为地址B的传输中的等待周期，所以地址C的传输的地址阶段受其影响 而扩展了一个周期</p><h5 id="场景四：大量连续数据的传输"><a href="#场景四：大量连续数据的传输" class="headerlink" title="场景四：大量连续数据的传输"></a>场景四：大量连续数据的传输</h5><p>$\quad$ 一次传输的数据量超过了数据总线的宽度， 例如，CPU需要从内存中读出连续的16字节（128位）的数据，但数据总线宽度为32位<br><img src="/../txmg/tx919.png"><br><img src="/../txmg/tx918.png"><br><img src="/../txmg/tx917.png"><br> $\quad$ BURST传输用于高速缓存的行填充（读）、行替换，外设和主存之间的大量连续数据传输以及主存中不同区域之间的大量连续数据传输</p><h6 id="要点-2"><a href="#要点-2" class="headerlink" title="要点"></a>要点</h6><p> $\quad$ T1 ：传输开始 ， 主模块发出第一个地址 ， 驱 动 HTRANS&#x3D;NONSEQ，HBURST&#x3D;INCR4<br>  $\quad$ T2 ：传输继续 ， 主模块发出第二个地址 ， 驱 动 HTRANS&#x3D;SEQ，保持HBURST&#x3D;INCR4<br> $\quad$ ……<br>$\quad$T6：主模块发出的第四个地址已被从模块采样，无需再 发出新的地址和控制信号，因此驱动HTRANS&#x3D;IDLE  $\quad$ T7：传输完成</p><h5 id="场景五：希望先得到Burst传输中的某个特定数据"><a href="#场景五：希望先得到Burst传输中的某个特定数据" class="headerlink" title="场景五：希望先得到Burst传输中的某个特定数据"></a>场景五：希望先得到Burst传输中的某个特定数据</h5><p><img src="/../txmg/tx920.png"><br><img src="/../txmg/tx921.png"><br><img src="/../txmg/tx922.png"></p><h6 id="要点-3"><a href="#要点-3" class="headerlink" title="要点"></a>要点</h6><p>$\quad$ 地址回卷的边界（假设数据宽度为4字节）<br>$\quad$$\quad$◦ WRAP4：在16的整数倍的地址处回卷（4×4）<br>$\quad$$\quad$◦ WRAP8：在32的整数倍的地址处回卷（4×8）<br>$\quad$$\quad$◦ WRAP16：在64的整数倍的地址处回卷（4×16）<br>$\quad$传输地址变化示例<br>$\quad$$\quad$◦ INCR4： 0x38 0x3C 0x40 0x44<br>$\quad$$\quad$◦ WRAP4：0x38 0x3C 0x30 0x34<br>$\quad$$\quad$◦ INCR4： 0x30 0x34 0x38 0x3C<br>$\quad$$\quad$$\quad$起始地址和访问区域相同</p><h5 id="场景六：在Burst传输的过程中，主模块未准备好"><a href="#场景六：在Burst传输的过程中，主模块未准备好" class="headerlink" title="场景六：在Burst传输的过程中，主模块未准备好"></a>场景六：在Burst传输的过程中，主模块未准备好</h5><p>主模块无法提供写数据 或主模块无法接收读数据<br><img src="/../txmg/tx923.png"><br><img src="/../txmg/tx924.png"></p><h5 id="场景七：需要传输的数据宽度比数据总线的宽度小"><a href="#场景七：需要传输的数据宽度比数据总线的宽度小" class="headerlink" title="场景七：需要传输的数据宽度比数据总线的宽度小"></a>场景七：需要传输的数据宽度比数据总线的宽度小</h5><p>$\quad$ 例如，需要传输1个16位的数据，而数据总线的宽度是32位的<br><img src="/../txmg/tx926.png"><br><img src="/../txmg/tx925.png"><br><img src="/../txmg/tx927.png"></p><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>COD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>COD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8-中断和异常</title>
    <link href="/2023/05/18/8-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/"/>
    <url>/2023/05/18/8-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<p> 对应 北京大学计算机组成与体系结构第八讲<br> 参考教材COD（计算机组成与设计-硬件&#x2F;软件接口）</p><span id="more"></span><h1 id="计算机组成与体系结构"><a href="#计算机组成与体系结构" class="headerlink" title="计算机组成与体系结构"></a>计算机组成与体系结构</h1><hr><h2 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h2><h3 id="中断与异常"><a href="#中断与异常" class="headerlink" title="中断与异常"></a>中断与异常</h3><h4 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h4><p><strong>第一个带有异常处理的系统</strong>： UNIVAC，1951年：算术运算溢出时，转向地址0执行两条修复指令，或者停机。1955年新增外部中断用于风洞数据的实时收集。<br><strong>第一个带有外部中断的系统</strong>： DYSEAC，1954年：有两个程序计数器PC，根据I&#x2F;O信号进行切换。</p><h4 id="CPU遇到的事件"><a href="#CPU遇到的事件" class="headerlink" title="CPU遇到的事件"></a>CPU遇到的事件</h4><p>$\quad$ 在程序运行时，系统外部、内部或现行程序本身出现需要特殊处理的事件，CPU立即强行终止现行程序的运行，改变机器的工作状态并启动相应的程序来处理这些事件，处理完成后，CPU恢复原来的程序运行。这些事件被称为“中断”或者“异常”。</p><h5 id="MIPS-CPU的异常处理"><a href="#MIPS-CPU的异常处理" class="headerlink" title="MIPS CPU的异常处理"></a>MIPS CPU的异常处理</h5><p>$\quad$ 1. 在EPC（异常程序计数器）中保存出现异常的指令的地址（需要减4）<br>$\quad$ 2. 清空流水线中之后的指令<br>$\quad$ 3. 记录产生异常的原因<br>$\quad$ 4. 将控制权转交给操作系统的特定地址，转移到特定地址执行下一条指令</p><h5 id="中断向量"><a href="#中断向量" class="headerlink" title="中断向量"></a>中断向量</h5><p>$\quad$ 中断服务程序的入口地址<br>$\quad$ 每个中断类型对应一个中断向量（4字节），前两个字节单元存放中断服务程序入口地址的偏移量（IP），低字节在前，高字节在后；后两个字节单元存放中断服务程序入口地址的段基值（CS），低字节在前，高字节在后。<br><img src="/../txmg/tx801.png"></p><h6 id="中断的检测"><a href="#中断的检测" class="headerlink" title="中断的检测"></a>中断的检测</h6><p><img src="/../txmg/tx802.png"></p><h6 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h6><p><img src="/../txmg/tx803.png"><br><img src="/../txmg/tx804.png"></p><h3 id="中断控制器"><a href="#中断控制器" class="headerlink" title="中断控制器"></a>中断控制器</h3><p> $\quad$ 外部中断的需求：<br> $\quad$ $\quad$ - 优先级：多个中断请求同时出现，如何确定响应次序？<br> $\quad$ $\quad$ - 屏蔽：可否屏蔽指定I&#x2F;O接口设备的中断请求<br> <img src="/../txmg/tx805.png"></p><h4 id="优先级的确定"><a href="#优先级的确定" class="headerlink" title="优先级的确定"></a>优先级的确定</h4><h5 id="1-软件查询确定中断优先级"><a href="#1-软件查询确定中断优先级" class="headerlink" title="1.软件查询确定中断优先级"></a>1.软件查询确定中断优先级</h5><p>$\quad$ 只需要少量硬件电路<br><img src="/../txmg/tx806.png"><br>$\quad$ 查询程序：一般来说，先查速度较快或者实时性较高的设备，它们优先级较高。<br><img src="/../txmg/tx807.png"></p><h5 id="2-硬件中断优先级编码电路"><a href="#2-硬件中断优先级编码电路" class="headerlink" title="2.硬件中断优先级编码电路"></a>2.硬件中断优先级编码电路</h5><p> $\quad$ 菊花链优先级排队电路：在每个设备接口设置一个简单的逻辑电路，根据优先级顺序来传递或截流CPU发出的中断响应信号，以实现响应中断的顺序。<br> <img src="/../txmg/tx808.png"></p><h5 id="3-可编程中断控制器"><a href="#3-可编程中断控制器" class="headerlink" title="3.可编程中断控制器"></a>3.可编程中断控制器</h5><p>$\quad$ 现代PC机中多采用可编程中断控制器（PIC，高级APIC）来处理中断<br><img src="/../txmg/tx809.png"></p><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><h4 id="计数与定时"><a href="#计数与定时" class="headerlink" title="计数与定时"></a>计数与定时</h4><p>$\quad$ <strong>计数</strong><br>$\quad$ $\quad$ 对外部事件发生的次数进行计量<br>$\quad$ <strong>定时</strong><br>$\quad$ $\quad$ 主要是指产生一段准确的时延<br>$\quad$ $\quad$ 定时是对固定的时间单位进行计数，本质上也是计数，是以计数为基础的</p><h5 id="主要用途"><a href="#主要用途" class="headerlink" title="主要用途"></a>主要用途</h5><p>$\quad$ <strong>计算机系统</strong><br>$\quad$ $\quad$ 提供系统的日时钟<br>$\quad$ $\quad$ 接口电路的工作节拍，信息传送的同步信号<br>$\quad$ $\quad$ 保证在确定时刻完成规定动作<br>$\quad$ $\quad$ 提供时间基准，供操作系统切换进程<br>$\quad$ <strong>工业测控系统</strong><br>$\quad$ $\quad$ 对产品计数，定时进行某些行为<br>$\quad$ <strong>声音&#x2F;音乐</strong><br>$\quad$ $\quad$ 由计数&#x2F;定时的基本功能派生而来</p><h4 id="可编程计数-x2F-定时器"><a href="#可编程计数-x2F-定时器" class="headerlink" title="可编程计数&#x2F;定时器"></a>可编程计数&#x2F;定时器</h4><p>$\quad$ 软硬件相结合的定时计数方法<br>$\quad$ 特点：功能灵活，使用方便</p><h5 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h5><p><img src="/../txmg/tx810.png"><br>$\quad$ CLK:时钟输入信号<br>$\quad$ GATE：门控输入信号，对计数过程进行控制<br>$\quad$ OUT：计数输出信号，“计数到零&#x2F;定时时间到”输出</p><h6 id="方式2-分频器"><a href="#方式2-分频器" class="headerlink" title="方式2:分频器"></a>方式2:分频器</h6><p>$\quad$ 输出波形：每输入N个CLK脉冲，输出宽度为1个CLK周期的负脉冲<br><img src="/../txmg/tx811.png"><br>$\quad$ 触发方式：软件启动，自动重复，周期性输出固定频率的脉冲<br>$\quad$ 用途：脉冲速率发生器<br><strong>DRAM定时刷新</strong><br><img src="/../txmg/tx812.png"><br><img src="/../txmg/tx813.png"></p><h6 id="方式3-方波发生器"><a href="#方式3-方波发生器" class="headerlink" title="方式3:方波发生器"></a>方式3:方波发生器</h6><p>$\quad$ 输出波形：对称方波或基本对称的矩形波<br><img src="/../txmg/tx814.png"><br>$\quad$ 触发方式：软件启动，自动重复，周期性输出固定频率的方波<br>$\quad$ 用途：产生系统时钟，扬声器发声控制<br><img src="/../txmg/tx816.png"><br><img src="/../txmg/tx815.png"></p><h3 id="系统中的中断与定时"><a href="#系统中的中断与定时" class="headerlink" title="系统中的中断与定时"></a>系统中的中断与定时</h3><p><img src="/../txmg/tx818.png"></p><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>COD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>COD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7-输入输出接口</title>
    <link href="/2023/05/10/7-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8E%A5%E5%8F%A3/"/>
    <url>/2023/05/10/7-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<p> 对应 北京大学计算机组成与体系结构第七讲<br> 参考教材COD（计算机组成与设计-硬件&#x2F;软件接口）</p><span id="more"></span><h1 id="计算机组成与体系结构"><a href="#计算机组成与体系结构" class="headerlink" title="计算机组成与体系结构"></a>计算机组成与体系结构</h1><hr><h2 id="输入输出接口"><a href="#输入输出接口" class="headerlink" title="输入输出接口"></a>输入输出接口</h2><p>$\quad$ 第一台微型计算机： Altair 8800</p><h3 id="输入输出接口电路"><a href="#输入输出接口电路" class="headerlink" title="输入输出接口电路"></a>输入输出接口电路</h3><h5 id="I-x2F-O接口的产生原因"><a href="#I-x2F-O接口的产生原因" class="headerlink" title="I&#x2F;O接口的产生原因"></a>I&#x2F;O接口的产生原因</h5><p>$\quad$ 1. CPU和外设之间的速度差距<br>$\quad$ 2. 外设处理的信息格式和接口信号形式多样</p><h5 id="I-x2F-O接口的基本功能"><a href="#I-x2F-O接口的基本功能" class="headerlink" title="I&#x2F;O接口的基本功能"></a>I&#x2F;O接口的基本功能</h5><p>$\quad$ 1. 数据缓冲——解决CPU和外设之间的速度差距<br>$\quad$ 2. 提供联络信息——协调同步数据交换工程<br>$\quad$ 3. 信息和信息格式的转换<br>$\quad$ 4. 设备选择<br>$\quad$ 5. 中断管理<br>$\quad$ 6. 可编程功能</p><h5 id="I-x2F-O接口的基本结构"><a href="#I-x2F-O接口的基本结构" class="headerlink" title="I&#x2F;O接口的基本结构"></a>I&#x2F;O接口的基本结构</h5><p><img src="/../txmg/tx701.png"></p><h3 id="输入和输出的过程"><a href="#输入和输出的过程" class="headerlink" title="输入和输出的过程"></a>输入和输出的过程</h3><h4 id="I-x2F-O端口及其编址方式"><a href="#I-x2F-O端口及其编址方式" class="headerlink" title="I&#x2F;O端口及其编址方式"></a>I&#x2F;O端口及其编址方式</h4><h5 id="I-x2F-O端口"><a href="#I-x2F-O端口" class="headerlink" title="I&#x2F;O端口"></a>I&#x2F;O端口</h5><p>$\quad$ I&#x2F;O接口内部包含一组称为I&#x2F;O端口的寄存器，每个I&#x2F;O端口都需有自己的端口地址（端口号），以便CPU访问。<br>$\quad$ 与复杂外设连接时，握手（handshaking）信号成对出现，定时协调与联络。</p><p><img src="/../txmg/tx704.png"></p><h5 id="I-x2F-O端口编址方式"><a href="#I-x2F-O端口编址方式" class="headerlink" title="I&#x2F;O端口编址方式"></a>I&#x2F;O端口编址方式</h5><h6 id="I-x2F-O端口和存储器分开编址"><a href="#I-x2F-O端口和存储器分开编址" class="headerlink" title="I&#x2F;O端口和存储器分开编址"></a>I&#x2F;O端口和存储器分开编址</h6><p>示例：<br><img src="/../txmg/tx702.png"><br><strong>优点</strong><br>$\quad$ - I&#x2F;O端口不占用存储器地址，不会减少用户的存储器地址空间<br>$\quad$ -  I&#x2F;O指令编码短，执行速度快<br>$\quad$ - I&#x2F;O指令的地址码较短，地址译码方便<br>$\quad$ - 采用单独的I&#x2F;O指令，使程序中的I&#x2F;O操作和其他操作层次清晰便于理解<br><strong>缺点</strong><br>$\quad$ - 内部结构相对复杂，CPU引脚更多<br>$\quad$ - 处理数据相对间接</p><h6 id="I-x2F-O端口和存储器统一编址"><a href="#I-x2F-O端口和存储器统一编址" class="headerlink" title="I&#x2F;O端口和存储器统一编址"></a>I&#x2F;O端口和存储器统一编址</h6><p>示例：<br><img src="/../txmg/tx703.png"><br><strong>优点</strong><br>$\quad$ - 可以用访向存储器的指令来访问I&#x2F;O端口，访问存储器的指令功能比较齐全，可以实现直接对I&#x2F;O端口以内的数据进行处理<br>$\quad$ - 可以将CPU中的I&#x2F;O操作与访问存储器操作统一设计为一套控制逻辑，简化内部结构，同时减少CPU的引脚数目<br><strong>缺点</strong><br>$\quad$ - 由于I&#x2F;O端口占用了一部分存储器地址空间，因而使用户的存储地址空间相对减小<br>$\quad$  - 由于利用访问存储器的指令来进行I&#x2F;O操作指令的长度通常比单独I&#x2F;O指令长，因此指令的执行时间也较长</p><h5 id="I-x2F-O指令说明"><a href="#I-x2F-O指令说明" class="headerlink" title="I&#x2F;O指令说明"></a>I&#x2F;O指令说明</h5><h6 id="IN指令（输入）"><a href="#IN指令（输入）" class="headerlink" title="IN指令（输入）"></a>IN指令（输入）</h6><p>$\quad$ 格式： IN AC，PORT<br>$\quad$ 操作：把外设端口的内容输入到AL或AX</p><h6 id="OUT指令（输出）"><a href="#OUT指令（输出）" class="headerlink" title="OUT指令（输出）"></a>OUT指令（输出）</h6><p>$\quad$ 格式： OUT PORT，AC<br>$\quad$ 操作：把AL或AX的内容输出到外设端口</p><h6 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h6><p>$\quad$ <strong>端口地址为0～255</strong><br>$\quad$ $\quad$ 直接寻址：用一个字节立即数指定端口地址<br>$\quad$ $\quad$ 间接寻址：用DX的内容指定端口地址<br>$\quad$ <strong>端口地址大于255</strong><br>$\quad$ $\quad$ 直接寻址：用DX的内容制定端口地址</p><h4 id="数据输出过程"><a href="#数据输出过程" class="headerlink" title="数据输出过程"></a>数据输出过程</h4><p><img src="/../txmg/tx705.png"></p><p>$\quad$ 1. CPU执行OUT指令，将控制字写入接口的“控制寄存器”，从而设置接口的工作模式<br>$\quad$ 2. CPU执行OUT指令，将数据写到接口的“输出缓冲寄存器”<br>$\quad$ 3. 接口将数据发到“并行数据输出”信号，并将“输出准备好”信号置为己有（亦可由CPU写控制字将该信息置为有效）<br>$\quad$ 4. 外设发现“输出准备好信号”后，从“并行数据输出”信号接收数据，并将“输出回答信号”置为有效<br>$\quad$ 5. 接口发现“输出回答”信号有效后，将“状态寄存器”中的状态位“输出缓存器空”置为有效<br>$\quad$ 6. 在这个过程中，CPU反复执行IN指令从“状态寄存”器中读出状态字，直到发现“输出缓冲器空”，然后开始下一个输出过程，继续输出新数据<br>$\quad$ （此为程序控制方式，还可以采用终端控制方式）</p><h4 id="数据输入过程"><a href="#数据输入过程" class="headerlink" title="数据输入过程"></a>数据输入过程</h4><p> <img src="/../txmg/tx706.png"></p><p>$\quad$ 1. 系统初始化时，CPU执行OUT指令，将控制字写入接口的“控制寄存器”，从而设置接口的工作模式<br>$\quad$ 2. 外设将数据发到“并行数据输入”信号，并将“输入准备好”信号置为有效<br>$\quad$ 3. 接口发现“输入准备好”信号有效后，从“并行数据输入”信号接收数据，放入“输入缓冲寄存器”，并将“输入回答”信号置为有效，阻止外设输入新数据<br>$\quad$ 4. 接口将状态寄存器中的状态位“输入缓存器满”置为有效<br>$\quad$ 5. 在上述过程中，CPU反复执行IN指令从“状态寄存器“中读出状态字，直到发现”输入缓冲器满“，然后执行IN指令，从“输入缓冲寄存器”中读出数据<br>$\quad$ 6. 接口将“输入回答”信号置为无效，等待外设输入新数据<br> $\quad$ （此为程序控制方式，还可以采用终端控制方式）</p><h3 id="串行和并行的比较"><a href="#串行和并行的比较" class="headerlink" title="串行和并行的比较"></a>串行和并行的比较</h3><p>$\quad$ <strong>串行通信</strong>：数据在单条一位宽的传输线上按时间先后一位一位地进行传送<br>$\quad$ <strong>并行通信</strong> ：数据在多位宽的传输线上各位同时进行传送<br>$\quad$ 串口通常指的是RS-232接口（COM接口），并口常指IEEE-1284接口（LPT接口）</p><h5 id="传输线上："><a href="#传输线上：" class="headerlink" title="传输线上："></a>传输线上：</h5><p>$\quad$ 串行传输线数量少，并行传输线数量多<br><img src="/../txmg/tx707.png"></p><h5 id="转换上："><a href="#转换上：" class="headerlink" title="转换上："></a>转换上：</h5><p>$\quad$ 串行通信需要经过复杂的串&#x2F;并转换，并行不需要<br><img src="/../txmg/tx708.png"></p><h5 id="数据传输上："><a href="#数据传输上：" class="headerlink" title="数据传输上："></a>数据传输上：</h5><p>$\quad$ 同频率下，串行通信数据传输率低，并行通信数据传输率高</p><h5 id="串扰上："><a href="#串扰上：" class="headerlink" title="串扰上："></a>串扰上：</h5><p>$\quad$ 串行通信不存在信号线之间的串扰而并行存在</p><h5 id="差分信号传输技术"><a href="#差分信号传输技术" class="headerlink" title="差分信号传输技术"></a>差分信号传输技术</h5><p>$\quad$ 发送端在两根线上发送振幅相等、相位相反的信号，接收端比较两个电压差来判断发送的是0或1<br>$\quad$ <strong>优点</strong><br>$\quad$ $\quad$ 抗干扰能力强<br>$\quad$ $\quad$ 能有效抑制电磁干扰<br>$\quad$ $\quad$ 时序定位准确<br>$\quad$ <strong>缺点</strong><br>$\quad$ $\quad$ 在电路板上，差分信号一定要走两根等长，等宽，紧密靠近且在同一层面的线，布线难度高</p><h3 id="并口芯片的应用实例：可编程并行接口8255A"><a href="#并口芯片的应用实例：可编程并行接口8255A" class="headerlink" title="并口芯片的应用实例：可编程并行接口8255A"></a>并口芯片的应用实例：可编程并行接口8255A</h3><p><img src="/../txmg/tx709.png"></p><h5 id="与外设的连线（24条）"><a href="#与外设的连线（24条）" class="headerlink" title="与外设的连线（24条）"></a>与外设的连线（24条）</h5><p>$\quad$ 端口A，端口B：PA0～7，PB0～7，可分别设定为输入或输出端口<br>$\quad$ 端口C：PC0～7 ：通常不用于普通的数据传送，而是作为A和B的”握手信号“，称为“A组”，“B组”</p><h5 id="与系统总线的连线"><a href="#与系统总线的连线" class="headerlink" title="与系统总线的连线"></a>与系统总线的连线</h5><p>$\quad$ 地址A1，A0：端口选择信号，CS有效时启用<br><img src="/../txmg/tx710.png"></p><h5 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h5><p>$\quad$ 0- 基本输入&#x2F;输出：单向输入&#x2F;输出，无握手信号<br>$\quad$ 1- 选通输入&#x2F;输出：单向输入&#x2F;输出，C用于握手信号<br>$\quad$ 2- 双向传输：双向传输，C用于握手信号</p><h5 id="XLAT指令说明"><a href="#XLAT指令说明" class="headerlink" title="XLAT指令说明"></a>XLAT指令说明</h5><p>$\quad$ 格式：XLAT<br>$\quad$ 操作：（事先定义字节型数据表）<br>$\quad$ $\quad$ 1. 从BX中取得数据表起始地址的偏移量<br>$\quad$ $\quad$ 2. 从AL中取得数据表项索引值<br>$\quad$ $\quad$ 3. 在数据表中查得表项内容<br>$\quad$ $\quad$ 4. 将查得表项内容存入AL</p><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>COD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>COD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6-流水线优化技术</title>
    <link href="/2023/05/01/6-%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
    <url>/2023/05/01/6-%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<p> 对应 北京大学计算机组成与体系结构第六讲<br> 参考教材COD（计算机组成与设计-硬件&#x2F;软件接口）</p><span id="more"></span><h1 id="计算机组成与体系结构"><a href="#计算机组成与体系结构" class="headerlink" title="计算机组成与体系结构"></a>计算机组成与体系结构</h1><hr><h2 id="流水线优化技术"><a href="#流水线优化技术" class="headerlink" title="流水线优化技术"></a>流水线优化技术</h2><h3 id="转移指令的影响"><a href="#转移指令的影响" class="headerlink" title="转移指令的影响"></a>转移指令的影响</h3><p><img src="/../txmg/tx601.png"><br>$\quad$ 改变指令流向，破坏流水模式</p><p>$\quad$ 转移指令损失（Branch Penalty）<br>$\qquad$ · Alpha 21264:转移损失平均7个周期<br>$\qquad$ · Pentium III：转移损失平均10～15个周期<br>$\qquad$ · AMD Athlon K7:转移损失10周期以上<br>Pipeline stall cycles from branches &#x3D; Brach Frequency（转移指令占比：10～15%）X Branch Penalty</p><h3 id="转移预测技术"><a href="#转移预测技术" class="headerlink" title="转移预测技术"></a>转移预测技术</h3><h5 id="转移开销："><a href="#转移开销：" class="headerlink" title="转移开销："></a>转移开销：</h5><p>$\quad$ 当转移指令被执行，并确定发生转移时，产生如下的开销：<br>$\qquad$ 1. 将按顺序预取的指令废除（即排空流水线）<br>$\qquad$ 2. 从转移目标地址重新取指令<br>$\quad$ 构成：<br>$\qquad$ 1.要不要转移（判定引起的开销）<br>$\qquad$ 2.转移到哪里（生成目标地址引起的开销）</p><h5 id="转移延迟"><a href="#转移延迟" class="headerlink" title="转移延迟"></a>转移延迟</h5><p>$\quad$ 在编译过程中通过编辑器调度，在转移指令后插入一条或几条适当的指令，当被调度的指令执行完后，目标地址和判断条件已计算完成</p><h5 id="转移预测"><a href="#转移预测" class="headerlink" title="转移预测"></a>转移预测</h5><p>$\quad$ 预测“要不要转移”和“转移到哪里”</p><h6 id="转移条件预测"><a href="#转移条件预测" class="headerlink" title="转移条件预测"></a>转移条件预测</h6><p>$\quad$ <strong>硬件固定预测不转移</strong>：在转移条件判定之前总是顺序地取下一条指令<br>$\quad$ $\quad$ 优点：实现简单；缺点：预测效果不佳<br>$\quad$ <strong>编译制导的预测</strong>：在转移指令的编码中增加一位，编译器通过该位预测，1转移0不转移。<br>$\quad$ $\quad$ 优点：可对不同指令进行不同预测；缺点：需要软件支持和修改ISA，不适应多变的执行环境<br>$\quad$ <strong>基于偏移的预测</strong>：如果相对偏移为负则预测转移<br>$\quad$ <strong>基于历史信息的预测</strong>（普遍采用）：转移与否取决于先前转移指令的执行情况。</p><h6 id="转移目标地址预测"><a href="#转移目标地址预测" class="headerlink" title="转移目标地址预测"></a>转移目标地址预测</h6><p>$\quad$ 转移目标缓冲器BTB（Branch Target Buffer），保存此前若干次转移指令执行时的目标地址<br><img src="/../txmg/tx602.png"></p><p>$\quad$ 基本操作：<br>$\quad$ $\quad$ 1. 分配BTB表项：转移目标第一次执行分配一个表项<br>$\quad$ $\quad$ 2. BTB表项比较：将需要预测的指令地址与BTB的转移指令地址进行比较，若命中则被执行过且为转移指令<br>$\quad$ $\quad$ 3. 产生转移目标地址：<br>$\quad$ $\quad$ 4. 更新BTB</p><p>$\quad$ 比较时机：<br><img src="/../txmg/tx603.png"><br>$\quad$ 工作机制：<br><img src="/../txmg/tx604.png"></p><h3 id="返回地址栈RAS"><a href="#返回地址栈RAS" class="headerlink" title="返回地址栈RAS"></a>返回地址栈RAS</h3><p>$\quad$ 特殊转移指令：过程返回指令RET<br>$\quad$ 专用预测部件：返回地址栈RAS<br><img src="/../txmg/tx605.png"></p><h6 id="指令特点："><a href="#指令特点：" class="headerlink" title="指令特点："></a>指令特点：</h6><p>$\quad$ 优点：<br>$\quad$ $\quad$ 1. 无需判定转移条件<br>$\quad$ $\quad$ 2. 转移目标地址已生成<br>$\quad$ $\quad$ 3. 出现可预期<br>$\quad$ 缺点：<br>$\quad$ $\quad$ 1. 同一条指令地址不同<br>$\quad$ $\quad$ 2. 转移目标地址访问时间较长<br>$\quad$ $\quad$ 3. 在流水线晚期才访问存储器获得转移目标地址</p><h6 id="运行示例："><a href="#运行示例：" class="headerlink" title="运行示例："></a>运行示例：</h6><p><img src="/../txmg/tx607.png"></p><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>COD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>COD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5-控制器的原理和分类</title>
    <link href="/2023/05/01/5-%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%88%86%E7%B1%BB/"/>
    <url>/2023/05/01/5-%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p> 对应 北京大学计算机组成与体系结构第五讲<br> 参考教材COD（计算机组成与设计-硬件&#x2F;软件接口）</p><span id="more"></span><h1 id="计算机组成与体系结构"><a href="#计算机组成与体系结构" class="headerlink" title="计算机组成与体系结构"></a>计算机组成与体系结构</h1><hr><h2 id="控制器的原理与分类"><a href="#控制器的原理与分类" class="headerlink" title="控制器的原理与分类"></a>控制器的原理与分类</h2><h3 id="控制器基本原理"><a href="#控制器基本原理" class="headerlink" title="控制器基本原理"></a>控制器基本原理</h3><p>$\quad$ 基本任务：按照指令每一步操作的需要，发出特定的命令信号<br>$\quad$ 简化控制信号示例：<br><img src="/../txmg/tx501.png"><br>$\quad$ 主要分类：<strong>硬布线控制器</strong>和<strong>微程序控制器</strong></p><h3 id="硬布线控制器"><a href="#硬布线控制器" class="headerlink" title="硬布线控制器"></a>硬布线控制器</h3><p>$\quad$ 也称硬连线控制器或组合逻辑控制器<br>$\quad$ 主要部件：环形脉冲发生器、指令编码器、微命令编码器<br>$\quad$ 原理图：<br><img src="/../txmg/tx502.png"><br>用·表示与，用+表示或，Ti表示第i个机器周期的节拍脉冲信号<br><img src="/../txmg/tx503.png"><br>$\quad$ <strong>优点</strong>：指令执行速度快<br>$\quad$ <strong>缺点</strong>：控制逻辑的电路复杂，设计和验证难度大，扩充和修改困难</p><h3 id="微程序控制器"><a href="#微程序控制器" class="headerlink" title="微程序控制器"></a>微程序控制器</h3><p>$\quad$ 发出信号计为1，不发为0，形成信号序列，称为微指令，一段微程序由多个微指令构成<br>$\quad$ 优点：规整性、灵活性<br>$\quad$ 缺点：速度较慢<br>$\quad$ 编码方式：直接表示法、编码表示法、混合表示法</p><h6 id="直接表示法"><a href="#直接表示法" class="headerlink" title="直接表示法"></a>直接表示法</h6><p>$\quad$ 将每个控制信号都作为微指令中的一位来编码<br>$\quad$ 优点：简单直观，输出直接用于控制<br>$\quad$ 缺点：编码效率低</p><h6 id="编码表示法"><a href="#编码表示法" class="headerlink" title="编码表示法"></a>编码表示法</h6><p>$\quad$ 将微指令代码进行分组编码，将不能同时出现的相斥信号分在一组<br>$\quad$ 优点：减少存储代码量<br>$\quad$ 缺点：增加硬件开销与信号延迟</p><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>COD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>COD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4-数字电路设计</title>
    <link href="/2023/03/30/4-%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/03/30/4-%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p> 对应 北京大学计算机组成与体系结构第四讲<br> 参考教材COD（计算机组成与设计-硬件&#x2F;软件接口）</p><span id="more"></span><h1 id="计算机组成与体系结构"><a href="#计算机组成与体系结构" class="headerlink" title="计算机组成与体系结构"></a>计算机组成与体系结构</h1><hr><h2 id="数字电路设计"><a href="#数字电路设计" class="headerlink" title="数字电路设计"></a>数字电路设计</h2><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><p>$\quad$ 莱布尼茨：二进制<br>$\quad$ 布尔：布尔代数（两个元素（真、假）；三种运算（与、或、非））<br>$\quad$ 香农：开关电路：模拟布尔逻辑运算，形成现代电子计算机的基本思路</p><h4 id="晶体管与门电路"><a href="#晶体管与门电路" class="headerlink" title="晶体管与门电路"></a>晶体管与门电路</h4><p>$\quad$ 现代集成电路通常使用MOS晶体管（Metal-Oxide-Semiconductor）<br>$\quad$ CMOS集成电路（Complementary MOS）：由PMOS和NMOS共同构成的互补型MOS集成电路<br>$\quad$ NMOS晶体管：Gate为高电压时导通<br>$\quad$ PMOS晶体管：Gate为低电压时导通</p><h6 id="非门"><a href="#非门" class="headerlink" title="非门"></a>非门</h6><p><img src="/../txmg/tx41.png"></p><h6 id="与门"><a href="#与门" class="headerlink" title="与门"></a>与门</h6><p><img src="/../txmg/tx42.png"></p><h6 id="或门"><a href="#或门" class="headerlink" title="或门"></a>或门</h6><p><img src="/../txmg/tx43.png"></p><h6 id="异或门"><a href="#异或门" class="headerlink" title="异或门"></a>异或门</h6><p><img src="/../txmg/tx44.png"></p><h6 id="运算的实现"><a href="#运算的实现" class="headerlink" title="运算的实现"></a>运算的实现</h6><p>例：<br><img src="/../txmg/tx45.png"><br>$\quad$ 其他运算同理</p><h6 id="半加器"><a href="#半加器" class="headerlink" title="半加器"></a>半加器</h6><p><img src="/../txmg/tx46.png"></p><h6 id="全加器"><a href="#全加器" class="headerlink" title="全加器"></a>全加器</h6><p><img src="/../txmg/tx47.png"></p><p>减法运算的实现：<br>A-B&#x3D;A+(~B+1)</p><h6 id="多路选择器"><a href="#多路选择器" class="headerlink" title="多路选择器"></a>多路选择器</h6><p><img src="/../txmg/tx48.png"></p><h4 id="时钟和触发器"><a href="#时钟和触发器" class="headerlink" title="时钟和触发器"></a>时钟和触发器</h4><h6 id="D触发器（D-flip-flop，DFF）"><a href="#D触发器（D-flip-flop，DFF）" class="headerlink" title="D触发器（D flip-flop，DFF）"></a>D触发器（D flip-flop，DFF）</h6><p>$\quad$ 具有存储信息能力的基本单元<br>$\quad$ 由若干逻辑门构成，有多种实现方式<br>$\quad$ 主要有一个数据输入，一个数据输出和一个时钟输入<br>$\quad$ 在时钟clock的上升沿（0-&gt;1），采样输入D的值，传送到输出Q，其余时间输出Q的值不变。<br><img src="/../txmg/tx49.png"></p><h6 id="D锁存器："><a href="#D锁存器：" class="headerlink" title="D锁存器："></a>D锁存器：</h6><p><img src="/../txmg/tx410.png"></p><h6 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h6><p><img src="/../txmg/tx417.png"><br>$\quad$ 基本存储单元（1 bit）：<br><img src="/../txmg/tx411.png"><br>$\quad$ 写入过程：<br><img src="/../txmg/tx412.png"><br><img src="/../txmg/tx413.png"><br><img src="/../txmg/tx414.png"><br>$\quad$ 读出过程：<br><img src="/../txmg/tx415.png"><br><img src="/../txmg/tx416.png"></p><h4 id="加法器，减法器，乘法器与除法器"><a href="#加法器，减法器，乘法器与除法器" class="headerlink" title="加法器，减法器，乘法器与除法器"></a>加法器，减法器，乘法器与除法器</h4><h5 id="加法器："><a href="#加法器：" class="headerlink" title="加法器："></a>加法器：</h5><h6 id="行波进位加法器"><a href="#行波进位加法器" class="headerlink" title="行波进位加法器"></a>行波进位加法器</h6><p>$\quad$ 多个串联，低位$C_{out}$连接高位$C_{in}$<br>$\quad$ 优点：布局简单，设计方便<br>$\quad$ 缺点：必须等待低位运算完成，延迟时间长<br>$\quad$ 门延迟：通过一次门电路计为1<br>$\quad$ 关键路径：延迟最长的路径</p><h6 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h6><p>$\quad$ $G_i &#x3D; A_i<em>B_i,P_i&#x3D;A_i+B_i$<br>$\quad$ 由$C_{i+1}&#x3D;G_i+P_i</em>C_i$ 提前计算进位信号，总延迟为4级门延迟</p><h5 id="减法器："><a href="#减法器：" class="headerlink" title="减法器："></a>减法器：</h5><p>$\quad$ 同加法器</p><h5 id="乘法器："><a href="#乘法器：" class="headerlink" title="乘法器："></a>乘法器：</h5><h6 id="实现结构："><a href="#实现结构：" class="headerlink" title="实现结构："></a>实现结构：</h6><p><img src="/../txmg/tx608.png"><br><img src="/../txmg/tx609.png"></p><h6 id="优化"><a href="#优化" class="headerlink" title="优化:"></a>优化:</h6><p><img src="/../txmg/tx610.png"></p><h5 id="除法器："><a href="#除法器：" class="headerlink" title="除法器："></a>除法器：</h5><h6 id="实现结构：-1"><a href="#实现结构：-1" class="headerlink" title="实现结构："></a>实现结构：</h6><p><img src="/../txmg/tx611.png"><br><img src="/../txmg/tx612.png"></p><h6 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h6><p><img src="/../txmg/tx613.png"></p><h4 id="集成电路的制造过程"><a href="#集成电路的制造过程" class="headerlink" title="集成电路的制造过程"></a>集成电路的制造过程</h4><p>​<br>第一阶段：硅$\rightarrow$ 硅锭<br>第二阶段：硅锭切割$\rightarrow$ 晶圆<br>第三阶段：光刻胶$\rightarrow$ 光刻<br>第四阶段：溶解光刻胶$\rightarrow$ 蚀刻$\rightarrow$ 清除光刻胶<br>第五阶段：再次光刻$\rightarrow$ 离子注入$\rightarrow$ 清除光刻胶<br>第六阶段：覆盖绝缘体并蚀刻孔洞$\rightarrow$ 电镀$\rightarrow$ 形成铜层<br>第七阶段：抛光$\rightarrow$ 金属层<br>第八阶段：晶圆测试$\rightarrow$ 晶圆切片$\rightarrow$ 丢弃瑕疵内核<br>第九阶段：从晶圆切下单个CPU裸片$\rightarrow$ 封装<br>第十阶段：等级测试$\rightarrow$ 装箱</p><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>COD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>COD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法设计与分析</title>
    <link href="/2023/03/25/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    <url>/2023/03/25/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>   北京大学算法设计与分析课程相关算法repo<br>  <span id="more"></span></p><h1 id="引言部分："><a href="#引言部分：" class="headerlink" title="引言部分："></a>引言部分：</h1><p>   算法是有限条指令的序列，算法的时间复杂度是对算法效率的度量<br>   算法的描述：伪代码<img src="/../sfmg/sf0.png"></p><h2 id="算法的数学基础"><a href="#算法的数学基础" class="headerlink" title="算法的数学基础"></a>算法的数学基础</h2><p>   函数渐进的界：<br>   <img src="/../sfmg/sf1.png"><br>   <img src="/../sfmg/sf2.png"><br>   <img src="/../sfmg/sf4.png"><br>   <img src="/../sfmg/sf3.png"><br>   多项式时间的算法：存在多项式p(n)使得算法的时间复杂度为O(p(n))<br>   对数函数：<br>        $log_b n &#x3D; o(n^\alpha),\alpha &gt; 0$ $a^{log_b n } &#x3D; n^{log_b a}$  $log_k n &#x3D; \Theta (log n)$<br>   阶乘：<br>       Stirling公式： $n!&#x3D; \sqrt{2\pi n }(\frac{n}{e})^n(1+\Theta(1&#x2F;n))$<br>       log(n!) &#x3D; $\Theta(nlogn)$<br> 取整函数：<br> <img src="/../sfmg/sf5.png"><br> <img src="/../sfmg/sf6.png"><br> 估算和式上界的方法：<br> <img src="/../sfmg/sf8.png"></p><h2 id="递推方程："><a href="#递推方程：" class="headerlink" title="递推方程："></a>递推方程：</h2><p>$\quad$ 设$序列 a_0,a_1…a_n,…$ 简记为{$a_n$ } ，一个把$a_n与某个a_i$联系起来的等式叫做关于序列的递推方程。<br><img src="/../sfmg/sf9.png"><br>递归树：<br>$\quad$ 结点带杈的二叉树，初始的递归树只有一个结点，它的权标记为W(n),然后不断进行迭代，直到树中不再含有权为函数的结点为止。<br><img src="/../sfmg/sf10.png"></p><p><img src="/../sfmg/sf11.png"></p><h1 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计:"></a>算法设计:</h1><h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><p>一般性描述：</p><blockquote><p><strong>Divide-and-Conquer(P)</strong></p><ol><li>if |P| $\leq$ c then S(P)</li><li>divide P into $P_1,P_2···P_k$ </li><li>for i&#x3D;1 to k do </li><li>$\quad$ $y_i$ $\leftarrow$ Divide-and-Conquer( $P_i$ )</li><li>return Merge( $y_1,y_2···y_k$ )</li></ol></blockquote><h3 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1.二分查找"></a>1.二分查找</h3><blockquote><p><strong>BinarySearch(T,x)</strong><br>输入：排好序的数组T；数x<br>输出：j</p><ol><li>l  $\leftarrow$  1;r $\leftarrow$ n</li><li>while l $\leq$ r do<br>3.$\quad$ m $\leftarrow$ $\lfloor (l+r)&#x2F;2 \rfloor$<br>4.$\quad$ if T[m]&#x3D;x then return m   &#x2F;&#x2F; x恰好等于中位元素</li><li>$\quad$ else if T[m]&gt; x then r $\leftarrow$ m-1 </li><li>$\quad$ else l $\leftarrow$ m+1</li><li>return 0</li></ol></blockquote><h3 id="2-芯片测试"><a href="#2-芯片测试" class="headerlink" title="2. 芯片测试"></a>2. 芯片测试</h3><blockquote><p><strong>Test(n)</strong><br>输入：n片芯片构成的数组，其中好芯片至少比坏芯片多一片<br>输出：1片好芯片</p><ol><li>k $\leftarrow$ n</li><li>while  k&gt;3  do</li><li>$\quad$ 将芯片分成$\lfloor k&#x2F;2 \rfloor$ 组</li><li>$\quad$ for i&#x3D;1 to $\lfloor k&#x2F;2 \rfloor$ do<br>  $\quad$  $\quad$ if 2片好，任取一片留下<br>$\quad$ $\quad$ else 2片同时丢掉</li><li>$\quad$ k $\leftarrow$ 剩下的芯片数</li><li>if k&#x3D;3<br>then 任取两片芯片测试<br> $\quad$ if  1好1坏，取没测的芯片<br> $\quad$   else  任取一片被测芯片</li><li>if k&#x3D;2 or 1 then 任取一片芯片</li></ol></blockquote><h3 id="3-平面两点最短距离"><a href="#3-平面两点最短距离" class="headerlink" title="3.  平面两点最短距离"></a>3.  平面两点最短距离</h3><blockquote><p><strong>MinDistance（P,X,Y)</strong><br>输入：n个点的集合P，X和Y分别给出P中点的横，纵坐标<br>输出：最近的两个点及距离</p><ol><li>如果P中点数小于等于3，则直接计算其中的最小距离</li><li>排序X，Y</li><li>做垂直线l将P近似划分为大小相等的点集 $P_L和P_R$  , $P_L$  的点在l左边，$P_R$ 的点在l右边</li><li>$MinDistance(P_L,X_L,Y_L);\theta _L&#x3D;P_L中的最小距离$&#x2F;&#x2F;递归计算左半平面最邻近点对</li><li>$MinDistance(P_R,X_R,Y_R);\theta _R&#x3D;P_R中的最小距离$&#x2F;&#x2F;递归计算右半平面最邻近点对</li><li>$\theta \leftarrow min(\theta _L,\theta _R)$ </li><li>对于在线l左边距离$\theta$ 范围内的每一个点，检查l右边是否有点与它的距离小于$\theta$ ,如果存在则将$\theta$ 修改为新值</li></ol></blockquote><h3 id="4-快速排序算法"><a href="#4-快速排序算法" class="headerlink" title="4. 快速排序算法"></a>4. 快速排序算法</h3><blockquote><p><strong>Quicksort(A,p,r)</strong><br>输入：数组A[p..r],1$\leq p \leq r \leq n$<br>输出：从A[p]到A[r]按照递增顺序排好序的数组A</p><ol><li>if p &lt; r</li><li>then q $\leftarrow$ Partition(A,p,r) </li><li>$\quad$ A[p]$\leftrightarrow$ A[q]</li><li>$\quad$ Quicksort(A,p,q-1)</li><li>$\quad$ Quicksort(A,q+1,r)</li></ol></blockquote><p>时间复杂度O（nlogn）</p><h3 id="5-选择问题"><a href="#5-选择问题" class="headerlink" title="5. 选择问题"></a>5. 选择问题</h3><blockquote><p><strong>Select(S,k)</strong><br>输入： n个数的数组S，正整数k<br>输出： S中的第k小元素</p><ol><li>将S划分成5个一组，共$\lceil n&#x2F;5 \rceil$ 个组</li><li>每组找一个中位数，把这些中位数放到集合M中</li><li>$m^* \leftarrow Select(M,\lceil |M|&#x2F;2 \rceil)$ &#x2F;&#x2F;选M的中位数，将S中的数划分为A，B，C，D是个部分</li><li>把A和D中的每个元素与$m^*$ 比较，小的构成$S_1$,大的构成$S_2$ </li><li>$S_1 \leftarrow S_1 \cup C;S_2 \leftarrow S_2 \cup B;$</li><li>if k&#x3D; $|S_1|$ +1 then 输出 $m^*$</li><li>else if k $\leq$ $|S_1|$</li><li>$\quad$ then Select($S_1$,k)</li><li>$\quad$ else Select($S_2,k-|S_1|-1$)</li></ol></blockquote><p>时间复杂度O(n)</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>优化原则： 一个最优决策序列的人任何子序列本身一定是相对于子序列的初始和结束状态的最优决策序列<br>设计要素：</p><ol><li>划分子问题，用参数表述子问题的边界，将问题求解转换为多步判断的过程。</li><li>确定优化函数，以函数的极大&#x2F;极小作为判断的依据，确定是否满足优化原则</li><li>列出关于优化函数的递推方程和边界条件</li><li>考虑是否需要设计标记函数，以记录划分位置</li><li>自底向上计算，以表格存储中间结果</li><li>根据表格和标记函数通过追溯给出最优解</li></ol><h3 id="1-背包问题"><a href="#1-背包问题" class="headerlink" title="1. 背包问题"></a>1. 背包问题</h3><p><img src="/../sfmg/sf13.png"></p><h3 id="2-LCS最长公共子序列"><a href="#2-LCS最长公共子序列" class="headerlink" title="2. LCS最长公共子序列"></a>2. LCS最长公共子序列</h3><blockquote><p>**LCS(X,Y,m,n)<br>输入：序列X、Y，其中X[1..m],Y[1..n]<br>输出：最长公共子序列长度C[i,j],标记B[i,j],$1 \leq i \leq m,1 \leq j \leq n$ </p><ol><li>for i $\leftarrow$ 1 to m do</li><li>$\quad$ C[i,0]$\leftarrow$ 0</li><li>for i $\leftarrow$ 1 to n do </li><li>$\quad$ C[0,i]$\leftarrow$ 0</li><li>for i $\leftarrow$ 1 to m do</li><li>$\quad$ for j $\leftarrow$ 1 to n do</li><li>$\quad$ $\quad$ if X[i]&#x3D;Y[j]$\quad$ &#x2F;&#x2F;X[i]和Y[j]都被选入公共子序列<br>8.$\quad$ $\quad$ then C[i,j]$\leftarrow$ C[i-1,j-1]+1</li><li>$\quad$ $\quad$ $\quad$ $\quad$ B[i,j]$\leftarrow$ “↖️”<br>10.$\quad$ $\quad$ else if C[i-1,j] $\geq$ C[i,j-1]</li><li>$\quad$ $\quad$ $\quad$ then C[i,j]$\leftarrow$ C[i-1,j]</li><li>$\quad$ $\quad$ $\quad$ $\quad$ B[i,j]$\leftarrow$ “⬆️”</li><li>$\quad$ $\quad$ else C[i,j]$\leftarrow$ C[i,j-1]</li><li>$\quad$ $\quad$ $\quad$ $\quad$ B[i,j]$\leftarrow$ “⬅️”</li></ol></blockquote><h3 id="3-整备类问题"><a href="#3-整备类问题" class="headerlink" title="3. 整备类问题"></a>3. 整备类问题</h3><p>F[j]表示1～j天加工任务的最大数目<br>w[i+1,j]表示在第i天进行检修，从第i+1到第j天连续工作的加工量</p><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p>贪心法必须进行正确性证明<br>证明方法：<br>归纳论证<br>交换论证：用最优解交换得到有限步骤得到贪心法的解</p><h3 id="1-活动选择问题"><a href="#1-活动选择问题" class="headerlink" title="1. 活动选择问题"></a>1. 活动选择问题</h3><p>按截止时间从小到大排序，从前往后挑选，只要相容便加入</p><blockquote><p><strong>Greedy Select</strong><br>输入：活动集S&#x3D;{1,2,···,n},活动i的开始时间$s_i$和截止时间$f_i$<br>输出：A$\subseteq$S,选中的活动子集</p><ol><li>A$\leftarrow$ {1}</li><li>j $\leftarrow$ 1</li><li>for i $\leftarrow$ 2 to n do</li><li>$\quad$ if $s_i \ge f_i$ </li><li>$\quad$ then A $\leftarrow$ A $\cup$ {i}</li><li>$\quad$ $\quad$ j $\leftarrow$ i</li><li>return A</li></ol></blockquote><h3 id="2-集装箱问题"><a href="#2-集装箱问题" class="headerlink" title="2. 集装箱问题"></a>2. 集装箱问题</h3><p>轻者先装</p><blockquote><p><strong>Loading</strong><br>输入：集装箱集合N，集装箱i的重量$w_i$<br>输出：I $\subseteq$ N，准备装入船的集装箱集合</p><ol><li>对集装箱重量按从小到大排序</li><li>I $\leftarrow$ {1}</li><li>W $\leftarrow w_1$</li><li>for j $\leftarrow$ 2 to n do</li><li>$\quad$ if W+$w_i \leq$ C</li><li>$\quad$ then W $\leftarrow$ W+$w_i$</li><li>$\quad$ $\quad$     I $\leftarrow$ I $\cup$ {j}</li><li>$\quad$ else return I,W</li></ol></blockquote><h3 id="3-调度问题"><a href="#3-调度问题" class="headerlink" title="3. 调度问题"></a>3. 调度问题</h3><blockquote><p><strong>Schedule</strong><br>输入：A，T，D &#x2F;&#x2F;A为等待的客户集合，T为预计对客户的服务时间，D为客户希望的完成时间<br>输出：f</p><ol><li>排序A使得$d_1 \leq d_2 \leq ··· d_n$</li><li>f(1) $\leftarrow$ 0</li><li>i $\leftarrow$ 2</li><li>while i $\leq$ n do </li><li>$\quad$ f(i) $\leftarrow$ f(i-1)+$t_{i-1}$</li><li>$\quad$ i $\leftarrow$ i+1</li></ol></blockquote><h3 id="4-哈夫曼树（最优前缀码问题）"><a href="#4-哈夫曼树（最优前缀码问题）" class="headerlink" title="4. 哈夫曼树（最优前缀码问题）"></a>4. 哈夫曼树（最优前缀码问题）</h3><p>可扩展到k叉树</p><blockquote><p><strong>Huffman(C)</strong><br>输入：C&#x3D;{$x_1,x_2···x_n$}是字符集，每个字符频率f($x_i$)<br>输出：Q</p><ol><li>n $\leftarrow$ |C|</li><li>Q $\leftarrow$ C</li><li>for i $\leftarrow$ 1 to n-1 do</li><li>$\quad$ z  $\leftarrow$  Allocate-Node()  &#x2F;&#x2F;生成结点z</li><li>$\quad$ z.left $\leftarrow$ Q中最小元    &#x2F;&#x2F;左儿子</li><li>$\quad$ z.right $\leftarrow$  Q中最小元.  &#x2F;&#x2F;右儿子</li><li>$\quad$ f(z) $\leftarrow$ f(x)+f(y)</li><li>$\quad$ Insert(Q,z)     &#x2F;&#x2F;z插入Q</li><li>return Q</li></ol></blockquote><h3 id="5-最小生成树"><a href="#5-最小生成树" class="headerlink" title="5. 最小生成树"></a>5. 最小生成树</h3><h4 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h4><blockquote><p><strong>Prim</strong><br>输入：连通图G&#x3D;&lt;V,E,W&gt;<br>输出：G的最小生成树T</p><ol><li>S $\leftarrow$ {1};T&#x3D;$\emptyset$ </li><li>while V-S $\ne \emptyset$ do</li><li>从V $\rightarrow$ S中选择j使得j到S中顶点的边e的权最小；T $\leftarrow$ T$\cup$ {e}</li><li>S  $\leftarrow$ S$\cup$ {j}</li></ol></blockquote><h4 id="Krusal算法"><a href="#Krusal算法" class="headerlink" title="Krusal算法"></a>Krusal算法</h4><blockquote><p><strong>Krusal</strong><br>输入：连通图G&#x3D;&lt;V，E，W&gt;<br>输出：G的最小生成树</p><ol><li>按照权从小到大顺序排序G中的边，使得E&#x3D;{$e_1,e_2···e_m$}</li><li>T $\leftarrow \emptyset$</li><li>repeat</li><li>$\quad$ e $\leftarrow$ E中最短边</li><li>$\quad$ if e的两端点不在同一个连通分支</li><li>$\quad$ then T  $\leftarrow$ T$\cup$ {e}</li><li>$\quad$ E $\leftarrow$  E-{e}</li><li>until T 包含了n-1条边</li></ol></blockquote><h3 id="6-单源最短路径"><a href="#6-单源最短路径" class="headerlink" title="6. 单源最短路径"></a>6. 单源最短路径</h3><blockquote><p><strong>Dijkstra</strong><br>输入：带权有向图&lt;V,E,W&gt;，源点s$\in$ V<br>输出：数组L，对所有j$\in$ V-{s},L[j]表示s到j的最短路径上j前一个结点的标号</p><ol><li>S  $\leftarrow$ {s}</li><li>dist[s] $\leftarrow$ 0</li><li>for i $\in$ V-{s} do </li><li>$\quad$ dist[i] $\leftarrow$ w(s,i)   &#x2F;&#x2F;如果没边，w为无限</li><li>while V-S $\ne \emptyset$ do </li><li>$\quad$ 从V-S中取出具有相对S的最短路径的结点j，k是路径上连接j的结点</li><li>$\quad$ S $\leftarrow$  S$\cup$ {j};L[j] $\leftarrow$ k </li><li>$\quad$ for i$\in$ V-S do </li><li>$\quad$ $\quad$ if dist[j]+w(j,i) &lt; dist[j]</li><li>$\quad$ $\quad$ then dist[i] $\leftarrow$ dist[j]+w(j,i)   &#x2F;&#x2F;修改结点i相对S的最短路径长度</li></ol></blockquote><h3 id="耗油问题"><a href="#耗油问题" class="headerlink" title="耗油问题"></a>耗油问题</h3><p>从起点向终点扫描，一遇到没有油的情况取经过加油站能加油的最大值进行加油</p><h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><p>解空间：搜索问题的解所在的集合，又称为搜索空间，通常为树形结构，如排列树，子集树<br>搜索策略：深度优先，广度优先<br>多米诺性质：P($x_1,x_2···x_n+1$)为真蕴含P($x_1,x_2···x_n$)为真<br>代价函数小于界立刻剪枝<br>0-1类：O($2^n$);<br>m着色: O($nm^n$);<br>排列类：O(n!);</p><h2 id="线性规划"><a href="#线性规划" class="headerlink" title="线性规划"></a>线性规划</h2><h6 id="一般形式："><a href="#一般形式：" class="headerlink" title="一般形式："></a>一般形式：</h6><blockquote><p>$min(max) z &#x3D; \sum^n_{j &#x3D; 1}c_jx_j$<br>s.t. $\sum^n_{j&#x3D;1}a_{ij}x_j\le(&#x3D;,\ge)b_i$,i&#x3D;1,2···m<br>$x_j\ge 0$ -非负条件<br>$x_j$任意 - 自由变量</p></blockquote><p>$\quad$ 可行解 满足约束条件 和非负条件的变量<br>$\quad$ 可行域 全体可行解<br>$\quad$ 最优解 目标函数值最小(最大)的可行解<br>$\quad$ 最优值 最优解的目标函数值</p><h6 id="图解法"><a href="#图解法" class="headerlink" title="图解法"></a>图解法</h6><p>高中内容</p><h6 id="标准形"><a href="#标准形" class="headerlink" title="标准形"></a>标准形</h6><blockquote><p>min z &#x3D; $\sum^n_{j &#x3D; 1}c_jx_j$<br>s.t. $\sum^n_{j&#x3D;1}a_{ij}x_j&#x3D;b_i$,i&#x3D;1,2···m<br>$x_j \ge 0$</p></blockquote><p>对于不等式引入新的变量构造等式，对于自由变量引入两个新变量</p><h6 id="对偶线性规划："><a href="#对偶线性规划：" class="headerlink" title="对偶线性规划："></a>对偶线性规划：</h6><p><img src="/../sfmg/sf14.png"></p><h2 id="网络流"><a href="#网络流" class="headerlink" title="网络流:"></a>网络流:</h2><p><strong>FF算法</strong><br>O（mC）<br><strong>Dinic算法</strong><br>O（n^3)</p><h2 id="近似算法"><a href="#近似算法" class="headerlink" title="近似算法:"></a>近似算法:</h2><p> $\quad$ A是一个多项式时间算法且对组合优化问题 Ⅱ 的每一个实例I输出一个可行解$\sigma$ .记A(I)&#x3D;c(σ)， c(σ)是σ的值<br>$\quad$ 性能估计:当II是最小化问题时，记rA(I)&#x3D;A(I)&#x2F;OPT(I)；当II是最大化问题时，记rA(2)&#x3D;OPT(I&#x2F;A(I)<br>$\quad$ 最优化算法:恒有A(I)&#x3D;OPT(I)，即rA(I)&#x3D;1.<br>$\quad$ A的近似比为r（A是r-近似算法）：对每一个实例I，rA（I）$\leq$ r<br>$\quad$ A具有常数近似比：r是一个常数。</p><p>$\quad$ 可近似性分类<br>$\quad$ （1)完全可近似的：对任意小的ε&gt;0，存在(1+ε)-近似：算法背包问题<br>$\quad$   (2)可近似的：存在具有常数比的近似算法：最小顶点覆盖问题、多机调度问题<br>$\quad$   (3)不可近似的：不存在具有常数比的近似算法：货郎问题</p><h2 id="随机算法："><a href="#随机算法：" class="headerlink" title="随机算法："></a>随机算法：</h2><p>$\quad$ <strong>ZPP</strong>：有效的Las Vegas算法<br>$\quad$ <strong>BPP</strong>：有效的Monte Carlo算法<br>$\quad$ <strong>RP</strong>：弃真型单侧错误概率有界算法<br>$\quad$ <strong>coRP</strong>：取伪型单侧错误概率有界算法</p><h4 id="Las-Vegas-型随机算法"><a href="#Las-Vegas-型随机算法" class="headerlink" title="Las Vegas 型随机算法"></a>Las Vegas 型随机算法</h4><p>$\quad$ 通过修改确定性算法得到,一般将算法的某步的确定型选择变成随机选择<br>$\quad$ 一次运行可能得不到解;若得到解,则解一定是正确的<br>$\quad$ 与确定型算法相结合有可能改进确定型算法平均情况下的时间复杂度</p><p><strong>随机快速排序</strong></p><blockquote><p>算法输入：包含 n 个元素的数组<br>输出:经过排序的n个元素的数组<br>1.若数组包含0或1个元素则返回<br>2.从数组中随机选择一个元素作为枢轴元素<br>3.把数组元素分为三个子数组,并且按照A,B,C顺序排列<br>$\quad$ $\quad$ A:包含比枢轴元素小的元素;B:包含与枢轴元素相等的元素;C:包含比枢轴元素大的元素.<br>4.对A和C递归地执行上述步骤</p></blockquote><p><strong>算法RandSelect(A, p,r,k)</strong>  &#x2F;&#x2F;从A[p..r]中选第k小</p><blockquote><ol><li>if p&#x3D; r then return A[p]</li><li>i←Random(p, r)</li><li>3.以A[i]为标准划分A</li><li>j&lt;划分后小于等于A[i]的数构成数组的大小</li><li>if k$\leq$j</li><li>then return RandSelect (A, p, p+j-1, k)</li><li>return RandSelect (A, p+j, r, k-j)</li></ol></blockquote><p><strong>算法BoolQueen(n)</strong></p><blockquote><ol><li>k$\leftarrow$ 1. &#x2F;&#x2F; k 放皇后的行号</li><li>count$\leftarrow$ 0  &#x2F;&#x2F; count 放好的皇后数</li><li>while k$\leq$ n do</li><li>for i←1 to n do &#x2F;&#x2F;i为待选列号</li><li>检查i与前面k-1个皇后的相容性</li><li>如果相容则将i加入S</li><li>ifS$\ne$  $\emptyset$ ，then</li><li><pre><code class="hljs">j←Random(1,S)</code></pre></li><li><pre><code class="hljs">$x_k \leftarrow S[j]$ </code></pre></li><li>count $\leftarrow$ count+1</li><li><pre><code class="hljs">k$\leftarrow$ k+1</code></pre></li><li>else k←n + 1</li><li>return count<br>**算法QueenLV(n)</li><li>p$\leftarrow$ BoolQueen(n)</li><li>while p&lt;n ,do<br>3 .    p$\leftarrow$ BoolQueen(n)</li></ol></blockquote><h4 id="Monte-Carlo型随机算法"><a href="#Monte-Carlo型随机算法" class="headerlink" title="Monte Carlo型随机算法"></a>Monte Carlo型随机算法</h4><p>$\quad$ 这种算法有时会给出错误的答案<br>$\quad$ 运行时间和出错概率都是随机变量<br>$\quad$ 多项式时间内运行切出错概率不超过1&#x2F;3的随机算法称为有效的蒙特卡罗型算法</p><p>$\quad$ <strong>弃真型单侧错误</strong>：接受一定对，拒绝可能错<br>$\quad$ <strong>取伪型单侧错误</strong>：拒绝一定对，接受可能错<br>$\quad$ <strong>双侧错误</strong>：所有输入上同时出现上述两种</p><p>$\quad$ <strong>素数检测算法</strong></p><blockquote><p>输入：自然数n<br>输出：n是否素数</p><ol><li>若n是偶数且n$\ne$ 2,则宣布n是合数，结束计算</li><li>若n&#x3D;2，则宣布n是素数，结束计算</li><li>若n&#x3D;1，则宣布n&#x3D;1，结束计算</li><li>从{1,……n-1}中随机选择自然数a</li><li>若gcd（n，a）&gt;1（最大公因数）或（a&#x2F;n）$\ne$ a^{n-1&#x2F;2}(mod n),则宣布n是合数</li><li>否则，宣布n是素数</li></ol></blockquote><h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><h2 id="平摊分析"><a href="#平摊分析" class="headerlink" title="平摊分析"></a>平摊分析</h2><p>$\quad$ 求一系列操作在最坏情况下的时间,不涉及概率<br>$\quad$ 三种方法:</p><h6 id="聚集分析"><a href="#聚集分析" class="headerlink" title="聚集分析"></a>聚集分析</h6><p>$\quad$ 暴力得到总运行时间再除以n</p><h6 id="记账法"><a href="#记账法" class="headerlink" title="记账法"></a>记账法</h6><p>$\quad$ 要求：余额大于0<br>$\quad$ 实际上就是猜测平摊代价后进行验证</p><h6 id="势能法"><a href="#势能法" class="headerlink" title="势能法"></a>势能法</h6><p>$\quad$ 要求：最终势能大于0<br>$\quad$ 和记账法类似</p><h2 id="问题的计算复杂度"><a href="#问题的计算复杂度" class="headerlink" title="问题的计算复杂度"></a>问题的计算复杂度</h2><h4 id="平凡下界："><a href="#平凡下界：" class="headerlink" title="平凡下界："></a>平凡下界：</h4><p>$\quad$ 问题的输入或输出规模是它的平凡下界<br>$\quad$ 下界的计算：找最少运算数</p><h4 id="决策树："><a href="#决策树：" class="headerlink" title="决策树："></a>决策树：</h4><p>$\quad$ 以比较作基本运算的算法模型<br>$\quad$ 一个问题确定了一类决策树，具有相同的构造规则，该决策树类决定了求解该问题的一个算法类<br>$\quad$ 结点数(或树叶数)等于输入分类的总数<br>$\quad$ 最坏情况下的时间复杂度对应于决策树的深度<br>$\quad$ 平均情况下的时间复杂度对应于决策树的平均路径长度</p><p><img src="/../sfmg/sf15.png"><br><img src="/../sfmg/sf16.png"><br><img src="/../sfmg/sf17.png"></p><h2 id="NP-完全性"><a href="#NP-完全性" class="headerlink" title="NP 完全性"></a>NP 完全性</h2><p><strong>多项式时间算法</strong>：以多项式为时间复杂度<br><strong>易解的问题</strong>：有多项式时间算法<br><strong>难解的问题</strong>：不存在多项式时间算法</p><p><strong>哈密顿回路（HC）</strong>：任给无向图G，问G有哈密顿回路吗？<br><strong>货郎问题（TSP）</strong>：任给n个城市，城市i与城市j之间的正整数距离d（i，j），i$\ne$j,以及正整数D，问有一条每一个城市恰好经过一次最后回到出发点且长度不超过D的巡回路线吗？</p><h4 id="组合优化问题"><a href="#组合优化问题" class="headerlink" title="组合优化问题"></a>组合优化问题</h4><p>II* 由3部分组成：<br>(1)实例集$D_{II*}$<br>(2) $\forall I \in D_{II*}$ ，有一个有穷非空集S(I)，其元素称作 I的可行解<br>(3) $\forall s \in S(I)$,有一个正整数 c(s)，称作s的值<br>如果s$* \in S(I)$，对所有的 s$\in$ S(I)，当II<em>是最小（大）化问题时，c(s$</em>$) $\leq$ c (s)(c(s*) $\leq$ c(s))则称s $<em>$是I的最优解，c(s</em>)是 I的最优值，记作OPT(I).</p><h4 id="II-对应的判定问题"><a href="#II-对应的判定问题" class="headerlink" title="II$*$ 对应的判定问题"></a>II$*$ 对应的判定问题</h4><p>$D_{II}$&#x3D;{$(I,K)|I \in D_{II*},K \in Z*$}<br>当II$<em>$是最小化问题时，Yn&#x3D;{(I,K)|OPT(I)$\leq$K);当П</em>是最大化问题时，Yn&#x3D;{(I，K)|OPT(I)$\ge$ K).</p><h4 id="P类与NP类"><a href="#P类与NP类" class="headerlink" title="P类与NP类"></a>P类与NP类</h4><p>$\quad$ 所有多项式时间可解的判定问题组成的问题称为P类<br>$\quad$ 设判定问题II&#x3D;&lt;D,Y&gt;,如果存在两个输入变量的多项式时间算法A和多项式p，对每一个实例$I\in D,I \in Y$ 当且仅当存在t，｜t｜$\leq$ p(|I|),且A对输入I和t输出“Yes”，则称II是多项式时间可验证的，A是II的多项式时间验证算法，而当I$\in$ Y时，称t是I$\in$ Y的证据。<br>$\quad$ 由所有多项式时间可验证的判定问题组成的问题称为NP类</p><p>$\quad$ <strong>非确定型多项式时间算法:</strong><br>$\quad$ $\quad$ (1)对给定的实例 I，首先“猜想”一个 t,|t| $\leq$ p(I)<br>$\quad$ $\quad$ (2)然后检查t是否是证明I$\in$ Y的证据<br>$\quad$ $\quad$ (3)猜想和检查可以在多项试时间内完成<br>$\quad$ $\quad$ (4)当且仅当I$\in$ Y时能够正确地猜想到一个证据t<br>$\quad$ $\quad$ *注:非确定型多项式时间算法不是真正的算法</p><p>$\quad$ P$\subseteq$ NP </p><p>$\quad$ <strong>多项式时间变换</strong><br>$\quad$ 定义 设判定问题П1&#x3D;&lt;D1,Y1&gt;,П2&#x3D;&lt;D2,Y2&gt;. 如果函数f:D1→D2满足条件：(1)f是多项式时间可计算的；(2)对所有的$I\in D_1,I \in Y_1 \leftrightarrow f(I) \in Y_2$ ;则称f是П1到П2的多项式时间变换.如果存在П1到П2的多项式时间变换,则称П1可多项式时间变换到П2,记作$П1 \leq_p П2$ </p><h4 id="NP完全性-NPC）"><a href="#NP完全性-NPC）" class="headerlink" title="NP完全性(NPC）"></a>NP完全性(NPC）</h4><p>$\quad$ 定义 :如果对所有的 П’$\in$ NP,П’$\leq_p$ Π,则称 П是NP难的.如果 П 是 NP 难的且 Π$\in$ NP，则称 Π 是 NP完全的.<br>$\quad$ 定理:如果存在NP难的问题 Π$\in$ P，则P&#x3D;NP.<br>$\quad$ 推论 :假设P $\ne$ NP,那么，如果 Π是NP难的，则 Π $\notin$ P.<br>$\quad$ 定理:如果存在NP难的问题 П’ 使得 П’$\leq_p  Π$  则 Π 是NP难的.<br>$\quad$ 推论:如果 П$\in$ NP并且存在 NP完全问题  Π’使得  Π’$\leq_p$ Π,则 Π是NP完全的.</p><p><strong>$\quad$ 证明NP完全性的“捷径”<br>$\quad$ (1)证明Π$\in$ NP;<br>$\quad$ (2)找到一个已知的NP完全问题I’，并证明 Π’$\leq_p$ П.</strong></p><p>$\quad$ 可满足性问题（SAT）：任给一个合取范式F，问F是可满足的吗？<br>$\quad$ SAT是NP完全的（NPC）<br><img src="/../sfmg/sf18.png"></p><p>$\quad$ 设无向图G&#x3D;&lt;V,E&gt;,V’$\subseteq$ V.V’是G的一个<br>$\quad$ $\quad$ 顶点覆盖：G的每一条边都至少有一个顶点在V’中。<br>$\quad$ $\quad$ 团：对任意的u,v$\in$ V’,且u$\ne$ v,都有(u,v)$\in$ E.<br>$\quad$ $\quad$ 独立集：对任意的u,v$\in$ V’，都有(u,v)$\notin$ E.</p><p>$\quad$ 引理 对任意的无向图G&#x3D;&lt;V,E&gt;和子集V’$\subseteq$ V,下述命题是等价的<br>$\quad$ $\quad$ (1) V’是G的顶点覆盖，<br>$\quad$ $\quad$ (2) V-V ‘ 是G的独立集;<br>$\quad$ $\quad$ (3) V-V’是补图 G&#x3D;&lt;V,E&gt;的团.</p><p>$\quad$ 顶点覆盖(VC)： 任给一个无向图G&#x3D;&lt;V,E&gt;和非负整数K$\leq$ ｜V｜，问G有顶点数不超过K的顶点覆盖吗？<br>$\quad$ 团：任给一个无向图G&#x3D;&lt;V,E&gt;和非负整数J$\leq$ ｜V｜，问G有顶点数不小于J的团吗？<br>$\quad$ 独立集：任给一个无向图G&#x3D;&lt;V,E&gt;和非负整数J$\leq$ ｜V｜，问G有顶点数不小于J的独立集吗？<br>$\quad$ 顶点覆盖（VC）是NP完全的</p><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3-CISC,X86,RISC,MIPS指令</title>
    <link href="/2023/03/19/3-CISC,X86,RISC,MIPS%E6%8C%87%E4%BB%A4/"/>
    <url>/2023/03/19/3-CISC,X86,RISC,MIPS%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p> 对应 北京大学计算机组成与体系结构第三讲<br> 参考教材COD（计算机组成与设计-硬件&#x2F;软件接口）</p><span id="more"></span><h1 id="计算机组成与体系结构"><a href="#计算机组成与体系结构" class="headerlink" title="计算机组成与体系结构"></a>计算机组成与体系结构</h1><hr><h2 id="CISC-X86-RISC-MIPS指令"><a href="#CISC-X86-RISC-MIPS指令" class="headerlink" title="CISC ,X86,RISC,MIPS指令"></a>CISC ,X86,RISC,MIPS指令</h2><p>$\quad$ CISC：Complex Instruction Set Computer：复杂指令系统计算机<br>$\quad$ RISC：Reduced Instruction Set Computer：精简指令系统计算机</p><h4 id="X86指令"><a href="#X86指令" class="headerlink" title="X86指令"></a>X86指令</h4><h5 id="传送类"><a href="#传送类" class="headerlink" title="传送类"></a>传送类</h5><p>$\quad$ 作用：把数据或地址传送到寄存器或存储器单元中。<br>$\quad$ 分为四大类14条指令<br><img src="/../txmg/tx30.png"></p><h6 id="MOV指令"><a href="#MOV指令" class="headerlink" title="MOV指令"></a>MOV指令</h6><p>$\quad$ 格式：MOV DST，SRC<br>$\quad$ 操作： DST$\leftarrow$ SRC<br>$\quad$ 说明：DST指令表示目的操作数，SRC表示源操作数。MOV指令把一个字节或字节操作数从源传送到目的，源操作数保持距离不变。<br>$\quad$ 传送方向和限制：<br><img src="/../txmg/tx31.png"></p><h6 id="XCHG指令（交换）"><a href="#XCHG指令（交换）" class="headerlink" title="XCHG指令（交换）"></a>XCHG指令（交换）</h6><p>$\quad$ 格式：XCHG OPR1，OPR2<br>$\quad$ 操作： OPTR1 $\leftrightarrow$ OPTR2<br>$\quad$ 说明：两个操作数的位宽要相同，类型包括寄存器&#x2F;存储器，存储器&#x2F;寄存器，寄存器&#x2F;寄存器，不允许使用段寄存器</p><h6 id="XLAT指令（换码，查表）"><a href="#XLAT指令（换码，查表）" class="headerlink" title="XLAT指令（换码，查表）"></a>XLAT指令（换码，查表）</h6><p>$\quad$ 格式：XLAT<br>$\quad$ 操作：<br>$\qquad$ 1. 从BX中取得数据表起始地址的偏移量<br>$\qquad$ 2. 从AL中取得数据表项索引值<br>$\qquad$ 3. 在数据表中查得表项内容<br>$\qquad$ 4. 将查得的表项内容存入AL</p><h5 id="运算类"><a href="#运算类" class="headerlink" title="运算类"></a>运算类</h5><p>$\quad$ 作用：完成加、减、乘、除等算术运算，提供运算结果调整，符号扩展等功能。<br>$\quad$ 操作数限制：对于双操作数的指令，限制与MOV指令相同（目的操作数不能是立即数或CS寄存器，两个操作数不能同时为存储器操作数）<br>$\quad$ 分类：五大类20条指令<br><img src="/../txmg/tx32.png"><br><img src="/../txmg/tx33.png"></p><h6 id="加法类指令"><a href="#加法类指令" class="headerlink" title="加法类指令"></a>加法类指令</h6><p>$\quad$ ADD：加<br>$\quad$ $\quad$ 格式：ADD DST，SRC<br>$\quad$ $\quad$ 操作：DST$\leftarrow$ DST+SRC<br>$\quad$ ADC：带进位的加<br>$\quad$ $\quad$ 格式：ADC DST，SRC<br>$\quad$ $\quad$ 操作：DST$\leftarrow$ DST+SRC+CF<br>$\quad$ INC：加1<br>$\quad$ $\quad$ 格式：INC OPR<br>$\quad$ $\quad$ 操作：OPR$\leftarrow$ OPR+1</p><h6 id="十进制调整指令"><a href="#十进制调整指令" class="headerlink" title="十进制调整指令"></a>十进制调整指令</h6><p>$\quad$ 格式：DAA<br>$\quad$ 操作：跟在二进制加法指令之后，将AL中的和调整为压缩BCD数形式，结果返回AL<br>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">MOV AL,<span class="hljs-number">27</span>H; AL=<span class="hljs-number">27</span>H<br>ADD AL,<span class="hljs-number">15</span>H; AL=<span class="hljs-number">3</span>CH<br>DAA.      ; AL=<span class="hljs-number">42</span>H<br></code></pre></td></tr></table></figure><p>$\qquad$ BCD（binary-Coded Decimal）具有二进制编码的形式，又保持了十进制的特点，可以作为人与计算机联系时的中间表示。<br><img src="/../txmg/tx34.png"></p><h5 id="转移类"><a href="#转移类" class="headerlink" title="转移类"></a>转移类</h5><p>$\quad$ 作用：改变指令执行顺序<br>$\quad$ 分类：根据是否有判断条件，分为无条件转移和条件转移指令；根据转移目的地址的提供方式，分为直接转移和间接转移。</p><h6 id="无条件转移指令"><a href="#无条件转移指令" class="headerlink" title="无条件转移指令"></a>无条件转移指令</h6><p><img src="/../txmg/tx35.png"><br>$\quad$ 直接转移：<br>$\qquad$ 短转移： JMP SHORT LABEL<br>$\quad$ $\quad$ 操作：IP$\leftarrow$ IP+8位的偏移量（-128～127Byte）<br>$\qquad$ 近转移：JMP NEAR PTR LABEL<br>$\quad$ $\quad$ 操作：IP$\leftarrow$ IP+16位的偏移量（+-32KByte）<br>$\qquad$ 远转移：JMP FAR PTR LABEL<br>$\quad$ $\quad$ 操作：IP$\leftarrow$ LABEL的偏移地址；CS$\leftarrow$ LABEL的段基值<br><img src="/../txmg/tx36.png"><br>$\quad$ 间接转移：JMP DWORD PTR OPR<br>$\quad$ $\quad$ 操作：寻址到OPR指定的存储器单元双字-&gt;将该双字中的低字送到IP寄存器中-&gt;将该双字中的高字送到CS寄存器中</p><h6 id="条件转移指令"><a href="#条件转移指令" class="headerlink" title="条件转移指令"></a>条件转移指令</h6><p><img src="/../txmg/tx37.png"><br><img src="/../txmg/tx38.png"><br>$\quad$ 操作：根据当前的状态标志位判断是否发生转移<br>$\quad$ 说明：8086中，所有的条件转移都是短转移，80386起，条件转移指令可以使用32位的长位移量</p><h6 id="循环控制指令"><a href="#循环控制指令" class="headerlink" title="循环控制指令"></a>循环控制指令</h6><p><img src="/../txmg/tx39.png"><br>LOOPNE&#x2F;LOOPNZ指令说明<br>$\quad$ 格式：LOOPNE LABEL或LOOPNZ LABEL<br>$\quad$ 操作：CX$\leftarrow$CX-1,若CX不为0且ZF为0，转移到LABEL处继续执行，否则结束循环顺序执行下一条指令</p><h5 id="串操作指令"><a href="#串操作指令" class="headerlink" title="串操作指令"></a>串操作指令</h5><p>$\quad$ 作用：对存储器中的数据串进行每次一个元素的操作<br>$\quad$ 分类：共5条串操作指令，3种重复前缀<br>$\quad$ 串的基本单位是字节或字，长度可达64KB<br><img src="/../txmg/tx320.png"></p><h6 id="重复前缀"><a href="#重复前缀" class="headerlink" title="重复前缀"></a>重复前缀</h6><p>$\quad$ <strong>REP</strong>（无条件重复）<br>$\qquad$ 当CX！&#x3D;0时，重复执行串操作指令，适用于MOVS，STO<br>$\qquad$ 处理完一个串元素后，CX减一<br><img src="/../txmg/tx321.png"><br>$\quad$ 串传送方向：DF&#x3D;0从低地址开始，DF&#x3D;1从高地址开始<br>$\quad$ <strong>REPNE&#x2F;REPNZ</strong>（不相等&#x2F;不为零重复）<br>$\qquad$ 当CX！&#x3D;0且ZF&#x3D;0时，重复执行串操作指令，适用于CMPS，SCAS</p><h5 id="处理器控制指令"><a href="#处理器控制指令" class="headerlink" title="处理器控制指令"></a>处理器控制指令</h5><p>$\quad$ 作用：控制CPU的功能，对标志位进行操作<br><img src="/../txmg/tx310.png"></p><h5 id="X86指令的发展历程："><a href="#X86指令的发展历程：" class="headerlink" title="X86指令的发展历程："></a>X86指令的发展历程：</h5><p><img src="/../txmg/tx311.png"><br><img src="/../txmg/tx312.png"></p><h4 id="MIPS指令"><a href="#MIPS指令" class="headerlink" title="MIPS指令"></a>MIPS指令</h4><p>$\quad$ 全称：Microprocessor without Interlocked Piped Stages<br>$\quad$ 主要关注点：减少指令的类型，降低指令的复杂度<br>$\quad$ 基本原则：A simpler CPU is a faster CPU</p><h5 id="指令示例"><a href="#指令示例" class="headerlink" title="指令示例"></a>指令示例</h5><h6 id="装载"><a href="#装载" class="headerlink" title="装载"></a>装载</h6><p>$\quad$ 格式：lw $8,($19)<br>$\quad$ 操作：以19号寄存器的内容为地址，取出存储器中的32位数据，存入八号寄存器</p><h6 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h6><p>$\quad$ 格式：add $10 , $9 ,  $8<br>$\quad$ 操作：将八号和九号寄存器的内容相加存入十号寄存器中（减法即为sub）</p><h6 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h6><p>$\quad$ 格式：sw $10,32 ($19)<br>$\quad$ 操作：将10号寄存器的内容存入存储器，地址为19号存储器的内容</p><h5 id="MIPS的通用寄存器"><a href="#MIPS的通用寄存器" class="headerlink" title="MIPS的通用寄存器"></a>MIPS的通用寄存器</h5><p>$\quad$ 32个，每个都是32位宽<br><img src="/../txmg/tx313.png"></p><h5 id="MIPS指令的特点"><a href="#MIPS指令的特点" class="headerlink" title="MIPS指令的特点"></a>MIPS指令的特点</h5><p>$\quad$ 1. 固定的指令长度（32-bit，即1word）<br>$\qquad$ 简化了从存储器取指令<br>$\qquad$ 对比x86长度不定，1～15字节<br>$\quad$ 2. 只有Load和Store指令可以访问存储器<br>$\quad$ 3. 简单的寻址模式<br>$\qquad$ 简化了从存储器取操作数<br>$\quad$ 4. 指令数量少，指令功能简单<br>$\qquad$ 一条指令只完成一个操作，简化指令的执行过程<br>$\qquad$ 影响：处理器设计简单，运行速度快，编程复杂，代码程序量大，需要优秀的编译器</p><h5 id="MIPS指令的基本格式"><a href="#MIPS指令的基本格式" class="headerlink" title="MIPS指令的基本格式"></a>MIPS指令的基本格式</h5><p>$\quad$ R： Register，寄存器<br>$\quad$  I：Immediate，立即数<br>$\quad$ J：Jump，无条件转移<br><img src="/../txmg/tx315.png"><br><img src="/../txmg/tx314.png"></p><h6 id="R型指令"><a href="#R型指令" class="headerlink" title="R型指令"></a>R型指令</h6><p><img src="/../txmg/tx317.png"><br>$\quad$ R型指令格式包括6个域，2个6-bit域（可表示0～63的数），4个5-bit域（可表示0～31的数）<br>$\quad$ opcode：用于指定指令的类型，对于所有R型指，该域的值均为0<br>$\quad$ funct：与opcode域结合，精确指定指令的类型<br>$\quad$ rs（Source Register）：指定第一个源操作数所在的寄存器编号<br>$\quad$ rt（Target Register）：指定第二个源操作数所在的寄存器编号<br>$\quad$ rd（Destination Register）：指定目的操作数（保存运算结果）的寄存器编号<br>$\quad$ shamt（shift amount）：用于指定移位指令进行移位操作的位数，非移位指令设为0<br>$\quad$ 5-bit的域可表示0~31，对应32个通用寄存器</p><h6 id="I型指令"><a href="#I型指令" class="headerlink" title="I型指令"></a>I型指令</h6><p><img src="/../txmg/tx316.png"><br>$\quad$ 大部分域与R指令相同<br>$\quad$  opcode：用于指定指令的类型<br>$\quad$ rs：指定第一个源操作数所在的寄存器编号<br>$\quad$ rt：一般指定用于目的操作数的寄存器编号；对于某些指令指定第二个源操作数所在的寄存器编号<br>$\quad$ immediate：16-bit的立即数，可以表示$2^{16}$ 个不同数值</p><h5 id="分支指令"><a href="#分支指令" class="headerlink" title="分支指令"></a>分支指令</h5><p>$\quad$ 分类：<br>$\qquad$ <strong>Branch</strong>：分支， 改变控制流<br>$\qquad$ <strong>Conditional Branch</strong>：条件分支，根据比较的结果改变控制流；两条指令：  <em>branch if equal（beg）；branch if not equal（bne）</em><br>$\qquad$ <strong>Unconditional Branch</strong> :非条件分支，无条件改变控制流：指令：<em>jump (j)</em> </p><h6 id="I型（条件分支）"><a href="#I型（条件分支）" class="headerlink" title="I型（条件分支）"></a>I型（条件分支）</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">beq rs,rt,imm   <span class="hljs-meta">#opcode=4</span><br>bne rs,rt,imm   <span class="hljs-meta">#opcode=5</span><br></code></pre></td></tr></table></figure><p>$\quad$ 目标地址计算方法：<br>$\qquad$ 分支条件不成立：PC&#x3D;PC+4<br>$\qquad$ 分支条件成立：PC&#x3D;PC+4+（immediate*4）</p><h6 id="J型（非条件分支）"><a href="#J型（非条件分支）" class="headerlink" title="J型（非条件分支）"></a>J型（非条件分支）</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">j addr<br></code></pre></td></tr></table></figure><p>$\quad$ 目标地址计算方法：PC &#x3D; { $(PC+4)[31..28],address,00$ }<br>$\quad$ 目标地址范围：$2^{28}bytes$ </p><h6 id="R型（非条件分支）"><a href="#R型（非条件分支）" class="headerlink" title="R型（非条件分支）"></a>R型（非条件分支）</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">jr rs<br></code></pre></td></tr></table></figure><h5 id="串操作指令-1"><a href="#串操作指令-1" class="headerlink" title="串操作指令"></a>串操作指令</h5><p><strong>MOVSB（字节串传送）</strong><br>$\quad$ 格式：MOVSB<br>$\quad$ 操作：将地址DS:SI所指向的存储器字节单元传送到地址ES:DI；修改SI和DI的内容，指向串的下一元素<br><strong>MOVSW（字串传送）</strong><br>$\quad$ 格式：MOVSW<br>$\quad$ 操作：将地址DS：SI所指向的存储器字单元传送到地址ES：DI；修改SI和DI的内容，指向串的下一元素</p><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>COD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>COD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2-计算机基本结构</title>
    <link href="/2023/03/19/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/"/>
    <url>/2023/03/19/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>  对应 北京大学计算机组成与体系结构第二讲<br>  参考教材COD（计算机组成与设计-硬件&#x2F;软件接口）</p><span id="more"></span><h1 id="计算机组成与体系结构"><a href="#计算机组成与体系结构" class="headerlink" title="计算机组成与体系结构"></a>计算机组成与体系结构</h1><hr><h2 id="计算机基本结构"><a href="#计算机基本结构" class="headerlink" title="计算机基本结构"></a>计算机基本结构</h2><h4 id="1-冯·诺依曼计算机结构"><a href="#1-冯·诺依曼计算机结构" class="headerlink" title="1. 冯·诺依曼计算机结构"></a>1. 冯·诺依曼计算机结构</h4><p> 要点：<br>$\quad$ 1. 计算机应该由运算器，控制器，存储器，输入设备和输出设备共五个部分组成。<br>$\quad$ 2. 数据和程序均以二进制代码形式不加区别地放在存储器中，存放位置由存储器的地址指定<br>$\quad$ 3. 计算机在工作时能够自动地从存储器中取出指令加以执行<br><img src="/../txmg/tx20.png"><br> 冯·诺伊曼计算机的主要构成：<br> $\quad$ 1. 运算器，CA：central arithmetical<br> $\quad$ 2. 控制器，CC：central control<br> $\quad$ 3. 存储器，M：memory<br> $\quad$ 4. 输入设备，I：input<br> $\quad$ 5. 输出设备，O：output<br> $\quad$ 外部记录设备，R：outside recording medium</p><h4 id="2-x86指令系统概览"><a href="#2-x86指令系统概览" class="headerlink" title="2. x86指令系统概览"></a>2. x86指令系统概览</h4><p><img src="/../txmg/tx21.png"><br>代表：<br> <strong>字长16位</strong>：<br>$\quad$ <em>Intel 8086</em>(1978年)<br> $\qquad$ 字长16位，内部的通用寄存器为16位，既能处理16位数据，也能处理8位数据。<br>  $\qquad$ 对外有16根数据线和20根地址线，可寻址的内存空间为1MByte($2^{20}$)。<br>   $\qquad$ 物理地址的形成采用“段加偏移”的方式。<br>$\quad$ <em>Intel 80286</em>（1982年）<br>  $\qquad$ 字长16位，地址总线扩展到24位，可寻址16MB的内存空间。<br>   $\qquad$ 引入了“保护模式”，但是机制有缺陷。<br> $\qquad$  为保持兼容，保留了8086的工作模式，被称为实模式（实地址模式)。<br> <strong>字长32位</strong>：<br>  $\quad$ <em>Intel 80386</em>（1985年）<br>$\qquad$ 80x86系列中的第一款32位微处理器。<br>$\qquad$ 地址总线扩展到32位，可寻址4GB的内存空间<br>$\qquad$ 改进了“保护模式”：（80386及以上的微处理器的主要工作模式，支持多任务，支持设置特权级，可以访问4GB的物理存储空间，引入了虚拟存储器的概念）<br>$\qquad$ 增加了“虚拟8086模式”，可以同时模拟多个8086微处理器<br><img src="/../txmg/tx22.png"><br> <strong>字长64位</strong>：<br>$\quad$ <em>AMD Opteron</em> （2003年）<br>$\qquad$ x86扩展到64位的第一款处理器<br>$\qquad$ 可以访问高于4GB的存储器<br>$\qquad$ 兼容32位x86程序，且不降低性能<br><img src="/../txmg/tx23.png"></p><h4 id="3-x86的地址空间"><a href="#3-x86的地址空间" class="headerlink" title="3. x86的地址空间"></a>3. x86的地址空间</h4><p><img src="/../txmg/tx24.png"><br> <strong>指令指针寄存器IP（Instruction Pointer）</strong>：<br> $\quad$ 保存一个内存地址，指向当前需要取出的指令。<br> $\quad$ 当CPU从内存中取出一个指令后，IP会自动增加，指向下一指令的地址。<br> $\quad$ 程序员不能直接对IP进行存取操作<br> $\quad$ 转移指令，过程调用与返回等会改变IP的内容。<br> <strong>段寄存器</strong><br> $\quad$ 与处理器中其他寄存器联合生成存储器地址<br> $\quad$ 段寄存器的功能在实模式下和保护模式下是不同的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp">DATA SEGMENT ; 数据段<br>    NUM DW <span class="hljs-number">0011101000000111B</span>;<br>    NOTES DB <span class="hljs-string">&#x27;The result is :&#x27;</span>,<span class="hljs-string">&#x27;$&#x27;</span><br>DATA ENDS ; 数据段结束<br><br>STACK SEGMENT ; 堆栈段<br>    STA DB <span class="hljs-number">50</span> <span class="hljs-built_in">DUP</span>(?)<br>    TOP EQU LENGTH STA<br>STACK ENDS ; 堆栈段结束<br><br>CODE SEGMENT ; 代码段<br>    ASSUME CS:CODE,DS:DATA,SS:STACK<br>BEGIN:<br>    MOV AX, DATA<br>    MOV DS, AX   ;为DS赋初值<br>    MOV AX, STACK <br>    MOV SS, AX   ;为SS赋初值<br>    MOV AX, TOP<br>    MOV SP, AX   ;为SP赋初值<br>    ...<br>CODE ENDS       ;  代码段结束<br>    END    BEGIN   ;模块结束<br></code></pre></td></tr></table></figure><p> $\quad$ ( 1 ) 代码段寄存器 CS (Code Segment)<br> $\qquad$ 保存了代码段(一个存储区域，用以保存微处理器使用的代码）的起始地址 。<br>  $\qquad$ 用CS:IP指示下一条要执行的指令地址<br>  <img src="/../txmg/tx25.png"></p><p>$\quad$ ( 2 ) 数据段寄存器 DS (Data Segment)<br>  $\qquad$ 保存了数据段（一个存储区域，包含程序所使用的大部分数据）的起始地址。<br>  $\qquad$ 实模式数据段的长度限制为64KB，保护模式数据段长度限制为4GB。<br>$\quad$（ 3 ）附加段寄存器 ES (Extra Segment)<br>  $\qquad$ 保存了附加段（附加的数据段，也用于数据的保存，某些串操作指令将附加段作为其目的操作数的存放区域，长度限制与代码段以及数据段相同。）的起始地址。<br>  $\qquad$ 用ES:DI指示串操作的目的操作数的地址<br>  <img src="/../txmg/tx26.png"></p><p>  $\qquad$ 如果数据存在放在数据段以外的其他段（例如附加段），则应在指令中给出“段跨越前缀”。<br>  如  MOV  AX，ES:[3000H]   或   ES:MOV AX，[3000H]<br>$\quad$（ 4 ）堆栈段寄存器 SS (Stack Segment)<br>$\qquad$ 用以指示堆栈段的首地址<br>$\qquad$ ESP&#x2F;SP或EBP&#x2F;BP指示堆栈栈顶的偏移地址<br>$\qquad$用SS:SP等组合操作堆栈中的数据<br><img src="/../txmg/tx27.png"><br>$\quad$ （ 5 ）新增加的附加段寄存器FS和GS<br>$\qquad$ 80386起新增了这两个附加段寄存器<br>$\qquad$ FS和GS的功能和ES相同<br>$\qquad$ 增加FS和GS可以减轻ES寄存器的负担，以便程序灵活访问相应的两个附加数据段。</p><p> <strong>8086的物理地址生成</strong><br> <img src="/../txmg/tx28.png"><br>  $\quad$ 实例：<br>  <img src="/../txmg/tx29.png"><br>  <strong>直观的存储器分段方法</strong><br>$\quad$ 实现方法：把20位物理地址分为2部分，高4位为段号，用段号寄存器来保存，低16位为段内地址，也称便宜地址。<br>$\quad$ 不足之处：段号寄存器和其他寄存器不兼容，且每个逻辑段固定占用16K字节，浪费存储空间，相比而言8086的分段技术更灵活。<br> <strong>IA-32的存储器寻址</strong><br>  实模式 CS:IP<br>  保护模式：CS:EIP，保护模式下，段基地不在CS中，而是在内存中。<img src="/../txmg/tx210.png"></p><h4 id="4-x86汇编语言的格式"><a href="#4-x86汇编语言的格式" class="headerlink" title="4. x86汇编语言的格式"></a>4. x86汇编语言的格式</h4><h6 id="Intel-和AT-amp-T-格式的区别"><a href="#Intel-和AT-amp-T-格式的区别" class="headerlink" title="Intel 和AT&amp;T 格式的区别"></a>Intel 和AT&amp;T 格式的区别</h6><p> <strong>Intel 格式</strong><br>$\quad$ Intel制定，x86相关的文档手册使用该格式<br>$\quad$ 主要应用在MS-DOS和Windows等系统中<br> <strong>AT&amp;T格式</strong><br>$\quad$ AT&amp;T制定，起源于贝尔实验室研发的Unix<br>$\quad$ 最初用在PDP-11&#x2F;VAX等机型，后移植到x86<br>$\quad$ 主要应用于Unix和Linux等系统中</p><ol><li>前缀（后缀）：<br> $\quad$ Intel语法：寄存器和立即数都没有前缀，十六进制、十进制、八进制和二进制立即数后缀分别为h,d，o(q)和b。整数默认为10进制，以字母开头的十六进制数必须加0，字符串常数用单引号括起。实数即为 （）E（）<br>  $\quad$ AT&amp;T语法“寄存器使用前缀”%“，立即数使用前缀”$“，十六进制立即数使用前缀0x<br>  <img src="/../txmg/tx211.png"></li><li>操作数方向<br>  $\quad$ Intel语法：第一个操作数是目的操作数，第二个操作数是源操作数<br>  $\quad$ AT&amp;T语法：第一个操作数是源操作数，第二个操作数是目的操作数</li><li>内存单元操作数<br>  $\quad$ Intel语法：基寄存器用[ ]标明<br>  $\quad$ AT&amp;T语法：基寄存器用（ ）标明</li><li>间接寻址方法<br>  $\quad$ Intel语法：segreg:[base+index*scale+disp]<br>  $\quad$ AT&amp;T语法：%segreg:disp(base,index,scale)<br>  <img src="/../txmg/tx212.png"></li><li>操作码后缀<br>  $\quad$ AT&amp;T语法： 操作码带后缀，以指出操作数的大小<br>  $\qquad$ I:32位；w: 16位 ；b：8位<br>  $\quad$ Intel语法：内存单元操作数带前缀，以指出操作数的大小<br>  $\qquad$ dword ptr; word ptr ;byte ptr<br>  <img src="/../txmg/tx213.png"></li></ol><h6 id="汇编语言程序"><a href="#汇编语言程序" class="headerlink" title="汇编语言程序"></a>汇编语言程序</h6><p> <strong>组成</strong><br>$\quad$ 分段结构：按段进行组织，最多由四个段组成（代码，数据 ，附加，堆栈），每个段以“段名   SEGMENT”开始，以“段名  ENDS”结束。<br>$\quad$ 语句行：段由若干语句行组成，语句行的三种类型：指令、伪指令<br>宏指令。<br> <strong>语句的执行</strong><br>$\quad$ 指令语句的执行：汇编器计算指令语句中表达式的值-&gt;汇编器将指令语句翻译成机器指令代码-&gt;程序运行时，由CPU按机器指令代码的要求完成各种运算与操作。<br>$\quad$ 伪指令语句的执行：汇编器计算伪指令语句中表达式的值，不产生机器代码，汇编器解释伪指令语句的含义并遵照执行。<br>$\qquad$ 数据定义：变量（编程时只能确定其初始值，程序运行期间可修改其值的数据对象称为变量）是存储单元中的数据，可定义在任何段，由伪指令说明符DB、DW、DD等定义<br>$\qquad$ 符号定义：常量（编程时已确定其值，程序运行期间不会改变其值）可由伪指令说明符”EQU”或“&#x3D;”定义，不产生目标代码，不占用存储单元。EQU左边的符号名不可重复定义，但&#x3D;可以。<br>$\qquad$ 段定义：说明符SEGMENT（段开始），ENDS（段结束），ASSUME（指定段寄存器）<br>$\qquad$ 指定段内的偏移地址：<br>$\qquad$ $\qquad$ “ORG 常数表达式”指定当前可用的存储单元的偏移地址为常数表达式的值。<br>$\qquad$ $\qquad$ “EVEN”将当前可用的存储单元的偏移地址调整为最近的偶数值。<br>$\qquad$ 示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">DATA SEGMENT<br>  ORG <span class="hljs-number">1000</span>H<br>  A DB <span class="hljs-number">47</span>H,<span class="hljs-number">12</span>H,<span class="hljs-number">45</span>H<br>  EVEN<br>  B DB <span class="hljs-number">47</span>H<br>DATA ENDS<br><span class="hljs-comment">//ORG指令将A的偏移地址部分指定为1000H，从A开始存放3个字节变量，占用地址1000H，1001H和1002H，EVEN指令会将B的偏移地址部分从1003H调整为偶数地址1004H</span><br><br></code></pre></td></tr></table></figure><p>$\qquad$ 过程定义：<br>$\qquad$ $\qquad$ “过程名  PROC  类型属性名”：从过程名代表的地址开始定义一个过程；“类型属性名”可以选择NEAR（近过程）或FAR（远过程），默认为NEAR<br>$\qquad$ $\qquad$ “过程名 ENDP”：表示该过程到此结束，此处的过程名必须与过程开始时PROC左边的过程名相同。</p><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>COD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>COD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1-课程概述</title>
    <link href="/2023/03/19/1-%E8%AF%BE%E7%A8%8B%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/03/19/1-%E8%AF%BE%E7%A8%8B%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p> 对应 北京大学计算机组成与体系结构第一讲<br> 参考教材COD（计算机组成与设计-硬件&#x2F;软件接口）</p><span id="more"></span><h1 id="计算机组成与体系结构"><a href="#计算机组成与体系结构" class="headerlink" title="计算机组成与体系结构"></a>计算机组成与体系结构</h1><hr><h2 id="课程概述"><a href="#课程概述" class="headerlink" title="课程概述"></a>课程概述</h2><h4 id="1-电子计算机的兴起"><a href="#1-电子计算机的兴起" class="headerlink" title="1. 电子计算机的兴起"></a>1. 电子计算机的兴起</h4><p>$\quad$ ENIAC：世界第一台电子计算机 设计者：约翰·莫克利和约翰·埃克特<br>$\quad$ 现代电子计算机之父：冯·诺依曼<br>$\quad$ EDVAC 第一台存储程序计算机（冯诺依曼结构)<br>$\quad$ UNIVAC：开启了商用计算机的时代<br>$\quad$ 第一台实际运行的冯·诺依曼结构：EDSAC，出现在英国</p><h4 id="2-计算机的主要类别"><a href="#2-计算机的主要类别" class="headerlink" title="2. 计算机的主要类别"></a>2. 计算机的主要类别</h4><p>$\quad$ 1. 超级计算机<br>$\quad$ $\quad$ 溯源：1964年，CDC6600<br>$\quad$ $\quad$ 特点：运算速度最快，性能最高，技术最复杂，代表该时期处理能力巅峰，解决科技领域中某些巨大的挑战性问题<br>$\quad$ $\quad$ 用途： 用于高度计算密集型的科学计算任务<br>$\quad$ $\quad$ 最多：美国<br>$\quad$ $\quad$ 目前排名：美国Frontier，日本Fugaku，芬兰LUMI<br>$\quad$ 2. 微型计算机<br>$\quad$ $\quad$ 溯源：1975年，Altair8800<br>$\quad$ $\quad$ 特点：以微处理器为中央处理单元（CPU）而组成的计算机系统，一大类为个人计算机，另一大类为微控制器嵌入到其他设备<br>$\quad$ $\quad$ 用途：个人处理，家用电器等<br>$\quad$ 3. 大型计算机<br>$\quad$ $\quad$ 溯源：1952年，IBM701<br>$\quad$  $\quad$ 特点：使用所在时代的先进技术构成的一类高性能，大容量通用计算机，强调高速输入输出，海量存储空间和并行事务处理 。<br>$\quad$ $\quad$ 用途：用于大容量数据的事务处理，兼顾科学计算<br>$\quad$ 4. 小型计算机<br>$\quad$ $\quad$ 溯源：1965年，PDP-8<br>$\quad$ $\quad$ 特点：规模介于大型计算机和微型计算机之间<br>$\quad$ $\quad$ 用途：非常广泛，事务处理和科学计算</p><p>摩尔定律：当价格不变时，集成电路可容纳的晶体管数数量，约每隔18个月便会增加一倍，性能也将提升一倍<br>衍生反摩尔定律：一个IT公司如果今天和18个月前卖掉同样多，同样的产品，它的营业额就要降一半。</p><p>$\quad$ </p><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>COD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>COD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>铃芽之旅</title>
    <link href="/2023/03/19/%E9%93%83%E8%8A%BD%E4%B9%8B%E6%97%85/"/>
    <url>/2023/03/19/%E9%93%83%E8%8A%BD%E4%B9%8B%E6%97%85/</url>
    
    <content type="html"><![CDATA[<h2 id="”有点过誉“"><a href="#”有点过誉“" class="headerlink" title="”有点过誉“"></a>”有点过誉“<br><span id="more"></span></h2><p>$\quad$ 三年之期已到，新海诚的新作《铃芽之旅》还未正式上映就已然吸引了各位的目光，各位也是很期待国内宣发的“集大成之作”到底会是什么样子。<br>$\quad$ PKU很给力的搞到了首映式的举办机会，无所谓，算分小班会出手（寄）</p><p><img src="/../post_img/suzume4.jpg"></p><p>$\quad$ でも大丈夫,元火还是给力的垄断了（bushi）北京地区的提前观影资格，身为元火子的本鼠鼠自然是参加了的</p><p><img src="/../post_img/suzume2.jpg"></p><p>$\quad$ 两个小时下来，怎么说呢，节奏过于快了，感觉换成12集的tv会比较好些，很多地方的细节都没有给出明确的解释，电影便结束了，目前看来口碑&lt;君名，$\approx$ 天气之子，应该是没有什么悬念的。（灾难三部曲疑似成为退步三部曲）。<br>$\quad$ 最后也是用chatgpt摸了个观后感（主人的任务罢了）</p><blockquote><p>$\quad$ 《铃芽之旅》是新海诚导演的第八部动画电影，也是他继《你的名字》和《天气之子》后，第三部涉及灾难题材的作品，被称为新海诚的“灾难三部曲”。该片讲述了17岁的少女岩户铃芽与负责关闭连接往生者世界“常世”的“后门”的“闭门师”宗像草太相遇，两人一起去关闭灾难源头之门的冒险故事。 $\newline$<br>在我看来，《铃芽之旅》是新海诚导演的集大成作，不仅展现了他惯有的细腻情感、精美画面和动听音乐，还突破了他以往作品的局限和套路，尝试了公路电影、日本庭园、万叶集等新颖元素，并直面了东日本大震災等现实问题。该片不仅有着浪漫而又悲伤的爱情故事，还有着对生命、时间和自我成长的深刻思考。  $\newline$<br>$\quad$ 首先，《铃芽之旅》延续了新海诚导演对于青春爱情故事的独特魅力。铃芽和草太两个性格迥异、身份悬殊、相貌平凡的主角，在经历了一系列奇遇和危机后，逐渐产生了超越友情和亲情的感情。他们在彼此身上找到了自己缺失或忘却的东西：铃芽找到了自己想要追寻和守护的目标；草太找到了自己想要珍惜和拥有的人生。他们在一起时互相开导、互相支持、互相取暖；分开时思念如潮、心痛如刀、坚持如命。他们用行动证明了爱情不分年龄、地域、身份，只要有勇气去追求就能跨越一切障碍。$\newline$<br>$\quad$ 其次，《铃芽之旅》展现了新海诚导演对于视觉美学和音乐艺术的高超水准。该片以日本列岛为舞台，从九州宫崎县到四国爱媛县再到东京都区内等地方都有精心描绘出来³。无论是港口小镇、山中废墟、市郊游乐园还是摩天轮上空，都充满了细节与真实感。该片还运用了多种色彩与光影效果来营造出不同场景与氛围：暗红色烟雾代表着灾难与危机；蓝色天空代表着希望与梦想；白色雨滴代表着洗涤与重生；金色阳光代表着温暖与幸福。该片还运用了多种镜头语言和动画技巧来表达出不同情感与意境：慢镜头、定格、倒带等手法突出了主角之间的心理变化和时间流逝；分屏、对比、重叠等手法展现了主角之间的距离感和相互联系；变形、抽象、隐喻等手法创造了主角之间的梦境和幻想。该片的音乐由日本摇滚乐队RADWIMPS负责，他们为该片创作了多首歌曲和配乐，其中有些歌曲还由原菜乃华和松村北斗亲自演唱。这些音乐不仅符合电影的风格和主题，还能够引起观众的共鸣和感动。$\newline$<br>$\quad$ 最后，《铃芽之旅》突破了新海诚导演对于灾难题材的固有模式，尝试了更加深刻和现实的探讨。该片中出现的灾难不仅是一种外在的威胁，也是一种内在的寓言。灾难源于人类对于时间和生命的扭曲，也反映了人类对于自我和他者的冲突。灾难既是一种惩罚，也是一种救赎。灾难让人类失去了很多东西，也让人类重新思考了很多东西。灾难让人类面临着选择，也让人类看到了希望。该片还直接引入了东日本大震災这一历史事件，并以此为契机展开了对于生死、记忆、责任等话题的思考。$\newline$<br>$\quad$ 综上所述，《铃芽之旅》是新海诚导演的集大成作，不仅有着动人心弦的爱情故事，还有着精彩绝伦的视听享受，更有着深刻而又现实的主题思想。这部电影值得每一个喜欢新海诚作品或者喜欢动画电影或者喜欢爱情故事或者喜欢冒险旅程或者喜欢灵异神秘或者喜欢日本文化或者喜欢美丽风景或者喜欢优美音乐或者喜欢感动落泪或者喜欢思考哲理或者只是单纯想要看一部好电影而已……总之就是值得每一个观众去观看并从中获得自己想要得到的东西。$\newline$</p></blockquote><p>$\quad$ u1s1，ai写的比我好（<br>$\quad$ 音乐和画面一如既往地发挥优秀吧，但是剧情有一说一，不大行了</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/../post_img/suzume.png"></h2>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
      <category>影评</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二次元</tag>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>番剧</title>
    <link href="/2023/03/12/anime/"/>
    <url>/2023/03/12/anime/</url>
    
    <content type="html"><![CDATA[<p>记录已看番剧</p><span id="more"></span><h3 id="Key社："><a href="#Key社：" class="headerlink" title="Key社："></a>Key社：</h3><p><a href="https://bgm.tv/subject/51">CLANNAD</a><br><a href="https://bgm.tv/subject/876">CLANNAD ～AFTER STORY～</a><br><a href="https://bgm.tv/subject/1851">Angel Beats!</a></p><h3 id="高达类系列："><a href="#高达类系列：" class="headerlink" title="高达类系列："></a>高达类系列：</h3><h5 id="UC"><a href="#UC" class="headerlink" title="UC:"></a>UC:</h5><p><a href="https://bgm.tv/subject/62680">機動戦士ガンダム THE ORIGIN</a><br><a href="https://bgm.tv/subject/349442">機動戦士ガンダム ククルス・ドアンの島</a><br><a href="https://bgm.tv/subject/50">機動戦士ガンダム UC0079</a><br><a href="https://bgm.tv/subject/2664">機動戦士ガンダム 第08MS小隊 UC0079</a><br><a href="https://bgm.tv/subject/1015">機動戦士ガンダム0080 ポケットの中の戦争 UC0080</a><br><a href="https://bgm.tv/subject/804">機動戦士ガンダム0083 STARDUST MEMORY UC0083</a><br><a href="https://bgm.tv/subject/9622">機動戦士Ζガンダム UC0084</a><br><a href="https://bgm.tv/subject/4213">機動戦士ガンダムZZ UC0088</a><br><a href="https://bgm.tv/subject/4583">機動戦士ガンダム 逆襲のシャア UC0093</a><br><a href="https://bgm.tv/subject/3113">機動戦士ガンダム Unicon UC0096</a><br><a href="https://bgm.tv/subject/243428">機動戦士ガンダム NT UC0097</a><br><a href="https://bgm.tv/subject/243429">機動戦士ガンダム 閃光のハサウェイ UC0105</a><br><a href="https://bgm.tv/subject/4482">機動戦士ガンダム F91 UC0123</a><br><a href="https://bgm.tv/subject/3553">∀ ガンダム</a><br><a href="https://bgm.tv/subject/106834">機動戦士ガンダムさん</a><br><a href="https://bgm.tv/subject/298573">機動戦士SDガンダム</a></p><h5 id="00"><a href="#00" class="headerlink" title="00:"></a>00:</h5><p><a href="https://bgm.tv/subject/286">機動戦士ガンダム 00</a><br><a href="https://bgm.tv/subject/1010">機動戦士ガンダム 00 セカンドシーズン</a><br><a href="https://bgm.tv/subject/5972">劇場版 機動戦士ガンダム 00 -A wakening of the Trailblazer</a></p><h5 id="W"><a href="#W" class="headerlink" title="W:"></a>W:</h5><p><a href="https://bgm.tv/subject/2774">新機動戦記ガンダム W</a><br><a href="https://bgm.tv/subject/2772">新機動戦記ガンダム W Endless Waltz 特別篇</a></p><h5 id="X"><a href="#X" class="headerlink" title="X:"></a>X:</h5><p><a href="https://bgm.tv/subject/3633">機動新世紀ガンダム X</a></p><h5 id="铁华团："><a href="#铁华团：" class="headerlink" title="铁华团："></a>铁华团：</h5><p><a href="https://bgm.tv/subject/139324">機動戦士ガンダム 鉄血のオルフェンズ </a><br><a href="https://bgm.tv/subject/170191">機動戦士ガンダム 鉄血のオルフェンズ 弐</a></p><h5 id="SEED"><a href="#SEED" class="headerlink" title="SEED:"></a>SEED:</h5><p><a href="https://bgm.tv/subject/1860">機動戦士ガンダム SEED</a><br><a href="https://bgm.tv/subject/1861">機動戦士ガンダム SEED DESTINY</a></p><h5 id="雷霆宙域："><a href="#雷霆宙域：" class="headerlink" title="雷霆宙域："></a>雷霆宙域：</h5><p><a href="https://bgm.tv/subject/151345">機動戦士ガンダム サンダーボルト</a><br><a href="https://bgm.tv/subject/198380">機動戦士ガンダム サンダーボルト 第2シーズン </a></p><h5 id="水星的魔女"><a href="#水星的魔女" class="headerlink" title="水星的魔女:"></a>水星的魔女:</h5><p><a href="https://bgm.tv/subject/349441">機動戦士ガンダム 水星の魔女</a><br><a href="https://bgm.tv/subject/403238">機動戦士ガンダム 水星の魔女 Season2</a></p><h5 id="三国伝"><a href="#三国伝" class="headerlink" title="三国伝:"></a>三国伝:</h5><p><a href="https://bgm.tv/subject/4294">SDガンダム三国伝 Brave Battle Warriors</a></p><h5 id="创战"><a href="#创战" class="headerlink" title="创战"></a>创战</h5><p><a href="https://bgm.tv/subject/105875">ガンダムビルドファイターズトライ</a><br><a href="https://bgm.tv/subject/182406">ガンダムビルドファイターズトライ アイランド・ウォーズ</a></p><h5 id="天使与龙的轮舞"><a href="#天使与龙的轮舞" class="headerlink" title="天使与龙的轮舞"></a>天使与龙的轮舞</h5><p><a href="https://bgm.tv/subject/109948">クロスアンジュ 天使と竜の輪舞</a></p><h3 id="异世界类"><a href="#异世界类" class="headerlink" title="异世界类:"></a>异世界类:</h3><h5 id="盾娘："><a href="#盾娘：" class="headerlink" title="盾娘："></a>盾娘：</h5><p><a href="https://bgm.tv/subject/302766">痛いのは嫌なので防御力に極振りしたいと思います。2 </a><br><a href="https://bgm.tv/subject/268545">痛いのは嫌なので防御力に極振りしたいと思います</a></p><h5 id="OVERLORD："><a href="#OVERLORD：" class="headerlink" title="OVERLORD："></a>OVERLORD：</h5><p><a href="https://bgm.tv/subject/112146">OVERLORD</a><br><a href="https://bgm.tv/subject/211027">OVERLORD II</a><br><a href="https://bgm.tv/subject/242170">OVERLORD III</a><br><a href="https://bgm.tv/subject/335389">OVERLORD IV</a></p><h5 id="无职："><a href="#无职：" class="headerlink" title="无职："></a>无职：</h5><p><a href="https://bgm.tv/subject/277554">無職転生 ～異世界行ったら本気だす～</a><br><a href="https://bgm.tv/subject/325585">無職転生 ～異世界行ったら本気だす～ 第2クール</a><br><a href="https://bgm.tv/subject/373247">無職転生Ⅱ ～異世界行ったら本気だす～</a></p><h5 id="异世界四重奏："><a href="#异世界四重奏：" class="headerlink" title="异世界四重奏："></a>异世界四重奏：</h5><p><a href="https://bgm.tv/subject/262865">異世界かるてっと</a><br><a href="https://bgm.tv/subject/285422">異世界かるてっと 2</a><br><a href="https://bgm.tv/subject/303126">劇場版 異世界かるてっと ～あなざーわーるど～</a></p><h5 id="素晴："><a href="#素晴：" class="headerlink" title="素晴："></a>素晴：</h5><p><a href="https://bgm.tv/subject/135275">この素晴らしい世界に祝福を！</a><br><a href="https://bgm.tv/subject/174043">この素晴らしい世界に祝福を！2</a><br><a href="https://bgm.tv/subject/220631">映画 この素晴らしい世界に祝福を！紅伝説</a><br><a href="https://bgm.tv/subject/385209">この素晴らしい世界に爆焔を!</a></p><h5 id="Re0"><a href="#Re0" class="headerlink" title="Re0:"></a>Re0:</h5><p><a href="https://bgm.tv/subject/140001">Re:ゼロから始める異世界生活</a><br><a href="https://bgm.tv/subject/278826">Re:ゼロから始める異世界生活 2nd season</a><br><a href="https://bgm.tv/subject/316247">Re:ゼロから始める異世界生活 2nd season 後半クール</a><br><a href="https://bgm.tv/subject/225462">Re:ゼロから始める異世界生活 Memory Snow</a></p><h5 id="幼女战记："><a href="#幼女战记：" class="headerlink" title="幼女战记："></a>幼女战记：</h5><p><a href="https://bgm.tv/subject/167655">幼女戦記</a><br><a href="https://bgm.tv/subject/234771">劇場版 幼女戦記</a></p><h5 id="エロ："><a href="#エロ：" class="headerlink" title="エロ："></a>エロ：</h5><p><a href="https://bgm.tv/subject/295017">回復術士のやり直し</a><br><a href="https://bgm.tv/subject/285482">異種族レビュアーズ</a><br><a href="https://bgm.tv/subject/291195">ピーター・グリルと賢者の時間</a><br><a href="https://bgm.tv/subject/356793">ピーター・グリルと賢者の時間 Super Extra</a><br><a href="https://bgm.tv/subject/373712">不徳のギルド</a><br><a href="https://bgm.tv/subject/374319">犬になったら好きな人に拾われた。</a></p><h5 id="default："><a href="#default：" class="headerlink" title="default："></a>default：</h5><p><a href="https://bgm.tv/subject/339326">異世界おじさん</a><br><a href="https://bgm.tv/subject/326868">天才王子の赤字国家再生術</a><br><a href="https://bgm.tv/subject/333176">このヒーラー、めんどくさい</a><br><a href="https://bgm.tv/subject/336458">異世界美少女受肉おじさんと</a><br><a href="https://bgm.tv/subject/264089">乙女ゲームの破滅フラグしかない悪役令嬢に転生してしまった…</a><br><a href="https://bgm.tv/subject/353657">勇者、辞めま</a><br><a href="https://bgm.tv/subject/48669">戦勇。</a><br><a href="https://bgm.tv/subject/69165">戦勇。第2期</a><br><a href="https://bgm.tv/subject/379639">勇者が死んだ！</a><br><a href="https://bgm.tv/subject/377607">神無き世界のカミサマ活動</a><br><a href="https://bgm.tv/subject/389571">マッシュル-MASHLE-</a><br><a href="https://bgm.tv/subject/376106">Lv1魔王とワンルーム勇者</a><br><a href="https://bgm.tv/subject/369784">Helck</a></p><h3 id="恋爱番："><a href="#恋爱番：" class="headerlink" title="恋爱番："></a>恋爱番：</h3><h5 id="高木类："><a href="#高木类：" class="headerlink" title="高木类："></a>高木类：</h5><p><a href="https://bgm.tv/subject/219200">からかい上手の高木さん</a><br><a href="https://bgm.tv/subject/271151">からかい上手の高木さん②</a><br><a href="https://bgm.tv/subject/347887">からかい上手の高木さん③</a><br><a href="https://bgm.tv/subject/347888">劇場版 からかい上手の高木さん</a><br><a href="https://bgm.tv/subject/324728">それでも歩は寄せてくる</a></p><h5 id="告白实行委员会："><a href="#告白实行委员会：" class="headerlink" title="告白实行委员会："></a>告白实行委员会：</h5><p><a href="https://bgm.tv/subject/212005">いつだって僕らの恋は10センチだった。</a><br><a href="https://bgm.tv/subject/140020">ずっと前から好きでした。～告白実行委員会～</a><br><a href="https://bgm.tv/subject/126798">告白実行委員会 告白予行練習 ショートストーリー</a><br><a href="https://bgm.tv/subject/175543">好きになるその瞬間を。～告白実行委員会～</a></p><h5 id="辉夜："><a href="#辉夜：" class="headerlink" title="辉夜："></a>辉夜：</h5><p><a href="https://bgm.tv/subject/248175">かぐや様は告らせたい～天才たちの恋愛頭脳戦～</a><br><a href="https://bgm.tv/subject/293049">かぐや様は告らせたい？～天才たちの恋愛頭脳戦～</a><br><a href="https://bgm.tv/subject/317613">かぐや様は告らせたい-ウルトラロマンティック-</a><br><a href="https://bgm.tv/subject/389474">かぐや様は告らせたい-ファーストキッスは終わらない-</a></p><h5 id="新海诚："><a href="#新海诚：" class="headerlink" title="新海诚："></a>新海诚：</h5><p><a href="https://bgm.tv/subject/927">秒速5センチメートル</a><br><a href="https://bgm.tv/subject/269235">天気の子</a><br><a href="https://bgm.tv/subject/160209">君の名は</a><br><a href="https://bgm.tv/subject/58949">言の葉の庭</a><br><a href="https://bgm.tv/subject/362577">すずめの戸締まり</a></p><h5 id="中二病："><a href="#中二病：" class="headerlink" title="中二病："></a>中二病：</h5><p><a href="https://bgm.tv/subject/29648">中二病でも恋がしたい！</a><br><a href="https://bgm.tv/subject/72942">中二病でも恋がしたい！戀</a><br><a href="https://bgm.tv/subject/215425">映画 中二病でも恋がしたい！ -Take On Me-</a></p><h5 id="鸭志田一："><a href="#鸭志田一：" class="headerlink" title="鸭志田一："></a>鸭志田一：</h5><p><a href="https://bgm.tv/subject/212278">Just Because!</a><br><a href="https://bgm.tv/subject/41488">さくら荘のペットな彼女</a><br><a href="https://bgm.tv/subject/240038">青春ブタ野郎はバニーガール先輩の夢を見ない</a><br><a href="https://bgm.tv/subject/260680">青春ブタ野郎はゆめみる少女の夢を見ない</a></p><h5 id="XX学妹类："><a href="#XX学妹类：" class="headerlink" title="XX学妹类："></a>XX学妹类：</h5><p><a href="https://bgm.tv/subject/299498">宇崎ちゃんは遊びたい!</a><br><a href="https://bgm.tv/subject/315744">宇崎ちゃんは遊びたい！ω</a><br><a href="https://bgm.tv/subject/309753">イジらないで、長瀞さん</a><br><a href="https://bgm.tv/subject/354042">イジらないで、長瀞さん 2nd Attack</a></p><h5 id="五等分的花嫁："><a href="#五等分的花嫁：" class="headerlink" title="五等分的花嫁："></a>五等分的花嫁：</h5><p><a href="https://bgm.tv/subject/256114">五等分の花嫁</a><br><a href="https://bgm.tv/subject/282000">五等分の花嫁∬</a><br><a href="https://bgm.tv/subject/331489">映画 五等分の花嫁</a></p><h5 id="default：-1"><a href="#default：-1" class="headerlink" title="default："></a>default：</h5><p><a href="https://bgm.tv/subject/117153">俺物語!!</a><br><a href="https://bgm.tv/subject/301541">トニカクカワイイ</a><br><a href="https://bgm.tv/subject/909">とらドラ!</a><br><a href="https://bgm.tv/subject/327055">死神坊ちゃんと黒メイド</a><br><a href="https://bgm.tv/subject/349319">死神坊ちゃんと黒メイド 第2期</a><br><a href="https://bgm.tv/subject/343656">阿波連さんははかれない</a><br><a href="https://bgm.tv/subject/100449">月刊少女野崎くん</a><br><a href="https://bgm.tv/subject/40533">となりの怪物くん</a><br><a href="https://bgm.tv/subject/271145">理系が恋に落ちたので証明してみた</a><br><a href="https://bgm.tv/subject/317042">理系が恋に落ちたので証明してみた。r&#x3D;1-sinθ</a><br><a href="https://bgm.tv/subject/332446">恋は世界征服のあとで</a><br><a href="https://bgm.tv/subject/207573">月がきれい</a><br><a href="https://bgm.tv/subject/208754">徒然チルドレン</a><br><a href="https://bgm.tv/subject/55113">たまこまーけっと</a><br><a href="https://bgm.tv/subject/90880">たまこラブストーリー</a><br><a href="https://bgm.tv/subject/48034">琴浦さん</a><br><a href="https://bgm.tv/subject/27364">氷菓</a><br><a href="https://bgm.tv/subject/309670">先輩がうざい後輩の話</a><br><a href="https://bgm.tv/subject/100444">四月は君の嘘</a><br><a href="https://bgm.tv/subject/114685">プラスティック・メモリーズ</a><br><a href="https://bgm.tv/subject/172498">エロマンガ先生</a><br><a href="https://bgm.tv/subject/356774">よふかしのうた</a><br><a href="https://bgm.tv/subject/375735">恋愛フロップス</a><br><a href="https://bgm.tv/subject/343106">継母の連れ子が元カノだった</a><br><a href="https://bgm.tv/subject/375817">Engage Kiss</a><br><a href="https://bgm.tv/subject/324295">可愛いだけじゃない式守さん</a><br><a href="https://bgm.tv/subject/333158">その着せ替え人形は恋をする</a><br><a href="https://bgm.tv/subject/194877">月曜日のたわわ</a><br><a href="https://bgm.tv/subject/349616">月曜日のたわわ2</a><br><a href="https://bgm.tv/subject/346242">がんばれ同期ちゃん</a><br><a href="https://bgm.tv/subject/295778">ジョゼと虎と魚たち</a><br><a href="https://bgm.tv/subject/117777">聲の形</a><br><a href="https://bgm.tv/subject/221736">君の膵臓をたべたい</a><br><a href="https://bgm.tv/subject/363308">ツンデレ悪役令嬢リーゼロッテと実況の遠藤くんと解説の小林さん</a><br><a href="https://bgm.tv/subject/390618">トモちゃんは女の子!</a><br><a href="https://bgm.tv/subject/49278">境界の彼方</a><br><a href="https://bgm.tv/subject/118908">境界の彼方 -I’LL BE HERE- 未来篇</a><br><a href="https://bgm.tv/subject/221293">ネト充のススメ</a><br><a href="https://bgm.tv/subject/394260">僕の心のヤバイやつ</a><br><a href="https://bgm.tv/subject/365437">君は放課後インソムニア</a><br><a href="https://bgm.tv/subject/253628">ドメスティックな彼女</a><br><a href="https://bgm.tv/subject/174143">クズの本懐</a><br><a href="https://bgm.tv/subject/315069">ホリミヤ</a><br><a href="https://bgm.tv/subject/45842">変態王子と笑わない猫。</a><br><a href="https://bgm.tv/subject/100403">冴えない彼女の育てかた</a><br><a href="https://bgm.tv/subject/132734">冴えない彼女の育てかた ♭</a><br><a href="https://bgm.tv/subject/231497">冴えない彼女の育てかた Fine</a><br><a href="https://bgm.tv/subject/278557">空の青さを知る人よ</a><br><a href="https://bgm.tv/subject/119344">心が叫びたがってるんだ。</a><br><a href="https://bgm.tv/subject/319513">カノジョも彼女</a><br><a href="https://bgm.tv/subject/208450">アホガール</a></p><h3 id="轻百："><a href="#轻百：" class="headerlink" title="轻百："></a>轻百：</h3><h5 id="京吹："><a href="#京吹：" class="headerlink" title="京吹："></a>京吹：</h5><p><a href="https://bgm.tv/subject/115908">響け！ユーフォニアム</a><br><a href="https://bgm.tv/subject/152091">響け！ユーフォニアム2</a><br><a href="https://bgm.tv/subject/216372">劇場版 響け！ユーフォニアム～誓いのフィナーレ～</a><br><a href="https://bgm.tv/subject/386195">特別編 響け！ユーフォニアム～アンサンブルコンテスト～</a><br><a href="https://bgm.tv/subject/216371">リズと青い鳥</a></p><h5 id="少歌："><a href="#少歌：" class="headerlink" title="少歌："></a>少歌：</h5><p><a href="https://bgm.tv/subject/214265">少女☆歌劇 レヴュースタァライト</a><br><a href="https://bgm.tv/subject/294135">劇場版 少女☆歌劇 レヴュースタァライト</a></p><h5 id="轻音："><a href="#轻音：" class="headerlink" title="轻音："></a>轻音：</h5><p><a href="https://bgm.tv/subject/1424">けいおん!</a><br><a href="https://bgm.tv/subject/3774">けいおん!!</a><br><a href="https://bgm.tv/subject/12426">映画 けいおん!</a></p><h5 id="default：-2"><a href="#default：-2" class="headerlink" title="default："></a>default：</h5><p><a href="https://bgm.tv/subject/328609">ぼっち・ざ・ろっく!</a><br><a href="https://bgm.tv/subject/9717">魔法少女まどか☆マギカ</a><br><a href="https://bgm.tv/subject/241158">となりの吸血鬼さん</a><br><a href="https://bgm.tv/subject/179949">小林さんちのメイドラゴン</a><br><a href="https://bgm.tv/subject/274234">小林さんちのメイドラゴンS</a><br><a href="https://bgm.tv/subject/364450">リコリス・リコイル</a><br><a href="https://bgm.tv/subject/292970">魔女の旅々</a><br><a href="https://bgm.tv/subject/188091">ガヴリールドロップアウト</a><br><a href="https://bgm.tv/subject/193282">にゃんこデイズ</a><br><a href="https://bgm.tv/subject/376565">4人はそれぞれウソをつく</a><br><a href="https://bgm.tv/subject/395714">転生王女と天才令嬢の魔法革命</a><br><a href="https://bgm.tv/subject/378862">お兄ちゃんはおしまい！</a><br><a href="https://bgm.tv/subject/276187">ソウナンですか？</a><br><a href="https://bgm.tv/subject/428735">BanG Dream! It’s MyGO!!!!!</a><br><a href="https://bgm.tv/subject/400551">でこぼこ魔女の親子事情</a></p><h3 id="EVA"><a href="#EVA" class="headerlink" title="EVA:"></a>EVA:</h3><p><a href="https://bgm.tv/subject/265">新世紀エヴァンゲリオン</a><br><a href="https://bgm.tv/subject/6048">新世紀エヴァンゲリオン劇場版 シト新生</a><br><a href="https://bgm.tv/subject/6049">新世紀エヴァンゲリオン劇場版 Air&#x2F;まごころを、君に</a><br><a href="https://bgm.tv/subject/772">ヱヴァンゲリヲン新劇場版:序</a><br><a href="https://bgm.tv/subject/3302">ヱヴァンゲリヲン新劇場版:破</a><br><a href="https://bgm.tv/subject/22505">ヱヴァンゲリヲン新劇場版:Q</a><br><a href="https://bgm.tv/subject/29883">シン・エヴァンゲリオン劇場版:│▌</a></p><h3 id="进击的巨人"><a href="#进击的巨人" class="headerlink" title="进击的巨人"></a>进击的巨人</h3><p><a href="https://bgm.tv/subject/55770">進撃の巨人</a><br><a href="https://bgm.tv/subject/118335">進撃の巨人 Season 2</a><br><a href="https://bgm.tv/subject/217300">進撃の巨人 Season 3</a><br><a href="https://bgm.tv/subject/285666">進撃の巨人 The Final Season</a><br><a href="https://bgm.tv/subject/376739">進撃の巨人 The Final Season 完結編</a></p><h3 id="魔禁系列："><a href="#魔禁系列：" class="headerlink" title="魔禁系列："></a>魔禁系列：</h3><p><a href="https://bgm.tv/subject/1014">とある魔術の禁書目録</a><br><a href="https://bgm.tv/subject/7843">とある魔術の禁書目録Ⅱ</a><br><a href="https://bgm.tv/subject/226540">とある魔術の禁書目録Ⅲ</a><br><a href="https://bgm.tv/subject/26804">とある魔術の禁書目録 エンデュミオンの奇蹟</a><br><a href="https://bgm.tv/subject/2585">とある科学の超電磁砲</a><br><a href="https://bgm.tv/subject/51928">とある科学の超電磁砲S</a><br><a href="https://bgm.tv/subject/262940">とある科学の超電磁砲T</a><br><a href="https://bgm.tv/subject/262939">とある科学の一方通行</a></p><h3 id="鲁邦："><a href="#鲁邦：" class="headerlink" title="鲁邦："></a>鲁邦：</h3><p><a href="https://bgm.tv/subject/115661">ルパン三世 PART4</a><br><a href="https://bgm.tv/subject/219164">ルパン三世 PART5</a><br><a href="https://bgm.tv/subject/337430">ルパン三世 PART6</a><br><a href="https://bgm.tv/subject/100437">LUPIN THE IIIRD 次元大介の墓標</a><br><a href="https://bgm.tv/subject/36355">LUPIN the Third ～峰不二子という女～</a><br><a href="https://bgm.tv/subject/192442">LUPIN THE IIIRD 血煙の石川五ェ門</a><br><a href="https://bgm.tv/subject/286238">ルパン三世 THE FIRST</a><br><a href="https://bgm.tv/subject/405990">LUPIN ZERO ルパンゼロ</a><br><a href="https://bgm.tv/subject/314">ルパン三世 カリオストロの城</a></p><h3 id="鲁鲁修："><a href="#鲁鲁修：" class="headerlink" title="鲁鲁修："></a>鲁鲁修：</h3><p><a href="https://bgm.tv/subject/793">コードギアス 反逆のルルーシュ</a><br><a href="https://bgm.tv/subject/8">コードギアス 反逆のルルーシュR2</a><br><a href="https://bgm.tv/subject/199228">コードギアス 復活のルルーシュ</a></p><h3 id="Love-Live-："><a href="#Love-Live-：" class="headerlink" title="Love Live!："></a>Love Live!：</h3><p><a href="https://bgm.tv/subject/49294">ラブライブ!</a><br><a href="https://bgm.tv/subject/75989">ラブライブ! 第2期</a><br><a href="https://bgm.tv/subject/107199">ラブライブ! The School Idol Movie</a><br><a href="https://bgm.tv/subject/165553">ラブライブ! サンシャイン!!</a><br><a href="https://bgm.tv/subject/210272">ラブライブ! サンシャイン!! 第2期</a><br><a href="https://bgm.tv/subject/234295">ラブライブ!サンシャイン!! The School Idol Movie Over the Rainbow</a><br><a href="https://bgm.tv/subject/389772">幻日のヨハネ -SUNSHINE in the MIRROR-</a><br><a href="https://bgm.tv/subject/296659">ラブライブ！虹ヶ咲学園スクールアイドル同好会</a><br><a href="https://bgm.tv/subject/335579">ラブライブ！虹ヶ咲学園スクールアイドル同好会 2期</a><br><a href="https://bgm.tv/subject/408883">ラブライブ！虹ヶ咲学園スクールアイドル同好会 NEXT SKY</a><br><a href="https://bgm.tv/subject/401960">にじよん あにめーしょん</a><br><a href="https://bgm.tv/subject/306742">ラブライブ！スーパースター!!</a><br><a href="https://bgm.tv/subject/376703">アイドルマスター シンデレラガールズ U149</a></p><h3 id="少战："><a href="#少战：" class="headerlink" title="少战："></a>少战：</h3><p><a href="https://bgm.tv/subject/40310">ガールズ&amp;パンツァー</a><br><a href="https://bgm.tv/subject/72266">ガールズ&amp;パンツァー 劇場版</a><br><a href="https://bgm.tv/subject/191302">ガールズ&amp;パンツァー 最終章 第1話</a><br><a href="https://bgm.tv/subject/208825">ガールズ&amp;パンツァー 最終章 第2話</a><br><a href="https://bgm.tv/subject/208826">ガールズ&amp;パンツァー 最終章 第3話</a><br><a href="https://bgm.tv/subject/208827">ガールズ&amp;パンツァー 最終章 第4話</a></p><h3 id="美漫"><a href="#美漫" class="headerlink" title="美漫"></a>美漫</h3><p><a href="https://bgm.tv/subject/93377">Rick and Morty Season 1~6</a><br><a href="https://bgm.tv/subject/406268">Family Guy Season 1~15</a><br><a href="https://bgm.tv/subject/19889">The Simpsons Season 1~31</a></p><h3 id="JOJO"><a href="#JOJO" class="headerlink" title="JOJO:"></a>JOJO:</h3><p><a href="https://bgm.tv/subject/43558">ジョジョの奇妙な冒険</a><br><a href="https://bgm.tv/subject/85631">ジョジョの奇妙な冒険 スターダストクルセイダース</a><br><a href="https://bgm.tv/subject/113292">ジョジョの奇妙な冒険 スターダストクルセイダース</a><br><a href="https://bgm.tv/subject/150490">ジョジョの奇妙な冒険 ダイヤモンドは砕けない</a><br><a href="https://bgm.tv/subject/235128">ジョジョの奇妙な冒険 黄金の風</a><br><a href="https://bgm.tv/subject/332261">ジョジョの奇妙な冒険 ストーンオーシャン</a><br><a href="https://bgm.tv/subject/375913">ジョジョの奇妙な冒険 ストーンオーシャン 第2クール</a><br><a href="https://bgm.tv/subject/395782">ジョジョの奇妙な冒険 ストーンオーシャン 第3クール</a><br><a href="https://bgm.tv/subject/289138">岸辺露伴は動かない</a></p><h3 id="民工漫："><a href="#民工漫：" class="headerlink" title="民工漫："></a>民工漫：</h3><p><a href="https://bgm.tv/subject/247">銀魂 全季度</a><br><a href="https://bgm.tv/subject/1600">BLEACH</a><br><a href="https://bgm.tv/subject/302286">BLEACH 千年血戦篇</a><br><a href="https://bgm.tv/subject/412916">BLEACH 千年血戦篇-訣別譚-</a><br><a href="https://bgm.tv/subject/34373">NARUTO -ナルト-</a><br><a href="https://bgm.tv/subject/351712">名探偵コナン 犯人の犯沢さん</a><br><a href="https://bgm.tv/subject/2784">犬夜叉</a><br><a href="https://bgm.tv/subject/28496">NARUTO-ナルト- SD ロック・リーの青春フルパワー忍伝</a><br><a href="https://bgm.tv/subject/411246">ポケットモンスター めざせポケモンマスター</a><br><a href="https://bgm.tv/subject/364468">うる星やつら</a><br><a href="https://bgm.tv/subject/294993">呪術廻戦</a><br><a href="https://bgm.tv/subject/369304">呪術廻戦 第2期</a><br><a href="https://bgm.tv/subject/331559">劇場版 呪術廻戦 0</a><br><a href="https://bgm.tv/subject/402128">Fate&#x2F;strange Fake -Whispers of Dawn-</a></p><h3 id="日常番："><a href="#日常番：" class="headerlink" title="日常番："></a>日常番：</h3><p><a href="https://bgm.tv/subject/9912">日常</a><br><a href="https://bgm.tv/subject/24790">男子高校生の日常</a><br><a href="https://bgm.tv/subject/265708">女子高生の無駄づかい</a><br><a href="https://bgm.tv/subject/235130">ぐらんぶる</a><br><a href="https://bgm.tv/subject/165829">坂本ですが？</a><br><a href="https://bgm.tv/subject/204145">ブレンド・S </a><br><a href="https://bgm.tv/subject/127563">ワンパンマン</a><br><a href="https://bgm.tv/subject/193619">ワンパンマン 第2期</a><br><a href="https://bgm.tv/subject/333664">であいもん</a><br><a href="https://bgm.tv/subject/387803">江戸前エルフ</a><br><a href="https://bgm.tv/subject/5649">生徒会役員共+OAD+OVA</a><br><a href="https://bgm.tv/subject/85204">生徒会役員共*+OAD+OVA</a><br><a href="https://bgm.tv/subject/200887">劇場版 生徒会役員共</a><br><a href="https://bgm.tv/subject/295918">劇場版 生徒会役員共2</a><br><a href="https://bgm.tv/subject/120187">干物妹! うまるちゃん</a><br><a href="https://bgm.tv/subject/212775">干物妹! うまるちゃんR</a><br><a href="https://bgm.tv/subject/80548">ディーふらぐ!</a><br><a href="https://bgm.tv/subject/414461">ゾン100～ゾンビになるまでにしたい100のこと～</a><br><a href="https://bgm.tv/subject/384672">デキる猫は今日も憂鬱</a><br><a href="https://bgm.tv/subject/294991">どうにかなる日々</a><br>[斉木楠雄のΨ難](<a href="https://bgm.tv/subject/181354">https://bgm.tv/subject/181354</a> “)<br><a href="https://bgm.tv/subject/204027">斉木楠雄のΨ難 第2期</a><br><a href="https://bgm.tv/subject/251831">斉木楠雄のΨ難 完結編</a><br><a href="https://bgm.tv/subject/278899">斉木楠雄のΨ難 Ψ始動編</a><br><a href="https://bgm.tv/subject/69214">私がモテないのはどう考えてもお前らが悪い!</a></p><h3 id="default"><a href="#default" class="headerlink" title="default:"></a>default:</h3><h5 id="国创："><a href="#国创：" class="headerlink" title="国创："></a>国创：</h5><p><a href="https://bgm.tv/subject/29399">围棋少年</a><br><a href="https://bgm.tv/subject/23446">Q版三国</a><br><a href="https://bgm.tv/subject/358660">中国奇谭</a><br><a href="https://bgm.tv/subject/151101">深海</a></p><h5 id="间谍过家家："><a href="#间谍过家家：" class="headerlink" title="间谍过家家："></a>间谍过家家：</h5><p><a href="https://bgm.tv/subject/329906">SPY×FAMILY</a><br><a href="https://bgm.tv/subject/373267">SPY×FAMILY 第2クール</a></p><h5 id="赛马娘："><a href="#赛马娘：" class="headerlink" title="赛马娘："></a>赛马娘：</h5><p><a href="https://bgm.tv/subject/212003">ウマ娘 プリティーダービー</a><br><a href="https://bgm.tv/subject/315574">ウマ娘 プリティーダービー Season 2</a></p><h5 id="狂赌之渊："><a href="#狂赌之渊：" class="headerlink" title="狂赌之渊："></a>狂赌之渊：</h5><p><a href="https://bgm.tv/subject/209408">賭ケグルイ</a><br><a href="https://bgm.tv/subject/234778">賭ケグルイ××</a><br><a href="https://bgm.tv/subject/356658">賭ケグルイ双</a></p><h5 id="鬼灭："><a href="#鬼灭：" class="headerlink" title="鬼灭："></a>鬼灭：</h5><p><a href="https://bgm.tv/subject/245665">鬼滅の刃</a><br><a href="https://bgm.tv/subject/291494">劇場版 鬼滅の刃 無限列車編</a><br><a href="https://bgm.tv/subject/328195">鬼滅の刃 遊郭編</a><br><a href="https://bgm.tv/subject/369768">鬼滅の刃 刀鍛冶の里編</a></p><h5 id="极主夫道："><a href="#极主夫道：" class="headerlink" title="极主夫道："></a>极主夫道：</h5><p><a href="https://bgm.tv/subject/317691">極主夫道</a><br><a href="https://bgm.tv/subject/332696">極主夫道 パート2</a><br><a href="https://bgm.tv/subject/402740">極主夫道 シーズン2</a></p><h5 id="人类痛经："><a href="#人类痛经：" class="headerlink" title="人类痛经："></a>人类痛经：</h5><p><a href="https://bgm.tv/subject/212279">ポプテピピック</a><br><a href="https://bgm.tv/subject/363600">ポプテピピック TVアニメーション作品第二シリーズ</a></p><h5 id="动物狂想曲："><a href="#动物狂想曲：" class="headerlink" title="动物狂想曲："></a>动物狂想曲：</h5><p><a href="https://bgm.tv/subject/273843">BEASTARS</a><br><a href="https://bgm.tv/subject/297224">BEASTARS 2nd Season</a></p><h5 id="虚构推理："><a href="#虚构推理：" class="headerlink" title="虚构推理："></a>虚构推理：</h5><p><a href="https://bgm.tv/subject/271687">虚構推理</a><br><a href="https://bgm.tv/subject/320839">虚構推理 Season2</a></p><h5 id="逆天："><a href="#逆天：" class="headerlink" title="逆天："></a>逆天：</h5><p><a href="https://bgm.tv/subject/182341">おなら吾郎</a><br><a href="https://bgm.tv/subject/37567">悪いのを倒せ！！サラリーマンマン</a><br><a href="https://bgm.tv/subject/389450">アキバ冥途戦争</a><br><a href="https://bgm.tv/subject/110048">監獄学園</a></p><h5 id="default：-3"><a href="#default：-3" class="headerlink" title="default："></a>default：</h5><p><a href="https://bgm.tv/subject/1773">DEATH NOTE</a><br><a href="https://bgm.tv/subject/88433">寄生獣 セイの格率</a><br><a href="https://bgm.tv/subject/218453">伊藤潤二『コレクション』</a><br><a href="https://bgm.tv/subject/384280">伊藤潤二『マニアック』</a><br><a href="https://bgm.tv/subject/240838">どろろ</a><br><a href="https://bgm.tv/subject/297022">憂国のモリアーティ</a><br><a href="https://bgm.tv/subject/319252">憂国のモリアーティ 2クール目</a><br><a href="https://bgm.tv/subject/347818">憂国のモリアーティ～百合の追憶～</a><br><a href="https://bgm.tv/subject/1959">MONSTER</a><br><a href="https://bgm.tv/subject/158316">モブサイコ100</a><br><a href="https://bgm.tv/subject/240760">モブサイコ100 Ⅱ</a><br><a href="https://bgm.tv/subject/353605">モブサイコ100 Ⅲ</a><br><a href="https://bgm.tv/subject/325285">オッドタクシー</a><br><a href="https://bgm.tv/subject/316607">ワンダーエッグ・プライオリティ</a><br><a href="https://bgm.tv/subject/37785">新世界より</a><br><a href="https://bgm.tv/subject/326895">サマータイムレンダ</a><br><a href="https://bgm.tv/subject/90597">トモダチゲーム</a><br><a href="https://bgm.tv/subject/321885">チェンソーマン</a><br><a href="https://bgm.tv/subject/193378">サクラダリセット</a><br><a href="https://bgm.tv/subject/10440">あの日見た花の名前を僕達はまだ知らない</a><br><a href="https://bgm.tv/subject/223563">映画大好きポンポさん</a><br><a href="https://bgm.tv/subject/965">BACCANO! -バッカーノ!-</a><br><a href="https://bgm.tv/subject/294713">かくしごと</a><br><a href="https://bgm.tv/subject/356756">パリピ孔明</a><br><a href="https://bgm.tv/subject/249637">私に天使が舞い降りた！</a><br><a href="https://bgm.tv/subject/320493">私に天使が舞い降りた！プレシャス・フレンズ</a><br><a href="https://bgm.tv/subject/309311">Cyberpunk: Edgerunners</a><br><a href="https://bgm.tv/subject/20851">Another</a><br><a href="https://bgm.tv/subject/335036">Arcane</a><br><a href="https://bgm.tv/subject/22759">花咲くいろは</a><br><a href="https://bgm.tv/subject/49892">劇場版 花咲くいろは HOME SWEET HOME</a><br><a href="https://bgm.tv/subject/289">ひぐらしのなく頃に</a><br><a href="https://bgm.tv/subject/325808">地獄楽</a><br><a href="https://bgm.tv/subject/404804">天国大魔境</a><br><a href="https://bgm.tv/subject/388067">マイホームヒーロー</a><br><a href="https://bgm.tv/subject/3892">逆境無頼カイジ Ultimate Survivor </a><br><a href="https://bgm.tv/subject/12317">逆境無頼カイジ 破戒録篇</a><br><a href="https://bgm.tv/subject/311">千と千尋の神隠し</a><br><a href="https://bgm.tv/subject/310">もののけ姫</a><br><a href="https://bgm.tv/subject/307">紅の豚</a><br><a href="https://bgm.tv/subject/386809">【推しの子】</a><br> <a href="https://bgm.tv/subject/82572">ノラガミ</a><br><a href="https://bgm.tv/subject/129988">ノラガミ ARAGOTO</a><br><a href="https://bgm.tv/subject/302189">86―エイティシックス―</a><br><a href="https://bgm.tv/subject/331887">86―エイティシックス― 第2クール</a><br><a href="https://bgm.tv/subject/425937">終末のワルキューレⅡ 後編</a><br><a href="https://bgm.tv/subject/346982">終末のワルキューレⅡ 前編</a><br><a href="https://bgm.tv/subject/322900">終末のワルキューレ</a><br><a href="https://bgm.tv/subject/62893">グラップラー刃牙</a><br><a href="https://bgm.tv/subject/317852">範馬刃牙</a><br><a href="https://bgm.tv/subject/375541">範馬刃牙 2期</a><br><a href="https://bgm.tv/subject/199373">バキ</a><br><a href="https://bgm.tv/subject/278202">バキ 大擂台賽編</a><br><a href="https://bgm.tv/subject/10380">STEINS;GATE</a><br><a href="https://bgm.tv/subject/93545">甘城ブリリアントパーク</a><br><a href="https://bgm.tv/subject/373390">HIGH CARD</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>高达</title>
    <link href="/2023/03/12/GUNPLA/"/>
    <url>/2023/03/12/GUNPLA/</url>
    
    <content type="html"><![CDATA[<hr><span id="more"></span><h1 id="GUNPLA"><a href="#GUNPLA" class="headerlink" title="GUNPLA"></a>GUNPLA</h1><h2 id="BANDAI"><a href="#BANDAI" class="headerlink" title="BANDAI"></a>BANDAI</h2><h3 id="PB-HGUC-1-x2F-144-MS-06F-多安专用扎古"><a href="#PB-HGUC-1-x2F-144-MS-06F-多安专用扎古" class="headerlink" title="PB HGUC 1&#x2F;144 MS-06F 多安专用扎古"></a>PB HGUC 1&#x2F;144 MS-06F 多安专用扎古</h3><p>购入价格：115（2200日元发售）<br>真男人机体，外甲部分新规，自带战损，相当于扎古I和扎古II的结合体（省下了买GTO扎古I和扎古II的钱），废件过多（高情商：可还原GTO扎古II）按照万代按重量定价的尿性，血亏。组合度和可动优秀。<br><img src="/../GUNDAM/duoan.jpg"></p><h3 id="MG-ASW-G-08-巴巴托斯第四形态"><a href="#MG-ASW-G-08-巴巴托斯第四形态" class="headerlink" title="MG ASW-G-08 巴巴托斯第四形态"></a>MG ASW-G-08 巴巴托斯第四形态</h3><p>购入价格：205（4500日元发售）<br>铁血的机设比较合胃口，液压管骨架结构很戳人，能和rg牛掰手腕的19年最佳拼装</p><h3 id="HG-TWFM-01-XGF-02-魔灵高达"><a href="#HG-TWFM-01-XGF-02-魔灵高达" class="headerlink" title="HG TWFM 01 XGF-02 魔灵高达"></a>HG TWFM 01 XGF-02 魔灵高达</h3><p>购入价格：79（1600日元发售）<br>在番剧热映期间五算购入主角机实属不易，分色优秀，细节刻画优秀，感受到了万代的技术进步</p><h3 id="HG-1-x2F-144-RX-78-2-超越全球元祖"><a href="#HG-1-x2F-144-RX-78-2-超越全球元祖" class="headerlink" title="HG 1&#x2F;144 RX-78-2 超越全球元祖"></a>HG 1&#x2F;144 RX-78-2 超越全球元祖</h3><p> 购入价格：66 （2 000日元发售价）<br> 组合度优秀，可动性极度优秀，非常值得入手<br><img src="/../GUNDAM/rx1.jpg"><img src="/../GUNDAM/rx2.jpg"><br><img src="/../GUNDAM/rx3.jpg"><img src="/../GUNDAM/rx4.jpg"></p><h3 id="HGCE-1-x2F-144-ZGMF-0X19A-无限正义-新生版"><a href="#HGCE-1-x2F-144-ZGMF-0X19A-无限正义-新生版" class="headerlink" title="HGCE 1&#x2F;144 ZGMF-0X19A 无限正义 新生版"></a>HGCE 1&#x2F;144 ZGMF-0X19A 无限正义 新生版</h3><p>购入价格：95 （2 200日元发售价）<br>最佳hg，分色优秀，枪上的贴纸是作为hg最后的倔强，可动优秀，组合度优秀。<br><img src="/../GUNDAM/jst3.jpg"><br><img src="/../GUNDAM/jst2.jpg"></p><h3 id="HGUC-1-x2F-144-MSM-07S-夏亚专用魔蟹"><a href="#HGUC-1-x2F-144-MSM-07S-夏亚专用魔蟹" class="headerlink" title="HGUC 1&#x2F;144 MSM-07S 夏亚专用魔蟹"></a>HGUC 1&#x2F;144 MSM-07S 夏亚专用魔蟹</h3><p>购入价格：34 （700日元发售价）<br>组合度一般，可动性优秀，由于关节多的原因能倒立，值得入手，吉翁水产谁不爱呢<br><img src="/../GUNDAM/red2.jpg"><br><img src="/../GUNDAM/red4.jpg"></p><h3 id="HGUC-1-x2F-144-MSM-04-龟霸"><a href="#HGUC-1-x2F-144-MSM-04-龟霸" class="headerlink" title="HGUC 1&#x2F;144 MSM-04 龟霸"></a>HGUC 1&#x2F;144 MSM-04 龟霸</h3><p> 购入价格：60（1400日元发售）<br> 组合度优秀，内构优秀，值得入手，龟霸可爱捏</p><h3 id="HGUC-1-x2F-144-MSM-07E-实验型魔蟹E"><a href="#HGUC-1-x2F-144-MSM-07E-实验型魔蟹E" class="headerlink" title="HGUC 1&#x2F;144 MSM-07E 实验型魔蟹E"></a>HGUC 1&#x2F;144 MSM-07E 实验型魔蟹E</h3><p>购入价格： 48（1200日元发售价）<br>组合度拉垮，可动性拉垮，分色优秀，价格低不是没有原因的，0080情怀产品，谁叫口袋里的战争是鼠鼠最喜欢的一部呢</p><h3 id="MICRO-WARS-食玩-吉姆"><a href="#MICRO-WARS-食玩-吉姆" class="headerlink" title="MICRO WARS 食玩 吉姆"></a>MICRO WARS 食玩 吉姆</h3><p>购入价格：21（发售价500日元）<br>大腿致命偷胶，部分需补色，相比hg更喜欢三头身的</p><h3 id="MICRO-WARS-食玩-老虎"><a href="#MICRO-WARS-食玩-老虎" class="headerlink" title="MICRO WARS 食玩 老虎"></a>MICRO WARS 食玩 老虎</h3><p>购入价格：21（发售价500日元）<br>大腿致命偷胶，部分需补色，相比hg更喜欢三头身的</p><h3 id="HG-Amplified-IMGN-龙神丸"><a href="#HG-Amplified-IMGN-龙神丸" class="headerlink" title="HG Amplified IMGN 龙神丸"></a>HG Amplified IMGN 龙神丸</h3><p>购入价格： 113（5000 日元发售）<br>组合度优秀，可动良好，极致の金属色表现！版件质感很好，有种自带消光&#x2F;光油的感觉，电镀部分容易被腐蚀，发售价偏贵，3算不到入的话还挺不错，也算还童年债了</p><h3 id="EVA-FRAME-食玩-3号机-8号机"><a href="#EVA-FRAME-食玩-3号机-8号机" class="headerlink" title="EVA  FRAME 食玩 3号机+8号机"></a>EVA  FRAME 食玩 3号机+8号机</h3><p>购入价格： 128（5盒+1枪）（590日元单盒发售价）<br>组合度优秀，可动优秀，有完整骨架与外甲，可玩性丰富，万代良心产品,可以做出鬼畜姿势（</p><p><img src="/../GUNDAM/eva_8.jpg"><br><img src="/../GUNDAM/eva_8_1.jpg"><br><img src="/../GUNDAM/eva_8_2.jpg"><br><img src="/../GUNDAM/eva_8_3.jpg"></p><h3 id="EG-PAC-MAN-吃豆人"><a href="#EG-PAC-MAN-吃豆人" class="headerlink" title="EG PAC-MAN 吃豆人"></a>EG PAC-MAN 吃豆人</h3><p>购入价格 ： 26（1 000日元发售）<br>组合度一般，可动性良好，比较好玩<br><img src="/../GUMDAM/../GUNDAM/PAC1.jpg"><br><img src="/../GUNDAM/PAC.jpg"></p><h3 id="宝可梦快拼-PLAMO-04-伊布"><a href="#宝可梦快拼-PLAMO-04-伊布" class="headerlink" title="宝可梦快拼 PLAMO 04 伊布"></a>宝可梦快拼 PLAMO 04 伊布</h3><p>购入价格：15（500日元发售）<br>可爱捏</p><h3 id="宝可梦快拼-PLAMO-08-迷拟Q"><a href="#宝可梦快拼-PLAMO-08-迷拟Q" class="headerlink" title="宝可梦快拼 PLAMO 08 迷拟Q"></a>宝可梦快拼 PLAMO 08 迷拟Q</h3><p>购入价格： 25 （500日元发售）<br>组合度优秀，可动性无，可爱捏<br><img src="/../GUMDAM/../GUNDAM/Q.jpg"></p><h3 id="MSE-重装重奏-MSM-04-龟霸"><a href="#MSE-重装重奏-MSM-04-龟霸" class="headerlink" title="MSE 重装重奏 MSM-04 龟霸"></a>MSE 重装重奏 MSM-04 龟霸</h3><p>购入价格 ： 28（500日元随机扭蛋发售）<br>组合读拉垮，有缩胶，基本无可动，手部有替换件，可爱的捏<br><img src="/../GUNDAM/qb1.jpg"><img src="/../GUNDAM/qb2.jpg"></p><h3 id="Petitrits-尼禄·克劳狄乌斯-Caster"><a href="#Petitrits-尼禄·克劳狄乌斯-Caster" class="headerlink" title="Petitrits 尼禄·克劳狄乌斯 Caster"></a>Petitrits 尼禄·克劳狄乌斯 Caster</h3><p>购入价格 ： 3（1400日元发售）<br>券前23的价格很不错的豆丁魂。按发售价的话就是冤大头了</p><h3 id="三国传-10周年特典-玉玺"><a href="#三国传-10周年特典-玉玺" class="headerlink" title="三国传 10周年特典 玉玺"></a>三国传 10周年特典 玉玺</h3><p>购入价格： 12<br>还可以，主打一个情怀</p><h2 id="DABAN"><a href="#DABAN" class="headerlink" title="DABAN"></a>DABAN</h2><h3 id="PG-1-x2F-60-MBF-02-AQM-x2F-E-X01-嫣红强袭-空中霸王"><a href="#PG-1-x2F-60-MBF-02-AQM-x2F-E-X01-嫣红强袭-空中霸王" class="headerlink" title="PG 1&#x2F;60 MBF-02+AQM&#x2F;E+X01 嫣红强袭+空中霸王"></a>PG 1&#x2F;60 MBF-02+AQM&#x2F;E+X01 嫣红强袭+空中霸王</h3><p>购入价格：253<br>比较划算的pg，内构细节丰富，联动丰富，万代的里程碑产品，兼备内构、联动与外设。但是优点全是万代的，组合度一般，可动优秀。</p><h3 id="MB式样-1-x2F-100-8802-ZGMF-X20A-强袭自由"><a href="#MB式样-1-x2F-100-8802-ZGMF-X20A-强袭自由" class="headerlink" title="MB式样 1&#x2F;100 8802 ZGMF- X20A 强袭自由"></a>MB式样 1&#x2F;100 8802 ZGMF- X20A 强袭自由</h3><p>购入价格： 127<br>经典大班科目二，组合度比初版好些但还是拉垮，头部等巨缝使用分子料理，外观很不错<br><img src="/../GUNDAM/8802_1.jpg"><br><img src="/../GUNDAM/8802_2.jpg"></p><h3 id="MB式样-1-x2F-100-8804-MBF-P01-Re2-金异端天蜜娜"><a href="#MB式样-1-x2F-100-8804-MBF-P01-Re2-金异端天蜜娜" class="headerlink" title="MB式样 1&#x2F;100  8804 MBF-P01-Re2 金异端天蜜娜"></a>MB式样 1&#x2F;100  8804 MBF-P01-Re2 金异端天蜜娜</h3><p>购入价格：155（初三入的，历史悠久）<br>组合度地狱，可动性地狱，背包过重，站尸没问题，外观好看,似乎已绝版<br><img src="/../GUNDAM/tianmina1.jpg"><img src="/../GUNDAM/tianmina2.jpg"><br><img src="/../GUNDAM/tianmina3.jpg"></p><h3 id="MB式样-1-x2F-100-8821-F91"><a href="#MB式样-1-x2F-100-8821-F91" class="headerlink" title="MB式样 1&#x2F;100 8821 F91"></a>MB式样 1&#x2F;100 8821 F91</h3><p>购入价格：101<br>本体组合度优秀，武器组合度地狱，极度需要搭配三红水贴。<br><img src="/../GUNDAM/F91.jpg"><br><img src="/../GUNDAM/F91_!.jpg"></p><h3 id="MG-1-x2F-100-老6601-MBF-P01KAI-红异端改"><a href="#MG-1-x2F-100-老6601-MBF-P01KAI-红异端改" class="headerlink" title="MG 1&#x2F;100  老6601 MBF-P01KAI 红异端改"></a>MG 1&#x2F;100  老6601 MBF-P01KAI 红异端改</h3><p>购入价格 ：70（初中入的）<br>入坑作，地狱难度，组合地狱可动地狱掉件地狱，现在只剩下个尸体，能站着就不错了<br><img src="/../GUNDAM/Red.jpg"></p><h3 id="MG-1-x2F-100-6619-Ka版-限定版-RX-93-牛高达-中国限定配色"><a href="#MG-1-x2F-100-6619-Ka版-限定版-RX-93-牛高达-中国限定配色" class="headerlink" title="MG 1&#x2F;100 6619 Ka版 限定版 RX-93 牛高达 中国限定配色"></a>MG 1&#x2F;100 6619 Ka版 限定版 RX-93 牛高达 中国限定配色</h3><p>购入价格： 130<br>降价入的还算不错，本体组合度优秀，武器浮游炮组合度拉垮，内构丰富<br><img src="/../GUNDAM/v.jpg"></p><h3 id="MG-1-x2F-100-6642-RX-0-独角兽三号机菲尼克斯"><a href="#MG-1-x2F-100-6642-RX-0-独角兽三号机菲尼克斯" class="headerlink" title="MG 1&#x2F;100 6642 RX-0  独角兽三号机菲尼克斯"></a>MG 1&#x2F;100 6642 RX-0  独角兽三号机菲尼克斯</h3><p>购入价格： 129(大怨种)<br>组合度一般，可动性一般，香槟金挺好看的，喷镀漆面一般但能看，但建议入6642S<br><img src="/../GUNDAM/pynix2.jpg"><br><img src="/../GUNDAM/pynix3.jpg"></p><h3 id="MG-1-x2F-100-6653-GN-002-力天使"><a href="#MG-1-x2F-100-6653-GN-002-力天使" class="headerlink" title="MG 1&#x2F;100 6653 GN-002 力天使"></a>MG 1&#x2F;100 6653 GN-002 力天使</h3><p>购入价格：77<br>组合度不错，可动性不错，细节相比万代有所阉割，但作为比较新的款式有这不错的表现</p><h3 id="HGUC-1-x2F-144-175-RX-0-独角兽二号机报丧女妖命运女神形态毁灭模式"><a href="#HGUC-1-x2F-144-175-RX-0-独角兽二号机报丧女妖命运女神形态毁灭模式" class="headerlink" title="HGUC 1&#x2F;144  175 RX-0 独角兽二号机报丧女妖命运女神形态毁灭模式"></a>HGUC 1&#x2F;144  175 RX-0 独角兽二号机报丧女妖命运女神形态毁灭模式</h3><p>购入价格： 20<br>组合度一般，可动一般，外观好看，站尸不错<br><img src="/../GUNDAM/lion1.jpg"><img src="/../GUNDAM/lion2.jpg"><br><img src="/../GUNDAM/lion3.jpg"><img src="/../GUNDAM/lion4.jpg"></p><h3 id="HGGT-1-x2F-144-HT01-雷霆宙域-FA-78-全装甲高达"><a href="#HGGT-1-x2F-144-HT01-雷霆宙域-FA-78-全装甲高达" class="headerlink" title="HGGT 1&#x2F;144 HT01 雷霆宙域 FA-78 全装甲高达"></a>HGGT 1&#x2F;144 HT01 雷霆宙域 FA-78 全装甲高达</h3><p>购入价格 32<br>组合度良好，可动一般，配件多，性价比不错<br><img src="/../GUNDAM/full2.jpg"><br><img src="/../GUNDAM/full3.jpg"></p><h2 id="龙桃子"><a href="#龙桃子" class="headerlink" title="龙桃子"></a>龙桃子</h2><h3 id="MB式样-1-x2F-100-ZGMF-X42S-海涅配色命运"><a href="#MB式样-1-x2F-100-ZGMF-X42S-海涅配色命运" class="headerlink" title="MB式样 1&#x2F;100  ZGMF-X42S 海涅配色命运"></a>MB式样 1&#x2F;100  ZGMF-X42S 海涅配色命运</h3><p>购入价格 159（差不多这价，记不清了，初中入的）<br>组合度优秀，可动性良好，值得入手（然而龙桃子已经凉了，价格翻了几倍了都）<br><img src="/../GUNDAM/fate2.jpg"><br><img src="/../GUNDAM/fate3.jpg"></p><h2 id="模匠魂"><a href="#模匠魂" class="headerlink" title="模匠魂"></a>模匠魂</h2><h3 id="MG-Hirm式样-1-x2F-100-MBF-02-红异端-EW猩猩臂"><a href="#MG-Hirm式样-1-x2F-100-MBF-02-红异端-EW猩猩臂" class="headerlink" title="MG Hirm式样 1&#x2F;100 MBF-02 红异端 +EW猩猩臂"></a>MG Hirm式样 1&#x2F;100 MBF-02 红异端 +EW猩猩臂</h3><p>购入价格 160+80+80<br>EW配件包组合度优秀，MJH组合度部分良好，部分组合度拉垮，Hirm的肌肉感很适合红异端<br><img src="/../GUNDAM/red_m.jpg"></p><h2 id="闪闪"><a href="#闪闪" class="headerlink" title="闪闪"></a>闪闪</h2><h3 id="HG-1-x2F-144-RX-78-2-超越全球元祖-G3配色"><a href="#HG-1-x2F-144-RX-78-2-超越全球元祖-G3配色" class="headerlink" title="HG 1&#x2F;144 RX-78-2 超越全球元祖 G3配色"></a>HG 1&#x2F;144 RX-78-2 超越全球元祖 G3配色</h3><p>购入价格 34<br>组合度优秀，可动性优秀，假G3配色（x），堪比万代，值的入手</p><h2 id="星动"><a href="#星动" class="headerlink" title="星动"></a>星动</h2><h3 id="HG-TWFM-风灵高达-彩透版"><a href="#HG-TWFM-风灵高达-彩透版" class="headerlink" title="HG TWFM 风灵高达 彩透版"></a>HG TWFM 风灵高达 彩透版</h3><p>购入价格： 23<br>组合度优秀，彩透有模有样，比万代先发布，牛逼</p><h2 id="高高"><a href="#高高" class="headerlink" title="高高"></a>高高</h2><h3 id="HGI-BO-1-x2F-144-01-ASW-G-08-巴巴托斯第四形态"><a href="#HGI-BO-1-x2F-144-01-ASW-G-08-巴巴托斯第四形态" class="headerlink" title="HGI-BO  1&#x2F;144 01 ASW-G-08 巴巴托斯第四形态"></a>HGI-BO  1&#x2F;144 01 ASW-G-08 巴巴托斯第四形态</h3><p>购入价格 5<br>性价比神中神，组合度一般，可动性一般，这价格还考虑个啥啊<br><img src="/../GUNDAM/babatosi2.jpg"><br><img src="/../GUNDAM/babatosi3.jpg"><img src="/../GUNDAM/babatosi4.jpg"></p><h3 id="HGCE-1-x2F-144-ORB-01-不知火·拂晓"><a href="#HGCE-1-x2F-144-ORB-01-不知火·拂晓" class="headerlink" title="HGCE 1&#x2F;144 ORB-01 不知火·拂晓"></a>HGCE 1&#x2F;144 ORB-01 不知火·拂晓</h3><p>购入价格： 22.5<br>组合度拉垮，可动性拉垮，喷镀漆面拉垮，看在喷镀金入的，稍微还能看<br><img src="/../GUNDAM/gold2.jpg"><br><img src="/../GUNDAM/gold3.jpg"></p><h3 id="HGI-BO-1-x2F-144-33-ASW-G-08-巴巴托斯天狼座帝王形态"><a href="#HGI-BO-1-x2F-144-33-ASW-G-08-巴巴托斯天狼座帝王形态" class="headerlink" title="HGI-BO 1&#x2F;144  33  ASW-G-08 巴巴托斯天狼座帝王形态"></a>HGI-BO 1&#x2F;144  33  ASW-G-08 巴巴托斯天狼座帝王形态</h3><p>购入价格 21<br>组合度良好，可动性良好，补色贴纸地狱，媲美万代的水准<br><img src="/../GUNDAM/king1.jpg"><br><img src="/../GUNDAM/king3.jpg"><img src="/../GUNDAM/king4.jpg"></p><h3 id="HGTWFM-XVX-016RN-风灵高达改修型"><a href="#HGTWFM-XVX-016RN-风灵高达改修型" class="headerlink" title="HGTWFM XVX-016RN 风灵高达改修型"></a>HGTWFM XVX-016RN 风灵高达改修型</h3><p>购入价格 21.5<br>组合度良好，可动性良好，细节有点糊，总体不错，挑衅万代</p><h2 id="国模“原创”"><a href="#国模“原创”" class="headerlink" title="国模“原创”"></a>国模“原创”</h2><h3 id="铁创-星灭原型机"><a href="#铁创-星灭原型机" class="headerlink" title="铁创 星灭原型机"></a>铁创 星灭原型机</h3><p>购入价：158</p><hr>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>12-并发编程</title>
    <link href="/2023/02/18/12-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/02/18/12-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="对应-CSAPP-第十二章节"><a href="#对应-CSAPP-第十二章节" class="headerlink" title="对应 CSAPP 第十二章节"></a>对应 CSAPP 第十二章节</h2><span id="more"></span><h1 id="ICS"><a href="#ICS" class="headerlink" title="ICS"></a><a href="https://aki-yzh.github.io/2023/02/18/1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8&%E7%9B%AE%E5%BD%95">ICS</a></h1><hr><h2 id="十二、并发编程"><a href="#十二、并发编程" class="headerlink" title="十二、并发编程"></a>十二、并发编程</h2><p>$\quad$ 使用应用级并发的应用程序称为并发程序，现代操作系统提供三种基本的构造并发程序的方法：<br>$\qquad$ 1. 进程<br>$\qquad$ 2.I&#x2F;O多路复用<br>$\qquad$ 3.线程</p><h4 id="12-1-基于进程的并发编程"><a href="#12-1-基于进程的并发编程" class="headerlink" title="12.1 基于进程的并发编程"></a>12.1 基于进程的并发编程</h4><p>$\quad$ 在父进程中接受客户端连接请求，然后创建一个新的子进程来为每个新客户端提供服务。<br>服务器接收客户端的连接请求后，服务器<code>fork</code>出一个子进程-&gt;子进程关闭<code>listenfd</code>，父进程关闭<code>connfd</code>，避免内存泄漏-&gt;子进程执行完后自动关闭连接，父进程继续监听<br>$\quad$ 优点：简单，地址空间独立，共享状态信息<br>$\quad$ 缺点：难共享信息，进程间通信开销高</p><p><strong>基于进程的并发echo服务器</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;csapp.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">echo</span><span class="hljs-params">(<span class="hljs-type">int</span> connfd)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sigchld_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">waitpid</span>(<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,WNOHANG)&gt;<span class="hljs-number">0</span>)<br>        ;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> listenfd,connfd;<br>    <span class="hljs-type">socklen_t</span> clientlen;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_storage</span> clientaddr;<br>    <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;usage: %s &lt;port&gt;\n&quot;</span>,argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-built_in">Signal</span>(SIGCHLD,sigchld_handler);<br>    listenfd = <span class="hljs-built_in">Open_listenfd</span>(argv[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        clientfdlen = <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr_storage);<br>        connfd = <span class="hljs-built_in">Accept</span>(listenfd,(SA *) &amp;clientaddr,&amp;clientlen);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Fork</span>() == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">Closr</span>(listenfd);<br>            <span class="hljs-built_in">echo</span>(connfd);<br>            <span class="hljs-built_in">Close</span>(connfd);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-built_in">Close</span>(connfd);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="12-2-基于I-x2F-O多路复用的并发编程"><a href="#12-2-基于I-x2F-O多路复用的并发编程" class="headerlink" title="12.2 基于I&#x2F;O多路复用的并发编程"></a>12.2 基于I&#x2F;O多路复用的并发编程</h4><p>  I&#x2F;O 多路复用的思想：同时监测若干个文件描述符是否可以执行IO操作的能力</p><p>当描述符准备好可读时再去读，读的时候再判断是从哪个描述符读的</p><p>  <code>select</code>确定要等待的描述符：<em>读集合</em><br> 状态机：等待描述符准备好、描述符准备好可以读、从描述符读一个文本行</p><p>$\quad$ 优点：一个逻辑控制流，一个地址空间，没有进程&#x2F;线程管理<br>$\quad$ 缺点：编码复杂，只能在一个核上跑</p><p><strong>基于I&#x2F;O多路复用的迭代echo服务器</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;csapp.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">echo</span> <span class="hljs-params">(<span class="hljs-type">int</span> connfd)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">command</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> listenfd,connfd;<br>    <span class="hljs-type">socklen_t</span> clientlen;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_storage</span> clientaddr;<br>    fd_set read_set,ready_set;<br>    <span class="hljs-keyword">if</span>(argc!=<span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;usage: %s &lt;port&gt;\n&quot;</span>,argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    listenfd = <span class="hljs-built_in">Open_listenfd</span>(argc[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">FD_ZERO</span>(read_set);<span class="hljs-comment">/* clear read set */</span><br>    <span class="hljs-built_in">FD_SET</span>(STDIN_FILENO,&amp;read_set);<span class="hljs-comment">/* add stdin to read set */</span><br>    <span class="hljs-built_in">FD_SET</span>(listenfd,&amp;read_set);<span class="hljs-comment">/* add listenfd to read set */</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        ready_set=read set;<br>        <span class="hljs-built_in">Select</span>(listenfd+<span class="hljs-number">1</span>,&amp;ready_set,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">FD_ISSET</span>(STDIN_FILENO,&amp;ready_set))<br>            <span class="hljs-built_in">command</span>();<span class="hljs-comment">/* Read command line from stdin */</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">FD_ISSET</span>(listenfd,&amp;ready_set))<br>        &#123;<br>            clientlen = <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr_storage);<br>            connfd = <span class="hljs-built_in">Accept</span>(listenfd,(SA*) &amp;clientaddr,&amp;clientlen);<br>            <span class="hljs-built_in">echo</span>(connfd);<span class="hljs-comment">/* echo client input until EOF */</span><br>            <span class="hljs-built_in">Close</span>(connfd);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">command</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> buf[MAXLINE];<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">Fgets</span>(buf,MAXLINE,stdin))<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,buf);<span class="hljs-comment">/* process to the input command */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>基于I&#x2F;O多路复用的并发echo服务器</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#inlcude<span class="hljs-string">&quot;csapp.h&quot;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-comment">/* represents a pool of connected descriptors */</span><br>&#123;<br>    <span class="hljs-type">int</span> maxfd;<span class="hljs-comment">/* largest descriptor in read_set */</span><br>    fd_set read_set;<span class="hljs-comment">/* set of all active descriptors */</span><br>    fd_set ready_set;<span class="hljs-comment">/* Subset of descriptors ready for reading */</span><br>    <span class="hljs-type">int</span> nready;<span class="hljs-comment">/* Number of ready descriptors from select */</span><br>    <span class="hljs-type">int</span> maxi;<span class="hljs-comment">/* High water index into client array */</span><br>    <span class="hljs-type">int</span> clientfd[FD_SETSIZE];<span class="hljs-comment">/* Set of active descriptors */</span><br>    <span class="hljs-type">rio_t</span> clientrio[FD_SETSIZE];<span class="hljs-comment">/* Set of active read buffers */</span><br>&#125; pool ;<br><span class="hljs-type">int</span> byte_cnt =<span class="hljs-number">0</span>;<span class="hljs-comment">/* Counts total bytes received by server */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc ,<span class="hljs-type">char</span> ** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> listenfd,connfd;<br>    <span class="hljs-type">socklen_t</span> clientlen;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_storage</span> clientaddr;<br>    <span class="hljs-type">static</span> pool pool;<br>    <span class="hljs-keyword">if</span>(argc!=<span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprinf</span>(stderr,<span class="hljs-string">&quot;usage: %s &lt;port&gt;\n&quot;</span>,argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    listenfd=<span class="hljs-built_in">Open_listenfd</span>(argv[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">init_pool</span>(listenfd,&amp;pool);<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">/* wait for listening/connected descriptors to be ready */</span><br>        pool.ready_set=pool.read_set;<br>        pool.nready=<span class="hljs-built_in">Select</span>(pool.maxfd+<span class="hljs-number">1</span>,&amp;pool.readyset,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-comment">/* if listening descriptor ready , add new client to pool */</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">FD_ISSET</span>(listenfd,&amp;pool.ready_set))<br>        &#123;<br>            clientlen=<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr_storage);<br>            connfd=<span class="hljs-built_in">Accept</span>(listenfd,(SA*)&amp;clientaddr,&amp;clientlen);<br>            <span class="hljs-built_in">add_client</span>(connfd,&amp;pool);<br>        &#125;<br>        <span class="hljs-comment">/* echo a text line from each ready connected descriptor */</span><br>        <span class="hljs-built_in">check_clients</span>(&amp;pool);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init_pool</span><span class="hljs-params">(<span class="hljs-type">int</span> listenfd,pool *p)</span><span class="hljs-comment">//初始化客户端池</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/* initially ,there are no connected descriptors */</span><br>    <span class="hljs-type">int</span> i;<br>    p-&gt;maxi =<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span> ;i&lt;FD_SETSIZE;i++)<br>        p-&gt;clientfd[i]=<span class="hljs-number">-1</span>;<br>    <span class="hljs-comment">/* initially ,listenfd is only member of select read set */</span><br>    p-&gt;maxfd = listenfd;<br>    <span class="hljs-built_in">FD_ZERO</span>(&amp;p-&gt;read_set);<br>    <span class="hljs-built_in">FD_SET</span>(listenfd,&amp;p-&gt;read_set);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_client</span><span class="hljs-params">(<span class="hljs-type">int</span> connfd,pool *p)</span><span class="hljs-comment">//向池中添加一个新的客户端连接</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    p-&gt;nready--;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;FD_SETSIZE,i++)<span class="hljs-comment">/* find an available slot */</span><br>        <span class="hljs-keyword">if</span>(p-&gt;clientfd[i]&lt;<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-comment">/* Add connected descriptor to the pool */</span><br>            p-&gt;clientfd[i]=connfd;<br>            <span class="hljs-built_in">Rio_readinitb</span>(&amp;p-&gt;clientrio[i],connfd);<br>            <span class="hljs-comment">/* add the descriptor to descriptor set */</span><br>            <span class="hljs-built_in">FD_SET</span>(connfd,&amp;p-&gt;read_set);<br>            <span class="hljs-comment">/* update max descriptor and pool high water mark */</span><br>            <span class="hljs-keyword">if</span>(connfd&gt;p-&gt;maxfd)<br>                p-&gt;maxfd=connfd;<br>            <span class="hljs-keyword">if</span>(i&gt;p-&gt;maxi)<br>                p-&gt;maxi=i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    <span class="hljs-keyword">if</span>(i==FD_SETSIZE)<span class="hljs-comment">/* couldn&#x27;t find an empty slot */</span><br>        <span class="hljs-built_in">app_error</span>(<span class="hljs-string">&quot;add_client error: too mant clients&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">check_clients</span><span class="hljs-params">(pool *p)</span><span class="hljs-comment">//服务准备好的客户端链接</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i,connfd,n;<br>    <span class="hljs-type">char</span> buf[MAXLINE];<br>    <span class="hljs-type">rio_t</span> rio;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;(i&lt;=p-&gt;maxi)&amp;&amp;(p-&gt;nready&gt;<span class="hljs-number">0</span>);i++)<br>    &#123;<br>        connfd = p-&gt;clientfd[i];<br>        rio=p-&gt;clientrio[i];<br>        <span class="hljs-comment">/* if the descriptor is ready ,echo a text line from it */</span><br>        <span class="hljs-keyword">if</span>((connfd&gt;<span class="hljs-number">0</span>)&amp;&amp;(<span class="hljs-built_in">FD_ISSET</span>(connfd,&amp;p-&gt;ready_set)))<br>        &#123;<br>            p-&gt;nready--;<br>            <span class="hljs-keyword">if</span>((n=<span class="hljs-built_in">Rio_readlineb</span>(&amp;rio,buf,MAXLINE))!=<span class="hljs-number">0</span>)<br>            &#123;<br>                byte_cnt+=n;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Server received %d (%d total) bytes on fd %d\n&quot;</span>,n,byte_cnt,connfd);<br>                <span class="hljs-built_in">Rio_writen</span>(connfd,buf,n);<br>            &#125;<br>            <span class="hljs-comment">/* EOF decteced ,remove descriptor from pool */</span><br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-built_in">Close</span>(connfd);<br>                <span class="hljs-built_in">FD_CLR</span>(connfd,&amp;p-&gt;read_set);<br>                p-&gt;clientfd[i]=<span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="12-3-基于线程的并发编程"><a href="#12-3-基于线程的并发编程" class="headerlink" title="12.3 基于线程的并发编程"></a>12.3 基于线程的并发编程</h4><p>线程：进程上下文中的逻辑流<br>$\quad$ 共享代码、数据、堆、共享库和打开的文件<br>$\quad$ 私有的线程ID、栈、栈指针、寄存器<br>$\quad$ 和一个进程相关的线程组成一个对等线程池<br>$\quad$ 上下文切换、创建和终止比进程快<br>每个进程开始生命周期时都是单一线程，这个线程称为主线程，在某一时刻，主线程创建一个对等线程，从这个时间点开始，两个线程并发运行。</p><p><strong>Posix</strong>线程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-type">void</span> *<span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">void</span> *)</span></span><br><span class="hljs-function"><span class="hljs-comment">/* 创建其他线程 */</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_create</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> *tid, <span class="hljs-type">pthread_attr_t</span> *attr, func *f, <span class="hljs-type">void</span> *arg)</span></span>;<span class="hljs-comment">//成功返回0，出错非0</span><br><span class="hljs-comment">/* 返回调用者的线程id */</span><br><span class="hljs-function"><span class="hljs-type">pthread_t</span> <span class="hljs-title">pthread_self</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><span class="hljs-comment">/* 终止线程 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pthread_exit</span><span class="hljs-params">(<span class="hljs-type">void</span> *thread_return)</span></span>;<span class="hljs-comment">//从不返回</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_cancel</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> tid)</span></span>;<span class="hljs-comment">//成功返回0，出错非0</span><br><span class="hljs-comment">/* 等待其他线程终止 */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_join</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> tid, <span class="hljs-type">void</span> **thread_return)</span></span>;<span class="hljs-comment">//成功返回0，出错非0</span><br><span class="hljs-comment">/* 分离线程 */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_detach</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> tid)</span></span>;<span class="hljs-comment">//成功返回0，出错非0</span><br><span class="hljs-comment">/* 初始化线程 */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_once</span><span class="hljs-params">(<span class="hljs-type">pthread_once_t</span> *once_control, <span class="hljs-type">void</span> (*init_routine)(<span class="hljs-type">void</span>))</span></span>;<span class="hljs-comment">//总是返回0</span><br></code></pre></td></tr></table></figure><p><strong>基于线程的并发echo服务器</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;csapp.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">echo</span><span class="hljs-params">(<span class="hljs-type">int</span> connfd)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">thread</span><span class="hljs-params">(<span class="hljs-type">void</span> vargp)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> listenfd,*connfdp;<br>    <span class="hljs-type">socklen_t</span> clientlen;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_storage</span> clientaddr;<br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;usage: %s &lt;port&gt;\n&quot;</span>,argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    listenfd = <span class="hljs-built_in">Open_listenfd</span>(argc[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        clientlen = <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr_storage);<br>        connfdp = <span class="hljs-built_in">Malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>        *connfdp = <span class="hljs-built_in">Accept</span>(listenfd ,(SA *) &amp;clientaddr,&amp;clientlen);<br>        <span class="hljs-built_in">Pthread_creat</span>(&amp;tid,<span class="hljs-literal">NULL</span>,thread,connfdp);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/* Thread routine */</span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *vargp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> connfd = *((<span class="hljs-type">int</span> *)vargp);<br>    <span class="hljs-built_in">Pthread_detach</span>(<span class="hljs-built_in">pthread_self</span>());<br>    <span class="hljs-built_in">Free</span>(vargp);<br>    <span class="hljs-built_in">echo</span>(connfd);<br>    <span class="hljs-built_in">Close</span>(connfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="12-4-多线程程序中的共享变量"><a href="#12-4-多线程程序中的共享变量" class="headerlink" title="12.4 多线程程序中的共享变量"></a>12.4 多线程程序中的共享变量</h4><p>多线程的C程序中变量根据他们的存储类型倍映射到虚拟内存：<br>$\quad$ <strong>全局变量</strong>：虚拟内存的读 &#x2F; 写区域只包含每个全局变量的一个实例<br>$\quad$ <strong>本地自动变量</strong>：定义在函数内部但不<code>static</code>，每个线程的栈都包含它自己的所有本地自动变量的实例<br>$\quad$ <strong>本地静态变量</strong>：只有一个实例，每个对等线程都读 &#x2F; 写这个实例</p><p><strong>共享变量</strong><br>变量是共享的 ⇔ 它的一个实例被一个以上的线程引用<br>本地自动变量也能被共享</p><h4 id="12-5-用信号量同步线程"><a href="#12-5-用信号量同步线程" class="headerlink" title="12.5 用信号量同步线程"></a>12.5 用信号量同步线程</h4><p><strong>进程图</strong><br>$\quad$ 将n个并发线程的执行模型化为一条n维笛卡尔空间中的轨迹线，每条轴k对应于线程k的进度。<br>$\qquad$ 对$H_1,L_1,U_1,H_2,L_2,S_1,T_1,U_2,S_2,T_2$ 的轨迹线：<br><img src="/../icsmg/20230216212506.png"><br><strong>信号量</strong><br><img src="/../icsmg/20230216215854.png"><br>$\quad$ 具有非负整数值的全局变量<code>s</code>，两种操作：<br>$\quad$ <code>P(s)</code>：如果<code>s</code>非零，则将<code>s</code>减1，返回；<code>s</code>为0，就挂起线程，直到<code>s</code>变为非0，<code>V</code>会重启这个线程，重启后<code>P</code>将<code>s</code>减1，返回<br>$\quad$ <code>V(s)</code>：将<code>s</code>加1，如果有线程阻塞在<code>P</code>且等着<code>s</code>变为非零，则<code>V</code>会重启这些线程中的一个<br>$\quad$ 同一时间，只有一个<code>P</code>或一个<code>V</code>能改变<code>s</code>变量；<br>$\quad$ 多个线程在等待同一个信号量时，无法预测<code>V</code>要重启哪个线程<br>$\quad$ 信号量不变性_：信号量不会为负<br>P和V的包装函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">P</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *s)</span></span>;<span class="hljs-comment">/* Wrapper function for sem_wait */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">V</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *s)</span></span>;<span class="hljs-comment">/* Wrapper function for sem_post */</span><br></code></pre></td></tr></table></figure><p><strong>调度共享资源</strong></p><ol><li><strong>生产者 - 消费者问题</strong></li></ol><p>$\quad$ 生产者和消费者线程共享一个有<code>n</code>个槽的有限缓冲区，生产者反复生成新的项目并加入缓冲区中，消费者不断从缓冲区中取出这些项目，然后处理<br>$\quad$ 插入和去除项目都涉及更新共享变量，所以必须保证对缓冲区的访问是互斥的，同时要调度对缓冲区的访问：<br>$\quad$ 如果缓冲区是满的，生产者必须等待，直到有槽位可用<br>$\quad$ 如果缓冲区是空的。消费者必须等待，直到有槽位不为空</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;csapp.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;sbuf.h&quot;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">int</span> *buf;<span class="hljs-comment">/* Buffer array */</span><br>    <span class="hljs-type">int</span> n;<span class="hljs-comment">/* Maxium number of slots */</span><br>    <span class="hljs-type">int</span> front;<span class="hljs-comment">/* buf[(front+1)%n] is first item */</span><br>    <span class="hljs-type">int</span> rear;<span class="hljs-comment">/* buf[rear%n] is last item */</span><br>    <span class="hljs-type">sem_t</span> mutex;<span class="hljs-comment">/* Protect accesses to buf */</span><br>    <span class="hljs-type">sem_t</span> slots;<span class="hljs-comment">/* Counts available slots */</span><br>    <span class="hljs-type">sem_t</span> items;<span class="hljs-comment">/* Counts available items */</span><br>&#125; <span class="hljs-type">sbuf_t</span>;<br><br><span class="hljs-comment">/* Creat an empty bounded shared FIFO buffer with n slots */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sbuf_init</span><span class="hljs-params">(<span class="hljs-type">sbuf_t</span> *sp, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    sp-&gt;buf = <span class="hljs-built_in">Calloc</span>(n, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>    sp-&gt;n = n;<span class="hljs-comment">/* buffer holds max of n items */</span><br>    sp-&gt;front=sp-&gt;rear=<span class="hljs-number">0</span>;<span class="hljs-comment">/* Empty buffer iff front=rear */</span><br>    <span class="hljs-built_in">Sem_init</span>(&amp;sp-&gt;mutex, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">/*Binary semaphore for locking */</span><br>    <span class="hljs-built_in">Sem_init</span>(&amp;sp-&gt;slots, <span class="hljs-number">0</span>, n); <span class="hljs-comment">/* initially buf has n empty slots */</span><br>    <span class="hljs-built_in">Sem_init</span>(&amp;sp-&gt;items, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">/* initially, buf has zeor dara items */</span><br>&#125;<br><span class="hljs-comment">/* clean up buffer sp */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sbuf_deinit</span><span class="hljs-params">(<span class="hljs-type">sbuf_t</span> *sp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">Free</span>(sp-&gt;buf);<br>&#125;<br><span class="hljs-comment">/* insert item onto the rear of shared buffer sp */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sbuf_insert</span><span class="hljs-params">(<span class="hljs-type">sbuf_t</span> *sp, <span class="hljs-type">int</span> item)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">P</span>(&amp;sp-&gt;slots); <span class="hljs-comment">/* wait for available slots */</span><br>    <span class="hljs-built_in">P</span>(&amp;sp-&gt;mutex); <span class="hljs-comment">/* lock the buffer */</span><br>    sp-&gt;buf[(++sp-&gt;rear)%(sp-&gt;n)]=item ;<span class="hljs-comment">/* insert the item */</span><br>    <span class="hljs-built_in">V</span>(&amp;sp-&gt;mutex); <span class="hljs-comment">/* Unlock the buffer */</span><br>    <span class="hljs-built_in">V</span>(&amp;sp-&gt;items); <span class="hljs-comment">/* Announce available item */</span><br>&#125;<br><span class="hljs-comment">/* Remove and return the first item from buffer sp */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sbuf_remove</span><span class="hljs-params">(<span class="hljs-type">sbuf_t</span> *sp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> item;<br>    <span class="hljs-built_in">P</span>(&amp;sp-&gt;items);<span class="hljs-comment">/* wait for available item */</span><br>    <span class="hljs-built_in">P</span>(&amp;sp-&gt;mutex);<span class="hljs-comment">/* lock the buffer */</span><br>    item = sp-&gt;buf[(++sp-&gt;front)%(sp-&gt;n)];<span class="hljs-comment">/* remove the item */</span><br>    <span class="hljs-built_in">V</span>(&amp;sp-&gt;mutex);<span class="hljs-comment">/* Unlock the buffer */</span><br>    <span class="hljs-built_in">V</span>(&amp;sp-&gt;slots);<span class="hljs-comment">/* Announce available item */</span><br>    <span class="hljs-keyword">return</span> item;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>读者-写者模型</strong><br>$\qquad$ 一组并发的线程要访问一个共享对象，有些线程只读对象，其他的修改对象。只读对象的线程为读者，修改对象的为写者。写者必须独占对象，读者可以和其他读者共享对象，考虑有无限多个并发的读者和写者.<br>$\qquad$ <strong>第一类</strong>：不让读者等待，除非此时有写者。读者不会因为有写者在等待而等待：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-type">int</span> readcnt;<span class="hljs-comment">/* initially = 0 */</span><br><span class="hljs-type">sem_t</span> mutex, w; <span class="hljs-comment">/* initially 1 */</span>  <span class="hljs-comment">// mutex为readcnt的互斥锁</span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reader</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) <br>    &#123;<br>        <span class="hljs-built_in">P</span>(&amp;mutex);<br>        readcnt++;<br>        <span class="hljs-keyword">if</span> (readcnt == <span class="hljs-number">1</span>)<span class="hljs-comment">/* first in */</span><br>            <span class="hljs-built_in">P</span>(&amp;w);<br>        <span class="hljs-built_in">V</span>(&amp;mutex);<br>        <br>    <span class="hljs-comment">/*  reading happens */</span><br>        <br>        <span class="hljs-built_in">P</span>(&amp;mutex);<br>        readcnt--;<br>        <span class="hljs-keyword">if</span> (readcnt == <span class="hljs-number">0</span>)<span class="hljs-comment">/* last out */</span><br>            <span class="hljs-built_in">V</span>(&amp;w);<br>        <span class="hljs-built_in">V</span>(&amp;mutex);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">writer</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">P</span>(&amp;w);<br>        <br>       <span class="hljs-comment">/* writing happens*/</span><br>        <br>        <span class="hljs-built_in">V</span>(&amp;w);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>$\qquad$ <strong>第二类</strong>：写者优先，写者后到达的读者也必须等待这个写者完成<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> readcnt, writecnt;<span class="hljs-comment">/* initially 0 */</span><br><span class="hljs-type">sem_t</span> rmutex, wmutex, r, w;<span class="hljs-comment">/* initially 1 */</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reader</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) <br>    &#123;<br>        <span class="hljs-built_in">P</span>(&amp;r);<br>        <span class="hljs-built_in">P</span>(&amp;rmutex);<br>        readcnt++;<br>        <span class="hljs-keyword">if</span> (readcnt == <span class="hljs-number">1</span>)<br>            <span class="hljs-built_in">P</span>(&amp;w);<br>        <span class="hljs-built_in">V</span>(&amp;rmutex);<br>        <span class="hljs-built_in">V</span>(&amp;r);<br>        <br>        <span class="hljs-comment">/* reading */</span><br>        <br>        <span class="hljs-built_in">P</span>(&amp;rmutex);<br>        readcnt--;<br>        <span class="hljs-keyword">if</span> (readcnt == <span class="hljs-number">0</span>)<br>            <span class="hljs-built_in">V</span>(&amp;w);<br>        <span class="hljs-built_in">V</span>(&amp;rmutex);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">writer</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">P</span>(&amp;wmutex);<br>        writecnt++;<br>        <span class="hljs-keyword">if</span> (writecnt == <span class="hljs-number">1</span>)<br>            <span class="hljs-built_in">p</span>(&amp;r);<br>        <span class="hljs-built_in">V</span>(wmutex);<br>        <br>        <span class="hljs-built_in">P</span>(&amp;w);<br>        <span class="hljs-comment">/*  writing */</span><br>        <span class="hljs-built_in">V</span>(&amp;w);<br>        <br>        <span class="hljs-built_in">P</span>(&amp;wmutex);<br>        writecnt--;<br>        <span class="hljs-keyword">if</span> (writecnt == <span class="hljs-number">0</span>)<br>            <span class="hljs-built_in">V</span>(&amp;r);<br>        <span class="hljs-built_in">V</span>(&amp;wmutex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p><strong>基于预线程化的并发服务器</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;csapp.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;sbuf.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NTHREADS 4</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SBUFSIZE 16</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">echo_cnt</span><span class="hljs-params">(<span class="hljs-type">int</span> connfd)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *vargp)</span></span>;<br><span class="hljs-type">sbuf_t</span> sbuf;<span class="hljs-comment">/* shared buffer of connected descriptors */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i,listenfd,counnfd;<br>    <span class="hljs-type">socklen_t</span> clientlen;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_storage</span> clientaddr;<br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-keyword">if</span>(argc!=<span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;usage: %s &lt;port&gt;\n&quot;</span>,argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    listenfd = <span class="hljs-built_in">Open_listenfd</span>(argv[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">sbuf_init</span>(&amp;sbuf,SBUFSIZE);<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span> ;i&lt;NTHREADS;i++)<span class="hljs-comment">/* Creat worker threads */</span><br>    &#123;<br>        <span class="hljs-built_in">Pthread_creat</span>(&amp;tid,<span class="hljs-literal">NULL</span>,thread,<span class="hljs-literal">NULL</span>);<br>    &#125;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        clientlen=<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr_storage);<br>        connfd=<span class="hljs-built_in">Accept</span>(listenfd,(SA*)&amp;clientaddr,&amp;clientlen);<br>        <span class="hljs-built_in">sbuf_insert</span>(&amp;sbuf,connfd);<span class="hljs-comment">/* insert connfd in buffer */</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">thread</span> <span class="hljs-params">(<span class="hljs-type">void</span> *vargp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">Pthread_detach</span>(<span class="hljs-built_in">pthread_self</span>());<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> connfd = <span class="hljs-built_in">sbuf_remove</span>(&amp;sbuf);<span class="hljs-comment">/* remove connfd from buffer */</span><br>        <span class="hljs-built_in">echo_cnt</span>(connfd);<span class="hljs-comment">/* service client */</span><br>        <span class="hljs-built_in">Close</span>(connfd);<br>    &#125;<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> byte_cnt;<span class="hljs-comment">/* byte counter */</span><br><span class="hljs-type">static</span> <span class="hljs-type">sem_t</span> mutex;<span class="hljs-comment">/* and the mutex thar protects it */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">init_echo_cnt</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">Sem_init</span>(&amp;mutex,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>    byte_cnt=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">echo_cnt</span><span class="hljs-params">(<span class="hljs-type">int</span> connfd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">char</span> buf[MAXLINE];<br>    <span class="hljs-type">rio_t</span> rio;<br>    <span class="hljs-type">static</span> <span class="hljs-type">pthread_once_t</span> once = PTHREAD_ONCE_INIT;<br>    <span class="hljs-built_in">Pthread_once</span> (&amp;once ,init_echo_cnt);<br>    <span class="hljs-built_in">Rio_readinitb</span>(&amp;rio,connfd);<br>    <span class="hljs-keyword">while</span>((n=<span class="hljs-built_in">Rio_readlineb</span>(&amp;rio,buf,MAXLINE))!=<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">P</span>(&amp;mutex);<br>        byte_cnt+=n;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;server received %d (%d total) bytes on fd %d \n&quot;</span>,n.byte_cnt,connfd);<br>        <span class="hljs-built_in">V</span>(&amp;mutex);<br>        <span class="hljs-built_in">Rio_writen</span>(connfd,buf,n);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="12-6-使用线程提高并行性"><a href="#12-6-使用线程提高并行性" class="headerlink" title="12.6 使用线程提高并行性"></a>12.6 使用线程提高并行性</h4><p>同步（互斥锁）开销巨大，要尽可能避免。如果无可避免，必须要用尽可能多的有用计算弥补这个开销</p><p>如：不要用互斥锁保护同一个全局变量，在每个对等线程中用私有变量计算部分和（每个对等线程把部分和累计到一个私有数组元素中）</p><p>再优化：累积到一个局部变量中，最后再移动到数组中</p><p><strong>刻画并行程序的性能</strong></p><p>$\quad$ 线程数 &lt; 核数：时间降低：线程数增加一倍，时间下降一半<br>$\quad$ 线程数 &gt; 核数：时间增加（一点）：上下文切换开销</p><p>公式：<br>$\quad$<strong>加速比</strong>：$S_p &#x3D; \frac{T_1}{T_p}$，$p$ 为处理器核数，$T_K$ 为在 k 个核上的运行时间<br>$\qquad$ T1 为程序顺序执行版本的执行时间：$S_p$ 为 <em>绝对加速比</em><br>$\qquad$ T1 为程序并行版本在一个核上的执行时间：$S_p$ 为 <em>相对加速比</em><br>$\quad$<strong>效率</strong>：$E_p &#x3D; \frac{S_p}{p}&#x3D;\frac{T_1}{p{T_p}}$：百分比，对由于并行化造成的开销的衡量<br>$\quad$<strong>弱扩展</strong>：增加处理器数量的同时，增加问题的规模，使得每个处理器执行的工作量保持不变：更加真实</p><h4 id="12-7-其他并发问题"><a href="#12-7-其他并发问题" class="headerlink" title="12.7 其他并发问题"></a>12.7 其他并发问题</h4><h5 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h5><p>$\quad$<strong>线程安全的函数</strong>：当且仅当它被多个并发线程反复调用时，能够一直产生正确的结果<br>$\quad$ 线程不安全函数类：<br>$\quad$ 1.  不保护共享变量的函数<br>$\quad$ 2.  保持跨越多个调用的状态的函数（如：<code>rand</code>，<code>srand</code>，当前调用的结果取决于前一次调用的结果，多线程中无法获得相同的序列）<br>$\quad$ 3.  返回指向静态变量指针的函数：<code>ctime, gethostbyname</code>：正在被一个线程使用的结果可能被另一个线程覆盖<br>$\quad$ 解决方法：<br>$\quad$ $\quad$ 1.  重写函数<br>$\quad$ $\quad$ 2.  将线程不安全函数与互斥锁联系起来：每次调用时用互斥锁加锁，将返回的结果复制到一个私有的内存位置，再解锁（包装函数）<br>$\quad$ 4.  调用线程不安全函数的函数（不一定：如果是1，3类函数，加了互斥锁就是安全的，2只有重写函数）</p><h5 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h5><p>$\quad$ 被多个线程调用时，不会引用_任何_共享数据<br>$\quad$ 线程安全包含可重入<br>$\quad$ <strong>显式可重入</strong>：所有的函数参数都是传值传递，所有的数据引用都是本地的自动栈变量<br>$\quad$ 隐式可重入：参数有传指针：小心使用就是可重入的</p><h5 id="竞争"><a href="#竞争" class="headerlink" title="竞争"></a>竞争</h5><p>$\quad$ 一个程序的正确性依赖于一个线程要在另一个线程到达 y 点之前到达它的控制流中的 x 点：程序员假定线程将通过某种特殊的轨迹线穿过执行状态空间<br>$\quad$ 消除竞争：通过<code>Malloc - Free</code>传参等</p><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>$\quad$ 一组线程被阻塞，等待一个永远不会为真的条件</p><p><img src="/../icsmg/20230216205835.png"></p><p>$\quad$ 出现：程序员使用P和V信号不当，导致两个信号量的禁止区域重叠<br>$\quad$ 避免死锁：<code>互斥锁加锁顺序规则</code>：给定所有互斥操作的一个全序，如果每个线程都是以一种顺序获得互斥锁并以相反的顺序释放，那么这个程序就是无死锁的</p><h5 id="活锁：冲突碰撞"><a href="#活锁：冲突碰撞" class="headerlink" title="活锁：冲突碰撞"></a>活锁：冲突碰撞</h5><h5 id="饥饿：如高优先度进程阻塞低优先度进程"><a href="#饥饿：如高优先度进程阻塞低优先度进程" class="headerlink" title="饥饿：如高优先度进程阻塞低优先度进程"></a>饥饿：如高优先度进程阻塞低优先度进程</h5><hr><h3 id="LAB"><a href="#LAB" class="headerlink" title="LAB:"></a>LAB:</h3><p><strong>此章节后完成<a href="https://github.com/Aki-yzh/PKU-ICS-2022/tree/main/LABS/8-proxylab">proxylab(75.0&#x2F;100.0)</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11-网络编程</title>
    <link href="/2023/02/18/11-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/02/18/11-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="对应-CSAPP-第十一章节"><a href="#对应-CSAPP-第十一章节" class="headerlink" title="对应 CSAPP 第十一章节"></a>对应 CSAPP 第十一章节</h2><span id="more"></span><h1 id="ICS"><a href="#ICS" class="headerlink" title="ICS"></a><a href="https://aki-yzh.github.io/2023/02/18/1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8&%E7%9B%AE%E5%BD%95">ICS</a></h1><hr><h2 id="十一、网络编程"><a href="#十一、网络编程" class="headerlink" title="十一、网络编程"></a>十一、网络编程</h2><h4 id="11-1-客户端-服务器编程模型"><a href="#11-1-客户端-服务器编程模型" class="headerlink" title="11.1 客户端-服务器编程模型"></a>11.1 客户端-服务器编程模型</h4><p> $\quad$ 每个网络应用都是基于客户端-服务器编程模型的。采用这个模型，一个应用是由一个服务器进程和一个或者多个客户端进程组成。服务器管理某种资源，并且通过操作这种资源来为他的客户端提供某种服务。（<strong>客户端和服务器都是进程</strong>）<br> $\quad$ 客户端-服务器变成模型的基本操作是事务：<br>  $\qquad$ 1) 当一个客户端需要服务时，向服务器发送一个请求<br>  $\qquad$ 2) 服务器收到请求，进行解释并以适当方式操作它的资源<br>  $\qquad$ 3) 服务器给客户端发送一个响应，并等待下一个请求<br>  $\qquad$ 4) 客户端收到响应并处理它<br>  <img src="/../icsmg/20230117150926.png"></p><h4 id="11-2-网络"><a href="#11-2-网络" class="headerlink" title="11.2 网络"></a>11.2 网络</h4><p>$\quad$ 对于主机而言，网络只是又一种I&#x2F;O设备，是数据源和数据的接收方。<br>$\quad$ 物理上来说，网络是一个按照地理位置远近组织的层次系统<br>$\quad$ 最底层是LAN（局域网），最流行的局域网技术是以太网（Ethernet）<br><img src="/../icsmg/20230117152239.png"><br>$\quad$ 一个以太网段包括一些电缆和一个集线器。以太网段中每台主机都能看到每个位。</p><p>$\qquad$ 每个以太网适配器都有一个全球唯一的48位地址。一台主机可以发送一段位（称为帧）到这个网段内的任何其他主机。每个帧包括一些固定数量的头部位，用来标识此帧的源和目的地址以及此帧的长度，此后紧随的就是数据位的有效载荷。每个主机适配器都能看到这个帧，但只有目的主机实际读取它。</p><p>$\quad$ 使用电缆和网桥，多个以太网段可以连接成较大的局域网，称为桥接以太网。<br><img src="/../icsmg/20230117152253.png"><br>$\quad$ 多个不兼容的局域网通过路由器连接，组成一个互联网络（internet）<br><img src="/../icsmg/20230117152436.png"><br>$\quad$ 路由器间点到点高速连接称为广域网（WAN）</p><p>$\quad$ 互联网协议用于消除不同局域网和广域网之间的差异，控制主机和路由器协同工作实现数据传输。<br>$\quad$ 具有两种基本能力：<br>$\qquad$ 命名机制：唯一标识主机<br>$\qquad$ 传送机制：把数据位捆扎成不连续的片（称为包（包头包含包的大小与源主机目的主机的地址））的同一方式。<br>$\quad$ 数据传输的8个基本步骤：<br>$\qquad$ 1)  客户端从虚拟地址空间复制数据到内核缓冲区<br>$\qquad$ 2) 主机A协议软件在数据前附加包头和帧头创建帧<br>$\qquad$ 3) LAN1适配器将帧复制到网络上<br>$\qquad$ 4) 路由器读取帧并传送到协议软件<br>$\qquad$ 5) 路由器从包头提取目的互联网地址，脱落旧帧头，加上新帧头，将帧传送到适配器<br>$\qquad$ 6) LAN2适配器将帧复制到网络上<br>$\qquad$ 7) 主机B的适配器读取此帧并把它传送到协议软件<br>$\qquad$ 8) 主机B读取帧，剥落包头和帧头<br><img src="/../icsmg/20230117152936.png"></p><h4 id="11-3-全球IP因特网"><a href="#11-3-全球IP因特网" class="headerlink" title="11.3 全球IP因特网"></a>11.3 全球IP因特网</h4><p>$\quad$ 因特网应用程序的基本硬件与软件结构：<br><img src="/../icsmg/20230117153046.png"><br>$\quad$ TCP&#x2F;IP协议（传输控制协议&#x2F;互联网络协议）：<br>   $\quad$ 几乎每个现代计算机系统都支持<br>   $\quad$ 实际上是个协议族：<br>$\qquad$ $\quad$ IP：基本命名方法和递送机制<br>$\qquad$ $\qquad$ IP机制是不可靠的，不会试图恢复丢失的数据报<br>$\qquad$ $\quad$ UDP：扩展IP协议（进程间传送）<br>$\qquad$ $\quad$ TCP：可靠的全双工连接<br>$\quad$ 从程序员角度看因特网：<br>$\qquad$ 主机集合，32位IP地址<br>$\qquad$ P地址映射为标识符（因特网域名）<br>$\qquad$ 因特网主机上的进程能通过连接和任何其他因特网主机上的进程通信</p><h6 id="IP地址："><a href="#IP地址：" class="headerlink" title="IP地址："></a>IP地址：</h6><p> $\quad$ 一个IP地址就是个32位无符号整数，因特网客户端和服务器相互通信时使用的就是IP地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* IP address structure */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">in_addr</span>&#123;<br>    <span class="hljs-type">uint32_t</span> s_addr;<span class="hljs-comment">/* Address in network byte order(big - endian)*/</span><br>&#125;;<span class="hljs-comment">//in后缀表示internet</span><br></code></pre></td></tr></table></figure><p>$\quad$ 网络字节顺序：大端字节顺序-&gt;主机字节顺序可能和网络字节顺序不一样<br>$\quad$ 通过如下函数实现网络与主机字节顺序转换<br><img src="/../icsmg/20230117153705.png"><br>$\quad$ 表示：点分十进制（每个字节用它的十进制表示）<br>$\quad$ 如 128.2.194.242就是地址0x8002c2f2的点分十进制表示。<br>$\quad$ 通过如下函数进行转换<br><img src="/../icsmg/20230117153847.png"></p><h6 id="因特网域名："><a href="#因特网域名：" class="headerlink" title="因特网域名："></a>因特网域名：</h6><p>$\quad$ 用句点风格的单词，域名集合形成了一个层次结构，每个域名编码了它在这个层次结构中的位置。<br><img src="/../icsmg/20230117154126.png"><br>$\quad$ 域名系统DNS<br>$\quad$ 从概念上讲，程序员可以把DNS数据库视为数百万条主机条目的集合<br>$\quad$ 每个主机条目定义了域名和IP地址之间的映射<br>$\quad$ 在数字意义上，主机条目是域名和IP地址的等价类</p><h6 id="因特网连接："><a href="#因特网连接：" class="headerlink" title="因特网连接："></a>因特网连接：</h6><p>$\quad$ 点对点的：连接一对进程<br>$\quad$ 全双工的：数据可以同时双向流动<br>$\quad$ 可靠的：由源进程发出的字节流最后被目的进程以它发出的顺序收到它<br>$\quad$ 套接字：一个套接字是连接的一个端点，每个套接字都有相应的套接字地址<br>$\quad$ 套接字由一个因特网地址和一个16位的整数端口组成<br>$\quad$ 客户端套接字地址中的端口由内核自动分配，称为临时端口<br>$\quad$ 服务器套接字地址端口通常是某个知名端口<br>$\qquad$ echo servers: echo 7<br>$\qquad$  ftp servers: ftp 21<br>$\qquad$ ssh servers: ssh 22<br>$\qquad$  email servers: smtp 25<br>$\qquad$ Web servers: http 80<br>$\quad$ 套接字对唯一确定一个连接<br>$\quad$(cliaddr:cliport, servaddr:servport)<br>$\qquad$ cliaddr:客户端IP地址，cliport：客户端端口，servaddr：服务器Ip地址，servport： 服务器端口</p><h4 id="11-4-套接字接口"><a href="#11-4-套接字接口" class="headerlink" title="11.4 套接字接口"></a>11.4 套接字接口</h4><p>$\quad$ 套接字接口是与UnixI&#x2F;O结合使用的一组系统级函数，用于构建网络应用程序，适用于所有现代系统<br><img src="/../icsmg/20230117155314.png"></p><p>$\quad$ 对于内核来说，套接字是与应用程序通信的端点。<br>$\quad$ 对应用来说，套接字是一个文件描述符，允许应用程序从网络读取或写入数据<br>套接字地址结构：<br><img src="/../icsmg/20230117155524.png"><br><strong>socket函数</strong>：创建一个套接字描述符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">socket</span><span class="hljs-params">(<span class="hljs-type">int</span> domain, <span class="hljs-type">int</span> type,<span class="hljs-type">int</span> protocol)</span></span>;<span class="hljs-comment">//若成功则返回非负描述符，否则返回-1；</span><br></code></pre></td></tr></table></figure><p>$\quad$使套接字称为连接的一个端点<br>$\quad$clientfd &#x3D; Socket(AF_INET,SOCK_STREAM,0);<br>$\quad$其中AF_INET表示我们正在使用32位IP地址，SOCK_STREAM表示这个套接字是连接的一个端点。<br><strong>connect函数</strong>：建立和服务器的连接</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> clientfd,<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr* addr,<span class="hljs-type">socklen_t</span> addrlen)</span></span>;<span class="hljs-comment">//成功返回0，否则-1</span><br></code></pre></td></tr></table></figure><p><strong>bind函数</strong>：服务器套接字地址和套接字描述符结合</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bind</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr* addr, <span class="hljs-type">socklen_t</span> addrlen)</span></span>;<span class="hljs-comment">//成功返回0，否则-1</span><br></code></pre></td></tr></table></figure><p><strong>listen函数</strong>： socket主动套接字-&gt;监听套接字</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">listen</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd,<span class="hljs-type">int</span> backlog)</span></span>;<span class="hljs-comment">//成功返回0，否则-1</span><br></code></pre></td></tr></table></figure><p><strong>accept函数</strong>：等待客户端连接请求</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">accept</span><span class="hljs-params">(<span class="hljs-type">int</span> listenfd,<span class="hljs-keyword">struct</span> sockaddr* addr,<span class="hljs-type">int</span> *addrlen)</span><span class="hljs-comment">//成功返回0，否则-1</span></span><br></code></pre></td></tr></table></figure><p><img src="/../icsmg/20230117161134.png"><br><strong>主机与服务器之间的转换</strong><br>  getaddrinfo:将主机名，主机地址，服务名和端口号的字符串表示转化成套接字地址结构<br>$\qquad$ 可重入的、与协议无关的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getaddrinfo</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *host,<span class="hljs-type">const</span> <span class="hljs-type">char</span> *service,cosnt <span class="hljs-keyword">struct</span> addrinfo* hints,<span class="hljs-keyword">struct</span> addrinfo **result)</span></span>;<span class="hljs-comment">//成功返回0，否则返回非0的错误代码</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">freeaddrinfo</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> addrinfo *result)</span></span>;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">gai_strerror</span><span class="hljs-params">(<span class="hljs-type">int</span> errcode)</span></span>;<span class="hljs-comment">//返回错误消息</span><br></code></pre></td></tr></table></figure><p>$\quad$ result指向一个addrinfo结构的链表，其中每个结构指向一个对应于host和service的套接字地址结构，host可以是域名，也可以是数字地址，service参数可以是服务名，也可以是十进制端口号。hints是个addrinfo结构，提供对getaddrinfo返回的套接字地址列表更好的控制。<br>如果不想把主机名转换成地址，可以把host设置为NULL，对于service来说也是一样，但是必须制定两者中其中一个。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">addrinfo</span><br>&#123;<br>    <span class="hljs-type">int</span>   ai_flags;<span class="hljs-comment">//AI_ADDRCONFIG-&gt;使用连接推荐使用，返回地址与主机设置一致；AI_CANONNAME-&gt;ai_canonname指向host的官方名；AI_NUMERICSERV-&gt;强制service为端口号；</span><br>    <span class="hljs-type">int</span>   ai_family;<span class="hljs-comment">//AF_INET-&gt;IPv4,AF_INET6-&gt;IPv6</span><br>    <span class="hljs-type">int</span>   ai_socktype;<br>    <span class="hljs-type">int</span>   ai_protocol;<br>    <span class="hljs-type">char</span>  *ai_canonname;<br>    <span class="hljs-type">size_t</span> ai_addrlen;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr</span> *addr;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">addrinfo</span> *ai_next;<br>&#125;<span class="hljs-comment">//如果要传递hints参数，只能设置flag，family，socktype和protocol，其他必须设0；</span><br></code></pre></td></tr></table></figure><p><img src="/../icsmg/20230117161728.png"><br> $\quad$ 客户端(服务器)调用getaddrinfo后会遍历result指向的列表，依次尝试每个套接字地址直到socket和connect(bind)成功<br> $\quad$ getnameinfo: 将套接字地址结构转换成主机和服务名字符串<br>$\qquad$ $\quad$ 可重入的、与协议无关的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getnameinfo</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *sa ,<span class="hljs-type">socklen_t</span> salen,<span class="hljs-type">char</span> *host,<span class="hljs-type">size_t</span> hostlen,<span class="hljs-type">char</span> *service, <span class="hljs-type">size_t</span> servlen,<span class="hljs-type">int</span> flags)</span></span>;<span class="hljs-comment">//成功返回0，错误返回非0的错误代码</span><br></code></pre></td></tr></table></figure><p>$\quad$ sa指向大小为salen的套接字地址结构，host指向大小为hostlen字节的缓冲区，service指向大小为servlen字节的缓冲区，getnameinfo将套接字地址结构转换成对应的主机和服务名字符串，并把它们复制到host和service缓冲区。flags是一个位掩码，修改默认行为(NI_NUMERICHOST-&gt;使函数返回数字地址字符串；NI_NUMERICSERV-&gt;函数跳过查找简单返回端口号)<br>$\quad$ 如果不想要主机名，可以把host设定为NULL，hostlen设置为0，对服务字段也是一样，不过两者只能设置其中之一。</p><p><strong>套接字接口的辅助函数</strong></p><p>$\quad$ open_clientfd:建立与服务器之间的连接</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;csapp.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">openclientfd</span><span class="hljs-params">(<span class="hljs-type">char</span> *hostname,<span class="hljs-type">char</span> *port)</span></span>;<span class="hljs-comment">//成功返回描述符，出错返回-1；</span><br></code></pre></td></tr></table></figure><p>$\quad$ open_listenfd:服务器创建监听描述符，准备接收连接请求,是可重入，与协议无关的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">open_listenfd</span><span class="hljs-params">(<span class="hljs-type">char</span> *port)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">addrinfo</span> hints,*listp,*p;<br>    <span class="hljs-type">int</span> listenfd,optval=<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">/* get a list of potential server addresses */</span><br>    <span class="hljs-built_in">memset</span> (&amp;hints,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> addrinfo));<br>    hints.ai_socktype = SOCK_STREAM;<span class="hljs-comment">/* accept connections */</span><br>    hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG;<span class="hljs-comment">/* on any IP address */</span><br>    hints.ai_flags = AI_NUMERICSERV;<span class="hljs-comment">/* usng port number */</span><br>    <span class="hljs-built_in">Getaddrinfo</span>(<span class="hljs-literal">NULL</span>,port,&amp;hints,&amp;listp);<br><br>    <span class="hljs-comment">/* walk the list for one that we can bind to */</span><br>    <span class="hljs-keyword">for</span>(p = listp;p;p=p-&gt;ai_next)<br>    &#123;<br>        <span class="hljs-comment">/* creat a socket descriptor */</span><br>        <span class="hljs-keyword">if</span>((listenfd = <span class="hljs-built_in">socket</span>(p-&gt;ai_family,p -&gt; ai_socketype,p-&gt;ai_protocol))&lt;<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">continue</span>;<span class="hljs-comment">/* socket failed ,try the next */</span><br><br>        <span class="hljs-comment">/* eliminates &quot;address already in use&quot; error from bind */</span><br>        <span class="hljs-built_in">Setsockopt</span>(listenfd,SOL_SOCKET,SO_REUSEADDR,(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *)&amp;optval,<span class="hljs-built_in">sizeof</span>(hint));<br><br>        <span class="hljs-comment">/* bind the descriptor to the address */</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">bind</span>(listenfd,p-&gt;ai_addr,p-&gt;ai_addrlen)==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<span class="hljs-comment">/* success */</span><br>        <span class="hljs-built_in">Close</span>(listenfd);<span class="hljs-comment">/* bind failed, try the next */</span><br>    &#125;<br>    <span class="hljs-comment">/* clean up */</span><br>    <span class="hljs-built_in">Freeaddrinfo</span>(listp);<br>    <span class="hljs-keyword">if</span>(!p)<span class="hljs-comment">/* no address worked */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-comment">/* make it a listening socket ready to accept connection requests */</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">listen</span>(listenfd, LISTENQ)&lt;<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">Close</span>(listenfd);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> listenfd;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="11-5-Web服务器"><a href="#11-5-Web服务器" class="headerlink" title="11.5 Web服务器"></a>11.5 Web服务器</h4><p>$\quad$ 迭代服务器：一次一个地在客户端间迭代<br>$\quad$ 并发服务器：能同时处理多个客户端<br><strong>Web基础</strong><br>$\quad$ Web客户端和服务器之间的交互用的是一个基于文本的应用级协议，叫做HTTP协议。<br>$\quad$ HTTP是一个简单的协议。一个Web客户端打开一个到服务器的因特网连接，并且请求某些内容，服务器响应所请求的内容，然后关闭连接，浏览器读取这些内容并把它显示在屏幕上。<br>$\quad$ Web内容采用html语言编写，一个HTML程序包括指令，它们告诉浏览器如何显示这页中的各种文本和图形对象<br><strong>Web内容</strong><br>$\quad$ 内容是与一个MIME类型相关的字节序列。</p><table><thead><tr><th>MIME类型</th><th>描述</th></tr></thead><tbody><tr><td>text&#x2F;html</td><td>html界面</td></tr><tr><td>text&#x2F;plain</td><td>无格式文本</td></tr><tr><td>application&#x2F;postscript</td><td>postscript 文档</td></tr><tr><td>image&#x2F;gif</td><td>GIF格式编码的二进制图像</td></tr><tr><td>image&#x2F;png</td><td>PNG格式编码的二进制图像</td></tr><tr><td>image&#x2F;jepg</td><td>JEPG格式编码的二进制图像</td></tr></tbody></table><p>$\quad$ Web服务器用两种不同的方式向客户端提供内容：<br>$\quad$ ·- 取一个磁盘文件，并将它的内容返回给客户端，磁盘文件称为静态内容，此过程称为服务静态内容<br>$\quad$ ·- 运行一个可执行文件，并把它的输出返回到客户端，运行可执行文件时的输出称为动态内容，此过程称为服务动态内容。<br>$\quad$ URL唯一标识服务器管理的文件<br>$\qquad$ 最小的URL后缀:“&#x2F;”所有服务器将其扩展为默认的主页 </p><p><strong>HTTP事务</strong><br>$\quad$ 1.HTTP请求：请求行+多个请求报头+一个空文本行（终止）<br>$\qquad$ GET方法：服务器生成和返回URI（文件名+可选参数<br>$\quad$ $\quad$ 请求行： method URI version（method 方法，一般用GET，URI：URL后缀，包括文件名和可选参数；version：HTTP版本）<br>$\quad$ $\quad$ 请求报头：header-name：header-data<br>$\quad$ 2.HTTP响应：响应行+多个响应报头+终止空行+响应主体<br>$\quad$ $\quad$ 响应行： version status-code status- message（version：http版本；status-code状态码）</p><table><thead><tr><th>状态码</th><th>状态消息</th><th>描述</th></tr></thead><tbody><tr><td>200</td><td>成功</td><td>处理请求无误</td></tr><tr><td>301</td><td>永久移动</td><td>内容已移动到location头中指明的主机上</td></tr><tr><td>400</td><td>错误请求</td><td>服务器不能理解请求</td></tr><tr><td>403</td><td>禁止</td><td>服务器无权访问所请求的文本</td></tr><tr><td>404</td><td>未发现</td><td>服务器不能找到所请求的文件</td></tr><tr><td>501</td><td>未实现</td><td>服务器不支持请求的方法</td></tr><tr><td>505</td><td>HTTP版本不支持</td><td>服务器不支持请求的版本</td></tr></tbody></table><p><strong>服务动态内容</strong></p><p>$\quad$ CGI（通用网关接口）<br>$\quad$（参数）客户端-&gt;服务器（URI）：<br>$\quad$ 用 ？分隔文件名和参数，&amp;分隔各个参数，空格写作%20<br>$\quad$（参数）服务器-&gt;子进程：设置环境变量<br>$\quad$ 子进程输出直接重定向至和客户端相关联的已连接描述符</p><h4 id="11-6-TINY-Web服务器"><a href="#11-6-TINY-Web服务器" class="headerlink" title="11.6 TINY Web服务器"></a>11.6 TINY Web服务器</h4><p>$\quad$ main：打开监听套接字，无限循环，接受请求，执行事务，并关闭连接的它的那一端</p><p>$\quad$ doit：处理一个HTTP事务</p><p>$\quad$ clienterror：检查明显错误并报告给客户端</p><p>$\quad$ read_requesthdrs：读取并忽略报头</p><p>$\quad$ parse_uri：解析URI为一个文件名和一个可选的CGI字符串</p><p>$\quad$ serve_static：提供静态内容</p><p>$\quad$ serve_dynamic：提供动态内容</p><p>$\quad$ 详见<a href="https://github.com/Aki-yzh/PKU-ICS-2022/tree/main/LABS/8-proxylab">proxylab</a></p><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10-系统级IO</title>
    <link href="/2023/02/18/10-%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/"/>
    <url>/2023/02/18/10-%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="对应-CSAPP-第十章节"><a href="#对应-CSAPP-第十章节" class="headerlink" title="对应 CSAPP 第十章节"></a>对应 CSAPP 第十章节</h2><span id="more"></span><h1 id="ICS"><a href="#ICS" class="headerlink" title="ICS"></a><a href="https://aki-yzh.github.io/2023/02/18/1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8&%E7%9B%AE%E5%BD%95">ICS</a></h1><hr><h2 id="十、系统级I-x2F-O"><a href="#十、系统级I-x2F-O" class="headerlink" title="十、系统级I&#x2F;O"></a>十、系统级I&#x2F;O</h2><p>$\quad$ 输入&#x2F;输出是在主存和外部设备之间复制数据的过程。</p><h4 id="10-1-Unix-I-x2F-O"><a href="#10-1-Unix-I-x2F-O" class="headerlink" title="10.1 Unix I&#x2F;O"></a>10.1 Unix I&#x2F;O</h4><p>$\quad$ 一个Linux文件就是一个m个字节的序列：$ B_0,B_1……B_{m-1} $<br>$\quad$ 所有的I&#x2F;O设备都被模型化为文件，所有的输入输出都被当作对相应文件的读和写来执行。<br>$\qquad$ 打开文件：创建描述符<br>$\qquad$ 每个进程开始时都有三个打开的文件：标准输入(0), 标准输出(1), 标准错误(2)<br>$\qquad$ 改变当前的文件位置：每个打开的文件内核保持一个文件位置k。<br>$\qquad$ 读写文件：读：从文件复制n个字节到内存，将文件位置从k增加到k+n，当文件位置超过文件大小触发EOF，文件结尾没有EOF符号，写类似。<br>$\qquad$ 关闭文件：当应用完成了对文件的访问之后，它就通知内核关闭这个文件</p><h4 id="10-2-文件"><a href="#10-2-文件" class="headerlink" title="10.2 文件"></a>10.2 文件</h4><p>$\quad$ 每个Linux文件都有一个类型来表明它在系统中的角色。<br>$\qquad$ <strong>普通文件</strong>包括任意数据。区分文本文件和二进制文件<br>$\qquad$ <strong>目录</strong>是包含一组连接的文件。其中每个链接都将一个文件名映射到一个文件（mkdir创建，ls查看，rmdir删除）.是到目录自身的链接，..是到父目录的链接。<br>$\qquad$ <strong>套接字</strong>是用来与另一个进程进行跨网络通信的文件<br>Linux内核将所有文件都组合成一个目录层次结构，由名为&#x2F;的根目录确定。系统中的每一个文件都是根目录的直接或间接后代。<br>$\qquad$ <strong>其它类型</strong>诸如命名通道，符号链接，字符，块设备。<br><img src="/../icsmg/20230214221030.png"><br>$\quad$ 每一个进程都有一个当前工作目录，可以用cd命令修改<br>$\qquad$ 绝对路径名：以一个斜杠开始，表示从根节点开始的路径<br>$\qquad$ 相对路径名：以文件名开始，表示从当前工作目录开始的路径</p><h4 id="10-3-打开和关闭文件"><a href="#10-3-打开和关闭文件" class="headerlink" title="10.3 打开和关闭文件"></a>10.3 打开和关闭文件</h4><p>$\quad$ 调用open函数来打开一个已经存在的文件或者创建一个新文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">char</span> *filename,<span class="hljs-type">int</span> flags,<span class="hljs-type">mode_t</span> mode)</span></span>;<span class="hljs-comment">//成功返回文件描述符，出错返回-1；</span><br></code></pre></td></tr></table></figure><p>$\qquad$ flags:访问模式：O_RDONLY只读；O_WRONLY只写；ORDWR可读可写<br>$\qquad$ $\qquad$ 写｜接上掩码为写提供一些额外的指示：<br>$\qquad$ $\qquad$ $\qquad$ O_CREAT：如果文件不存在，创建截断的文件<br>$\qquad$ $\qquad$ $\qquad$ O_TRUNC：文件已经存在，截断它<br>$\qquad$ $\qquad$ $\qquad$ O_APPEND：设定文件位置在文件的结尾<br>$\qquad$ mode：访问权限<br><img src="/../icsmg/20230214222419.png"><br>$\quad$ close函数用于关闭已经打开的文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span>;<span class="hljs-comment">//成功返回0，出错-1</span><br></code></pre></td></tr></table></figure><h4 id="10-4-读和写文件"><a href="#10-4-读和写文件" class="headerlink" title="10.4 读和写文件"></a>10.4 读和写文件</h4><p>$\quad$ 调用read和write函数来执行输入与输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">void</span> *buf,<span class="hljs-type">size_t</span> n)</span></span>;<span class="hljs-comment">//成功返回读的字节数，EOF返回0，出错-1</span><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf,<span class="hljs-type">size_t</span> n)</span></span>;<span class="hljs-comment">//成功返回写的字节数，出错-1</span><br></code></pre></td></tr></table></figure><p>$\quad$ 不足值：<br>$\qquad$ 读时遇到EOF<br>$\qquad$ 从终端读文本行：不足值等于文本行大小<br>$\qquad$ 读和写网络套接字：内部缓冲约束和网络延迟</p><h4 id="10-5-用RIO包健壮地读写"><a href="#10-5-用RIO包健壮地读写" class="headerlink" title="10.5 用RIO包健壮地读写"></a>10.5 用RIO包健壮地读写</h4><p><strong>无缓冲的输入输出函数</strong><br>$\quad$ 直接在内存和文件之间传送数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">rio_readn</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">void</span> *usrbuf,<span class="hljs-type">size_t</span> n)</span></span>;<br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">rio_writen</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">void</span> *usrbuf,<span class="hljs-type">size_t</span> n)</span></span>;<span class="hljs-comment">//返回规则同上</span><br></code></pre></td></tr></table></figure><p><strong>带缓冲的输入函数</strong><br>$\quad$ 带缓冲函数的调用不应和无缓冲的函数交叉使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">rio_readlineb</span>(<span class="hljs-type">rio_t</span> *rp,<span class="hljs-type">int</span> fd);<br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">rio_readlineb</span><span class="hljs-params">(<span class="hljs-type">rio_t</span> *rp,<span class="hljs-type">void</span> *usrbuf,<span class="hljs-type">size_t</span> maxlen)</span></span>;<br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">rio_readnb</span><span class="hljs-params">(<span class="hljs-type">rio_t</span> *rp,<span class="hljs-type">void</span> *usrbuf,<span class="hljs-type">size_t</span> n)</span></span>;<br></code></pre></td></tr></table></figure><h4 id="10-6-读取文件元数据"><a href="#10-6-读取文件元数据" class="headerlink" title="10.6 读取文件元数据"></a>10.6 读取文件元数据</h4><p>$\quad$ 调用stat和fstat，检索文件元数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">stat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename,<span class="hljs-keyword">struct</span> stat *buf)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fstat</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-keyword">struct</span> stat *buf)</span></span>;<span class="hljs-comment">//成功返回0，出错-1</span><br></code></pre></td></tr></table></figure><p>$\quad$ stat参数文件名，fstat参数描述符作为输入<br>填写stat数据结构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">stat</span><br>&#123;<br>    <span class="hljs-type">dev_t</span>          st_dev;<span class="hljs-comment">/* Devive */</span><br>    <span class="hljs-type">ino_t</span>          st_ino;<span class="hljs-comment">/* inode */</span><br>    <span class="hljs-type">mode_t</span>         st_mode;<span class="hljs-comment">/* Protection and file type (S_ISREG(普通文件），S_ISDIR（目录文件），S_ISSOCK（网络套接字））*/</span><br>    <span class="hljs-type">nlink_t</span>        st_nlink;<span class="hljs-comment">/* number of hard links */</span><br>    <span class="hljs-type">uid_t</span>          st_uid;<span class="hljs-comment">/* User ID of owner */</span><br>    <span class="hljs-type">gid_t</span>          st_gid;<span class="hljs-comment">/* Group ID of owner */</span><br>    <span class="hljs-type">dev_t</span>          st_rdev;<span class="hljs-comment">/* Device type */</span><br>    <span class="hljs-type">off_t</span>          st_size;<span class="hljs-comment">/* Total size,in bytes */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>  st_blksize;<span class="hljs-comment">/* Block size for filesystem I/O */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>  st_blocks;<span class="hljs-comment">/* Number of blocks allocated */</span><br>    <span class="hljs-type">time_t</span>         st_atime;<span class="hljs-comment">/* Time of last access */</span><br>    <span class="hljs-type">time_t</span>         st_mtime;<span class="hljs-comment">/* Time of last modiffication */</span><br>    <span class="hljs-type">time_t</span>         st_ctime;<span class="hljs-comment">/* Time of last change */</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="10-7-读取目录内容"><a href="#10-7-读取目录内容" class="headerlink" title="10.7 读取目录内容"></a>10.7 读取目录内容</h4><p>$\quad$ 用readdir系列函数来读取目录内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">DIR *<span class="hljs-title">opendir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span></span>;<span class="hljs-comment">//成功返回处理指针，否则NULL</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dirent</span> *<span class="hljs-built_in">readdir</span>(DIR *dirp);<span class="hljs-comment">//返回指向下一个目录项的指针，否则NULL</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">closedir</span><span class="hljs-params">(DIR *dirp)</span></span>;<span class="hljs-comment">//成功0，错误-1</span><br></code></pre></td></tr></table></figure><h4 id="10-8-共享文件"><a href="#10-8-共享文件" class="headerlink" title="10.8 共享文件"></a>10.8 共享文件</h4><p>$\quad$ 内核用三个相关的数据结构来表示打开的文件<br><strong>描述符表</strong><br>$\quad$ 每个进程都有独立的描述符表，每个打开的描述符表项指向文件表中的一个表项。<br><strong>文件表</strong><br>$\quad$ 所有进程共享<br><strong>v-node表</strong><br>$\quad$ 所有进程共享，包含stat信息</p><h4 id="10-9-I-x2F-O重定向"><a href="#10-9-I-x2F-O重定向" class="headerlink" title="10.9 I&#x2F;O重定向"></a>10.9 I&#x2F;O重定向</h4><p>$\quad$ 使用dup2函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dup2</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd,<span class="hljs-type">int</span> newfd)</span></span>;<span class="hljs-comment">//成功返回非负描述符，错误返回-1</span><br></code></pre></td></tr></table></figure><p>$\quad$ 复制oldfd并覆盖至newfd，若newfd已打开，则会先关闭newfd</p><h4 id="10-10-标准I-x2F-O"><a href="#10-10-标准I-x2F-O" class="headerlink" title="10.10 标准I&#x2F;O"></a>10.10 标准I&#x2F;O</h4><p>$\quad$ C语言库，<br>$\quad$ 流：指向FILE类型结构的指针<br>$\quad$ 标准输入(stdin), 标准输出(stdout), 标准错误(stderr)<br>$\quad$ 高级输入输出函数（fopen和fclose，fread和fwrite，fgets和fputs，scanf和printf）</p><p>$\quad$ 只要有可能就使用标准I&#x2F;O<br>$\quad$ 不要用scanf或rio_readlineb来读二进制文件<br>$\quad$ 对网络套接字I&#x2F;O使用RIO<br><img src="/../icsmg/20230214230707.png"></p><hr><h3 id="LAB"><a href="#LAB" class="headerlink" title="LAB:"></a>LAB:</h3><p><strong>此章节后完成<a href="https://github.com/Aki-yzh/PKU-ICS-2022/tree/main/LABS/6-shelllab">shelllab(134.0&#x2F;138.0)</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9-虚拟内存</title>
    <link href="/2023/02/18/9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    <url>/2023/02/18/9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="对应-CSAPP-第九章节"><a href="#对应-CSAPP-第九章节" class="headerlink" title="对应 CSAPP 第九章节"></a>对应 CSAPP 第九章节</h2><span id="more"></span><h1 id="ICS"><a href="#ICS" class="headerlink" title="ICS"></a><a href="https://aki-yzh.github.io/2023/02/18/1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8&%E7%9B%AE%E5%BD%95">ICS</a></h1><hr><h2 id="九、虚拟内存"><a href="#九、虚拟内存" class="headerlink" title="九、虚拟内存"></a>九、虚拟内存</h2><p>$\quad$ 虚拟内存是硬件异常，硬件地址翻译，主存，磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的，一致的和私有的地址空间。<br>$\quad$ 虚拟内存提供了三个重要能力：<br>$\quad$  1. 它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，高效地使用了主存。<br>$\quad$  2. 它为每个进程提供了一致的地址空间，从而简化了内存管理<br>$\quad$  3. 它保护了每个进程的地址空间不被其他进程破坏</p><h4 id="9-1-物理和虚拟寻址"><a href="#9-1-物理和虚拟寻址" class="headerlink" title="9.1 物理和虚拟寻址"></a>9.1 物理和虚拟寻址</h4><p>$\quad$ 主存被组织成一个由M个连续的字节大小的单元组成的数组，每个字节都有一个唯一的物理地址。<br>$\quad$ CPU访问内存的最自然的方式就是使用物理地址，我们把这种方式称为物理寻址。</p><p>$\quad$ 使用虚拟寻址，CPU通过生成一个虚拟地址来访问主存，这个虚拟地址在被传送到内存之前先转换成适当的物理地址。<br>$\quad$ 将一个虚拟地址转换为物理地址的任务叫做地址翻译，CPU上叫做内存管理单元的专用硬件利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容由操作系统管理。</p><h4 id="9-2-地址空间"><a href="#9-2-地址空间" class="headerlink" title="9.2 地址空间"></a>9.2 地址空间</h4><p>$\quad$ 地址空间是一个非负整数地址的有序集合。<br>$\quad$ 线性地址空间：地址空间中整数是连续的<br>$\quad$ 虚拟地址空间(N&#x3D;2^n)（n位地址空间）<br>$\quad$ 物理地址空间(M&#x3D;2^m)</p><h4 id="9-3-虚拟内存作为缓存的工具"><a href="#9-3-虚拟内存作为缓存的工具" class="headerlink" title="9.3 虚拟内存作为缓存的工具"></a>9.3 虚拟内存作为缓存的工具</h4><p>$\quad$ 虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组，每个字节有唯一的虚拟地址，作为到数组的索引。<br>$\quad$ 磁盘上数组的内容被缓存在主页中。<br>$\quad$ VM系统通过将虚拟内存分割为称为虚拟页的大小固定的块来处理这个问题。每个虚拟页的大小为$P&#x3D;2^p$ 个字节。类似的，物理内存被分配为物理页，大小也为P字节。（物理页也被称为页帧）<br>$\quad$ 在任意时刻，虚拟页面的集合都分为三个不相交的子集：<br>$\qquad$ 1. 未分配的：VM还未分配（或者创建）的页。没有任何数据与之相关联，因此也不占用任何磁盘空间<br>$\qquad$ 2. 缓存的：已缓存在物理内存中的已分配页<br>$\qquad$ 3. 未缓存的： 未缓存在物理内存中的已分配页</p><p>$\quad$ DRAM缓存（虚拟内存系统的缓存）：虚拟页往往很大，全相联，总是使用写回</p><p><strong>页表</strong><br>$\quad$ 页表存放在物理内存中，将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转化为物理地址时，都会读取页表。<br>$\quad$ 页表就是个页表条目(PTE)的数组，每个PTE是由一个有效位和一个n位地址字段组成的。<br><img src="/../icsmg/20230215212321.png"><br><strong>页命中</strong><br>$\quad$ 虚拟地址-&gt;索引-&gt;有效位1-&gt;物理地址<br><img src="/../icsmg/20230215212633.png"><br><strong>缺页</strong><br>$\quad$ DRAM缓存不命中-&gt;调用内核中的异常处理程序-&gt;页面调度（按需页面调度）<br><img src="/../icsmg/20230215213456.png"><br><strong>分配页面</strong><br><img src="/../icsmg/20230215212920.png"><br>$\quad$ 局部性保证了任意时刻程序趋向于在一个较小的活动页面集合上工作</p><h4 id="9-4-虚拟内存作为内存管理的工具"><a href="#9-4-虚拟内存作为内存管理的工具" class="headerlink" title="9.4 虚拟内存作为内存管理的工具"></a>9.4 虚拟内存作为内存管理的工具</h4><p>$\quad$ 按需页面调度+独立地址空间&#x3D;简化链接、简化加载、简化共享、简化内存分配</p><h4 id="9-5-虚拟内存作为内存保护的工具"><a href="#9-5-虚拟内存作为内存保护的工具" class="headerlink" title="9.5 虚拟内存作为内存保护的工具"></a>9.5 虚拟内存作为内存保护的工具</h4><p>$\quad$ 三个许可位：SUP，READ，WRITE表示权限</p><h4 id="9-6-地址翻译"><a href="#9-6-地址翻译" class="headerlink" title="9.6 地址翻译"></a>9.6 地址翻译</h4><p><img src="/../icsmg/20230215213421.png"><br>$\quad$ 形式上来说，地址翻译是一个N元素的虚拟地址空间中的元素（VAS）和一个M元素的物理地址空间（PAS）中元素之间的映射<br>$\qquad \qquad \quad MAP:VAS\rightarrow PAS \cup \emptyset$<br><img src="/../icsmg/20230215214022.png"><br>$\quad$ PPO和VPO是相同的<br><img src="/../icsmg/20230215214156.png"><br>$\quad$ 页面命中后，CPU硬件：<br>$\qquad$ 1. 处理器生成一个虚拟地址，并把它传给MMU<br>$\qquad$ 2. MMU生成PTE地址，并从高速缓存&#x2F;主存中请求得到它<br>$\qquad$ 3. 高速缓存&#x2F;主存向MMU返回PTE<br>$\qquad$ 4. MMU构造物理地址，并把它传送给高速缓存&#x2F;主存<br>$\qquad$ 5. 高速缓存&#x2F;主存返回所请求的数据字给处理器<br>$\quad$ 缺页时：<br>$\qquad$ 1. 处理器生成一个虚拟地址，并把它传给MMU<br>$\qquad$ 2. MMU生成PTE地址，并从高速缓存&#x2F;主存中请求得到它<br>$\qquad$ 3. 高速缓存&#x2F;主存向MMU返回PTE<br>$\qquad$ 4. PTE的有效位是0，MMU触发了一次异常，传递CPU中的控制到操作系统内核中的缺页异常处理程序<br>$\qquad$ 5. 缺页处理程序确定出物理内存中的牺牲页，如果这个页面已经被修改了，则把它换出到磁盘<br>$\qquad$ 6. 缺页处理程序调入新的页面，并更新内存中的PTE<br>$\qquad$ 7. 缺页处理程序返回到原来的进程，再次执行导致缺页的指令。CPU将引起缺页的虚拟地址重新发送给MMU。因为虚拟页面现在换存在物理内存中，所以就会命中，在MMU执行了页面命中后，主存将所请求字返回给处理器。</p><p><img src="/../icsmg/20230215214326.png"><br><strong>结合高速缓存和虚拟内存</strong><br><img src="/../icsmg/20230215215737.png"><br><strong>利用TLB加速地址翻译</strong><br>$\quad$ TLB：小的，虚拟寻址的缓存，称为快表，每一行保存着一个由单个PTE组成的块。<br>$\quad$ 若TLB有2^t个组，则VPN最低t位为TLB索引（TLBI）</p><p><img src="/../icsmg/20230215220155.png"><br>$\quad$ 1. CPU产生一个虚拟地址<br>$\quad$ 2. MMU从TLB中取出相应的PTE<br>$\quad$ 3. MMU将这个虚拟地址翻译成一个物理地址，并且将它发送到高速缓存&#x2F;主存。<br>$\quad$ 4. 高速缓存&#x2F;主存将所请求的数据字返回给CPU<br><img src="/../icsmg/20230215215804.png"><br><strong>多级页表</strong></p><p><img src="/../icsmg/20230215220457.png"><br>$\quad$ 每个高级PTE指向一个下一级页表的基址，逐级访问直到最终访问到目标地址，只有一级页表才需要总是保存在主存中。<br>$\quad$ 能减小内存要求<br>$\quad$ 若一级页表中一个PTE是空的，相应的二级页表根本不会存在<br><img src="/../icsmg/20230215220429.png"></p><h4 id="9-7-Intel-Core-i7-x2F-Linux-内存系统"><a href="#9-7-Intel-Core-i7-x2F-Linux-内存系统" class="headerlink" title="9.7 Intel Core i7&#x2F;Linux 内存系统"></a>9.7 Intel Core i7&#x2F;Linux 内存系统</h4><p><strong>Intel Core i7</strong><br>$\quad$ 四级页表层次结构，64位内存地址，40位PPN，4个许可位，1个标记位，引用位(A)，修改位(D)<br><strong>Linux虚拟内存系统</strong><br>$\quad$ 基本同上述虚拟内存系统</p><h4 id="9-8-内存映射"><a href="#9-8-内存映射" class="headerlink" title="9.8 内存映射"></a>9.8 内存映射</h4><p>$\quad$ 将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容<br>$\quad$ 映射对象：普通文件和匿名文件</p><p><strong>共享对象&amp;私有对象</strong><br>$\quad$ 映射了同一个共享对象的各进程对这个对象的写是相互可见的，也会反映到磁盘上的原始对象中<br>$\quad$ 对私有区域的写操作不会反映到磁盘上的对象中<br>$\quad$ 写时复制：试图写时会触发保护故障，创建一个新的副本（写操作仅执行在该副本上，且其他进程不可见）<br><img src="/../icsmg/20230215224447.png"><br><strong>再看fork</strong><br>$\quad$ 为新进程创建各种数据结构，PID<br>$\quad$ 两个进程的每个页面都标记为只读<br>$\quad$ 每个区域结构都标记为私有的写时复制<br>$\quad$ 为每个进程维护私有地址空间的抽象概念</p><p><strong>再看execve</strong><br>$\quad$ 删除已存在的用户区域<br>$\quad$ 映射私有区域（都是私有的，写时复制的）<br>$\quad$ 映射共享区域<br>$\quad$ 设置程序计数器(PC)，指向代码区域入口</p><p><strong>mmap与munmap：用户级内存映射</strong><br>$\quad$ mmap：创建新的虚拟内存区域，并将对象映射到这些区域中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *start,<span class="hljs-type">size_t</span> length,<span class="hljs-type">int</span> prot,<span class="hljs-type">int</span> flags,<span class="hljs-type">int</span> fd,<span class="hljs-type">off_t</span> offfset)</span></span>;<br><span class="hljs-comment">//成功返回指向映射区域的指针，出错返回MAP——FAILED（-1）</span><br></code></pre></td></tr></table></figure><p>$\quad$ prot：访问权限位：PROT_EXEC（页面可以被CPU执行的指令组成）；PROT_READ（页面可读）；PROT_WRITE（页面可写）；PROT_NONE（页面不能被访问）<br><img src="/../icsmg/20230215224830.png"></p><p>$\quad$ munmap：删除虚拟内存的start开始由接下来length字节构成的区域</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">munmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *start,<span class="hljs-type">size_t</span> length)</span></span>;<span class="hljs-comment">//成功返回0，出错返回-1</span><br></code></pre></td></tr></table></figure><h4 id="9-9-动态内存分配"><a href="#9-9-动态内存分配" class="headerlink" title="9.9 动态内存分配"></a>9.9 动态内存分配</h4><p><img src="/../icsmg/20230215225518.png"></p><p><strong>显示分配器</strong>：显式地释放已分配的块</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* 分配块 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">malloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span></span>;<span class="hljs-comment">//成功返回已分配块的指针，否则NULL</span><br><span class="hljs-comment">/* 释放块 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">free</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr)</span></span>;<br><span class="hljs-comment">/* 扩展/收缩堆 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">sbrk</span><span class="hljs-params">(<span class="hljs-type">intptr_t</span> incr)</span></span>;<br></code></pre></td></tr></table></figure><p>要求<br>$\quad$ 处理任意请求序列：约束：每个释放必须对应一个已分配的块<br>$\quad$ 立即响应请求：不允许重排或缓冲<br>$\quad$ 只使用堆<br>$\quad$ 对齐块：对齐块使得能保存任何类型的数据对象<br>$\quad$ 不修改已分配的块<br>目标<br>$\quad$ 最大化吞吐率<br>$\quad$ 吞吐率：单位时间完成的请求数<br>$\quad$ 最大化内存利用率<br>$\quad$ 峰值利用率：聚集有效载荷&#x2F;堆大小<br><img src="/../icsmg/20230215225953.png"><br><strong>碎片</strong><br>$\quad$ 内部碎片：已分配块比有效载荷大<br>$\quad$ 外部碎片：空闲内存分散</p><p><strong>隐式空闲链表</strong></p><p>$\quad$ 整个链表需要一个特殊标记的结束块<br>$\quad$ 空闲块之间通过头部的块大小隐式地连接<br><img src="/../icsmg/20230215230110.png"><br>放置已分配的块<br> $\quad$ 首次适配<br> $\quad$ 下一次适配（内存利用率最低）<br> $\quad$ 最佳适配（内存利用率最高）<br>分割空闲块<br>$\quad$ 获取额外堆内存<br>合并空闲块<br> 立即合并<br> 推迟合并<br> 带边界标记的合并（脚部）<br><img src="/../icsmg/20230215230135.png"><br><strong>显式空闲链表</strong><br><img src="/../icsmg/20230215230249.png"></p><p><strong>分离空闲链表</strong><br>$\quad$ 维护多个空闲链表，每个链表中的块有相似的大小<br>$\quad$ 简单分离存储：一个类中所有块大小都一样，不分割不合并<br>$\quad$ 分离适配：首次适配，分割，释放后合并<br>$\quad$ 伙伴系统：按2的幂进行分配、分割、合并</p><p>详见malloclab</p><h4 id="9-10-垃圾收集"><a href="#9-10-垃圾收集" class="headerlink" title="9.10 垃圾收集"></a>9.10 垃圾收集</h4><p>$\quad$ 垃圾收集器：动态内存分配器<br>$\quad$ 自动释放程序不再需要的已分配块<br>$\quad$ 内存视为有向可达图，不可达节点-&gt;垃圾<br>$\quad$ Mark&amp;Sweep垃圾收集器<br>$\quad$ Mark阶段：标记根节点和所有可达的后继<br>$\quad$ Sweep阶段：释放每个未标记的已分配块</p><h4 id="9-11-C程序中与内存有关的错误"><a href="#9-11-C程序中与内存有关的错误" class="headerlink" title="9.11 C程序中与内存有关的错误"></a>9.11 C程序中与内存有关的错误</h4><p>$\quad$ 间接引用坏指针、读未初始化的内存、允许栈缓冲区溢出、造成错位错误、假设指针和它们指向的对象是相同大小的、引用指针而不是它所指向的对象、误解指针运算、引用不存在的变量、引用空闲堆块中的数据、引起内存泄漏……</p><hr><h3 id="LAB"><a href="#LAB" class="headerlink" title="LAB:"></a>LAB:</h3><p><strong>此章节后完成<a href="https://github.com/Aki-yzh/PKU-ICS-2022/tree/main/LABS/7-malloclab">malloclab(103.0&#x2F;120.0)</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8-异常控制流</title>
    <link href="/2023/02/18/8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/"/>
    <url>/2023/02/18/8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="对应-CSAPP-第八章节"><a href="#对应-CSAPP-第八章节" class="headerlink" title="对应 CSAPP 第八章节"></a>对应 CSAPP 第八章节</h2><span id="more"></span><h1 id="ICS"><a href="#ICS" class="headerlink" title="ICS"></a><a href="https://aki-yzh.github.io/2023/02/18/1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8&%E7%9B%AE%E5%BD%95">ICS</a></h1><hr><h2 id="八、异常控制流（ECF）"><a href="#八、异常控制流（ECF）" class="headerlink" title="八、异常控制流（ECF）"></a>八、异常控制流（ECF）</h2><p>$\quad$ ECF是操作系统用来实现I&#x2F;O，进程和虚拟内存的基本机制。</p><h4 id="8-1-异常"><a href="#8-1-异常" class="headerlink" title="8.1 异常"></a>8.1 异常</h4><p>$\quad$ 异常就是控制流中的突变，用来响应处理器状态中的某种变化。<br>$\quad$ 当处理器状态发生一个重要的变化时，处理器正在执行某个当前指令 $I_{curr}$ .在处理器中，状态被编码为不同的位和信号。状态变化称为事件，事件可能和当前指令的执行直接相关。<br><img src="/../icsmg/20230214154528.png"><br>$\quad$ 在任何情况下，当处理器检测到有事件发生时，它就会通过一张叫做异常表的跳转表，进行一个间接过程调用（异常），到一个专门设计用来处理这类事件的操作系统子程序（异常处理程序）。当异常处理程序完成处理后，根据引起异常的事件的类型，会发生以下三种情况中的一种：<br>$\quad$ 1) 处理程序将控制返回给当前指令 $I_{curr}$ ,即当事件发生时正在执行的指令。<br>$\quad$ 2) 处理程序将控制返回给 $I_{next}$ ,如果没有异常将会执行的下一条指令<br>$\quad$ 3) 处理程序终止被中断的程序</p><p><strong>异常的分类</strong><br><img src="/../icsmg/20230214155537.png"><br>$\quad$ 1. 中断：<br>$\quad$  中断是异步发生的，是来自处理器外部的I&#x2F;O设备的信号的结果。<br><img src="/../icsmg/20230214155452.png"><br>造成以下异常的指令称为故障指令。<br>$\quad$ 2. 陷阱：<br>$\quad$   陷阱是有意的异常，是执行一条指令的结果，是同步的，总是返回到下一条指令，陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做系统调用。<br><img src="/../icsmg/20230214155811.png"><br>$\quad$ 3. 故障：<br>$\quad$   故障由错误情况引起，它可能被故障处理程序修正。如果能被修正，则将控制返回到引起故障的指令，否则返回内核中的abort例程。</p><p><img src="/../icsmg/20230214155859.png"><br>$\quad$ 4.  终止：<br>$\quad$  终止是不可恢复的致命错误造成的结果，通常是一些硬件错误。</p><p><strong>Linux&#x2F;x86-64 系统中的异常</strong></p><table><thead><tr><th>异常号</th><th>描述</th><th>异常类别</th></tr></thead><tbody><tr><td>0</td><td>除法错误（浮点异常）</td><td>故障</td></tr><tr><td>13</td><td>一般保护故障</td><td>故障</td></tr><tr><td>14</td><td>缺页</td><td>故障</td></tr><tr><td>18</td><td>机器检查</td><td>终止</td></tr><tr><td>32~255</td><td>操作系统定义的异常</td><td>中断或陷阱</td></tr></tbody></table><p><strong>Linux&#x2F;x86-64 系统调用</strong><br><img src="/../icsmg/20230214161004.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//用write写helloword</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">write</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;hello,world\n&quot;</span>,<span class="hljs-number">13</span>);<br>    _exit(<span class="hljs-number">0</span>);<br>&#125;<span class="hljs-comment">//第一个参数将输出发送到stdout，第二个参数是要写的字节序列，第三个参数是要写的字节数。</span><br></code></pre></td></tr></table></figure><h4 id="8-2-进程"><a href="#8-2-进程" class="headerlink" title="8.2 进程"></a>8.2 进程</h4><p>$\quad$ 进程的经典定义是一个执行中程序的实例。系统中的每个程序都在某个进程的上下文中。上下文是由程序正确运行所需的状态组成的，这个状态包括存放在内存中的程序的代码和数据，它的栈，通用目的寄存器的内容，程序计数器，环境变量以及打开文件描述符的集合。</p><p><strong>逻辑控制流</strong><br>$\quad$ 进程是轮流使用处理器的，每个进程执行它的流的一部分，然后被抢占（暂时挂起），然后轮到其他进程。<br><strong>并发流</strong><br>$\quad$ 一个逻辑流的执行在时间上与另一个流重叠<br>$\quad$ 并发流的进程实际上仍是交错的，处理器不会同时处理两个进程<br><strong>私有地址空间</strong><br>$\quad$ 这个空间中某个地址关联的内存不能被其他进程读写<br>$\quad$ 每个私有地址空间都有相同的通用结构<br><strong>用户模式与内核模式</strong><br>$\quad$ 设置了模式位就运行在内核模式中，否则运行在用户模式中。<br>$\quad$ 内核模式可以执行任何指令，访问系统的任何位置。<br>$\quad$ 进程从用户模式变为内核模式的唯一方法是通过异常，处理程序运行在内核模式中，当它返回到$\quad$ 应用程序代码时，处理器改回到用户模式<br><strong>上下文切换（控制转移）</strong><br>$\quad$ 保存当前进程的上下文-&gt;恢复某个先前被抢占的进程保存的上下文-&gt; 将控制传递给新恢复的进程<br><img src="/../icsmg/20230214162756.png"></p><h4 id="8-3-系统调用错误处理"><a href="#8-3-系统调用错误处理" class="headerlink" title="8.3 系统调用错误处理"></a>8.3 系统调用错误处理</h4><p>$\quad$ 默认使用错误处理包装函数，使代码简洁</p><h4 id="8-4-进程控制"><a href="#8-4-进程控制" class="headerlink" title="8.4 进程控制"></a>8.4 进程控制</h4><p><strong>获取进程id</strong><br>$\quad$ 每个进程都有一个唯一的正数进程ID（PID）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">getpid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<span class="hljs-comment">//返回调用进程的pid</span><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">getppid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<span class="hljs-comment">//返回父进程的pid</span><br></code></pre></td></tr></table></figure><p><strong>创建和终止进程</strong><br>$\quad$ 进程总是处于以下三种状态之一：<br>$\quad$ $\quad$ 运行：要么在CPU上执行，要么在等待被执行且最终会被内核调度<br>$\quad$ $\quad$ 停止： 进程的执行被挂起，且不会被调度。<br>$\quad$ $\quad$ 终止： 收到终止信号&#x2F;从主程序返回&#x2F;调用exit函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">exit</span><span class="hljs-params">(<span class="hljs-type">int</span> status)</span></span>;<span class="hljs-comment">//exit函数以status退出状态来终止进程。</span><br></code></pre></td></tr></table></figure><p>$\quad$父进程通过调用fork函数创建一个新的运行的子进程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>$\quad$ 两个进程并发执行，地址空间相同但独立，共享打开的文件<br>$\quad$ 调用一次，返回两次，父进程返回子进程的PID，子进程总是返回0。<br>$\quad$ 父进程和子进程之间最大的区别在于他们拥有不同的PID。<br>$\quad$ 返回值提供了一个明确的方法来分辨程序是在父进程还是在子进程中执行。<br>进程图<br>$\quad$ 每个顶点是一条语句的执行<br>$\quad$ main是起始点<br>$\quad$ 并发式程序的语句执行存在拓扑排序<br><img src="/../icsmg/20230214164108.png"><br><strong>回收子进程</strong><br>$\quad$ 子进程终止后保持一个已终止的状态直到被父进程回收<br>$\quad$ 父进程终止后内核会安排init(PID&#x3D;1)为其所有孤儿进程的养父<br>$\quad$ 一个进程可以通过调用waitpid函数来等待它的子进程终止或停止,成功返回子进程的pid，如果WNOHANG，返回0，否则返回-1.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">waitpid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid , <span class="hljs-type">int</span> *statusp,<span class="hljs-type">int</span> options)</span></span>;<br></code></pre></td></tr></table></figure><p>$\quad$ pid: 判定等待集合（&gt;0，单一子进程；&#x3D;-1，所有子进程）<br>$\quad$options：可修改的默认行为(WNOHANG：任何子进程都未终止返回0； WUNTRACED：$\quad$挂起调用进程的执行，直到等待集合中的一个进程变为已终止或被停止； WCONTINUED：挂起调用进程的执行，知道等待集合中的一个被停止的进程收到SIGCONT信号重新开始执行)（也可以用｜组合起来）<br>$\quad$ statusp：检查已回收子进程的退出状态<br>$\qquad$ WIFEXITED：子进程通过调用exit或者return正常终止，true<br>$\qquad$ WEXITSIATUS：返回一个正常终止子进程的退出状态<br>$\qquad$ WIFSIGNALED： 如果子进程是因为一个未被捕获的信号终止的，那么就返回真<br>$\qquad$ WTERMSIG：返回导致子进程终止的信号的编号<br>$\qquad$ WIFSTOPPED： 如果引起返回的子进程当前是停止的，那么就返回真<br>$\qquad$ WSTOPSIG：返回引起子进程停止的信号的编号<br>$\qquad$ WIFCONTINUED：如果子进程收到SIGCONT信号重新启动，则返回真。<br>$\quad$ 错误条件：如果调用进程没有子进程，那么waitpid返回-1，并设置errno为ECHILD，如果waidpid函数被一个信号中断，返回-1，设置errno为EINTR。<br><strong>wait函数</strong><br>$\quad$ 等价于waitpid(-1,&amp;status,0);<br><strong>让进程休眠</strong><br>$\quad$ sleep函数将一个进程挂起一段指定的时间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> secs)</span></span>;<br></code></pre></td></tr></table></figure><p>$\quad$ 如果请求的时间量已经到了，返回0，否则返回还剩下要休眠的秒数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pause</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>$\quad$ pause函数让调用函数休眠直到该进程收到一个信号<br><strong>加载并运行程序</strong><br>$\quad$ execve函数在当前进程的上下文中加载并运行一个新程序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execve</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename,<span class="hljs-type">const</span> <span class="hljs-type">char</span> *argv[],<span class="hljs-type">const</span> <span class="hljs-type">char</span> *envp[])</span></span>;<br></code></pre></td></tr></table></figure><p>$\quad$ 加载并运行可执行目标文件filename，且带参数列表argv和环境变量列表envp。成功不返回，错误返回-1。<br><strong>shell：交互型应用级程序</strong><br>$\quad$ 命令行-&gt;parseline-&gt;builtincommand<br>$\quad$ 最后一个参数：<br>$\qquad$ &amp;-&gt;后台执行<br>$\qquad$ 其他-&gt;前台执行</p><h4 id="8-5-信号"><a href="#8-5-信号" class="headerlink" title="8.5 信号"></a>8.5 信号</h4><p><img src="/../icsmg/20230214174524.png"><br><strong>发送信号</strong><br>$\quad$ 内核通过更新目的进程中上下文中的某个状态，发送一个信号给目的进程。<br>$\quad$ 原因：1.内核检测到一个系统事件，比如除0错误或子进程终止2.一个进程调用了kill函数，显式地要求内核发送一个信号给目的进程。<br>$\quad$ 一个进程可以发送信号给它自己。<br>$\quad$ 发送信号基于进程组，进程组由一个正整数进程组ID来标识。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">getpgrp</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<span class="hljs-comment">//返回当前进程的进程组ID</span><br></code></pre></td></tr></table></figure><p>$\quad$ 默认地，一个子进程和它的父进程同属于一个进程组，一个进程可以通过setpgid来改变自己或者其他进程的进程组。将进程pid的进程组改为pgid，如果pid是0，那么就使用当前进程的PID，如果pgid是0，那么就用pid指定的进程的PID作为进程组id。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">setpgid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid,<span class="hljs-type">pid_t</span> pgid)</span></span>;<span class="hljs-comment">//成功返回0，错误返回-1；</span><br></code></pre></td></tr></table></figure><p>发送途径：<br>$\qquad$ <em>用&#x2F;bin&#x2F;kill程序发送信号</em>：&#x2F;bin&#x2F;kill -9 114514 -&gt;发送信号9给进程114514，符号表示发给进程组中的每个进程。<br>$\qquad$ 从键盘发送信号<br>$\qquad$ 用kill函数发送信号 ,pid大于0，发送sig到pid；pid等于0，发送sig到调用进程所在进程组中的每个进程，pid小于0，发送sig到|pid|中的每个进程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kill</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid ,<span class="hljs-type">int</span> sig)</span></span>;<span class="hljs-comment">//成功返回0，错误返回-1</span><br></code></pre></td></tr></table></figure><p>$\qquad$ 用alarm函数发送信号：向自己发送SIGALRM信号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">alarm</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> secs)</span></span>;<span class="hljs-comment">//返回前一次闹钟剩余的秒数，若没设定，返回0</span><br></code></pre></td></tr></table></figure><p>$\qquad$<br><strong>接收信号</strong><br>$\quad$ 目的进程被内核强迫对信号作出反应，进程p从内核模式切换到用户模式时，若待处理信号集合为空，控制传递到p的下一条指令；若非空，选择某个信号k，强制p接受k</p><p><img src="/../icsmg/20230214193024.png"></p><p><strong>待处理信号</strong></p><p>$\quad$ 发出但没有被接收的信号<br>$\quad$ 任何时候一个类型至多有一个待处理信号（用pending位向量维护，传送时设置，接收时清除）</p><p><strong>阻塞&#x2F;解除阻塞信号</strong></p><p>$\quad$ 隐式阻塞：默认阻塞当前正在处理信号的同类型信号<br>$\quad$ 显式阻塞：sigprocmask函数和相关函数，明确地阻塞&#x2F;解除阻塞指定的信号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigprocmask</span><span class="hljs-params">(<span class="hljs-type">int</span> how,<span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *set,<span class="hljs-type">sigset_t</span> *oldset)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigemptyset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *set)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigfillset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *set)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigaddset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *set,<span class="hljs-type">int</span> signum)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigdelset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *set,<span class="hljs-type">int</span> signum)</span></span>;<br><span class="hljs-comment">/* 成功返回0，出错-1 */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigismember</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *set,<span class="hljs-type">int</span> signum)</span></span>;<br><span class="hljs-comment">//signum是set成员返回1，不是则0，出错-1</span><br></code></pre></td></tr></table></figure><p>how：<br>$\qquad$ SIG_BLOCK：把set中的信号添加到blocked中<br>$\qquad$ SIGUNBLOCK：从block中删除set中的信号<br>$\qquad$ SIG_SETMASK：BLOCK&#x3D;set</p><p><strong>编写信号处理程序</strong><br>$\quad$ 安全的信号处理：<br>$\qquad$ 处理程序尽可能简单<br>$\qquad$ 只调用异步信号安全的函数（可重入，不可被信号处理程序中断）<br>$\qquad$ $\qquad$ SIO包：安全打印简单信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;csapp.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">sio_putl</span><span class="hljs-params">(<span class="hljs-type">long</span> v)</span></span>;<span class="hljs-comment">//向标准输出传送long类型数</span><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">sio_puts</span><span class="hljs-params">(<span class="hljs-type">char</span> s[])</span></span>;<span class="hljs-comment">//向标准输出传送一个字符串</span><br></code></pre></td></tr></table></figure><p>$\qquad$ 保存和恢复errno<br>$\qquad$ 阻塞所有信号，保护对共享全局数据结构的访问<br>$\qquad$ 用volatile声明全局变量-&gt;阻止编译器缓存变量<br>$\qquad$ 用sig_atomic_t声明标志<br><strong>同步流以避免并发错误</strong><br>$\qquad$ 由于父进程和子进程并发进行，可能存在竞争，导致信号丢失<br>$\qquad$ 解决：调用前阻塞信号</p><h4 id="8-6-非本地跳转"><a href="#8-6-非本地跳转" class="headerlink" title="8.6 非本地跳转"></a>8.6 非本地跳转</h4><p>$\quad$ 将控制直接从一个函数转移到另一个函数（无需调用返回）<br>$\quad$ 通过setjmp和longjmp提供</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;setjmp.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">setjmp</span><span class="hljs-params">(jmp_buf env)</span></span>;<span class="hljs-comment">//在env缓冲区中保存当前调用环境</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigsetjmp</span><span class="hljs-params">(sigjmp_buf env,<span class="hljs-type">int</span> savesigs)</span></span>;<span class="hljs-comment">//从env缓冲区恢复调用环境，并触发最近一个setjmp的返回</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7-链接</title>
    <link href="/2023/02/18/7-%E9%93%BE%E6%8E%A5/"/>
    <url>/2023/02/18/7-%E9%93%BE%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="对应-CSAPP-第七章节"><a href="#对应-CSAPP-第七章节" class="headerlink" title="对应 CSAPP 第七章节"></a>对应 CSAPP 第七章节</h2><span id="more"></span><h1 id="ICS"><a href="#ICS" class="headerlink" title="ICS"></a><a href="https://aki-yzh.github.io/2023/02/18/1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8&%E7%9B%AE%E5%BD%95">ICS</a></h1><hr><h2 id="七、链接"><a href="#七、链接" class="headerlink" title="七、链接"></a>七、链接</h2><p>$\quad$ 链接是把各种代码和数据片段收集并组合成一个单一文件的过程，这个文件可被加载（复制）到内存并执行，链接可以执行于编译时，也就是在源代码被译为机器代码时，也可以执行于加载时，甚至可以执行于运行时。早期链接是手动执行的，而在现代系统中，链接是由链接器自动执行的。<br>$\quad$ 链接器使得分离编译成为可能。</p><p>$\quad$ 编译器驱动程序先运行C预处理器cpp，把源程序翻译成一个ASCII码的中间程序main.i，然后运行C编译器ccl把main.i翻译成main.s,最后运行汇编器as把main.i翻译成ASCII语言汇编文件main.o，另一边同样流程生成swap.o，最后运行链接器程序ld，将main.o和swap.o以及一些必要的系统目标文件组合起来，创建一个可执行目标文件p。</p><p><img src="/../icsmg/20221119215951.png"></p><p>$\quad$ 要执行可执行文件p，shell调用操作系统中一个叫做加载器的函数，将p中的代码复制到内存，然后将控制转移到这个程序的开头。</p><h4 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h4><p>$\quad$ 静态链接器以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的，可以加载和运行的可执行目标文件作为输出。输出的可重定位目标文件由各种不同的代码和数据节组成，每一节都是一个连续的字节序列<br>$\quad$ 为了构造可执行性文件，链接器必须完成两个主要任务：<br>$\quad$ $\quad$ 1.符号解析：每一个符号对应于一个函数，一个全局变量或者一个静态变量（static），使得每一个符号引用恰好和每一个符号定义关联起来<br>$\quad$ $\quad$ 2.重定位：编译器和汇编器生成从地址0开始的代码和数据节，链接器通过把每个符号定义和一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用。</p><p>$\quad$ 目标文件有三种形式：<br>$\quad$ $\quad$ 1.可重定位目标文件：包含二进制代码和数据，可以在编译时和其他可重定位文件合并。<br>$\quad$  $\quad$ $\quad$ .text:已编译程序的机器代码<br>$\quad$ $\quad$ $\quad$.rodata：只读数据，比如printf语句中的格式串“%d……”和开关语句的跳转表<br>$\quad$ $\quad$ $\quad$.data：已经初始化的全局和静态C变量<br>$\quad$ $\quad$ $\quad$.bss: 未初始化的全局和静态C变量<br>$\quad$ $\quad$ $\quad$.symtab：符号表<br>$\quad$ $\quad$ $\quad$.debug：调试符号表<br>$\quad$ $\quad$ $\quad$ 其余不重要</p><p><img src="/../icsmg/20221119221349.png"><br>$\quad$ $\quad$ $\quad$ $\quad$ <strong>符号表</strong><br>$\quad$ $\quad$ $\quad$ $\quad$ $\quad$ 对于一个模块m<br>$\quad$ $\quad$ $\quad$ $\quad$ $\quad$ 非静态的局部变量不在符号表里，由栈进行管理。<br>$\quad$ $\quad$ $\quad$ $\quad$ $\quad$ $\quad$ 有以下3种不同符号：<br>$\quad$ $\quad$ $\quad$ $\quad$ $\quad$ $\quad$ 1.由模块m定义并能被其他模块引用的全局符号（GLOBAL），对应于非静态的C函数和全局变量<br>$\quad$ $\quad$ $\quad$ $\quad$ $\quad$ $\quad$ 2.有其他模块定义并能被模块m引用的全局符号，成为外部符号，对应于在其他模块定义的非静态C函数和全局变量<br>$\quad$ $\quad$ $\quad$ $\quad$ $\quad$  $\quad$ 3.只被m定义和引用的局部符号（LOCAL），对应于带static属性的C函数和全局变量<br>$\quad$ $\quad$ $\quad$ $\quad$ $\quad$ 伪节：<br>$\quad$ $\quad$ $\quad$ $\quad$ $\quad$ $\quad$ ABS：不该被重定位的表<br>$\quad$ $\quad$ $\quad$ $\quad$ $\quad$ $\quad$ UNDEF:未被定义的符号，代表在本目标模块中被引用，却在其他地方定义的符号<br>$\quad$ $\quad$ $\quad$ $\quad$ $\quad$ $\quad$ COMMON 未初始化的全局变量<br>$\quad$ $\quad$ bind表示符号是全局还是局部（GLOBAL or LOCAL），type表示类型（FUNC or OBJECT）ndx表示所在的表（由节头部表中代表的整数索引或者UND表示）</p><p>$\quad$ $\quad$ 2.可执行目标文件：可以直接被复制到内存并执行，不在需要.rel节<br>$\quad$ $\quad$ 3.共享目标文件：特殊的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接。</p><p>$\quad$ 符号解析：<br>$\quad$ $\quad$ 编译器向汇编器输出每个全局符号，或者是强或者是弱，而汇编器隐含地把这个信息编码在可重定位目标文件的符号表里。函数和已初始化的全局变量是强符号，未初始化的全局变量时弱符号。<br>$\quad$ $\quad$ 规则：不允许有多个同名的强符号，优先选择强符号，不然任意选择。<br>$\quad$ 与静态库链接：<br>$\quad$ $\quad$ 所有的编译系统都提供一种机制，把所有相关的目标文件打包成一个单独的文件，称为静态库。可以用作链接器的输入。当链接器构造一个输出的可执行文件时，它只复制静态库里被应用程序引用的目标模块。<br>$\quad$ $\quad$ 利用静态库减少了可执行文件在磁盘和内存中的大小<br><img src="/../icsmg/20230215235042.png"><br>  $\quad$ 重定位：<br>$\quad$ 重定位由两步组成<br>$\quad$ $\quad$ $\quad$ 1.重定位节和符号定义：链接器把所有相同类型的节合并为同一类型的新的聚合节，内存地址赋给新的聚合节，此时程序中的每条指令和全局变量都有唯一的运行时的内存地址了。<br>$\quad$ $\quad$ $\quad$ 2.重定位节中的符号引用：修改符号引用使其指向正确的运行地址。<br>$\quad$ $\quad$ $\quad$ 重定位类型：<br>$\quad$ $\quad$ $\quad$ $\quad$ 1.R_X86_64_PC32：PC相对引用，距离PC当前运行值的偏移量<br>$\quad$ $\quad$ $\quad$ $\quad$ 2.R_X86_64_32:绝对引用，不需要进一步修改<br>$\quad$ $\quad$ $\quad$ $\quad$ 汇编器会在后一行上告知进行何种引用<br>$\quad$ $\quad$ $\quad$ $\quad$ 重定位的计算参考书P481，分为重定位相对引用的计算和绝对引用的计算。<br>$\quad$ $\quad$ $\quad$ 相对引用：<br>$\quad$ $\quad$ $\quad$ $\quad$ ADDR（s)&#x3D;ADDR(.text)<br>$\quad$ $\quad$ $\quad$ $\quad$ ADDR(r.symbol)&#x3D;ADDR(函数\变量名)<br>$\quad$ $\quad$ $\quad$ $\quad$ 运行时地址refaddr&#x3D;ADDR(s)+r.offset<br>$\quad$ $\quad$ $\quad$ $\quad$ *refptr&#x3D;ADDR(r.symbol)+r.addend-refaddr<br>$\quad$ $\quad$ $\quad$ 绝对引用：<br>$\quad$ $\quad$ $\quad$ $\quad$ ADDR(r.symbol)&#x3D;ADDR(函数\变量名)<br>$\quad$ $\quad$ $\quad$ $\quad$ *refptr&#x3D;ADDR（r.symbol）+r.addend<br>$\quad$ 加载可执行目标文件：<br>$\quad$ $\quad$ 把程序复制到内存并运行的过程叫做加载<br>$\quad$ $\quad$ 在程序头部表的引导下，加载器把可执行文件的片复制到代码段和数据段，接着加载器跳转到程序的入口点，即_start函数的地址。</p><h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p>$\quad$ 共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来，这个过程叫做动态链接，是由一个叫做动态链接器的程序来执行的。</p><p>!<img src="/../icsmg/20221119230728.png"></p><p>$\quad$ $\quad$ 动态链接器先重定位libc.so文本和数据到某个内存段，在重定位 libvector.so的文本和数据到另一个内存段，最后重定位二者中所有对定义的符号的引用<br>$\quad$ 共享库的一个主要目的就是允许多个正在运行的进程共享内存中相同的库代码，节约宝贵的内存资源。<br>$\quad$ 可以加载无需重定位的代码叫做位置无关代码(PIC)，共享库的编译必须总是使用该选项。<br>$\quad$ 在数据段开始的地方创建全局偏移量表（GOT）。<br>$\quad$ 延迟绑定能够避免动态链接器在加载时进行不必要的重定位。<br>$\quad$ 过程链接表（PLT）PLT[0]特殊，PLT[1]调用系统启动函数，从PLT[2]开始调用用户代码调用的函数　</p><ul><li>$\quad$ GOT[0]：<code>.dynamic</code>的地址</li><li>$\quad$ GOT[1]：重定位条目的地址</li><li>$\quad$ GOT[2]：动态链接器的地址</li><li>$\quad$ GOT[3]：系统启动函数</li><li>$\quad$ GOT[4]开始：调用的函数</li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6-存储器层次结构</title>
    <link href="/2023/02/18/6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/"/>
    <url>/2023/02/18/6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="对应-CSAPP-第六章节"><a href="#对应-CSAPP-第六章节" class="headerlink" title="对应 CSAPP 第六章节"></a>对应 CSAPP 第六章节</h2><span id="more"></span><h1 id="ICS"><a href="#ICS" class="headerlink" title="ICS"></a><a href="https://aki-yzh.github.io/2023/02/18/1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8&%E7%9B%AE%E5%BD%95">ICS</a></h1><hr><h3 id="六、存储器层次结构"><a href="#六、存储器层次结构" class="headerlink" title="六、存储器层次结构"></a>六、存储器层次结构</h3><h4 id="6-1-存储技术"><a href="#6-1-存储技术" class="headerlink" title="6.1 存储技术"></a>6.1 存储技术</h4><p>$\quad$ 随机访问存储器（RAM）分为两类：静态的和动态的</p><p>$\quad$ 静态（SRAM）具有双稳态特性，每位有6个晶体管，价格高，存取快，对光电不敏感，用于高速缓存存储器；动态（DRAM）每位一个晶体管，价格低，功耗更小，对光电敏感，用于主存和帧缓冲区。 </p><p><img src="/../icsmg/20221119152443.png"><br>$\quad$ 非易失性存储器（ROM）的发展：PROM-&gt;EPROM-&gt;EEPROM</p><p>$\quad$ RAM有电才能存储数据</p><p>磁盘存储：</p><p>$\quad$ 磁盘由盘片构成，每个盘片有2面或者称为表面，表面覆盖磁性记录材料，盘中央有一个可以旋转的主轴，使得盘片以固定的旋转速率旋转。每个表面是由一组称为磁道的同心圆组成的，每个磁道被划分为一组扇区，扇区之间由一组  间隙分隔开。</p><p>$\quad$ 抽象化成逻辑块序列。</p><p>$\quad$ 磁盘容量&#x3D;（字节数&#x2F;扇区）x（平均扇区数&#x2F;磁道）x（磁道数&#x2F;表面）x（表面数&#x2F;盘片）x（盘片数&#x2F;磁盘）</p><p><img src="/../icsmg/20221119151953.png"><br>$\quad$ 磁盘访问时间&#x3D;寻道时间+旋转时间+传送时间</p><p>$\quad$ 旋转时间&#x3D;1&#x2F;RPM x 60s&#x2F;1min x 1&#x2F;2</p><p>$\quad$ 传送时间 &#x3D; 1&#x2F;RPM x 1&#x2F;（平均扇区数&#x2F;磁道）x 60s&#x2F;1min</p><p>$\quad$ 磁盘没电也能存储数据</p><p>$\quad$ 固态硬盘（SSD）：</p><p>$\quad$ 基于闪存芯片（半导体存储器）的存储技术，读比写快，以页为单位进行读写</p><p>$\quad$ 速度： SRAM&gt;DRAM&gt;DISK</p><h4 id="6-2-局部性"><a href="#6-2-局部性" class="headerlink" title="6.2 局部性"></a>6.2 局部性</h4><p>$\quad$ 时间局部性：被引用过的内存位置在不远的将来再次被多次引用</p><p>$\quad$ 空间局部性：一个内存位置被引用，那么不远的将来引用其附近的内存位置</p><p> $\quad$ 重复引用相同变量的程序拥有良好的时间局部性</p><p>$\quad$ 步长为K的引用模式，步长越小，空间局部性越好</p><p>$\quad$ 取指令循环具有好的时间与空间局部性</p><p>存储器层次结构：<br><img src="/../icsmg/20221119152158.png"><br>$\quad$ 思想：速度快容量小的存储设备作为速度慢容量大的存储设备的缓存</p><h4 id="6-3-高速缓存（cache）"><a href="#6-3-高速缓存（cache）" class="headerlink" title="6.3 高速缓存（cache）"></a>6.3 高速缓存（cache）</h4><p>$\quad$ 第k+1层的存储器被划分成连续的数据对象组块，称为块 数据以块为单位来回复制 </p><p><img src="/../icsmg/20221119152227.png"></p><p><strong>缓存命中</strong></p><p>$\quad$ 当程序需要读取第k+1层的某个数据对象d时，首先在当前存储在k层的一个块中查找d，若d刚好存储在第k层中，那就是缓存命中。程序直接从第k层读取d。</p><p><strong>缓存不命中</strong></p><p>$\quad$ 第k层的缓存就从k+1层去除包含d的那个块，若k层已满，覆盖现存的一个块。这个过程叫做替换或者驱逐这个块。被驱逐的称为牺牲块，决定替换哪个由替换策略控制。</p><p>分类：</p><p>$\quad$ 冷不命中（强制性不命中）：第k层为空（称为冷缓存）</p><p>$\quad$ 冲突不命中：限制性的防治策略社对象映射到同一个缓存块</p><p>$\quad$ 容量不命中：缓存太小了</p><p><strong>高速缓存存储器</strong></p><p>$\quad$ 早期计算机系统的存储器层次结构只有三层：CPU寄存器，DRAM主存储器和磁盘。后插入了小的SRAM高速缓存，称为L1高速缓存</p><p>$\quad$ 对于下列只讨论仅有L1高速缓存</p><p>$\quad$ 考虑一个计算机系统，每个存储器地址有m位，形成M&#x3D;$2^m$个不同的地址。被组织成$S&#x3D;2^s$个高速缓存组的数组。每个组包含E个高速缓存行。每个行由$B&#x3D;2^b$个字节的数据块构成</p><p>$\quad$ 将m个地址分为t位的标记位，s位的组索引，b位的块偏移</p><p>$\quad$ 标记为表示取自哪个块群，有效位可以理解为是否缓存了东西<br><img src="/../icsmg/20221119152309.png"><br><img src="/../icsmg/20221119152333.png"><br>$\quad$ cache容量 （所有块的大小 ）：     C&#x3D;SxExB</p><p><strong>直接映射高速缓存</strong></p><p>$\quad$ 每个组只有一行（E&#x3D;1），称为直接映射高速缓存</p><p>$\quad$ 高速缓存确定一个请求是否命中，然后抽取出被请求的字的过程，分为三步：</p><p>1.组选择</p><p>$\quad$ 从w的地址中取出s个组索引</p><p>2.行匹配</p><p>$\quad$ 只有一行，直接比对标记是否一致</p><p>$\quad$ 最终结果：命中&#x2F;不命中</p><p>3.字抽取（缓存命中）</p><p>  $\quad$ 把块看成一个字节的数组，字节偏移是到这个数组的一个索引</p><p>$\quad$ $\quad$ 行替换（缓存不命中）</p><p>$\quad$ $\quad$ 从下一层取出被请求的块放入高速缓存行中，代替当前行</p><p><strong>组相连高速缓存</strong></p><p>$\quad$ 1&lt;EC&#x2F;B</p><p>$\quad$ 组选择：和上述一样</p><p>$\quad$ 行匹配和字选择：检查多个行的标记位与有效位</p><p>$\quad$ 行替换：空行优先，否则用策略替换LRU，FIFO（先进先出）LFU，随机替换</p><p><strong>全相连高速缓存</strong></p><p>$\quad$ E&#x3D;C&#x2F;B</p><p>$\quad$ 一个组包含所有的行</p><p>$\quad$ 组选择：只有一个组</p><p>$\quad$ 行匹配和字选择：同上</p><p><strong>写</strong>:<br>$\quad$ 只写：立即将高速缓存块协会到低一层中；写回：推迟更新</p><p>$\quad$ 写分配：加载入高速缓存。非写分配：避开高速缓存</p><p>$\quad$ 不命中率&#x3D;不命中数量&#x2F;引用数量</p><h4 id="6-5-编写高速缓存友好的代码"><a href="#6-5-编写高速缓存友好的代码" class="headerlink" title="6.5 编写高速缓存友好的代码"></a>6.5 编写高速缓存友好的代码</h4><p>$\quad$ 1.让最常见的情况运行最快</p><p>$\quad$ 2.尽量减小每个循环内部的缓存不命中数量</p><h4 id="6-6-高速缓存对程序性能的影响"><a href="#6-6-高速缓存对程序性能的影响" class="headerlink" title="6.6 高速缓存对程序性能的影响"></a>6.6 高速缓存对程序性能的影响</h4><p>$\quad$ 读吞吐量：从存储系统中读数据的速率  v&#x3D;n&#x2F;s</p><p>$\quad$ 重排列循环以提高空间局部性</p><hr><h3 id="LAB"><a href="#LAB" class="headerlink" title="LAB:"></a>LAB:</h3><p><strong>此章节后完成<a href="https://github.com/Aki-yzh/PKU-ICS-2022/tree/main/LABS/5-cachelab">cachelab(60.0&#x2F;60.0)</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5-优化程序性能</title>
    <link href="/2023/02/18/5-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/"/>
    <url>/2023/02/18/5-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="对应-CSAPP-第五章节"><a href="#对应-CSAPP-第五章节" class="headerlink" title="对应 CSAPP 第五章节"></a>对应 CSAPP 第五章节</h2><span id="more"></span><h1 id="ICS"><a href="#ICS" class="headerlink" title="ICS"></a><a href="https://aki-yzh.github.io/2023/02/18/1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8&%E7%9B%AE%E5%BD%95">ICS</a></h1><hr><h3 id="五、优化程序性能"><a href="#五、优化程序性能" class="headerlink" title="五、优化程序性能"></a>五、优化程序性能</h3><p>$\quad$ 引入度量标准没元素的周期数CPE作为衡量程序性能的方法</p><h5 id="编译器优化："><a href="#编译器优化：" class="headerlink" title="编译器优化："></a>编译器优化：</h5><p>$\quad$ 编译器的优化必须是保守的，即不改变代码的程序级行为</p><p>$\quad$ 无法优化的情况<br>$\quad$ $\quad$ 浮点数不满足结合律（选择题中出现浮点数）<br>$\quad$ $\quad$ 无法判断地址重复引用（即选择题中出现指针）<br>$\quad$ $\quad$ 无法判断循环体中函数是否有副作用（即选择题中优化出现了未知函数）</p><h5 id="程序员优化："><a href="#程序员优化：" class="headerlink" title="程序员优化："></a>程序员优化：</h5><p><strong>1.消除循环的低效率</strong></p><p>$\quad$ 把可以只运行一次的函数调用移出循环</p><p><strong>2.减少过程调用</strong></p><p>$\quad$ 减少过程中的函数调用</p><p><strong>3.消除不必要的内存引用</strong></p><p><strong>循环展开</strong></p><p>$\quad$ 增加每次迭代计算的元素的数量，减少迭代次数</p><p><strong>优化的限制</strong></p><p>$\quad$ 寄存器溢出</p><p>$\quad$ 分支预测错误处罚</p><p>$\quad$ 内存性能限制</p><hr><h3 id="LAB"><a href="#LAB" class="headerlink" title="LAB:"></a>LAB:</h3><p><strong>此章节后完成<a href="https://github.com/Aki-yzh/PKU-ICS-2022/tree/main/LABS/4-archlab">archlab(190.0&#x2F;190.0)</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4-处理器体系结构</title>
    <link href="/2023/02/18/4-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <url>/2023/02/18/4-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="对应-CSAPP-第四章节"><a href="#对应-CSAPP-第四章节" class="headerlink" title="对应 CSAPP 第四章节"></a>对应 CSAPP 第四章节</h2><span id="more"></span><h1 id="ICS"><a href="#ICS" class="headerlink" title="ICS"></a><a href="https://aki-yzh.github.io/2023/02/18/1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8&%E7%9B%AE%E5%BD%95">ICS</a></h1><hr><h3 id="四、处理器体系结构"><a href="#四、处理器体系结构" class="headerlink" title="四、处理器体系结构"></a>四、处理器体系结构</h3><h5 id="4-1-Y86-64指令集体系结构"><a href="#4-1-Y86-64指令集体系结构" class="headerlink" title="4.1 Y86-64指令集体系结构"></a>4.1 Y86-64指令集体系结构</h5><h6 id="4-1-1-程序员可见的状态"><a href="#4-1-1-程序员可见的状态" class="headerlink" title="4.1.1 程序员可见的状态"></a>4.1.1 程序员可见的状态</h6><p>$\quad$ 程序员：用汇编代码写程序的人或产生机器级代码的编译器</p><p>$\quad$ 可见状态：每条指令都会读取或修改处理器状态的某些部分<br>    <br><img src="/../icsmg/20221119152952.png"><br>    <br>$\quad$ 15个程序寄存器，每个程序寄存器存储一个64位的字（8字节），寄存器%rsp被出栈，入栈，调用和返回指令作为栈指针。3个1位的条件码ZF，OF，SF，程序计数器PC存放当前正在执行指令的地址</p><h6 id="4-1-2-Y86-64指令"><a href="#4-1-2-Y86-64指令" class="headerlink" title="4.1.2 Y86-64指令"></a>4.1.2 Y86-64指令</h6><p>$\quad$ movq指令被分成了4个不同的指令：irmovq，rrmovq，mrmovq，rmmovq，源可以是立即数（i），寄存器（r）或内存（m）。指令的第一个字符表示源的类型，第二个表示了目的的类型。同x86-64，我们不允许将内存直接传送到另一个内存，也不允许将立即数传送到内存。<br>    <br><img src="/../icsmg/20221119153309.png"><br>$\quad$ halt 停止指令的执行</p><p>$\quad$ nop 空操作</p><p>$\quad$ 4个整数操作指令addq，subq，andq，xorq</p><p>$\quad$ 7个跳转指令（图中的jxx）jmp、jle、jl、je、jne、jge、jg分支条件和x86-64一致。</p><p>$\quad$ 6个条件传送指令（图中的cmovxx）：cmovle、cmovl、cmove、cmovne、cmovge和cmovg、格式与rrmovq一样，但是只有当条件码满足约束才会更新寄存器的值。</p><p>$\quad$ call 将返回地址入栈，然后跳到目的地址。ret指令从这样的调用中返回。</p><p>$\quad$ pushq和pullq实现了入栈和出栈。</p><h6 id="4-1-3指令编码"><a href="#4-1-3指令编码" class="headerlink" title="4.1.3指令编码"></a>4.1.3指令编码</h6><p>$\quad$ 每条指令需要1～10个字节不等，每条指令的第一个字节表示指令的类型，这些字节分为两个部分，每部分4位：高四位是代码部分，低四位是功能部分（fn）。代码值位0～0x8<br><img src="/../icsmg/20221119153404.png"><br>$\quad$ rrmovq与条件传送有相同的指令代码，可以把它看作是无条件传送，功能代码都是0</p><p>寄存器标识符</p><p><img src="/../icsmg/20221119153049.png"><br>$\quad$ rA和rB被称为寄存器指示符字节，指定标识符对应的寄存器。不需要寄存器的则将r设置为0xF。</p><p>$\quad$ 有些指令需要一个附加的8字节常数字，这个字能作为irmovq的立即数，rmmovq和mrmovq的地址指示符的偏移量，以及分支指令和调用指令的目的地址。（分支指令和调用指令的目的是一个绝对地址，而非相对寻址）</p><p>$\quad$ 比如对 rmmovq %rsp，0x123456789abcd（%rdx）；先填充为8字节得00 01 23 45 67 89 ab cd在小断法反序成cd ab 89 67 45 23 01 00，连起来得指令的编码为40 42 cd ab 89 67 45 23 01 00.</p><p>$\quad$ 字节编码有唯一的解释。</p><h6 id="旁注-RISC和CISC"><a href="#旁注-RISC和CISC" class="headerlink" title="旁注  RISC和CISC"></a>旁注  RISC和CISC</h6><p>$\quad$ 二者主要区别在于CISC指令数量很多而RISC少，RISC代码固定为4字节，RISC没有条件码，RISC寻址简单，RISC只有load和store允许内存调用，RISC细节可见。RISC指令延迟短，RISC比较简单，故代码长度一般更长</p><h6 id="4-1-4-Y86-64异常"><a href="#4-1-4-Y86-64异常" class="headerlink" title="4.1.4  Y86-64异常"></a>4.1.4  Y86-64异常</h6><p>$\quad$ 状态码Stat描述程序运行的总体状态。<br><img src="/../icsmg/20221119153452.png"></p><h6 id="4-1-5-Y86-64程序"><a href="#4-1-5-Y86-64程序" class="headerlink" title="4.1.5 Y86-64程序"></a>4.1.5 Y86-64程序</h6><p>$\quad$ 与x86-64的汇编代码相比，Y86-64需要将常数加载到寄存器。从内存中读取数值并与一个寄存器相加时，Y86-64需要两条指令，x86-64只需要一条。</p><h5 id="4-2-逻辑设计和硬件控制语言HCL"><a href="#4-2-逻辑设计和硬件控制语言HCL" class="headerlink" title="4.2 逻辑设计和硬件控制语言HCL"></a>4.2 逻辑设计和硬件控制语言HCL</h5><h6 id="逻辑门"><a href="#逻辑门" class="headerlink" title="逻辑门"></a>逻辑门</h6><p><img src="/../icsmg/20221119153513.png"><br>组合电路要求：<br>$\quad$ 1）每个逻辑门的输入必须连接到系统输入或者存储器输出或逻辑门输出上<br>$\quad$ 2） 逻辑门的输出不能连在一起<br>$\quad$ 3）网必须是无环的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">HCL：<br>数据类型：<span class="hljs-type">bool</span>, <span class="hljs-type">int</span><br>操作<br>简单的布尔表达式:    <span class="hljs-type">bool</span> out = (s&amp;&amp;a)||(!s&amp;&amp;b)<br>情况表达式（多选器） word out = [select1 : expr1, select2 : expr2 ... ]<br>集合关系 <span class="hljs-type">bool</span> s = code in &#123; item1, item2, ... &#125;<br>与C语言逻辑运算的区别<br>组合电路输出持续响应输入的变化<br>HCL无C语言中的“短路”，不会部分求值<br></code></pre></td></tr></table></figure><p>存储器<br>$\quad$ 分为时钟存储器和随机访问存储器</p><h5 id="4-3-Y86-64程序的实现"><a href="#4-3-Y86-64程序的实现" class="headerlink" title="4.3  Y86-64程序的实现"></a>4.3  Y86-64程序的实现</h5><p>$\quad$ 描述一个SEQ的处理器</p><h6 id="4-3-1-将处理组织成阶段"><a href="#4-3-1-将处理组织成阶段" class="headerlink" title="4.3.1  将处理组织成阶段"></a>4.3.1  将处理组织成阶段</h6><p>$\quad$ 1.取指（fetch）：从内存读取指令字节，地址为PC的值。从指令中抽取出指令指示符字节的两个四位部分，icode（指令代码）和ifun（指令功能）。可能取出一个寄存器指示符字节，指明一个或两个寄存器操作数指示符rA和rB。还可能取出个8字节常数字valC，计算出下一条指令地址valP。即valP等于PC+已执行操作的字节</p><p>$\quad$ 2.译码（decode）：从寄存器文件读入最多两个操作数，得到valA和&#x2F;或valB</p><p>$\quad$ 3.执行（execute）ALU进行指令指明的操作或对栈指针进行增减，同时可能设置条件码</p><p>$\quad$ 4.访存（memory） 将数据写入内存或读出数据</p><p>$\quad$ 5.写回（write back）将结果写回寄存器文件</p><p>$\quad$ 6.更新PC（PCupdate）将PC设置成下一条指令的地址</p><p>例：<br><img src="/../icsmg/20221119153959.png"><br><img src="/../icsmg/20221119155842.png"><br><img src="/../icsmg/20221119155911.png"><br><img src="/../icsmg/20221119155923.png"><br>$\quad$ 其中PC 、rA、rB、OP等在运算中都是具体的值。</p><p>$\quad$ 整数操作指令遵循上面列出的通用模式。</p><p>如<br><img src="/../icsmg/20221119155946.png"><br>$\quad$ 其他的操作同理。</p><h6 id="4-3-2-SEQ硬件结构"><a href="#4-3-2-SEQ硬件结构" class="headerlink" title="4.3.2  SEQ硬件结构"></a>4.3.2  SEQ硬件结构</h6><p><img src="/../icsmg/20221119160543.png"></p><p>$\quad$ 取指：将程序计数器寄存器作为地址</p><p>$\quad$ 译码：寄存器文件有两个读端口A和B，从这两个端口分别读取寄存器值valA和valB</p><p>$\quad$ 执行：ALU执行，CC为条件码寄存器</p><p>$\quad$ 访存：访问内存，进行写入或者读</p><p>$\quad$ 写回：寄存器文件有两个写端口，E用来写入ALU计算出的值，M用来写从数据内存中读出来的值</p><p>$\quad$ PC更新：valP：下一条指令的地址；valC：调用指令或跳转指令制定的目标地址；valM：从内存读取的返回地址</p><h6 id="4-3-3-SEQ的时序"><a href="#4-3-3-SEQ的时序" class="headerlink" title="4.3.3 SEQ的时序"></a>4.3.3 SEQ的时序</h6><p>$\quad$ 原则：从不回读（处理器从来不需要为了完成一条指令的执行而去读由该指令更新了的状态）<br>例：没有指令既设置又读取条件码</p><h6 id="4-3-4-SEQ阶段的实现"><a href="#4-3-4-SEQ阶段的实现" class="headerlink" title="4.3.4 SEQ阶段的实现"></a>4.3.4 SEQ阶段的实现</h6><p><img src="/../icsmg/20221119160132.png"><br>$\quad$ 1.取指阶段：以PC作为字节0的地址，一次从内存读出10个字节。第一个字节被解释成指令字节，然后icode和ifun的控制逻辑块计算指令和功能码。</p><p>$\quad$ instr_valid：指令非法</p><p>$\quad$ need_regids:包含寄存器指示符字节</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs hcl">bool need_regids=&#123;<br>    icode in&#123;IRRMOVLQ,IOPQ,IPUSHQ,IPOPQ,<br>        IIRMOVQ,IRMMOVQ,IMRMOVQ&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>$\quad$ need_valC:包含常数字节</p><p> $\quad$ 剩下9个字节是寄存器指示符字节和常数字节的组合编码。</p><p>$\quad$ 若need_regids为1，则字节1被分开装入rA和rB中，否则设为0xFF</p><p>$\quad$ 产生常数valC根据need_regids的值由2～9或者1～8产生<br><img src="/../icsmg/20221119160213.png"><br>$\quad$ PC值为p+1+r+8i（r为need_regids的值，i为need_valC的值，p为初始PC）</p><p>$\quad$ 2.译码和写回阶段：从寄存器文件中读取数据，寄存器文件有四个端口，读端口的地址输入为srcA和srcB，写端口的地址输入为dstE和dstM。读出的数值通过valA和valB输出，写入的数值通过valM和valE</p><p><img src="/../icsmg/20221119160237.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs hcl">word srcA=&#123;<br>    icode in &#123;IRRMOVQ,IRMMOVQ,IOPQ,IPUSHQ&#125;:rA;<br>    icode in&#123;IPOPQ,IRET&#125;:RRSP;<br>    1:RNONE;#Don&#x27;t need register<br>&#125;<br>#warning :conditional move not implemented correctly here<br>word destE=&#123;<br>    icode in&#123;IRRMOVQ&#125;:rB;<br>    icode in &#123;IIRMOVQ,IOPQ&#125;:rB;<br>    icode in &#123; IPUSHQ,IPOPQ,ICALL,IRET&#125;:RRSP;<br>    1:RNONE;#Don&#x27;t need register<br>&#125;<br></code></pre></td></tr></table></figure><p> 3.执行阶段：</p><p>$\quad$ 对输入的aluA和aluB进行算数与逻辑运算<br><img src="/../icsmg/20221119160348.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs hcl">word aluA=&#123;<br>    icode in&#123;IRRMOVQ,IOPQ &#125;:valA;<br>    icode in&#123;IIRMOVQ,IRMMOVQ,IMRMOVQ&#125;:valC;<br>    icode in &#123;ICALL,IPUShQ&#125;:-8;<br>    icode in &#123;IRET,IPOPQ&#125;:8;<br>    #other instructions don&#x27;t need ALU<br>&#125;<br>bool set_cc = icode in &#123;IOPQ&#125;;//仅运算改变条件码寄存器<br></code></pre></td></tr></table></figure><p>4.访存阶段</p><p>$\quad$ 从内存读入或者把数据写入内存中</p><p>$\quad$ 进行读时产生valM<br><img src="/../icsmg/20221119160328.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs hcl">word mem_addr=[<br>    icode in &#123;IRMMOVQ,IPUSHQ,ICALL,IMRMOVQ&#125;:valE;<br>    icode in&#123;IPOPQ,IRET&#125;:valA;<br>#Other instructions don&#x27;t need address<br><br>];<br>bool mem_read=[<br>    icode in&#123;IMRMOVQ,IPOPQ,IRET&#125;;<br>]//只读数据<br></code></pre></td></tr></table></figure><p>5.更新PC状态<br><img src="/../icsmg/20221119160424.png"><br>新PC可能是valC，valM或valP</p><p>$\quad$ 当正在执行call或者满足跳转条件即将跳转时，PC为valC，正在执行RET，valM，其他为当前PC加当前指令长度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs hcl">word new_PC=[<br>    icode == ICALL:valC;<br>    icode == IJXX&amp;&amp;Cnd:valC;<br>    icode == IRET:valM;<br>    #default <br>    1:valP;<br>]<br></code></pre></td></tr></table></figure><p>总结<br><img src="/../icsmg/20221119160037.png"></p><h5 id="4-4-流水线的通用原理"><a href="#4-4-流水线的通用原理" class="headerlink" title="4.4 流水线的通用原理"></a>4.4 流水线的通用原理</h5><p>$\quad$ 我们用每秒千兆条指令（GIPS），也就是每秒十亿条指令，为单位来描述吞吐量。延迟为吞吐量的倒数。</p><p>$\quad$ 吞吐量&#x3D;1&#x2F;（执行时间+延迟）</p><p>$\quad$ 画出流程图进行分析</p><p>v指令的转移由时钟信号决定</p><h5 id="4-5-Y86-64的流水线实现"><a href="#4-5-Y86-64的流水线实现" class="headerlink" title="4.5 Y86-64的流水线实现"></a>4.5 Y86-64的流水线实现</h5><p>$\quad$ 将更新PC放在一个时钟周期的开始时执行</p><p> $\quad$ 实现方法：创建一个寄存器来保存指令在执行过程中产生的信号，标号为前面加个p：电路重定时</p><p> $\quad$ 流水线寄存器：</p><p>$\quad$ F：保存程序计数器的预测值</p><p>$\quad$ D：位于取指和译码之间，保存最新取出的指令的信息</p><p>$\quad$ E：位于译码和执行之间，保存关于最新译码的指令和从寄存器文件中读出的值的信息</p><p>$\quad$ M ：位于执行和访存之间，保存最新执行的指令的结果</p><p>$\quad$ W：位于访存和反馈路径之间<br><img src="/../icsmg/20221119160847.png"><br> $\quad$ 流水线冒险<br><img src="/../icsmg/20221119161037.png"></p><p>$\quad$ 存在数据相关或者控制相关，会产生错误的结果</p><p>$\quad$ 指令在译码阶段读取寄存器时， 寄存器的ID分别与执行阶段，访存阶段以及写回阶段的目的寄存器进行比较 ，若相等则存在数据相关。</p><p>$\quad$ 1.用暂停来避免数据冒险</p><p>         stalling； 让一条指令停止在译码阶段，直到产生它的源操作数的指令通过了写回阶段</p><p>$\quad$ 方法：插入气泡（bubble）气泡会占据周期<br><img src="/../icsmg/20221119161100.png"><br>$\quad$ 用暂停实现会严重降低流水线的吞吐量</p><p>$\quad$ 2.用转发来避免数据冒险</p><p>$\quad$   $\quad$ 转发在基本的硬件结构里添加了额外的数据链接与控制逻辑</p><p>$\quad$ 增加逻辑块Sel+FwdA和FwdB<br><img src="/../icsmg/20221119161146.png"><br>$\quad$ 不能单用转发解决的，暂停和转发结合使用</p><p>控制冒险：</p><p>$\quad$ 取指出现ret指令（暂停处理新指令直到ret到达写回阶段）</p><p>$\quad$ 出现jxx指令：分支预测</p><p>$\quad$ 假设总是进行跳转；若到达执行阶段发现预测错误则取消这些指令</p><p><strong>PIPE各阶段的实现</strong></p><p>$\quad$ 1.PC选择和取指阶段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs hcl">word f_pc&#123;<br>    M_icode == IJXX &amp;&amp; !M_Cnd:M_valA;<br>    W_icode == IRET :W_valM;<br>    1：F_predPC;<br>&#125;;<br>word f_predPC =[<br>    f_icode in &#123;IJXX,ICALL&#125;:f_valC;<br>    1:f_valP;<br>];<br></code></pre></td></tr></table></figure><p>$\quad$ 2.译码和写回阶段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs hcl">//译码阶段由于加入了转发变得复杂<br>word d_valA =[<br>    D_icode in &#123;ICALL,IJXX&#125;:D_valP;<br>    d_srcA == e_dstE :e_valE ;//优先级执行优先<br>    d_srcA == M_dstM : m_valM ;//访存次之<br>    d_srcA == M_dstE : M_valE;<br>    d_srcA == W_dstM : W_valM;//写回最次，先M后E<br>    d_secA == W_dstE :W_valE;<br>    1:d_rvalA;<br>]<br></code></pre></td></tr></table></figure><p>$\quad$ 3.执行阶段</p><p>$\qquad$ 与SEQ差别不大</p><p>$\quad$ 4.访存阶段</p><p>$\qquad$ 差别不大</p><p><strong>性能分析</strong></p><p>$\quad$ 一个阶段处理了$C_i$条指令和$C_b$个气泡</p><p>$\quad$ CPI &#x3D; 1+Cb&#x2F;Ci</p><p>估算：</p><p>$\quad$ 加载指令（mrmovq和popq）占执行指令的25%，20%会导致冒险1气泡</p><p>$\quad$ 条件分支指令占20%，40%不选择分支，2气泡</p><p>$\quad$ 返回指令占2% 3气泡</p><p>$\quad$ CPI&#x3D;1+$\sum$ 指令频率x条件频率x气泡数</p><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3-程序的机器级表示</title>
    <link href="/2023/02/18/3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/"/>
    <url>/2023/02/18/3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="对应-CSAPP-第三章节"><a href="#对应-CSAPP-第三章节" class="headerlink" title="对应 CSAPP 第三章节"></a>对应 CSAPP 第三章节</h2><span id="more"></span><h1 id="ICS"><a href="#ICS" class="headerlink" title="ICS"></a><a href="https://aki-yzh.github.io/2023/02/18/1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8&%E7%9B%AE%E5%BD%95">ICS</a></h1><hr><h3 id="三、程序的机器级表示"><a href="#三、程序的机器级表示" class="headerlink" title="三、程序的机器级表示"></a>三、程序的机器级表示</h3><p>$\quad$ 忽略以.开头的伪指令</p><p>$\quad$ 指令分为 操作码与操作数两部分 </p><p>$\quad$ PC    用%rip表示，给出将要执行的下一条指令在内存中的地址</p><p>$\quad$ 整数寄存器文件用来存放整数数据和指针<br><img src="/../icsmg/20221119161455.png"><br>$\quad$ 条件码寄存器 存储算数或逻辑指令的状态信息</p><p>$\quad$ 调用者保存（caller）：调用函数前保存寄存器的值</p><p>$\quad$ 被调用者保存（callee）：在调用函数时保存寄存器的值<br><img src="/../icsmg/20221119161346.png"><br>$\quad$ 一般用开头的pushq和结尾的popq实现</p><p>数据大小：</p><p>$\quad$ 用字表示16位的数据类型大小，用双字表示32位，四字表示64位。<br><img src="/../icsmg/20221119161430.png"><br><strong>寄存器</strong><br><img src="/../icsmg/20221119161646.png"><br>$\quad$ r8～r15 无后缀64位，后缀b8位，w16位，d32位</p><p>$\quad$ rax用来保存函数的返回值，rsp保存程序栈的结束位置，其他六个用于传参，rbx和rbp保存被调用者，rdi，rsi，rdx，rcx用于第1，2，3，4个参数的保存。</p><p>$\quad$ 描述中用R[%r]表示寄存器%r的值</p><p>$\quad$ 当指令以寄存器作为操作目标时，对于生成小于8字节结果的指令：生成1字节和2字节数字的指令会保持剩下的字节不变，生成4字节数字的指令会把高位4个字节设置为0</p><h4 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a>操作数</h4><p>$\quad$ 大致分为3类：立即数（$接整数），寄存器，内存引用（比如寄存器外加小括号(%rdi)等）</p><p>$\quad$ 一般用M[addr]表示从addr开始b个字节值的引用</p><p>$\quad$ 常用$Imm(r_b,r_i.s)$表示，Imm表示立即数，rb是基址寄存器，ri是变址寄存器，s是比例因子，必须为1，2，4或者8。rb和ri都必须是<strong>64位寄存器</strong>&#x2F;&#x2F;考察点</p><p>$\quad$ 有效地址计算为 Imm+rb+ri*s；<br><img src="/../icsmg/20221119161822.png"><br>$\quad$ 需要特别注意不带$的立即数和带了括号的寄存器都是内存引用</p><h4 id="数据传输指令"><a href="#数据传输指令" class="headerlink" title="数据传输指令"></a>数据传输指令</h4><p> $\quad$ 将数据从一个位置移动到另一个位置的指令</p><p>$\quad$ 有movb，movw，movl，movq四种，区别在于移动数据的大小不同。<br><img src="/../icsmg/20221119162028.png"><br>$\quad$ 含有两个操作数：源操作数与目的操作数</p><p>$\quad$ MOV            源操作数 （立即数，寄存器或内存）          目的操作数（寄存器或内存引用，用于存放源操作数）</p><p>$\quad$ 源操作数和目的操作数不能都是内存引用</p><p>$\quad$ MOV指令只会改变目的操作数，movl除外，会把源操作数高位4字节设为0</p><p>$\quad$ $\quad$ movq移动32位补码数的立即数时先符号扩展再进行移动</p><p>$\quad$ $\quad$ movavsq 移动64位立即数，目的操作数只能是寄存器。</p><p>MOVZ类：</p><p>$\quad$ 两个字母一个表示源操作数的大小，第二个表示目的操作数的大小，做0扩展</p><p>MOVS类同理，做符号位扩展                </p><h4 id="栈指令"><a href="#栈指令" class="headerlink" title="栈指令"></a>栈指令</h4><p>$\quad$ popq 将四字弹栈，栈指针加8，相当于subq $8 ,%rsp    movq %rbp  ,(%rsp)</p><p>$\quad$ pushq 将四字压栈，栈指针减8,相当于 movq (%rsp),%rax  addq $8,%rsp</p><p>$\quad$ 栈放在内存的某个区域</p><h4 id="算数和逻辑操作"><a href="#算数和逻辑操作" class="headerlink" title="算数和逻辑操作"></a>算数和逻辑操作</h4><p>$\quad$ 大写表示一个操作类 操作码为后面加上一个字母表示操作数的大小</p><p>     加载有效地址  leaq</p><p>leaq    S，D  实际上是movq指令的变形 效果D&#x3D;&amp;S</p><p>$\quad$ 并不是从内存地址读取数据，直接赋予有效地址给D就行</p><p>$\quad$ 如  leaq 7（%rdx,%rdx,2),%rax  （若%rdx值为x）表示 将%rax赋值为7+3x</p><p>leaq用于实现加法与有限形式的乘法</p><p>一元操作：<br><img src="/../icsmg/20221119162119.png"><br>二元操作：<br><img src="/../icsmg/20221119162128.png"><br>移位操作：<br><img src="/../icsmg/20221119162143.png"><br>$\quad$ &#x2F;&#x2F;A代表arithmetical代表算数<br>特殊的算数操作<br><img src="/../icsmg/20221119162241.png"></p><h4 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h4><p>条件码    长度只有1个bit</p><p>CF：最近的操作使最高位产生了进位，可以检查无符号操作的溢出</p><p>ZF：0标志，最近操作结果为0</p><p>SF：符号标志，最近操作结果为负数</p><p>OF：溢出标志，最近操作使补码溢出</p><p>$\quad$ 以下算数逻辑运算会改变条件码寄存器的值<br><img src="/../icsmg/20221119162507.png"><br>还有两类指令能设置条件码寄存器<br>CMP指令和TEST指令</p><p>$\quad$ CMP根据两个操作数的差来设置条件码寄存器，和减法指令区别在不会改变操作数的值</p><p>$\quad$ TEXT指令则比较两个数是否一样，同样是只设置条件码</p><p>SET指令调用条件码</p><p>$\quad$ set D    D被设为为1或0</p><p>$\quad$ SET前常接CMP指令</p><p>$\quad$ SET后接的字母         l：less（有符号）    g：greater  （有符号） e:equal      n:not     s:负数    a:above无符号大于    b：below无符号小于</p><h4 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h4><p>$\quad$ jmp无条件跳转</p><p>$\quad$ jmp后直接接地址表示直接跳转，接*表示间接跳转</p><p>$\quad$ 其他的j后接跳转条件，字母与set后接的代表一致</p><p>$\quad$ 跳转指令勇于实现跳转与分支，循环（将循环化成goto再化成汇编）</p><p>$\quad$ switch的实现通过跳转表实现。jmp  * .Ln（，%r，k   ）        .Ln表示跳转表的名称，%r标志switch的n所在的寄存器，k一般为8以模拟case0<br><img src="/../icsmg/20221119162325.png"></p><h4 id="条件传送指令"><a href="#条件传送指令" class="headerlink" title="条件传送指令"></a>条件传送指令</h4><p>$\quad$ cmov后接字母，表示与上述一致，对所有的操作数长度适用。<br><img src="/../icsmg/20221119162341.png"></p><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p><img src="/../icsmg/20221119162850.png"><br>$\quad$ call    调用函数</p><p>$\quad$ ret 从过程调用中返回</p><p>$\quad$ 如果一个函数有大于6个整型参数，超出6个的部分则需要通过栈来传递。</p><p>$\quad$ 局部变量不需要对齐，而传递的参数需要对齐<br><img src="/../icsmg/20221119162822.png"></p><h4 id="数组的分配和访问"><a href="#数组的分配和访问" class="headerlink" title="数组的分配和访问"></a>数组的分配和访问</h4><p>$\quad$ 起始地址为 $x_0$ ,数组元素i被存放在 $x_0$ +L*i处</p><p>$\quad$ *可以理解为从地址中取数据</p><p>$\quad$ 嵌套数组：a[i][j]看作是有i个元素的数组，每个元素都是j个int的数组，线性排列</p><h4 id="异质的数据结构"><a href="#异质的数据结构" class="headerlink" title="异质的数据结构"></a>异质的数据结构</h4><p>$\quad$ struct结构体：每个元素各占一个区域</p><p>$\quad$ union联合:所有字段共享存储区域，联合体的大小取决于最大字段的大小，应用于事先知道几个字段的存在是互斥的</p><p>数据对齐</p><table><thead><tr><th>K</th><th>type</th></tr></thead><tbody><tr><td>1</td><td>char</td></tr><tr><td>2</td><td>short</td></tr><tr><td>4</td><td>int ,float</td></tr><tr><td>8</td><td>long,double,char*</td></tr></tbody></table><p>$\quad$ .align 8表示使其后面的数据起始地址是8的倍数</p><p>$\quad$ 对于结构体，每个元素后要满足下一个元素的对齐要求，（即下一个元素的起始地址必须是其对应的K的倍数）总的内存长度要满足所有元素的对齐要求。</p><h4 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h4><p>$\quad$ 解决方法：栈随机化，栈破坏检测（金丝雀值：在底部存储一个特殊值），限制可执行代码区域</p><p><img src="/../icsmg/20221119162958.png"></p><hr><h3 id="LAB"><a href="#LAB" class="headerlink" title="LAB:"></a>LAB:</h3><p><strong>此章节后完成<a href="https://github.com/Aki-yzh/PKU-ICS-2022/tree/main/LABS/2-bomblab">bomblab(70.0&#x2F;70.0)</a>与<a href="https://github.com/Aki-yzh/PKU-ICS-2022/tree/main/LABS/3-attacklab">attacklab(105.0&#x2F;105.0)</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2-信息的表示与处理</title>
    <link href="/2023/02/18/2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/"/>
    <url>/2023/02/18/2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="对应-CSAPP-第二章节"><a href="#对应-CSAPP-第二章节" class="headerlink" title="对应 CSAPP 第二章节"></a>对应 CSAPP 第二章节</h2><span id="more"></span><h1 id="ICS"><a href="#ICS" class="headerlink" title="ICS"></a><a href="https://aki-yzh.github.io/2023/02/18/1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8&%E7%9B%AE%E5%BD%95">ICS</a></h1><hr><h3 id="二、信息的表示与处理"><a href="#二、信息的表示与处理" class="headerlink" title="二、信息的表示与处理"></a>二、信息的表示与处理</h3><h4 id="1-信息的存储"><a href="#1-信息的存储" class="headerlink" title="1.信息的存储"></a>1.信息的存储</h4><p>$\quad$ 机器级程序将内存视为一个非常大的字节数组，称为虚拟内存。所有可能地址的集合称为虚拟地址空间。</p><p>$\quad$ 字节：信息存储的基本单元，由8个位组成，每个位为0或1。</p><p>$\quad$ 十六进制数 ：0x开头，数字0～9，字母A～F可大写可小写。</p><p>进制间的转换</p><p>$\quad$ 对于一个字长为w的机器来说，虚拟地址的范围为0～$2^w-1$ ,程序最多访问$2^w$个字节</p><p>$\quad$ 32位字长限制虚拟地址空间位4GB，扩展到64位有16EB</p><p>$\quad$ 64位机器做了向后兼容，能运行32位机器程序，32位则不能反之。</p><p><img src="/../icsmg/20221119163733.png"></p><p>寻址和字节顺序</p><p><img src="/../icsmg/20221119163748.png"><br>$\quad$ 大端法：顺着读</p><p>$\quad$ 小端法：以字节为单位倒着读</p><p>$\quad$ 大多数Intel兼容机、Andriod、IOS都适用小端法，IBM和Oracle按照大端法。</p><p>位运算（返回一个数）</p><p>$\quad$ ～取反           ｜或          &amp;与      ^异或</p><p>逻辑运算（返回0x01或0x00）</p><p>$\quad$ &amp;&amp; 且     ｜｜或       ！非</p><p>移位运算</p><p>$\quad$ &lt;&lt;左移             &gt;&gt;右移（分为逻辑右移和算数右移，逻辑右移直接移，算数右移高位补k个最高有效位的值。（有符号数算数右移，无符号数逻辑右移））</p><h4 id="2-整数-Integer"><a href="#2-整数-Integer" class="headerlink" title="2. 整数 Integer"></a>2. 整数 Integer</h4><p>$\quad$ Java只支持有符号整数</p><p><strong>无符号数的编码</strong></p><p>$\quad$ B2U&#x3D;$\sum_{i&#x3D;0}^{w-1}x_i*2^i$</p><p>$\quad$ 函数B2U是一个双射</p><p><strong>补码编码</strong></p><p>$\quad$ $B2T_w&#x3D;-x_{w-1}2^{w-1}+\sum_{i&#x3D;0}^{w-2}x_i2^i$</p><p>$\quad$ 最高位$x^{w-1}$也称为符号位，若符号位为0则和无符号数编码表示差不多</p><p>$\quad$ B2$T_w$也是个双射，补码的范围是不对称的<br><img src="/../icsmg/20221119163707.png"><br> <strong>有符号数与无符号数之间的转换</strong></p><p> $\quad$ 强制类型转换的结果保持位值不变，只是改变了这些位的解释方式。</p><p>$\quad$ 无符号数与补码的转换关系：</p><p>$\quad$ U表示无符号数<br><img src="/../icsmg/20221119163815.png"><br>对于C语言中： </p><p>$\quad$ 若双方中同时存有无符号数与有符号数，C语言会隐式的将有符号数强制转换成无符号数来执行运算比如&gt;和&lt;运算。若双方都是U或都是T则用原来的处理。</p><p> <strong>数字的扩展</strong></p><p>$\quad$ 无符号数零扩展：在表示的开头补0</p><p>$\quad$ 有符号数的符号扩展：扩展的数位补符号位</p><p><strong>截断数字</strong></p><p>$\quad$ 直接把前k位舍弃</p><p>数值上：</p><p>$\quad$ 截断无符号数：（相当于取模$2^k$)</p><p>$\quad$ 截断有符号数：相当于视为无符号数处理后再转换为无符号数。</p><p><strong>整数的运算</strong></p><p>$\quad$ 无符号数加法<br><img src="/../icsmg/20221119163843.png"><br>$\quad$ 正常：直接相加                        溢出：减去$2^w$（即为扔去溢出位）</p><p>$\quad$ 判断无符号加法溢出：return sum&gt;&#x3D;x;(true 表示未溢出)</p><p>求反：<br><img src="/../icsmg/20221119163857.png"></p><p>$\quad$ 有符号数的加法</p><p>$\quad$ 分为正溢出和负溢出<br><img src="/../icsmg/20221119163911.png"><br>$\quad$ 补码加法和无符号加法有完全相同的位级表示</p><p>取反：<br><img src="/../icsmg/20221119163935.png"><br>$\quad$ Tmin&#x3D;0x8000000</p><p>无符号乘法：</p><p>$\quad$ 截取运行结果的低w位$(x·y)mod2^w$</p><p>补码乘法：</p><p>$\quad$ 与无符号乘法位级表示一样，数值上多一步转换成无符号数</p><p>$\quad$ 乘2的幂相当于左移操作，乘常数就可以分解成移位和加法</p><p>除法</p><p>$\quad$ 除以2的幂：</p><p>$\quad$ 采用右移，无符号数逻辑右移，朝着向0的方向进行舍入。有符号数算数右移，也朝0舍入，所以会在移位之前加入一个偏置来修正。偏置的值等于1左移k位减1。&#x2F;&#x2F;只有负数需要用偏置</p><p>$\quad$ 不能推广到任意常数。</p><h4 id="3-浮点数"><a href="#3-浮点数" class="headerlink" title="3.  浮点数"></a>3.  浮点数</h4><p>$\quad$ 二进制小数：.后为2的负幂如（1&#x2F;8）&#x3D; $（0.001）_2$</p><p>IEEE浮点表示：</p><p>$V&#x3D;(-1)^s<em>M</em>2^E$</p><p>$\quad$ s为符号位；M是尾数，是二进制小数；E是阶码<br><img src="/../icsmg/20221119164129.png"><br>$\quad$ float 1-8-23</p><p>$\quad$ double 1-11-52</p><p>$\quad$ exp是无符号数</p><p>分类<br><img src="/../icsmg/20221119164142.png"></p><p>$\quad$ 规格化的值：exp不为0或255</p><p>$\quad$ 非规格化的值：exp为0</p><p>$\quad$ 无穷大：exp为255（全是1），frac全为0</p><p>$\quad$ NaN：exp为255，frac不为0</p><p><strong>表示规格化的值时：</strong></p><p>$\quad$ 阶码字段为以偏置形式表示的有符号整数，E&#x3D;e-Bias</p><p>$\quad$ $e\in[1,254],Bias&#x3D;2^{k-1}-1$(单精度为127，双精度为1023)</p><p> $\quad$ $E\in[-126,127]$ (float),$E\in<a href="double">-1022,1023</a>$，$M\in[1,2)$<br><img src="/../icsmg/20221119164220.png"></p><p><strong>表示非规格化的值时：</strong></p><p>$\quad$ exp，s，frac全为0，表示+0，s&#x3D;1，frac，exp为0，表示-0</p><p>$\quad$ 此时M&#x3D;f；E&#x3D;1-Bias</p><p><strong>特殊值</strong>： 表示无穷大</p><p><strong>浮点数舍入</strong></p><p>$\quad$ 1. 向偶数舍入</p><p>   $\quad$ 向最近值进行舍入，为0.5则遵循最低有效数位是偶数</p><p>$\quad$ 2. 向0舍入</p><p>$\quad$ 3. 向下舍入</p><p>$\quad$ 4. 向上舍入</p><p>  $\quad$ 浮点数运算不具有结合性与分配性，因为可能出现溢出和舍入。</p><hr><h3 id="LAB"><a href="#LAB" class="headerlink" title="LAB:"></a>LAB:</h3><p><strong>此章节后完成<a href="https://github.com/Aki-yzh/PKU-ICS-2022/tree/main/LABS/1-datalab">datalab（80.0&#x2F;80.0）</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1-计算机系统漫游&amp;目录</title>
    <link href="/2023/02/18/1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8&amp;%E7%9B%AE%E5%BD%95/"/>
    <url>/2023/02/18/1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8&amp;%E7%9B%AE%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="对应-CSAPP-第一章节"><a href="#对应-CSAPP-第一章节" class="headerlink" title="对应 CSAPP 第一章节"></a>对应 CSAPP 第一章节</h2><span id="more"></span><h1 id="ICS"><a href="#ICS" class="headerlink" title="ICS"></a>ICS</h1><hr><h2 id="计算机系统漫游"><a href="#计算机系统漫游" class="headerlink" title="计算机系统漫游"></a>计算机系统漫游</h2><p>$\quad$ 对32位机器，一个word占4字节；对64位机器，一个word占8个字节*</p><p>$\quad$ 8个位为1字节即对16进制编码00为一个字节</p><h4 id="Amahl定律"><a href="#Amahl定律" class="headerlink" title="Amahl定律"></a>Amahl定律</h4><p>$\quad$ 加速比$S&#x3D;T_{old}&#x2F;T_{new}&#x3D;1&#x2F;((1-\alpha)+\alpha&#x2F;k)$  </p><p>$\quad$ $\alpha$为某部分执行时间与$T_{old}$的比，k为该部分性能提升比例</p><hr><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="一、程序结构与执行"><a href="#一、程序结构与执行" class="headerlink" title="一、程序结构与执行"></a>一、程序结构与执行</h3><h4 id="2-信息的表示与处理"><a href="#2-信息的表示与处理" class="headerlink" title="2. 信息的表示与处理"></a>2. <a href="https://aki-yzh.github.io/2023/02/18/2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86">信息的表示与处理</a></h4><h4 id="3-程序的机器级别表示"><a href="#3-程序的机器级别表示" class="headerlink" title="3. 程序的机器级别表示"></a>3. <a href="https://aki-yzh.github.io/2023/02/18/3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA">程序的机器级别表示</a></h4><h4 id="4-处理器体系结构"><a href="#4-处理器体系结构" class="headerlink" title="4. 处理器体系结构"></a>4. <a href="https://aki-yzh.github.io/2023/02/18/4-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">处理器体系结构</a></h4><h4 id="5-优化程序性能"><a href="#5-优化程序性能" class="headerlink" title="5. 优化程序性能"></a>5. <a href="https://aki-yzh.github.io/2023/02/18/5-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD">优化程序性能</a></h4><h4 id="6-存储器层次结构"><a href="#6-存储器层次结构" class="headerlink" title="6. 存储器层次结构 "></a>6. <a href="https://aki-yzh.github.io/2023/02/18/6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84">存储器层次结构 </a></h4><h3 id="二、在系统上运行程序"><a href="#二、在系统上运行程序" class="headerlink" title="二、在系统上运行程序"></a>二、在系统上运行程序</h3><h4 id="7-链接"><a href="#7-链接" class="headerlink" title="7. 链接"></a>7. <a href="https://aki-yzh.github.io/2023/02/18/7-%E9%93%BE%E6%8E%A5">链接</a></h4><h4 id="8-异常控制流"><a href="#8-异常控制流" class="headerlink" title="8. 异常控制流"></a>8. <a href="https://aki-yzh.github.io/2023/02/18/8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81">异常控制流</a></h4><h4 id="9-虚拟内存"><a href="#9-虚拟内存" class="headerlink" title="9. 虚拟内存"></a>9. <a href="https://aki-yzh.github.io/2023/02/18/9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98">虚拟内存</a></h4><h3 id="三、程序间的交互和通信"><a href="#三、程序间的交互和通信" class="headerlink" title="三、程序间的交互和通信"></a>三、程序间的交互和通信</h3><h4 id="10-系统级I-x2F-O"><a href="#10-系统级I-x2F-O" class="headerlink" title="10. 系统级I&#x2F;O"></a>10. <a href="https://aki-yzh.github.io/2023/02/18/10-%E7%B3%BB%E7%BB%9F%E7%BA%A7IO">系统级I&#x2F;O</a></h4><h4 id="11-网络编程"><a href="#11-网络编程" class="headerlink" title="11. 网络编程"></a>11. <a href="https://aki-yzh.github.io/2023/02/18/11-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B">网络编程</a></h4><h4 id="12-并发编程"><a href="#12-并发编程" class="headerlink" title="12. 并发编程"></a>12. <a href="https://aki-yzh.github.io/2023/02/18/12-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B">并发编程</a></h4><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
      <tag>目录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Helloworld</title>
    <link href="/2023/01/22/hello-world/"/>
    <url>/2023/01/22/hello-world/</url>
    
    <content type="html"><![CDATA[<p>This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>$i_8$</p><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>

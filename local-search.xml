<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>cfar</title>
    <link href="/2024/02/16/CFAR/"/>
    <url>/2024/02/16/CFAR/</url>
    
    <content type="html"><![CDATA[<p>恒虚警率算法</p><span id="more"></span><h1 id="CFAR"><a href="#CFAR" class="headerlink" title="CFAR"></a>CFAR</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>$\quad$ 检测过程可用门限检测来描述。几乎所有的判断都是以接收机的输出与某个门限电平的比较为基础的，如果接收机输出的包络超过了某一设置门限，就认为出现了目标。<br>$\quad$ 探测时会受到噪声、杂波和干扰的影响，因而采用固定门限进行目标检测时会产生一定的虚警，特别是当杂波背景起伏变化时虚警率会急剧上升，严重影响检测性能。因此，根据杂波数据动态调整检测门限，在虚警概率保持不变的情况下实现目标检测概率最大化，这种方法称为恒虚警率（Constant False Alarm Rate，CFAR）检测技术。<br>$\quad$ 判决过程中，可能会出现两类错误。第一类是在没有目标时判断为有目标，这类错误称为虚警。另一类是在有目标时判断为没有目标，这类错误称为漏警。以上两类错误以一定的概率出现，分别称为虚警概率和漏警概率。</p><h2 id="CFAR检测算法"><a href="#CFAR检测算法" class="headerlink" title="CFAR检测算法"></a>CFAR检测算法</h2><p>$\quad$ 目前，研究人员针对各种杂波环境下提出了许多高效的CFAR检测算法，大体可分为两类：一类是均值类CFAＲ(CA-CFAＲ)算法，该类算法应用的前提是假设背景杂波是均匀分布的；另一类是有序统计类CFAＲ(OS-CFAＲ)算法，这类算法是为了应对邻域内多目标情况而设计的。</p><h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>$\quad$ CFAR检测器的输入一般包括检测单元Y和2n个参考单元。参考单元位于检测单元两侧，前后各n个。保护单元主要用在单目标情况下，防止目标能量泄漏到参考单元影响检测效果。设参考门限电平为$V_{TH},V_{TH}&#x3D;T * Z$ 其中：Z为总的杂波功率水平的估计，T为门限因子，则当 Y &gt; $V_{TH}$ 时，认为有目标；反之，认为没有目标。<br>处理流程如下图所示<br><img src="/../FMCWmg/CFAR1.png"><br>$\quad$ 一般情况下，杂波同噪声相互独立，且平方律检波后都满足指数分布。参考单元的概率密度函数为：<br><img src="/../FMCWmg/cfar02.png"><br>$\quad$ 设$H_0$ 表示为没有目标， $P[Y&gt;TZ|H_0]$ 则表示为在没有目标的条件下判断为有目标的概率，从而得到虚警概率的表达式为<br><img src="/../FMCWmg/cfar03.png"><br>$\quad$ 式中， μ是噪声功率； Z为随机变量，它的分布取决于CFAR算法的类型以及参考单元的分布； $M_{Z}(u)_{u&#x3D;T&#x2F;2μ}$为矩母函数</p><h3 id="几种典型的CFAR"><a href="#几种典型的CFAR" class="headerlink" title="几种典型的CFAR"></a>几种典型的CFAR</h3><p><img src="/../FMCWmg/cfar04.png"><br>$\quad$ CA(Cell Averaging)-CFAR杂波功率水平 Z的计算方式为 2 n个参考单元之和，最大选择GO(Greatest Of)-CFAR是选取前面 n个参考单元之和与后面 n 个参考单元之和中的大者作为背景杂波功率水平 Z ；SO(Smallest Of)-CFAR是选取前面 n 个参考单元之和与后面 n 个参考单元之和中的小者作为背景杂波功率水平 Z。<br><img src="/../FMCWmg/cacfar2.png"><br><img src="/../FMCWmg/gocfar.png"><br><img src="/../FMCWmg/cacfar.png"><br><img src="/../FMCWmg/socfar.png"></p><hr>]]></content>
    
    
    <categories>
      
      <category>CS科研</category>
      
      <category>cfar</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FMCW</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ Boost：：asio库的使用</title>
    <link href="/2024/01/27/C++%20Boost%EF%BC%9A%EF%BC%9Aasio%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/01/27/C++%20Boost%EF%BC%9A%EF%BC%9Aasio%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>C++ Boost：：asio库的使用</p><span id="more"></span><p> boost 库是一个优秀的，可移植的，开源的 C++ 库，它是由 C++ 标准委员会发起的，其中一些内容已经成为了下一代 C++ 标准库的内容，在 C++ 社区中影响甚大，是一个不折不扣的准标准库，它的功能十分强大，弥补了 C++ 很多功能函数处理上的不足。</p><h6 id="Boost库的下载安装"><a href="#Boost库的下载安装" class="headerlink" title="Boost库的下载安装"></a>Boost库的下载安装</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">wget https://dl.bintray.com/boostorg/release/<span class="hljs-number">1.76</span><span class="hljs-number">.0</span>/source/boost_1_76_0.tar.gz<br><br>tar -xzvf boost_1_76_0.tar.gz<br><br>./bootstrap.sh --prefix=/usr/local<br><br>./b2 install<br></code></pre></td></tr></table></figure><h6 id="Boost库的使用"><a href="#Boost库的使用" class="headerlink" title="Boost库的使用"></a>Boost库的使用</h6><p><strong>头文件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;boost/asio.hpp&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>tcp操作</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//tcp connect</span><br>boost::asio::io_service io_service;<br><br><span class="hljs-function">tcp::acceptor <span class="hljs-title">acceptor</span><span class="hljs-params">(io_service, tcp::endpoint(tcp::v4(), <span class="hljs-number">5001</span>))</span></span>;<br><br><span class="hljs-function">tcp::socket <span class="hljs-title">socket</span><span class="hljs-params">(io_service)</span></span>;<br><br><br>acceptor.<span class="hljs-built_in">accept</span>(socket);<br><br><span class="hljs-comment">// Set input buffer size</span><br><br>boost::asio::<span class="hljs-function">socket_base::receive_buffer_size <span class="hljs-title">option</span><span class="hljs-params">(<span class="hljs-number">1028</span> * Para.FRAME_SIZE)</span></span>;<br><br>socket.<span class="hljs-built_in">set_option</span>(option);<br><br>......<br><br><span class="hljs-function">std::vector&lt;<span class="hljs-type">short</span>&gt; <span class="hljs-title">data</span><span class="hljs-params">(whole_num * for_nums)</span></span>;<br><br><span class="hljs-comment">// 读取数据</span><br><br>boost::asio::<span class="hljs-built_in">read</span>(socket, boost::asio::<span class="hljs-built_in">buffer</span>(data));<br><br></code></pre></td></tr></table></figure><p><strong>串口操作</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++">boost::asio::io_service io;<br><br>boost::<span class="hljs-function">asio::serial_port <span class="hljs-title">serial</span><span class="hljs-params">(io)</span></span>;<br><br><span class="hljs-comment">// 打开串口设备</span><br><br>serial.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/dev/ttyUSB1&quot;</span>);<br><br><span class="hljs-comment">// 设置波特率</span><br><br>serial.<span class="hljs-built_in">set_option</span>(boost::asio::serial_port::<span class="hljs-built_in">baud_rate</span>(<span class="hljs-number">3000000</span>));<br><br><span class="hljs-comment">// 发送指令</span><br><br>std::string instruction = <span class="hljs-string">&quot;scan start -1 stream_on adc lvds\n&quot;</span>;<br><br><span class="hljs-comment">//std::vector&lt;int&gt; instruction(instruction_str.begin(),instruction_str.end());</span><br><br>boost::asio::<span class="hljs-built_in">write</span>(serial, boost::asio::<span class="hljs-built_in">buffer</span>(instruction));<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>CS科研</category>
      
      <category>C++库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Boost</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ fftw库的使用</title>
    <link href="/2024/01/27/C++%20fftw%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/01/27/C++%20fftw%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>C++ fftw库的使用</p><span id="more"></span><p>FFTW ( the Faster Fourier Transform in the West) 是一个快速计算离散傅里叶变换的标准C语言程序集，其由MIT的M.Frigo 和S. Johnson 开发。可计算一维或多维实和复数据以及任意规模的DFT。如果你的输入信号的采样频率是Fs，你执行了N点的FFT，那么结果数组的第i个元素对应的频率是i*Fs&#x2F;N</p><h6 id="fftw库的下载安装"><a href="#fftw库的下载安装" class="headerlink" title="fftw库的下载安装"></a>fftw库的下载安装</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>tar -xzvf fftw-<span class="hljs-number">3.3</span><span class="hljs-number">.8</span>.tar.gz<br><br>./configure --prefix=/home/xxx/usr/fftw --enable-mpi --enable-openmp --enable-threads --enable-shared MPICC=mpicc CC=gcc F77=gfortran<br><br>make<br><br>make install<br><br>export LD_LIBRARY_PATH=/home/xxx/usr/fftw/lib:$LD_LIBRARY_PATH<br><br></code></pre></td></tr></table></figure><h6 id="fftw库的使用"><a href="#fftw库的使用" class="headerlink" title="fftw库的使用"></a>fftw库的使用</h6><p><strong>头文件</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fftw3.h&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>进行fft</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fft</span><span class="hljs-params">(std::vector&lt;std::complex&lt;<span class="hljs-type">double</span>&gt;&gt;&amp; a)</span> </span>&#123;<br><br><span class="hljs-function">vector&lt;Complex&gt; <span class="hljs-title">temp</span><span class="hljs-params">(N)</span></span>;<br><br>fftw_complex* data = <span class="hljs-built_in">reinterpret_cast</span>&lt;fftw_complex*&gt;(a.<span class="hljs-built_in">data</span>());<br><br>fftw_complex* data1 = <span class="hljs-built_in">reinterpret_cast</span>&lt;fftw_complex*&gt;(temp.<span class="hljs-built_in">data</span>());<br><br>fftw_plan p = <span class="hljs-built_in">fftw_plan_dft_1d</span>(N, data, data1, FFTW_FORWARD, FFTW_ESTIMATE);<br><br><span class="hljs-built_in">fftw_execute</span>(p);<br><br>a.<span class="hljs-built_in">assign</span>(temp.<span class="hljs-built_in">begin</span>(),temp.<span class="hljs-built_in">end</span>());<br><br>&#125;<br></code></pre></td></tr></table></figure><p>2维同理</p><hr>]]></content>
    
    
    <categories>
      
      <category>CS科研</category>
      
      <category>C++库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Boost</tag>
      
      <tag>linux</tag>
      
      <tag>fft</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派网络问题</title>
    <link href="/2024/01/26/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/"/>
    <url>/2024/01/26/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>科研过程中遇到的树莓派网络相关问题与解决</p><span id="more"></span><h6 id="一、网口静态ip的配置"><a href="#一、网口静态ip的配置" class="headerlink" title="一、网口静态ip的配置"></a>一、网口静态ip的配置</h6><p><strong>问题描述</strong><br>以太网口需要配置静态ip<br><strong>问题解决</strong><br>修改&#x2F;etc&#x2F;dhcpcd.conf文件，配置为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c">interface eth0<br><br><span class="hljs-type">static</span> ip_address=<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.100</span>/<span class="hljs-number">24</span><br><br><span class="hljs-type">static</span> routers=<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span><br><br><span class="hljs-type">static</span> domain_name_servers=<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span><br><br>interface eth1 #外接以太网口的配置<br><br><span class="hljs-type">static</span> ip_address=<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.100</span>/<span class="hljs-number">24</span><br><br><span class="hljs-type">static</span> routers=<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span><br><br><span class="hljs-type">static</span> domain_name_servers=<span class="hljs-number">192.168</span><span class="hljs-number">.1</span><span class="hljs-number">.1</span><br></code></pre></td></tr></table></figure><h6 id="二、有线网卡与无线网卡的同时使用优先级"><a href="#二、有线网卡与无线网卡的同时使用优先级" class="headerlink" title="二、有线网卡与无线网卡的同时使用优先级"></a>二、有线网卡与无线网卡的同时使用优先级</h6><p><strong>问题描述</strong><br>以太网口eth0连接内网而无线网卡wlan0连接外网，但是连接上以太网口后无法ping通外网<br><strong>问题解决</strong><br>为使用网络的优先级问题<br>输入</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">$ sudo ip route show<br></code></pre></td></tr></table></figure><p>显示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">pi@raspberrypi:~ $ ip route show<br><span class="hljs-keyword">default</span> via <span class="hljs-number">192.168</span><span class="hljs-number">.9</span><span class="hljs-number">.1</span> dev eth0 src <span class="hljs-number">192.168</span><span class="hljs-number">.9</span><span class="hljs-number">.98</span> <br><span class="hljs-keyword">default</span> via <span class="hljs-number">192.168</span><span class="hljs-number">.77</span><span class="hljs-number">.1</span> dev wlan0 src <span class="hljs-number">192.168</span><span class="hljs-number">.77</span><span class="hljs-number">.186</span> <br><span class="hljs-number">192.168</span><span class="hljs-number">.9</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span> dev eth0 proto dhcp scope link src <span class="hljs-number">192.168</span><span class="hljs-number">.9</span><span class="hljs-number">.98</span> <br><span class="hljs-number">192.168</span><span class="hljs-number">.77</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span> dev wlan0 proto dhcp scope link src <span class="hljs-number">192.168</span><span class="hljs-number">.77</span><span class="hljs-number">.186</span> <br></code></pre></td></tr></table></figure><p>表示eth0的优先级高于wlan0<br>我们修改&#x2F;etc&#x2F;dhcpcd.conf文件，加入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">interface wlan0<br><br>metric <span class="hljs-number">200</span><br><br>interface eth1 #外接以太网口的配置<br><br>metric <span class="hljs-number">300</span><br></code></pre></td></tr></table></figure><p>此时再次输入命令行，显示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">pi@raspberrypi:~ $ ip route show<br><span class="hljs-keyword">default</span> via <span class="hljs-number">192.168</span><span class="hljs-number">.77</span><span class="hljs-number">.1</span> dev wlan0 src <span class="hljs-number">192.168</span><span class="hljs-number">.77</span><span class="hljs-number">.186</span> metric <span class="hljs-number">200</span><br><span class="hljs-keyword">default</span> via <span class="hljs-number">192.168</span><span class="hljs-number">.9</span><span class="hljs-number">.1</span> dev eth0 src <span class="hljs-number">192.168</span><span class="hljs-number">.9</span><span class="hljs-number">.98</span> metric <span class="hljs-number">300</span><br><span class="hljs-number">192.168</span><span class="hljs-number">.9</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span> dev eth0 proto dhcp scope link src <span class="hljs-number">192.168</span><span class="hljs-number">.9</span><span class="hljs-number">.98</span> metric <span class="hljs-number">300</span><br><span class="hljs-number">192.168</span><span class="hljs-number">.77</span><span class="hljs-number">.0</span>/<span class="hljs-number">24</span> dev wlan0 proto dhcp scope link src <span class="hljs-number">192.168</span><span class="hljs-number">.77</span><span class="hljs-number">.186</span> metric <span class="hljs-number">200</span><br></code></pre></td></tr></table></figure><p>配置成功，可ping通外网</p><hr>]]></content>
    
    
    <categories>
      
      <category>CS科研</category>
      
      <category>树莓派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树莓派</tag>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链路层-无线网络</title>
    <link href="/2024/01/03/%E9%93%BE%E8%B7%AF%E5%B1%82-%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C/"/>
    <url>/2024/01/03/%E9%93%BE%E8%B7%AF%E5%B1%82-%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<p> 对应 北京大学计算机网络课程第五讲第三部分<br> 参考教材计算机网络-自顶向下方法</p><span id="more"></span><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="链路层-无线网络"><a href="#链路层-无线网络" class="headerlink" title="链路层-无线网络"></a>链路层-无线网络</h2><h3 id="无线网络简介"><a href="#无线网络简介" class="headerlink" title="无线网络简介"></a>无线网络简介</h3><h6 id="组成无线网络的元素"><a href="#组成无线网络的元素" class="headerlink" title="组成无线网络的元素"></a>组成无线网络的元素</h6><p>$\quad$ 无线主机</p><p>$\quad$ $\quad$ 例：笔记本电脑，智能手机</p><p>$\quad$ $\quad$ 运行应用程序</p><p>$\quad$ $\quad$ 静止的或者移动的</p><p>$\quad$ $\quad$ $\quad$ 无线并不意味着移动</p><p>$\quad$ 基站</p><p>$\quad$ $\quad$ 通常与有线网络连接</p><p>$\quad$ $\quad$ 主要功能：中继（relay）</p><p>$\quad$ $\quad$ $\quad$ 在有线网络与无线主机之间互相传输报文</p><p>$\quad$ $\quad$ $\quad$ 有覆盖范围限制</p><p>$\quad$ $\quad$ $\quad$ 例：无线信号塔，WiFi接入点</p><p>$\quad$ 无线链路</p><p>$\quad$ $\quad$ 主要用于连接基站与无线主机</p><p>$\quad$ $\quad$ $\quad$ 有些场景下也用于连接其他网络设备（如交换机与路由器）</p><p>$\quad$ $\quad$ 需要多路访问控制，以协调各个主机对链路的访问</p><p>$\quad$ $\quad$ 各类链路传输速率，支持距离差异很大</p><h6 id="无线网络的分类"><a href="#无线网络的分类" class="headerlink" title="无线网络的分类"></a>无线网络的分类</h6><p>$\quad$ 类型1：基于基础设施的无线网络</p><p>$\quad$ $\quad$ 特点：使用基站连向更大的网络</p><p>$\quad$ $\quad$ 切换（handoff）问题: 设备移动，导致所连接的基站发生变化</p><p>$\quad$ 类型2：自组织网络</p><p>$\quad$ $\quad$ 没有基站</p><p>$\quad$ $\quad$ 节点自我组织成一个网络</p><p>$\quad$ $\quad$ $\quad$ 节点只能在无线链路的覆盖范围内互相连接</p><p>$\quad$ $\quad$ $\quad$ 相互路由、交换</p><p>$\quad$ 还可以根据数据报文是否经过多个无线链路分类</p><p><img src="/../CNP/CN1601.png"></p><h6 id="无线网络的核心问题"><a href="#无线网络的核心问题" class="headerlink" title="无线网络的核心问题"></a>无线网络的核心问题</h6><p>$\quad$ 无线（wireless)：如何通过无线链路进行数据传输</p><p>$\quad$ $\quad$ 数据链路层技术</p><p>$\quad$ $\quad$ 需要根据无线链路物理特性，考虑差错控制、多路访问控制等功能</p><p>$\quad$ 移动（mobility）：处理主机所连基站发生的变动</p><p>$\quad$ $\quad$ 定位主机</p><p>$\quad$ $\quad$ IP地址</p><p>$\quad$ $\quad$ 保持TCP连接</p><h3 id="无线链路特征与多路访问"><a href="#无线链路特征与多路访问" class="headerlink" title="无线链路特征与多路访问"></a>无线链路特征与多路访问</h3><h6 id="无线链路特征"><a href="#无线链路特征" class="headerlink" title="无线链路特征"></a>无线链路特征</h6><p>$\quad$ 递减的信号强度</p><p>$\quad$ $\quad$ 信号穿过物体时，强度将减弱</p><p>$\quad$ $\quad$ 即使自由空间中，随着距离增加也会衰减（称为路径损耗 path loss）</p><p>$\quad$ 其他信号源的干扰</p><p>$\quad$ $\quad$ 如：2.4GHz 无线LAN与2.4GHz 无线电话</p><p>$\quad$ $\quad$ 微波、电动机等等</p><p>$\quad$ 多路径传播：电磁波反射后，通过不同路径到达接收端</p><p>$\quad$ 在无线链路上进行数据传输更为困难</p><p>$\quad$ 信噪比（signal-to-noise ratio，SNR）：收到信息强度与噪声强度的相对值</p><p>$\quad$ $\quad$ 单位：分贝</p><p>$\quad$ $\quad$ 信噪比越高，越容易提取信息</p><p>$\quad$ 比特差错率（BER）：接收方收到的错误比特的比例</p><p>$\quad$ 物理层：不同传输速率、不同BER vs SNR</p><p>$\quad$ $\quad$ 给定物理层：增加传输功率 -&gt; 增加SNR -&gt; 降低BER</p><p>$\quad$ $\quad$ 给定信噪比：增加传输速率 -&gt; 增加BER</p><p>$\quad$ 实际：SNR随着主机移动或者环境变化改变</p><p>$\quad$ $\quad$ 自适应物理层技术：在BER不超过特定值下，选择最高传输速率</p><h6 id="多路访问问题"><a href="#多路访问问题" class="headerlink" title="多路访问问题"></a>多路访问问题</h6><p>相比于有线链路，无线链路有更复杂问题</p><p>$\quad$ 问题1：隐藏终端</p><p>$\quad$ $\quad$ B与A可以互相听到</p><p>$\quad$ $\quad$ B与C可以互相听到</p><p>$\quad$ $\quad$ A与C之间存在障碍，无法听到对方存在</p><p>$\quad$ $\quad$ $\quad$ 更无法知道双方在B处互相干扰</p><p>$\quad$ 问题2：信号衰减</p><p>$\quad$ $\quad$ B与A可以互相听到</p><p>$\quad$ $\quad$ B与C可以互相听到</p><p>$\quad$ $\quad$ A与C之间收到的对方信号极为微弱</p><p>$\quad$ $\quad$ $\quad$ 更无法知道双方在B处互相干扰</p><h5 id="多路访问"><a href="#多路访问" class="headerlink" title="多路访问"></a>多路访问</h5><p>$\quad$ 信道划分:</p><p>$\quad$ $\quad$ TDMA、FDMA、基于编码（CDMA）</p><p>$\quad$ 随机访问</p><p>$\quad$ $\quad$ ALOHA类：纯ALOHA、时隙ALOHA</p><p>$\quad$ $\quad$ CSMA类：非持续CSMA、1-持续CSMA、p-持续CSMA、CSMA&#x2F;CD、CSMA&#x2F;CA（WLAN中使用）</p><p>$\quad$ 轮流协议：</p><p>$\quad$ $\quad$ 轮询协议</p><p>$\quad$ $\quad$ 令牌协议</p><p>$\quad$ $\quad$ 位图协议</p><p>$\quad$ $\quad$ 二进制倒计数协议</p><p>$\quad$ $\quad$ 有限竞争协议：自适应树</p><h6 id="码分复用-Code-Division-Multiple-Access-CDMA"><a href="#码分复用-Code-Division-Multiple-Access-CDMA" class="headerlink" title="码分复用 Code Division Multiple Access (CDMA)"></a>码分复用 Code Division Multiple Access (CDMA)</h6><p>$\quad$ 本质上将所有可能编码的集合划分给用户</p><p>$\quad$ $\quad$ 所有用户采用同样的信道频段</p><p>$\quad$ $\quad$ 每个用户拥有各自的编码机制（称为码片 code chipping）</p><p>$\quad$ 允许用户同时传输数据</p><p>$\quad$ $\quad$ 通过编码机制的设计，尽量减少干扰的影响（称为编码正交性）</p><p>$\quad$ 编码过程</p><p><img src="/../CNP/CN1602.png"></p><p>$\quad$ 解码过程</p><p><img src="/../CNP/CN1603.png"></p><p>$\quad$ 例子:</p><p><img src="/../CNP/CN1604.png"></p><p>$\quad$ 两个发送者</p><p><img src="/../CNP/CN1605.png"></p><p>$\quad$ CDMA属扩频(spread spectrum)通信中的一种</p><p>$\quad$ 扩频通信通常有两大类：</p><p>$\quad$ $\quad$ 1.一种是直接序列扩频DSSS (Direct Sequence Spread Spectrum)，如CDMA使用码片序列就是这一类</p><p>$\quad$ $\quad$ 2.另一种是跳频扩频FHSS (Frequency Hopping Spread Spectrum)，在蓝牙802.15中使用</p><h3 id="802-11无线局域网（WiFi）"><a href="#802-11无线局域网（WiFi）" class="headerlink" title="802.11无线局域网（WiFi）"></a>802.11无线局域网（WiFi）</h3><p>$\quad$ 网络由基本服务集（Basic Service Set, BSS) 组成</p><p>$\quad$ 基本服务集包含:</p><p>$\quad$ $\quad$ 无线主机</p><p>$\quad$ $\quad$ 接入点（access point, AP): 基站的角色</p><p>$\quad$ $\quad$ $\quad$ 主机间通过AP进行通信</p><p>$\quad$ $\quad$ $\quad$ 只在基础设施模式下存在</p><p>$\quad$ $\quad$ 自组织模式: 只有无线主机</p><h6 id="信道与关联"><a href="#信道与关联" class="headerlink" title="信道与关联"></a>信道与关联</h6><p>$\quad$ 每个无线主机在能够发送或接收网络层数据之前，必须与一个AP关联（association)</p><p>$\quad$ AP的部署（802.11b为例）</p><p>$\quad$ $\quad$ 管理员为每个AP配置一个服务集标识符（SSID）</p><p>$\quad$ $\quad$ 802.11b频段范围 2.4GHz-2.485GHz spectrum，被划分为11个信道</p><p>$\quad$ $\quad$ 管理员为AP选择一个信道</p><p>$\quad$ $\quad$ 冲突不可避免：不同的AP可能选择相同信道、信道可能重叠</p><p>$\quad$ 主机关联AP的过程</p><p>$\quad$ $\quad$ AP周期性发送信标帧（beacon frame），包含AP的SSID与MAC地址</p><p>$\quad$ $\quad$ 主机扫描信道，监听信标帧</p><p>$\quad$ $\quad$ 收到多个AP的信标帧时，选择1个进行关联</p><p>$\quad$ $\quad$ $\quad$ 没有明确的选择算法</p><p>$\quad$ $\quad$ 关联时，需要身份验证（可选）、分配IP（通常用DHCP）</p><p><img src="/../CNP/CN1606.png"></p><h6 id="多路访问控制"><a href="#多路访问控制" class="headerlink" title="多路访问控制"></a>多路访问控制</h6><p>$\quad$ 目标：避免冲突，即防止多于1个站点同时在信道内传输数据</p><p>$\quad$ $\quad$ 难点1：隐藏终端</p><p>$\quad$ $\quad$ 难点2：信号衰减</p><p>$\quad$ 发送前侦听信道</p><p>$\quad$ $\quad$ 避免干扰正在使用信道的其他站点</p><p>$\quad$ 发送时不再进行冲突检测（有别于以太网CSMA&#x2F;CD）</p><p>$\quad$ $\quad$ 由于信号强度衰减，发送时很难收到冲突信号</p><p>$\quad$ $\quad$ CSMA&#x2F;CA（collision avoidance）：发送前就尽量避免冲突</p><h6 id="CSMA-x2F-CA"><a href="#CSMA-x2F-CA" class="headerlink" title="CSMA&#x2F;CA"></a>CSMA&#x2F;CA</h6><p>$\quad$ 802.11 发送方</p><p>$\quad$ $\quad$ 1 如果发送前信道空闲时间达到DIFS，则发送整个帧</p><p>$\quad$ $\quad$ $\quad$ 发送时不进行冲突检测</p><p>$\quad$ $\quad$ 2 如果发送前检测到信道忙，则选择一个随机值作为计时器</p><p>$\quad$ $\quad$ $\quad$ 信道空闲时，计时器递减</p><p>$\quad$ $\quad$ $\quad$ 信道忙时，计时器不变</p><p>$\quad$ $\quad$ 3 计时器减为0时，发送，并等待ACK</p><p>$\quad$ $\quad$ 4 收到ACK后，若马上有下一帧发送，进入步骤2</p><p>$\quad$ $\quad$ $\quad$ 若未收到ACK，进入步骤2准备重传，并且使用更大的随机值</p><p>$\quad$ 802.11 接收方</p><p>$\quad$ $\quad$ 如果收到1个正确的帧，等到SIFS时间后，发送ACK</p><p>$\quad$ $\quad$ (由于隐藏终端，ACK是必要的)</p><p>$\quad$ CSMA&#x2F;CD：一旦空闲，立刻发送</p><p>$\quad$ CSMA&#x2F;CA：一旦空闲，递减计时器</p><p>$\quad$ 防止某个帧传输结束时，多个发送者马上发送冲突</p><h6 id="802-11-预约机制"><a href="#802-11-预约机制" class="headerlink" title="802.11 预约机制"></a>802.11 预约机制</h6><p>$\quad$ 核心思想：允许发送者“预约保留”信道，而不是随机访问</p><p>$\quad$ $\quad$ 避免大帧传输的冲突</p><p>$\quad$ 步骤1：发送者先使用CSMA&#x2F;CA发送一个小报文RTS（request-to-send）给基站</p><p>$\quad$ $\quad$ RTS报文仍然可能发生冲突</p><p>$\quad$ $\quad$ 发生冲突时重试</p><p>$\quad$ $\quad$ 代价可以接受：RTS很小</p><p>$\quad$ 步骤2：基站广播CTS（clear-to-send）消息，作为对RTS的回复</p><p>$\quad$ 步骤3：所有站点都会收到CTS</p><p>$\quad$ $\quad$ 发送者开始传输</p><p>$\quad$ $\quad$ 其他站点推迟传输</p><p>$\quad$ 步骤4：其他站点在传输完成后也能收到ACK</p><p>$\quad$ $\quad$ 开始倒计时、传输</p><p><img src="/../CNP/CN1607.png"></p><h6 id="地址字段"><a href="#地址字段" class="headerlink" title="地址字段"></a>地址字段</h6><p><img src="/../CNP/CN1608.png"></p><p><img src="/../CNP/CN1609.png"></p><h6 id="其他字段"><a href="#其他字段" class="headerlink" title="其他字段"></a>其他字段</h6><p><img src="/../CNP/CN1610.png"></p><h6 id="同一子网下的移动"><a href="#同一子网下的移动" class="headerlink" title="同一子网下的移动"></a>同一子网下的移动</h6><p>$\quad$ H1从基本服务集BBS 1移动到基本服务集BBS 2</p><p>$\quad$ BBS 1与BBS 2属于同一子网，其AP连到同一交换机不同端口</p><p>$\quad$ 移动后，H1仍在同一子网内，IP地址不变</p><p>$\quad$ 交换机：通过逆向学习，知道H1连向哪个端口</p><h6 id="802-11其他功能"><a href="#802-11其他功能" class="headerlink" title="802.11其他功能"></a>802.11其他功能</h6><p>$\quad$ 自适应传输速率</p><p>$\quad$ $\quad$ 根据无线主机的移动，信噪比SNR发生变化</p><p>$\quad$ $\quad$ 基站与无线主机都将动态调整传输速率</p><p>$\quad$ $\quad$ 通过改变物理层的调制技术</p><p>$\quad$ $\quad$ $\quad$ 1. 主机远离基站 -&gt; SNR 降低 -&gt; BER 上升</p><p>$\quad$ $\quad$ $\quad$ 2. 当BER超过一定阈值 -&gt; 选择有更低传输速率但BER也更低的物理层方案</p><p>$\quad$ 功率管理：无线主机在睡眠&#x2F;唤醒两种状态间切换，睡眠状态下节省能耗</p><p>$\quad$ $\quad$ 问题：睡眠状态下，AP无法向主机发送帧</p><p>$\quad$ $\quad$ 流程：</p><p>$\quad$ $\quad$ $\quad$ 主机 -&gt; AP：通知将进入睡眠状态，直到下一个信标帧到来</p><p>$\quad$ $\quad$ $\quad$ $\quad$ 在802.11帧首部将功率管理比特置1</p><p>$\quad$ $\quad$ $\quad$$\quad$ 信标帧每隔100ms发送一次</p><p>$\quad$ $\quad$ $\quad$ AP：在下一个信标帧之前，不再给该主机发送帧，而是进行缓存</p><p>$\quad$ $\quad$ $\quad$ 信标帧：列出了有帧缓存的无线主机</p><p>$\quad$ $\quad$ $\quad$ $\quad$ 如果有帧缓存：主机进入唤醒状态，接收帧</p><p>$\quad$ $\quad$ $\quad$ $\quad$ 如果没有帧缓存：继续睡眠</p><p>$\quad$ $\quad$ $\quad$ $\quad$ 唤醒时间：250μs</p><h3 id="802-15个人域无线网-蓝牙"><a href="#802-15个人域无线网-蓝牙" class="headerlink" title="802.15个人域无线网(蓝牙)"></a>802.15个人域无线网(蓝牙)</h3><p>$\quad$ 传播直径小于10米</p><p>$\quad$ 取代一些有线设备</p><p>$\quad$ $\quad$ 鼠标、键盘、耳机</p><p>$\quad$ 自组织方式：没有基础设施</p><p>$\quad$ 主从模式（master-slave）</p><p>$\quad$ $\quad$ Slave节点请求发送权限</p><p>$\quad$ $\quad$ Master节点授权传输</p><p>$\quad$ 802.15：从蓝牙技术演化而来</p><p>$\quad$ $\quad$ 工作在2.4 GHz波段</p><p>$\quad$ $\quad$ 最高速度 721kbps</p><p>$\quad$ $\quad$ 信道访问控制：划分为长度625μs的时间片、79个频段</p><p>$\quad$ $\quad$ $\quad$ 每个时间片使用1个频段，并且以伪随机方式跳到下一个频段（跳频扩展频谱FHSS）</p><h3 id="蜂窝网"><a href="#蜂窝网" class="headerlink" title="蜂窝网"></a>蜂窝网</h3><p>$\quad$ 核心思想：</p><p>$\quad$ $\quad$ 通过移动电话网络，</p><p>$\quad$ $\quad$ 提供移动数据传输</p><p>$\quad$ 移动交换中心MSC</p><p>$\quad$ $\quad$ 将小区连接到有线网络</p><p>$\quad$ $\quad$ 管理呼叫建立</p><p>$\quad$ $\quad$ 处理移动性</p><p>$\quad$ 小区(cell)</p><p>$\quad$ $\quad$ 覆盖某个地理区域</p><p>$\quad$ $\quad$ 基站(base station, BS): 类似 802.11 AP</p><p>$\quad$ $\quad$ 移动用户通过基站连接到网络</p><h6 id="蜂窝网的第一跳"><a href="#蜂窝网的第一跳" class="headerlink" title="蜂窝网的第一跳"></a>蜂窝网的第一跳</h6><p>$\quad$ 空中接口（air interface）：将无线设备连接到基站</p><p>$\quad$ 2G：组合使用FDMA与TDMA</p><p>$\quad$ $\quad$ 将信道划分为频段</p><p>$\quad$ $\quad$ 每个频段划分为时间片</p><p>$\quad$ 3G：CDMA</p><p>$\quad$ $\quad$ W-CDMA（欧洲）</p><p>$\quad$ $\quad$ CDMA-2000（美国）</p><p>$\quad$ $\quad$ TD-SCDMA（中国）</p><p>$\quad$ 4G：正交频分复用</p><p>$\quad$ 5G：非正交频分复用 + MIMO</p><h3 id="移动性"><a href="#移动性" class="headerlink" title="移动性"></a>移动性</h3><p>网络角度的移动性分类</p><p>:<img src="/../CNP/CN1611.png"></p><p>归属网络: 每个移动设备有个长期的归属网络，一般不更换（如：128.119.40&#x2F;24）</p><p>归属代理: 归属网络中，代表移动设备执行移动性功能的实体</p><p><img src="/../CNP/CN1612.png"></p><p>设备注册</p><p><img src="/../CNP/CN1613.png"></p><h4 id="移动设备如何通信"><a href="#移动设备如何通信" class="headerlink" title="移动设备如何通信"></a>移动设备如何通信</h4><p>$\quad$ 通过代理解决：</p><p>$\quad$ $\quad$ 间接路由：通信者 ßà  归属代理 ßà 外部代理 ßà 移动设备</p><p>$\quad$ $\quad$ 直接路由：通信者 ßà 外部代理 ßà 移动设备</p><p>$\quad$ $\quad$ $\quad$ 通信者一开始仍需要通过归属代理，获取移动设备的转交地址</p><h6 id="间接路由"><a href="#间接路由" class="headerlink" title="间接路由"></a>间接路由</h6><p><img src="/../CNP/CN1614.png"></p><p>$\quad$ 当设备从一个访问网络移动到另一个访问网络</p><p>$\quad$ $\quad$ 在新访问网络进行注册</p><p>$\quad$ $\quad$ 新访问网络中的外部代理通知归属代理</p><p>$\quad$ $\quad$ 归属代理更新该设备的转交地址记录</p><p>$\quad$ $\quad$ 后续报文使用新转交地址发往该设备</p><p>$\quad$ 对于通信者而言，设备移动、访问网络改变、转交地址改变是透明的</p><p>$\quad$ $\quad$ 设备与通信者的连接仍然可以保持！</p><p>$\quad$ 移动设备使用2个地址</p><p>$\quad$ $\quad$ 永久地址：被通信者使用，因此对于通信者而言移动设备的位置是透明的</p><p>$\quad$ $\quad$ 转交地址：被归属代理使用，用于转发到访问网络</p><p>$\quad$ 三角路由问题：</p><p>$\quad$ $\quad$ 效率低下，特别当通信者与移动设备在同一访问网络时</p><h6 id="直接路由"><a href="#直接路由" class="headerlink" title="直接路由"></a>直接路由</h6><p><img src="/../CNP/CN1615.png"></p><p>$\quad$ 解决了三角路由问题</p><p>$\quad$ 对通信者不透明：通信者必须从归属代理获取转交地址</p><p>$\quad$ $\quad$ 如果设备移动到其他访问网络？</p><p>$\quad$ 使用锚外部代理（anchor foreign agent）：第一个访问网络中的外部代理</p><p>$\quad$ 通信者数据始终发往锚外部代理，由锚外部代理转发到当前访问网络</p><p>$\quad$ 当设备到达新的访问网络时</p><p>$\quad$ $\quad$ 向新的外部代理注册（步骤3）</p><p>$\quad$ $\quad$ 新的外部代理向锚外部代理提供新的转交地址（步骤4）</p><h4 id="移动性管理"><a href="#移动性管理" class="headerlink" title="移动性管理"></a>移动性管理</h4><p>$\quad$ 移动IP：支持移动性的Internet体系架构与协议，RFC 5944</p><p>$\quad$ 多个已经学过的技术特征</p><p>$\quad$ $\quad$ 归属代理、外部代理、外部代理注册、转交地址、封装</p><p>$\quad$ 三部分组成</p><p>$\quad$ $\quad$ 报文间接路由</p><p>$\quad$ $\quad$ 代理发现</p><p>$\quad$ $\quad$ 代理注册</p><h6 id="移动IP下的简介路由"><a href="#移动IP下的简介路由" class="headerlink" title="移动ＩＰ下的简介路由"></a>移动ＩＰ下的简介路由</h6><p><img src="/../CNP/CN1616.png"></p><h6 id="移动IP下的代理发现"><a href="#移动IP下的代理发现" class="headerlink" title="移动IP下的代理发现"></a>移动IP下的代理发现</h6><p>$\quad$ 代理通告 – 外部代理&#x2F;归属代理通过广播ICMP报告（typefield&#x3D;9），通告代理服务的存在</p><p>$\quad$ 代理请求 – 设备发送代理请求报文（ICMP typefiled&#x3D;10），然后代理广播通告</p><p>$\quad$ 随后进行注册请求、注册回复</p><p><img src="/../CNP/CN1617.png"></p><h6 id="移动IP下的代理注册"><a href="#移动IP下的代理注册" class="headerlink" title="移动IP下的代理注册"></a>移动IP下的代理注册</h6><p><img src="/../CNP/CN1618.png"></p><h5 id="蜂窝网的移动性管理"><a href="#蜂窝网的移动性管理" class="headerlink" title="蜂窝网的移动性管理"></a>蜂窝网的移动性管理</h5><p>$\quad$ 归属网络：设备订购服务的网络（如：中国移动、中国联通、中国电信）</p><p>$\quad$ $\quad$ 归属位置注册器（HLR）：一个数据库，记录了用户当前位置、电话号码以及各类用户信息（订阅服务、账单、使用偏好）</p><p>$\quad$ $\quad$ 归属MSC：即之前提到的网关MSC</p><p>$\quad$ $\quad$ 归属MSC + 归属HLR &#x3D; 归属代理</p><p>$\quad$ 被访网络：用户设备当前所处网络</p><p>$\quad$ $\quad$ 访问者位置注册（VLR）：一个数据库，记录访问者信息</p><p>$\quad$ $\quad$ VLR + 被访网络的MSC &#x3D; 外部代理</p><p>$\quad$ $\quad$ 被访网络有时与归属网络是同一网络</p><h6 id="间接路由-1"><a href="#间接路由-1" class="headerlink" title="间接路由"></a>间接路由</h6><p><img src="/../CNP/CN1619.png"></p><h6 id="切换"><a href="#切换" class="headerlink" title="切换"></a>切换</h6><p>同一MSC，不同基站</p><p>$\quad$ 切换：将呼叫路径从一个基站转移到另一个基站</p><p>$\quad$ 原因： GSM没有规定切换策略（即何时切换），只规定切换机制（即如何切换）</p><p>$\quad$ $\quad$ 新基站信号更强</p><p>$\quad$ $\quad$ 负载均衡：释放旧基站的信道（GSM采用组合FDM&#x2F;TDM）</p><p>$\quad$ 切换由旧基站发起</p><p>$\quad$ 1.旧基站通知被访MSC即将发起切换，并提供包含至少1个新基站的列表</p><p>$\quad$ 2.MSC选择新基站，设置到新基站的路径，分配相应路由资源，通知新基站</p><p>$\quad$ 3.新基站分配无线信道给该设备</p><p>$\quad$ 4.新基站通知MSC与旧基站，并提供与设备的关联信息</p><p>$\quad$ 5.旧基站告诉无线设备，即将进行切换</p><p>$\quad$ 6.移动设备与新基站交换信息，激活信道</p><p>$\quad$ 7.移动用户通知新基站与MSC，完成激活。MSC中后续呼叫讲路由到新基站</p><p>$\quad$ 8.MSC通知旧基站释放资源</p><p>MSC之间</p><p>$\quad$ 锚MSC：第一个被访网络中的MSC</p><p>$\quad$ $\quad$ 后续呼叫都经过锚MSC</p><p>$\quad$ 设备向新MSC注册时，新MSC通知锚MSC设备位置信息</p><h6 id="LTE（4G）中的移动性管理"><a href="#LTE（4G）中的移动性管理" class="headerlink" title="LTE（4G）中的移动性管理"></a>LTE（4G）中的移动性管理</h6><p>$\quad$ GSM：电话网络中，设备始终处于激活状态</p><p>$\quad$ 4G：设备可能处于休眠状态</p><p>$\quad$ $\quad$ 休眠状态下，从一个基站移动到另一个基站，网络无法获知位置移动</p><p>$\quad$ 解决方案：寻呼（paging），基站定期广播报文，确认设备仍然存在</p><p>$\quad$ 切换过程：与2G、3G类似</p><p>$\quad$ $\quad$ 新基站与MSC准备</p><p>$\quad$ $\quad$ 执行切换</p><p>$\quad$ $\quad$ 完成切换</p><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>CN</category>
      
      <category>链路层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CN</tag>
      
      <tag>链路层</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链路层-有线局域网</title>
    <link href="/2023/12/15/%E9%93%BE%E8%B7%AF%E5%B1%82-%E6%9C%89%E7%BA%BF%E5%B1%80%E5%9F%9F%E7%BD%91/"/>
    <url>/2023/12/15/%E9%93%BE%E8%B7%AF%E5%B1%82-%E6%9C%89%E7%BA%BF%E5%B1%80%E5%9F%9F%E7%BD%91/</url>
    
    <content type="html"><![CDATA[<p> 对应 北京大学计算机网络课程第五讲第二部分<br> 参考教材计算机网络-自顶向下方法</p><span id="more"></span><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="链路层-有线局域网"><a href="#链路层-有线局域网" class="headerlink" title="链路层-有线局域网"></a>链路层-有线局域网</h2><h3 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h3><p>$\quad$ 网络层的子网概念：有相同网络地址的接口组成的网络</p><p>$\quad$ 局域网：不需要网络层技术，就可以传输数据的网络</p><p>$\quad$ 虽然定义不同，但实际上，局域网 &#x3D; 子网</p><h6 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h6><p>$\quad$ IP地址：每个网络接口在网络层的标识</p><p>$\quad$ $\quad$ 用途：网络层转发功能</p><p>$\quad$ $\quad$ 可以修改（静态分配或者DHCP动态分配）</p><p>$\quad$ $\quad$ IPv4:32位，IPv6:128位</p><p>$\quad$ MAC地址（局域网地址或物理地址）：</p><p>$\quad$ $\quad$ 功能：物理上相连的网络接口之间收发帧</p><p>$\quad$ $\quad$ 大部分不可修改：烧录在网络接口控制器（NIC）硬件上</p><p>$\quad$ $\quad$ 48位：例如1A-2F-BB-76-09-AD</p><p>$\quad$ MAC地址由IEEE分配</p><p>$\quad$ $\quad$ 各个网络设备厂商从IEEE购买到特定MAC地址前缀</p><p>$\quad$ $\quad$ 厂商保证所有设备MAC地址不同</p><p>$\quad$ 类比：</p><p>$\quad$ $\quad$ MAC地址: 身份证号</p><p>$\quad$ $\quad$ IP地址: 通信地址</p><p>$\quad$ MAC地址：扁平化 ➜ 可移植</p><p>$\quad$ $\quad$ 可以将一块网卡从一个网络搬到另一个网络</p><p>$\quad$ IP地址：层次化 ➜ 不可移植</p><p>$\quad$ $\quad$ 地址与所属网络有关</p><p>$\quad$ IP地址与MAC地址的映射关系，通过ARP协议得到（参考网络层协议部分讲义）</p><p>$\quad$ $\quad$ ARP只在一个局域网内部工作</p><h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><p>$\quad$ 当前最主流的有线局域网技术</p><p>$\quad$ 也是第一个广泛使用的有线局域网技术</p><p>$\quad$ 主要特点：简单、成本低廉、易于扩展、高速</p><h6 id="以太网帧"><a href="#以太网帧" class="headerlink" title="以太网帧"></a>以太网帧</h6><p><img src="/../CNP/CN1501.png"></p><p>$\quad$ Preamble（前同步码）：8个字节</p><p>$\quad$ $\quad$ 前7个字节值均为10101010：用于同步发送方与接收方的时钟频率</p><p>$\quad$ $\quad$ $\quad$ 以太网有多种频率：10Mbps、100Mbps、1Gbps、10Gbps</p><p>$\quad$ $\quad$ $\quad$ 频率可能会发生偏移</p><p>$\quad$ $\quad$ 第8个字节值为10101011：真正的定界符（字节填充的定界符）</p><p>$\quad$ 物理层交付链路层时，8字节的前同步码不需要保留，也不计入帧头长度</p><p>$\quad$ 目的地址、源地址：各6字节</p><p>$\quad$ $\quad$ 当目的地址与自身地址相同，或者目的地址为一个广播地址，才将帧的data交付给网络层</p><p>$\quad$ $\quad$ 否则，丢弃帧</p><p>$\quad$ $\quad$ 特殊情况：网卡开启混杂模式，可以接收目的MAC地址不是本网络接口的帧</p><p>$\quad$ $\quad$ $\quad$ 用途：Hacker、网络分析</p><p>$\quad$ 类型：2字节，上层（网络层）的报文类型</p><p>$\quad$ $\quad$ 大部分情况下为0x0800，表示网络层为IP协议</p><p>$\quad$ $\quad$ 也可以有其他取值</p><p>$\quad$ CRC：接收方用于校验</p><p>$\quad$ $\quad$ 使用CRC32计算除了校验和以外的其他字段</p><p>$\quad$ $\quad$ 对于检查出的无效 MAC 帧就简单地丢弃。以太网不负责重传丢弃的帧。</p><p>$\quad$ $\quad$ $\quad$ 数据字段的长度与长度字段的值不一致；</p><p>$\quad$ $\quad$ $\quad$ 帧的长度不是整数个字节；</p><p>$\quad$ $\quad$ $\quad$ CRC检验出错；</p><p>$\quad$ $\quad$ $\quad$ 数据字段的长度不在 46 ~ 1500 字节之间。</p><p>$\quad$ 数据字段</p><p>$\quad$ $\quad$ 46 ~ 1500字节</p><p>$\quad$ $\quad$ 最小帧长 &#x3D; 46+18 &#x3D; 64B</p><p>$\quad$ $\quad$ 最大帧长 &#x3D; 1500+18 &#x3D; 1518B （MTU：1500B）</p><p>$\quad$ 数据字段不足46字节，需要填充整数字节（Padding）至46字节，以保证以太网MAC帧不小于64字节。</p><p>$\quad$ 以太网规定最短有效帧长为 64 字节，凡长度小于 64 字节的帧都是由于冲突而异常中止的无效帧。</p><p>$\quad$ $\quad$ 如果发生冲突，就一定是在发送的前 64 字节之内</p><p>$\quad$ $\quad$ 由于一检测到冲突就立即中止发送，这时已经发送出去的数据一定小于 64 字节</p><h6 id="以太网提供的服务"><a href="#以太网提供的服务" class="headerlink" title="以太网提供的服务"></a>以太网提供的服务</h6><p>$\quad$ 无连接：两个NICs之间无需建立连接即可通信</p><p>$\quad$ 不可靠：接收方不发送ACK或者NACK</p><p>$\quad$ $\quad$ 接收方CRC校验失败或者目的地址不符合都直接丢弃数据，并且不通知发送方</p><p>$\quad$ $\quad$ 依赖上层协议（如TCP）进行丢失数据恢复</p><p>$\quad$ 多路访问控制：CSMA&#x2F;CD</p><p>$\quad$ $\quad$ 回退时，基于二进制回退决定随机等待时间</p><h6 id="以太网标准"><a href="#以太网标准" class="headerlink" title="以太网标准"></a>以太网标准</h6><p>$\quad$ 以太网标准是一系列标准的集合</p><p>$\quad$ $\quad$ 包含物理层标准与数据链路层标准</p><p>$\quad$ $\quad$ 不同速率：2 Mbps, 10 Mbps, 100 Mbps, 1Gbps, 10 Gbps, 40 Gbps</p><p>$\quad$ $\quad$ 不同物理介质：光纤、铜线</p><p>$\quad$ 所有标准，都采用相同的帧格式</p><h3 id="数据链路层交换"><a href="#数据链路层交换" class="headerlink" title="数据链路层交换"></a>数据链路层交换</h3><h6 id="组建以太网：集线器"><a href="#组建以太网：集线器" class="headerlink" title="组建以太网：集线器"></a>组建以太网：集线器</h6><p>$\quad$ 早期：使用集线器（HUB）组建以太网</p><p>$\quad$ $\quad$ Hub所有端口内部都是连通的</p><p>$\quad$ $\quad$ 使同一根总线</p><p>$\quad$ Hub的缺点</p><p>$\quad$ $\quad$ 集线器不能增加容量</p><p>$\quad$ $\quad$ 用集线器组成更大的局域网都在一个冲突域中</p><p>$\quad$ $\quad$ Hub级连：限制了网络的可扩展性</p><h6 id="组建以太网：交换机"><a href="#组建以太网：交换机" class="headerlink" title="组建以太网：交换机"></a>组建以太网：交换机</h6><p>$\quad$ 数据链路层设备扩充网络</p><p>$\quad$ $\quad$ 交换机（又称网桥）</p><p>$\quad$ $\quad$ 分隔了冲突域</p><p><img src="/../CNP/CN1502.png"></p><p><img src="/../CNP/CN1503.png"></p><h5 id="数据链路层交换原理"><a href="#数据链路层交换原理" class="headerlink" title="数据链路层交换原理"></a>数据链路层交换原理</h5><p>$\quad$ 现代数据链路层的核心是交换机（Switch）</p><p>$\quad$ $\quad$ 早期又被称为网桥</p><p>$\quad$ $\quad$ 工作在数据链路层，检查MAC 帧的目的地址对收到的帧进行转发</p><p>$\quad$ $\quad$ 交换机通过高速背板把帧传送到目标端口</p><p>$\quad$ 理想的交换机是透明的</p><p>$\quad$ $\quad$ 即插即用，无需任何配置</p><p>$\quad$ $\quad$ 网络中的站点无需感知交换机的存在与否</p><p>$\quad$ 逆向学习：构建MAC地址表</p><p>$\quad$ $\quad$ 根据帧的源地址在MAC地址表查找匹配表项，</p><p>$\quad$ $\quad$ $\quad$ 如果没有，则增加一个新表项（源地址、入境端口、帧到达时间），</p><p>$\quad$ $\quad$ $\quad$ 如果有，则更新原表项的帧到达时间，重置老化时间。</p><p>$\quad$ 对入境帧的转发过程：使用MAC地址表</p><p>$\quad$ $\quad$ 查帧的目的地址是否在MAC地址表中</p><p>$\quad$ $\quad$ $\quad$ 如果有，且入境端口≠出境端口，则从对应的出境端口转发帧；</p><p>$\quad$ $\quad$ $\quad$ 如果有，且入境端口&#x3D;出境端口，则丢弃帧（即过滤帧）；</p><p>$\quad$ $\quad$ $\quad$ 如果没有，则向除入境端口以外的其它所有端口泛洪帧。</p><h6 id="逆向学习"><a href="#逆向学习" class="headerlink" title="逆向学习"></a>逆向学习</h6><p><img src="/../CNP/CN1504.png"></p><p><img src="/../CNP/CN1505.png"></p><p><img src="/../CNP/CN1506.png"></p><p>$\quad$ MAC地址表的构建</p><p>$\quad$ $\quad$ 增加表项：帧的源地址对应的项不在表中</p><p>$\quad$ $\quad$ 删除表项：老化时间到期</p><p>$\quad$ $\quad$ 更新表项：帧的源地址在表中，更新时间戳</p><h6 id="处理数据帧"><a href="#处理数据帧" class="headerlink" title="处理数据帧"></a>处理数据帧</h6><p>交换机对于入境帧的处理分3种情况：（forwarding、filtering、flooding）</p><p><img src="/../CNP/CN1507.png"></p><p><img src="/../CNP/CN1508.png"><img src="/../CNP/CN1509.png"></p><p>$\quad$ Flooding（泛洪）</p><p>$\quad$ $\quad$ 两种目的地址的帧，需要泛洪：</p><p>$\quad$ $\quad$ 广播帧：目的地址为FF-FF-FF-FF-FF-FF的数据帧</p><p>$\quad$ $\quad$ 未知单播帧：目的地址不在MAC地址转发表中的单播数据帧</p><h5 id="交换模式"><a href="#交换模式" class="headerlink" title="交换模式"></a>交换模式</h5><h6 id="1-存储转发模式（Store-and-Forward）"><a href="#1-存储转发模式（Store-and-Forward）" class="headerlink" title="1)  存储转发模式（Store and Forward）"></a>1)  存储转发模式（Store and Forward）</h6><p>$\quad$ 特点：转发前必须接收整个帧、执行CRC校验</p><p>$\quad$ 缺点：延迟大</p><p>$\quad$ 优点：不转发出错帧</p><p><img src="/../CNP/CN1510.png"></p><h6 id="2）直通模式（Cut-through）"><a href="#2）直通模式（Cut-through）" class="headerlink" title="2）直通模式（Cut-through）"></a>2）直通模式（Cut-through）</h6><p>$\quad$ 特点：一旦接收到帧的目的地址，就开始转发</p><p>$\quad$ 缺点：可能转发错误帧</p><p>$\quad$ 优点：延迟非常小，可以边入边出</p><p><img src="/../CNP/CN1511.png"></p><h6 id="3-无碎片模式（Fragment-free）"><a href="#3-无碎片模式（Fragment-free）" class="headerlink" title="3)  无碎片模式（Fragment-free）"></a>3)  无碎片模式（Fragment-free）</h6><p>$\quad$ 特点：接收到帧的前64字节，即开始转发</p><p>$\quad$ 缺点：仍可能转发错误帧</p><p>$\quad$ 优点：过滤了冲突碎片，延迟和转发错帧介于存储转发和直通交换之间</p><p><img src="/../CNP/CN1512.png"></p><h5 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h5><p>$\quad$ 传统LAN分段</p><p>$\quad$ $\quad$ 交换机端口通常与集线器连接；</p><p>$\quad$ $\quad$ 使用交换机把LAN分段为更小的冲突域。</p><p>$\quad$ 现代LAN分段</p><p>$\quad$ $\quad$ 直连PC，微分段，创建无冲突域</p><h3 id="虚拟局域网"><a href="#虚拟局域网" class="headerlink" title="虚拟局域网"></a>虚拟局域网</h3><p>$\quad$ 交换机上连接多组用户</p><p>$\quad$ 问题1：为每一组用户建立各自局域网，但不添置新交换机</p><p>$\quad$ 问题2：为每一组用户建立各自广播域</p><p>$\quad$ $\quad$ ARP，DHCP，未知MAC地址都会产生广播</p><p>$\quad$ $\quad$ 安全&#x2F;隐私要求</p><p>$\quad$ $\quad$ 性能要求</p><p>$\quad$ 可以通过配置交换机，在一套物理交换机设备上，运行多个虚拟局域网（VLAN）</p><p>$\quad$ $\quad$ 每个虚拟局域网，有一个单独的广播域</p><p>$\quad$ 虚拟局域网的类型</p><p>$\quad$ $\quad$ 基于端口的VLAN（最常见）</p><p>$\quad$ $\quad$ 基于MAC地址的VLAN</p><p>$\quad$ $\quad$ 基于协议的VLAN</p><p>$\quad$ $\quad$ 基于子网的VLAN</p><h6 id="类型1-基于端口"><a href="#类型1-基于端口" class="headerlink" title="类型1 :基于端口"></a>类型1 :基于端口</h6><p><img src="/../CNP/CN1513.png"></p><p><img src="/../CNP/CN1514.png"></p><p>$\quad$ 好处：</p><p>$\quad$ $\quad$ 好处1 – 流量隔离：发往&#x2F;来自端口1-8 的帧，最终只能到达端口1-8</p><p>$\quad$ $\quad$ 好处2 – 动态配置：可以动态变更端口属于哪个VLAN</p><p>$\quad$ $\quad$ VLAN之间的数据传输: 通过网络层路由 (如同2个独立局域网之间)</p><p>$\quad$ $\quad$ $\quad$ 现代路由器&#x2F;交换机同时支持链路层与网络层传输</p><h6 id="类型2：基于MAC地址"><a href="#类型2：基于MAC地址" class="headerlink" title="类型2：基于MAC地址"></a>类型2：基于MAC地址</h6><p><img src="/../CNP/CN1515.png"></p><h6 id="类型3：基于协议"><a href="#类型3：基于协议" class="headerlink" title="类型3：基于协议"></a>类型3：基于协议</h6><p><img src="/../CNP/CN1516.png"></p><h6 id="类型4：基于子网"><a href="#类型4：基于子网" class="headerlink" title="类型4：基于子网"></a>类型4：基于子网</h6><p><img src="/../CNP/CN1517.png"></p><h5 id="跨多交换机的虚拟局域网"><a href="#跨多交换机的虚拟局域网" class="headerlink" title="跨多交换机的虚拟局域网"></a>跨多交换机的虚拟局域网</h5><p>$\quad$ trunk port: 在帧头部添加额外标签，识别所属的VLAN（802.1Q协议）</p><p><img src="/../CNP/CN1518.png"></p><h6 id="802-1Q协议"><a href="#802-1Q协议" class="headerlink" title="802.1Q协议"></a>802.1Q协议</h6><p><img src="/../CNP/CN1519.png"></p><h6 id="VLAN优点"><a href="#VLAN优点" class="headerlink" title="VLAN优点"></a>VLAN优点</h6><p>$\quad$ 有效控制广播域范围</p><p>$\quad$ $\quad$ 广播流量被限制在一个VLAN内；</p><p>$\quad$ 增强网络的安全性</p><p>$\quad$ $\quad$ VLAN间相互隔离,无法进行二层通信,不同VLAN需通过三层设备通信；</p><p>$\quad$ 灵活构建虚拟工作组</p><p>$\quad$ $\quad$ 同一工作组的用户不必局限于同一物理范围；</p><p>$\quad$ 提高网络的可管理性</p><p>$\quad$ $\quad$ 将不同的业务规划到不同VLAN便于管理。</p><h3 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h3><p>$\quad$ 防止故障：冗余拓扑</p><p>$\quad$ 付出的代价：导致物理环路</p><h6 id="物理环路引发的问题"><a href="#物理环路引发的问题" class="headerlink" title="物理环路引发的问题"></a>物理环路引发的问题</h6><p>1：广播风暴</p><p>$\quad$ 交换机（网桥）在物理环路上无休止地泛洪广播流量，无限循环，迅速消耗网络资源。</p><p><img src="/../CNP/CN1520.png"></p><p>2：重复帧</p><p>$\quad$ X发送到环路的单播帧，造成目的设备Y收到重复的帧。</p><p><img src="/../CNP/CN1521.png"></p><p>3：MAC地址表不稳定</p><p>$\quad$ 当一个帧的多个副本到达不同端口时，交换机会不断修改同一MAC地址对应的端口。</p><p><img src="/../CNP/CN1522.png"></p><h4 id="生成树协议"><a href="#生成树协议" class="headerlink" title="生成树协议"></a>生成树协议</h4><p>$\quad$ 怎么得到一棵无环的生成树呢？</p><p>$\quad$ $\quad$ 参与的交换机（网桥）：通过BPDU（Bridge Protocol Data Unit）消息</p><p>$\quad$ $\quad$ 选举产生根桥、根端口、指定端口，形成生成树</p><h6 id="桥协议数据单元BPDU"><a href="#桥协议数据单元BPDU" class="headerlink" title="桥协议数据单元BPDU"></a>桥协议数据单元BPDU</h6><p>$\quad$ $\quad$ 根桥ID（Root ID）: 被选为根的桥ID。</p><p>$\quad$ $\quad$ $\quad$ 桥ID共8字节，由2字节的优先级和6字节的MAC地址组成的</p><p><img src="/../CNP/CN1523.png"></p><p>$\quad$ $\quad$ 根路径开销（Root Path Cost）: 到根桥的最小路径开销</p><p>$\quad$ $\quad$ 指定桥ID（Designated Bridge ID）: 发送BPDU的桥ID</p><p>$\quad$ $\quad$ 指定端口ID（Designated Port ID）: 发送BPDU的端口ID</p><h5 id="生成树的三个选举步骤"><a href="#生成树的三个选举步骤" class="headerlink" title="生成树的三个选举步骤"></a>生成树的三个选举步骤</h5><p>$\quad$ (1) 选举根桥(Root Bridge) 。</p><p>$\quad$ (2) 为每个非根桥选出一个根端口（Root Port）。</p><p>$\quad$ (3) 为每个网段确定一个指定端口（Designated Port）</p><h6 id="选举根桥"><a href="#选举根桥" class="headerlink" title="选举根桥"></a>选举根桥</h6><p>$\quad$ 同一广播域中的所有交换机均参与选举；</p><p>$\quad$ 桥ID最小的交换机（网桥）成为生成树的根；</p><p>$\quad$ 在给定广播域内只有一个根桥，其它均为非根桥。</p><p>$\quad$ 根桥的所有端口都处在转发状态。（可以接收和发送数据帧）</p><p><img src="/../CNP/CN1524.png"></p><h6 id="为每个非根桥选出一个根端口"><a href="#为每个非根桥选出一个根端口" class="headerlink" title="为每个非根桥选出一个根端口"></a>为每个非根桥选出一个根端口</h6><p>$\quad$ 每个非根桥，通过比较其每个端口到根桥的根路径开销，选出根端口；</p><p>$\quad$ 具有最小根路径开销的端口被选作根端口；</p><p>$\quad$ 如果多个端口的根路径开销相同，则端口ID最小的端口被选作根端口；</p><p>$\quad$ 非根桥只能有一个根端口，根端口处于转发状态。</p><p>$\quad$ 什么是根路径开销？</p><p>$\quad$ $\quad$ 根桥：所有端口的根路径开销为0</p><p>$\quad$ $\quad$ 非根桥：一个端口的根路径开销为到该端口根桥的路径上所有链路开销之和</p><p>$\quad$ $\quad$ 一些品牌设备，端口开销值使用厂商私有标准</p><p>$\quad$ $\quad$ 链路开销值由IEEE定义（如下表），也可通过手工配置改变</p><p><img src="/../CNP/CN1525.png"></p><h6 id="为每个网段确定一个指定端口"><a href="#为每个网段确定一个指定端口" class="headerlink" title="为每个网段确定一个指定端口"></a>为每个网段确定一个指定端口</h6><p>$\quad$ 对于每一个网段， 在所有连接到它的交换机（网桥）端口中进行选择；</p><p>$\quad$ 一个具有最小根路径开销的端口，作为该网段的指定端口；</p><p>$\quad$ 指定端口处于转发状态，负责该网段的数据转发；</p><p>$\quad$ 连接该网段的其他端口，若既不是指定端口，也不是根端口，则阻塞。</p><p><img src="/../CNP/CN1526.png"></p><h5 id="端口状态"><a href="#端口状态" class="headerlink" title="端口状态"></a>端口状态</h5><p>$\quad$ 经过上述构造生成树的三个过程，端口角色便确定了。</p><p>$\quad$ 事实上，802.1D标准给出了五种端口状态。</p><p><img src="/../CNP/CN1527.png"></p><h6 id="端口状态的迁移"><a href="#端口状态的迁移" class="headerlink" title="端口状态的迁移"></a>端口状态的迁移</h6><p>$\quad$ 端口角色确定为指定端口或根端口后，从Blocking状态经Listening和Learning才能到Forwarding状态；</p><p>$\quad$ 默认的Forwarding Delay时间是15秒，能保证当网络的拓扑发生改变时，新的配置信息能够传遍整个网络，从而避免由于网络为收敛而造成临时环路。</p><p>$\quad$ 由交换机（网桥）或链路故障导致网络拓扑改变时，重新构造生成树。</p><h3 id="其他局域网技术"><a href="#其他局域网技术" class="headerlink" title="其他局域网技术"></a>其他局域网技术</h3><h4 id="PPP"><a href="#PPP" class="headerlink" title="PPP"></a>PPP</h4><p>$\quad$ PPP (Point-to-Point Protocol)协议由IETF制定，1994年成为正式标准（RFC1661）</p><p>$\quad$ PPP协议广泛用于将用户接入运营商网络（Internet）</p><p>$\quad$ 能够在不同的链路上运行</p><p>$\quad$ 能够承载不同的网络层分组</p><p>$\quad$ 特点：简单、灵活、面向连接</p><p>$\quad$ 应用场景</p><p>$\quad$ $\quad$ 拥有LAN的单位，每个LAN都有一个或者多个路由器与外界联系，它们通过租用线路，连接到远程的路由器，这些路由器与租用线路构成子网</p><p>$\quad$ $\quad$ 个人用户的PC通过调制解调器呼叫Internet服务提供商的路由器，来实现与互联网的互连。用户终止会话之后，PC与路由器之间的链接也就终止</p><h6 id="实现的功能"><a href="#实现的功能" class="headerlink" title="实现的功能"></a>实现的功能</h6><p>$\quad$ 利用帧定界符封装成帧：字节填充、零比特填充</p><p>$\quad$ 帧的差错检测：</p><p>$\quad$ $\quad$ 接收方收到一个帧，就进行CRC检验，如CRC检验正确，就收下这个帧；反之，丢弃帧，其它什么也不做</p><p>$\quad$ 实时监测链路工作状态：正常 or 故障</p><p>$\quad$ 设置链路最大传输单元（MTU）</p><p>$\quad$ 网络层地址协商机制：两端互相告知网络层地址</p><p>$\quad$ 数据压缩协商机制</p><h6 id="未实现的功能"><a href="#未实现的功能" class="headerlink" title="未实现的功能"></a>未实现的功能</h6><p>$\quad$ 帧数据的纠错功能</p><p>$\quad$ $\quad$ 数据链路层的PPP协议只进行检错，PPP协议是不可靠传输协议</p><p>$\quad$ 流量控制功能</p><p>$\quad$ $\quad$ PPP协议未实现点到点的流量控制</p><p>$\quad$ 可靠传输功能</p><p>$\quad$ $\quad$ PPP为不可靠协议，不使用帧的序号。不可靠网络中可能使用有序号的工作方式。</p><p>$\quad$ 多点连接功能</p><p>$\quad$ $\quad$ PPP协议不支持多点线路，只支持点对点的链路通信。</p><p>$\quad$ 单工和半双工链路</p><p>$\quad$ $\quad$ PPP协议只支持全双工链路</p><h6 id="PPP协议的构成"><a href="#PPP协议的构成" class="headerlink" title="PPP协议的构成"></a>PPP协议的构成</h6><p>$\quad$ 封装 (Encapsulation)</p><p>$\quad$ $\quad$ 提供在同一链路上支持不同的网络层协议</p><p>$\quad$ $\quad$ PPP既支持字节链路，也支持面向比特的比特链路</p><p>$\quad$ $\quad$ IP数据包在PPP帧中是其信息部分，其长度受到MTU的限制</p><p>$\quad$ 链路控制协议 LCP (Link Control Protocol)。</p><p>$\quad$ $\quad$ 用来建立、配置和测试数据链路的链路控制协议，通信双方可协商一些选项</p><p>$\quad$ 网络控制协议 NCP (Network Control Protocol)。</p><p>$\quad$ $\quad$ 针对不同的网络层协议（IP、OSI的网络层、DECnet、AppleTalk）提供配置</p><h6 id="工作状态转换"><a href="#工作状态转换" class="headerlink" title="工作状态转换"></a>工作状态转换</h6><p><img src="/../CNP/CN1528.png"></p><h4 id="PPPoE"><a href="#PPPoE" class="headerlink" title="PPPoE"></a>PPPoE</h4><p>$\quad$ Ethernet优点</p><p>$\quad$ $\quad$ 原理简单，应用非常广，设备成本低</p><p>$\quad$ Ethernet缺点</p><p>$\quad$ $\quad$ 安全性较低、不宜管理：使用广播信道，造成了安全性较低，无认证功能</p><p>$\quad$ PPP优点</p><p>$\quad$ $\quad$ 原理简单</p><p>$\quad$ $\quad$ 安全性高：点对点信道，提供认证机制</p><p>$\quad$ $\quad$ 提供良好的访问控制和计费功能</p><p>$\quad$ PPPoE（Point-to-Point Protocol over Ethernet）</p><p>$\quad$ $\quad$ 提供在以太网链路上的PPP连接</p><p>$\quad$ $\quad$ 实现了传统以太网不能提供的身份验证、加密，以及压缩等功能</p><p>$\quad$ $\quad$ 实现基于用户的访问控制、计费、业务类型分类等，运营商广泛支持</p><p>$\quad$ $\quad$ PPPoE使用Client&#x2F;Server模型，服务器通常是接入服务器</p><h6 id="组网方式1"><a href="#组网方式1" class="headerlink" title="组网方式1"></a>组网方式1</h6><p>$\quad$ 设备之间建立 PPP 会话，所有主机通过同一个 PPP 会话传送数据，主机上不用安装 PPPoE 客户端拨号软件，一般是一个机构共用一个账号</p><p>$\quad$ PPPoE Client 位于机构内</p><p>$\quad$ PPPoE Server 是运营商的设备</p><p><img src="/../CNP/CN1529.png"></p><h6 id="组网方式2"><a href="#组网方式2" class="headerlink" title="组网方式2"></a>组网方式2</h6><p>$\quad$ PPP 会话建立在 主机和运营商的路由器之间，为每一个主机建立一个 PPP 会话，每个主机都是 PPPoE Client，每个主机有一个帐号，方便运营商对用户进行计费和控制</p><p>$\quad$ 主机上需要安装PPPoE 客户端软件</p><p><img src="/../CNP/CN1530.png"></p><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>CN</category>
      
      <category>链路层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CN</tag>
      
      <tag>链路层</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据链路层 - 概述、成帧、差错控制、访问控制</title>
    <link href="/2023/12/07/%E9%93%BE%E8%B7%AF%E5%B1%82%20-%20%E6%A6%82%E8%BF%B0%E3%80%81%E6%88%90%E5%B8%A7%E3%80%81%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6%E3%80%81%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/"/>
    <url>/2023/12/07/%E9%93%BE%E8%B7%AF%E5%B1%82%20-%20%E6%A6%82%E8%BF%B0%E3%80%81%E6%88%90%E5%B8%A7%E3%80%81%E5%B7%AE%E9%94%99%E6%8E%A7%E5%88%B6%E3%80%81%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p> 对应 北京大学计算机网络课程第五讲第一部分<br> 参考教材计算机网络-自顶向下方法</p><span id="more"></span><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="数据链路层-概述、成帧、差错控制、访问控制"><a href="#数据链路层-概述、成帧、差错控制、访问控制" class="headerlink" title="数据链路层 - 概述、成帧、差错控制、访问控制"></a>数据链路层 - 概述、成帧、差错控制、访问控制</h2><h3 id="链路层概述"><a href="#链路层概述" class="headerlink" title="链路层概述"></a>链路层概述</h3><h6 id="在协议栈中的位置"><a href="#在协议栈中的位置" class="headerlink" title="在协议栈中的位置"></a>在协议栈中的位置</h6><p>$\quad$ 向下：利用物理层提供的位流服务</p><p>$\quad$ 向上：向网络层提供明确的 (well-defined) 服务接口</p><p><img src="/../CNP/CN1401.png"></p><h6 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h6><p>$\quad$ 数据链路层的作用是在物理相连的两个结点间进行数据传输</p><p>$\quad$ 主机与路由器统称为结点或站点</p><p>$\quad$ 连接两个站点间的物理链路: 链路或信道</p><p>$\quad$ $\quad$ 有线信道</p><p>$\quad$ $\quad$ 无线信道</p><p>$\quad$ $\quad$ 一个局域网整体也可以看作一个信道</p><p>$\quad$ 2层数据包: 帧, 封装了3层数据报文</p><h6 id="特点：差异性"><a href="#特点：差异性" class="headerlink" title="特点：差异性"></a>特点：差异性</h6><p>$\quad$ 不同链路上采用不同协议:</p><p>$\quad$ $\quad$ 如：第一个链路为以太网链路，中间链路为帧中继, 最后一跳为802.11无线链路</p><p>$\quad$ 不同的链路层协议提供不同的服务</p><p>$\quad$ $\quad$ 如：可靠 vs 不可靠</p><p>$\quad$ 类比:</p><p>$\quad$ $\quad$ 从北京大学到上海交通大学</p><p>$\quad$ $\quad$ 公交车: 北京大学 -&gt; 首都机场</p><p>$\quad$ $\quad$ 飞机: 首都机场 -&gt; 上海虹桥</p><p>$\quad$ $\quad$ 地铁: 上海虹桥 -&gt; 上海交通大学</p><p>$\quad$ $\quad$ 旅行者 &#x3D; 网络层数据报文</p><p>$\quad$ $\quad$ 行程段 &#x3D; 链路层信道</p><p>$\quad$ $\quad$ 交通方式 &#x3D; 链路层协议</p><p>$\quad$ $\quad$ 旅行社（行程规划） &#x3D; 路由协议</p><h6 id="实现的位置"><a href="#实现的位置" class="headerlink" title="实现的位置"></a>实现的位置</h6><p>$\quad$ 每一台主机与网络内部设备都需要实现链路层</p><p>$\quad$ 链路层的实现通常包括硬件、固件、软件部分</p><p>$\quad$ 硬件与固件：链路层主要功能在“网络适配器”（又称网络接口卡Network Interface Card，NIC）</p><p>$\quad$ $\quad$ NIC包括数据链路层+物理层</p><p>$\quad$ NIC通过数据总线(buses)接入系统，与链路层软件部分交互</p><p>$\quad$ 软件：给网络层提供接口、中断处理等</p><p><img src="/../CNP/CN1402.png"></p><h6 id="提供的服务"><a href="#提供的服务" class="headerlink" title="提供的服务"></a>提供的服务</h6><p>$\quad$ 成帧 （Framing）</p><p>$\quad$ $\quad$ 将比特流划分成“帧”的主要目的是为了检测和纠正物理层在比特传输中可能出现的错误，数据链路层功能需借助“帧”的各个域来实现</p><p>$\quad$ 差错控制 （Error Control）</p><p>$\quad$ $\quad$ 处理传输中出现的差错，如位错误、丢失等</p><p>$\quad$ 流量控制 （Flow Control）</p><p>$\quad$ $\quad$ 确保发送方的发送速率，不大于接收方的处理速率−避免接收缓冲区溢出</p><p>$\quad$ 无确认 无连接 服务（ Unacknowledged connectionless ）</p><p>$\quad$ $\quad$ 接收方不对收到的帧进行确认</p><p>$\quad$ $\quad$ 适用场景：误码率低的可靠信道；实时通信；</p><p>$\quad$ $\quad$ 网络实例：以太网</p><p>$\quad$ 有确认 无连接 服务（ Acknowledged connectionless ）</p><p>$\quad$ $\quad$ 每一帧都得到单独的确认</p><p>$\quad$ $\quad$ 适用场景：不可靠的信道（无线信道）</p><p>$\quad$ $\quad$ 网络实例：802.11</p><p>$\quad$ 有确认 有连接 服务（ Acknowledged connection-oriented ）</p><p>$\quad$ $\quad$ 适用场景：长延迟的不可靠信道</p><p>$\quad$ 许多服务只在早期链路层技术中使用，链路层已不再提供</p><h3 id="成帧"><a href="#成帧" class="headerlink" title="成帧"></a>成帧</h3><p>$\quad$ 关键问题：如何标识一个帧的开始？</p><p>$\quad$ $\quad$ 接收方必须能从物理层接收的比特流中明确区分出一帧的开始和结束，这个问题被称为帧同步或帧定界</p><p>$\quad$ $\quad$ 关键：选择何种定界符？定界符出现在数据部分如何处理？</p><p>$\quad$ 成帧（framing）的方式</p><p>$\quad$ $\quad$ 字节计数法（ Byte count ）</p><p>$\quad$ $\quad$ 带字节填充的定界符法（ Flag bytes with byte stuffing ）</p><p>$\quad$ $\quad$ 带比特填充的定界符法（ Flag bits with bit stuffing ）</p><p>$\quad$ $\quad$ 物理层编码违例（ Physical layer coding violations ）</p><h6 id="分组与帧的关系"><a href="#分组与帧的关系" class="headerlink" title="分组与帧的关系"></a>分组与帧的关系</h6><p><img src="/../CNP/CN1403.png"></p><h6 id="字节计数法"><a href="#字节计数法" class="headerlink" title="字节计数法"></a>字节计数法</h6><p>$\quad$ 无差错传输的情形</p><p><img src="/../CNP/CN1404.png"></p><p>$\quad$ 出现了一个字节差错的情形</p><p><img src="/../CNP/CN1405.png"></p><h6 id="带字节填充的定界符法"><a href="#带字节填充的定界符法" class="headerlink" title="带字节填充的定界符法"></a>带字节填充的定界符法</h6><p>$\quad$ 定界符（FLAG）：一个特殊的字节，比如 01111110，即 0x7E，用于区分前后两个不同的帧</p><p><img src="/../CNP/CN1406.png"></p><p><img src="/../CNP/CN1407.png"></p><p>$\quad$ 接收方的处理</p><p>$\quad$ $\quad$ 逐个检查收到的每一个字节</p><p>$\quad$ $\quad$ 收到ESC−则后一字节无条件成为有效载荷，不予检查</p><p>$\quad$ $\quad$ 收到FLAG−则为帧的边界</p><p><img src="/../CNP/CN1408.png"></p><h6 id="带比特填充的定界符法"><a href="#带比特填充的定界符法" class="headerlink" title="带比特填充的定界符法"></a>带比特填充的定界符法</h6><p>$\quad$ 定界符：两个0比特之间，连续6个1比特，即01111110，0x7E</p><p><img src="/../CNP/CN1409.png"></p><p>$\quad$ 发送方检查有效载荷</p><p>$\quad$ $\quad$ 若在有效载荷中出现连续5个1比特，则直接插入1个0比特</p><p><img src="/../CNP/CN1410.png"></p><p>$\quad$ 接收方的处理</p><p>$\quad$ 若出现连续5个1比特</p><p>$\quad$ $\quad$ −若下一比特为0，则为有效载荷，直接丢弃0比特</p><p>$\quad$ $\quad$ −若下一比特为1，则连同后一比特的0，构成定界符，一帧结束</p><p><img src="/../CNP/CN1411.png"></p><h6 id="物理编码违例"><a href="#物理编码违例" class="headerlink" title="物理编码违例"></a>物理编码违例</h6><p>$\quad$ 核心思想：选择的定界符不会在数据部分出现</p><p>$\quad$ 4B&#x2F;5B编码方案</p><p>$\quad$ $\quad$ 4比特数据映射成5比特编码，剩余的一半码字（16个码字）未使用，可以用做帧定界符</p><p>$\quad$ $\quad$ 例如： 00110组合不包含在4B&#x2F;5B编码中，可做帧定界符</p><p>$\quad$ 前导码</p><p>$\quad$ $\quad$ 存在很长的 前导码（preamble），可以用作定界符</p><p>$\quad$ $\quad$ 例如：传统以太网、802.11</p><p>$\quad$ 曼切斯特编码 &#x2F; 差分曼切斯特编码</p><p>$\quad$ $\quad$ 正常的信号在周期中间有跳变，持续的高电平（或低电平）为违例码，可以用作定界符</p><p>$\quad$ $\quad$ 例如：802.5令牌环网</p><h3 id="差错检测与修复"><a href="#差错检测与修复" class="headerlink" title="差错检测与修复"></a>差错检测与修复</h3><p>$\quad$ 链路层存在的一个问题：信道的噪声导致数据传输问题</p><p>$\quad$ $\quad$ 差错（ incorrect ）：数据发生错误</p><p>$\quad$ $\quad$ 丢失（ lost ）：接收方未收到</p><p>$\quad$ $\quad$ 乱序（out of order）：先发后到，后发先到</p><p>$\quad$ $\quad$ 重复（repeatedly delivery）：一次发送，多次接收</p><p>$\quad$ 解决方案：差错检测与纠正、确认重传</p><p>$\quad$ $\quad$ 确认：接收方校验数据（差错校验），并给发送方应答，防止差错</p><p>$\quad$ $\quad$ 定时器：发送方启动定时器，防止丢失</p><p>$\quad$ $\quad$ 顺序号：接收方检查序号，防止乱序递交、重复递交</p><h4 id="差错检测与纠正"><a href="#差错检测与纠正" class="headerlink" title="差错检测与纠正"></a>差错检测与纠正</h4><p>$\quad$ 如何解决信道传输差错问题</p><p>$\quad$ $\quad$ 通常采用增加冗余信息（或称校验信息）的策略</p><p>$\quad$ $\quad$ 简单示例：每个比特传三份，如果每比特的三份中有一位出错，可以纠正</p><p>$\quad$ $\quad$ 蓝牙1&#x2F;3 FEC采用这种方法</p><p><img src="/../CNP/CN1412.png"></p><p>$\quad$ 目标：保证一定差错检测和纠错能力的前提下，如何减少冗余信息量？</p><p>$\quad$ 考虑的问题</p><p>$\quad$ $\quad$ 信道的特征和传输需求</p><p>$\quad$ $\quad$ 冗余信息的计算方法、携带的冗余信息量</p><p>$\quad$ $\quad$ 计算的复杂度等</p><p>$\quad$ 两种主要策略</p><p>$\quad$ $\quad$ 检错码（error-detecting code）</p><p>$\quad$ $\quad$ 纠错码（error-correcting code)</p><p>$\quad$ 选择错略具体策略取决于信道特征，如：</p><p>$\quad$ $\quad$ 误码率较高的无线链路</p><p>$\quad$ $\quad$ 误码率较低的光纤链路</p><p><img src="/../CNP/CN1413.png"></p><p>$\quad$ 检错码（error-detecting code）</p><p>$\quad$ $\quad$ 只能使接收方推断是否发生错误，但不能推断哪位发生错误，接收方可以请求发送方重传数据</p><p>$\quad$ $\quad$ 主要用在高可靠、误码率较低的信道上，例如光纤链路</p><p>$\quad$ $\quad$ 偶尔发生的差错，可以通过重传解决差错问题</p><p>$\quad$ 纠错码（error-correcting code)</p><p>$\quad$ $\quad$ 接收方能够判断接收到的数据是否有错，并能纠正错误（定位出错的位置）</p><p>$\quad$ $\quad$ 主要用于错误发生比较频繁的信道上，如无线链路</p><p>$\quad$ $\quad$ 也经常用于物理层，以及更高层（例如，实时流媒体应用和内容分发）</p><p>$\quad$ $\quad$ 使用纠错码的技术通常称为前向纠错（FEC，Forward Error Correction)</p><p>$\quad$ 差错检测不是100%正确的</p><p>$\quad$ $\quad$ 有些错误可能无法被检测出来，但概率极低</p><p>$\quad$ 使用更多的冗余信息，通常可以提升正确率</p><h5 id="典型检错码"><a href="#典型检错码" class="headerlink" title="典型检错码"></a>典型检错码</h5><h6 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h6><p><img src="/../CNP/CN1414.png"></p><p><img src="/../CNP/CN1415.png"></p><h6 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h6><p><img src="/../CNP/CN1416.png"></p><h6 id="循环冗余校验CRC"><a href="#循环冗余校验CRC" class="headerlink" title="循环冗余校验CRC"></a>循环冗余校验CRC</h6><p>$\quad$ 设原始数据D为m位二进制串</p><p>$\quad$ 如果要产生r位CRC校验码，事先选定一个r+1位二进制串G (称为生成多项式，收发双方提前商定)，G的最高位为1</p><p>$\quad$ 将原始数据D乘以2r （相当于在D后面添加 r 个 0），产生m+r位二进制串</p><p>$\quad$ 用G对D*2r做模2除，得到余数R（r位，不足r位前面用0补齐）即为CRC校验码</p><p>$\quad$ 接收端校验：收到&lt;D, R&gt;</p><p>$\quad$ $\quad$ 将&lt;D, R&gt;除以G（模2除），若余数为0，则通过校验</p><p><img src="/../CNP/CN1417.png"></p><p><img src="/../CNP/CN1418.png"></p><p>$\quad$ 如何生成多项式G</p><p><img src="/../CNP/CN1419.png"></p><h6 id="理论分析"><a href="#理论分析" class="headerlink" title="理论分析"></a>理论分析</h6><p>$\quad$ 码字 (code word)：一个包含m个数据位（信息位）和r个校验位的n位单元</p><p>$\quad$ $\quad$ 描述为 (n, m) 码，n&#x3D;m+r</p><p>$\quad$ 码率 (code rate)：码字中不含冗余部分所占的比例，可以用m&#x2F;n表示</p><p>$\quad$ 海明距离 (Hamming distance)：两个码字之间不同对应比特的数目</p><p>$\quad$ $\quad$ 例：0000000000 与0000011111的海明距离为5</p><p>$\quad$ $\quad$ 如果两个码字的海明距离为d，则需要d个单比特错就可以把一个码字转换成另一个码字</p><p>$\quad$ $\quad$ 为了检查出d个错（比特错），可以使用海明距离为 d+1 的编码</p><p>$\quad$ $\quad$ 为了纠正d个错，可以使用海明距离为 2d+1 的编码</p><p>$\quad$ 例如：</p><p>$\quad$ $\quad$ 一个只有4个有效码字的编码方案：0000000000, 0000011111, 1111100000, 1111111111</p><p>$\quad$ $\quad$ 海明距离为5，可以检测4位错，纠正2位错</p><p>$\quad$ $\quad$ 如果已知只有1位或2位错误，接收方接收0000000111</p><p>$\quad$ $\quad$ $\quad$ −则可知原码字为：0000011111</p><p>$\quad$ $\quad$ 如果发生3位错误，例如0000000000变成0000000111，接收方无法纠正错误，但可以检测出错误</p><p>$\quad$ 纠正单比特错误的最低要求</p><p>$\quad$ $\quad$ 目的：m个信息位，r个校验位，纠正单比特错</p><p>$\quad$ $\quad$ n个比特一共可以有2n个码字，包含有效码字与无效码字</p><p>$\quad$ $\quad$ 每个m位有效信息，除了本身的n位有效码字，与该有效码字距离为1的n个码字必须无效</p><p>$\quad$ $\quad$ $\quad$ 否则，当单比特错误发生时，无法判断是否出错</p><p>$\quad$ $\quad$ 同时，任何两个有效码字，它们距离为1的无效码字没有重叠</p><p>$\quad$ $\quad$ $\quad$ 否则，无法判断错误的码字离哪个有效码字更近</p><p>$\quad$ $\quad$ 因此，每个m位有效信息，实际上消耗至少 n+1 个码字，即：(n + 1) 2m £ 2n</p><p>$\quad$ $\quad$ 利用 n &#x3D; m + r，得到 (m + r + 1) £ 2r</p><p>$\quad$ $\quad$ 在给定m的情况下，利用该式可以得出r的下界</p><h6 id="海明码"><a href="#海明码" class="headerlink" title="海明码"></a>海明码</h6><p>$\quad$ 目标：以奇偶校验为基础，如何找到出错位置，提供1位纠错能力</p><p>$\quad$ 理解海明码编码过程，以 (15, 11)海明码为例</p><p>$\quad$ $\quad$ 15位 &#x3D; 11个数字位 + 4个校验位</p><p>$\quad$ $\quad$ 校验位：2的幂次方位（记为p1, p2, p4, p8）</p><p>$\quad$ $\quad$ 每个校验位对数据位的子集做校验，缩小定位错误的范围</p><p>$\quad$ 例如：11比特的数据01011001101</p><p>$\quad$ $\quad$ 11比特数据按顺序放入数据位</p><p>$\quad$ $\quad$ 问题：每个校验位如何计算？</p><p><img src="/../CNP/CN1420.png"><br>$\quad$ 对于第 k 个数据位，将 k 分解为2的次幂之和，得到的每个2的次幂，都参与对第 k 位的校验</p><p><img src="/../CNP/CN1421.png"></p><p><img src="/../CNP/CN1422.png"></p><p><img src="/../CNP/CN1423.png"></p><p><img src="/../CNP/CN1424.png"></p><p><img src="/../CNP/CN1425.png"></p><p><img src="/../CNP/CN1426.png"></p><h6 id="Reed-Solomon-code"><a href="#Reed-Solomon-code" class="headerlink" title="Reed-Solomon code"></a>Reed-Solomon code</h6><p>$\quad$ RS码：以有限域运算为基础，提供多位纠错能力</p><p>$\quad$ $\quad$ RS会将需要编码的01流数据重新划分为以符号(Symbol)为单位的数据块</p><p>$\quad$ $\quad$ m表示符号的大小，如 m&#x3D;4 表示每个符号由4位二进制数组成</p><p>$\quad$ $\quad$ 对于一个(n, k) RS编码，k为原始数据符号数，n-k为校验符号数</p><p>$\quad$ $\quad$ n-k&#x3D;2t，t表示能够纠正的错误数</p><p><img src="/../CNP/CN1427.png"></p><p>$\quad$ 例子：每个Symbol为10位二进制数 (m&#x3D;10)</p><p>$\quad$ 以RS(544, 514)编码为例：</p><p>$\quad$ $\quad$ 原始需要保护的数据为514个symbols (k&#x3D;514)</p><p>$\quad$ $\quad$ 校验数据为30个symbols (2t&#x3D;30)</p><p>$\quad$ $\quad$ 最终完成的编码为544个symbols (n&#x3D;544)</p><p>$\quad$ $\quad$ 可以纠正15个symbols的错误</p><p><img src="/../CNP/CN1428.png"></p><p>$\quad$ 校验帧里的内容，通过对数据进行线性组合得到</p><p>$\quad$ $\quad$ 本质上是一个伽罗华域 Galois Field arithmatic (又称有限域 finite field arithmetic)</p><p>$\quad$ $\quad$ 加、乘、除运算都在GF(2m)上进行，m为symbol的位数</p><p>$\quad$ G &#x3D; 生成矩阵 Generator matrix (k x n)</p><p><img src="/../CNP/CN1429.png"></p><p>$\quad$ 有多种方式可以计算parity</p><p>$\quad$ $\quad$ 不直接构造G：基于生成多项式</p><p>$\quad$ $\quad$ 直接构造G：使用范德蒙德矩阵 Vandermonde matrix、柯西矩阵 Cauchy Matrix</p><p><strong>使用生成多项式</strong></p><p><img src="/../CNP/CN1430.png"></p><p>$\quad$ 编码的数学过程：</p><p>$\quad$ $\quad$ 1.将原始需要编码的数据后面补2t个0（图中「取余」运算符左侧部分，补0意思是为校验码占位）</p><p>$\quad$ $\quad$ 2.除以生成多项式g(x)  取余下的多项式为校验多项式p(x) </p><p>$\quad$ $\quad$ 3.将校验多项式加到刚才补过0的编码数据多项式中，就是最终生成的编码</p><p><img src="/../CNP/CN1431.png"></p><p><img src="/../CNP/CN1432.png"></p><p><strong>使用范德蒙德矩阵</strong></p><p><img src="/../CNP/CN1433.png"></p><p><strong>使用柯西矩阵</strong></p><p><img src="/../CNP/CN1434.png"></p><h3 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h3><p>$\quad$ 信道：信号的通道</p><p>$\quad$ $\quad$ 比如：双绞线、铜缆、光纤、卫星、空气等</p><p>$\quad$ 点到点信道：信道直接连接两个端点</p><p>$\quad$ $\quad$ 比如：家中计算机通过modem连接到电信公司端局</p><p>$\quad$ 多点访问信道： 多用户共享一根信道</p><p>$\quad$ $\quad$ 早期使用集线器的以太网是总线式的，信道是共享的</p><p>$\quad$ $\quad$ 其他例子：WiFi</p><p>$\quad$ 广播信道面临的问题</p><p>$\quad$ $\quad$ 可能两个（或更多）站点同时请求占用信道，产生冲突（collisions)</p><p>$\quad$ 解决办法：介质的多路访问控制</p><p>$\quad$ $\quad$ 在多路访问信道上确定下一个使用者（信道分配）</p><p>$\quad$ $\quad$ 本质上是分布式算法</p><p>$\quad$ $\quad$ 挑战：结点间协同，本身也需要使用信道</p><p>$\quad$ 没有专门用于分布式访问控制的信道</p><h6 id="常见的局域网拓扑"><a href="#常见的局域网拓扑" class="headerlink" title="常见的局域网拓扑"></a>常见的局域网拓扑</h6><p>$\quad$ 局域网经典拓扑：总线拓扑、星型拓扑、环型拓扑</p><p>$\quad$ 共同点：共享一根信道（别称：广播信道、多路访问信道、随机访问信道）</p><p><img src="/../CNP/CN1435.png"></p><h6 id="理想的多路访问控制"><a href="#理想的多路访问控制" class="headerlink" title="理想的多路访问控制"></a>理想的多路访问控制</h6><p>$\quad$ 目标：</p><p>$\quad$ $\quad$ 性能：当只有一个结点需要传输时，能够以速率R进行发送</p><p>$\quad$ $\quad$ 公平：当M个结点需要传输时，每个结点发送速率R&#x2F;M</p><p>$\quad$ $\quad$ 去中心化</p><p>$\quad$ $\quad$ $\quad$ 不需要结点协调传输</p><p>$\quad$ $\quad$ $\quad$ 不需要全局时钟或者其他全局信息</p><p>$\quad$ $\quad$ $\quad$ 简单、易实现</p><h6 id="主要的多路访问控制方法"><a href="#主要的多路访问控制方法" class="headerlink" title="主要的多路访问控制方法"></a>主要的多路访问控制方法</h6><p>$\quad$ 信道划分（channel partitioning）</p><p>$\quad$ $\quad$ 将信道划分为多个部分（时间、频率、编码）</p><p>$\quad$ $\quad$ 每个站点分配一个部分，进行无冲突的传输</p><p>$\quad$ 随机接入（random access）</p><p>$\quad$ $\quad$ 不划分信道，允许冲突</p><p>$\quad$ $\quad$ 冲突发生时，进行“恢复”</p><p>$\quad$ 轮流协议（taking turns）</p><h4 id="信道划分"><a href="#信道划分" class="headerlink" title="信道划分"></a>信道划分</h4><h5 id="TDMA-time-division-multiple-access"><a href="#TDMA-time-division-multiple-access" class="headerlink" title="TDMA: time division multiple access"></a>TDMA: time division multiple access</h5><p>$\quad$ 划分出等长时间片（长度为报文传输时间）</p><p>$\quad$ 时间片依次分给各个站点</p><p>$\quad$ 未使用的时间片处于空闲</p><p>$\quad$ 例子: 6-站点共享信道, 站点1,3,4有数据包要发送, 时间片2,5,6空闲</p><p><img src="/../CNP/CN1436.png"></p><h5 id="FDMA-frequency-division-multiple-access"><a href="#FDMA-frequency-division-multiple-access" class="headerlink" title="FDMA: frequency division multiple access"></a>FDMA: frequency division multiple access</h5><p>$\quad$ 将信道分为多个频段</p><p>$\quad$ 每个站点分配得到1个固定的频段，每个频段带宽相同</p><p>$\quad$ 未使用的频段处于空闲</p><p>$\quad$ 例子: 6-站点共享信道, 站点1,3,4有数据包要发送, 频段2,5,6空闲</p><p><img src="/../CNP/CN1437.png"></p><h5 id="静态分配的性能分析"><a href="#静态分配的性能分析" class="headerlink" title="静态分配的性能分析"></a>静态分配的性能分析</h5><p>$\quad$ 静态分配方法：TDM、FDM</p><p>$\quad$ 静态分配的排队论分析（ M&#x2F;M&#x2F;1排队系统模型）</p><p>$\quad$ $\quad$ M（顾客到达时间间隔分布）</p><p>$\quad$ $\quad$ $\quad$ 帧到达时间间隔服从指数分布</p><p>$\quad$ $\quad$ $\quad$ 平均到达率（输入率）：l 帧&#x2F;秒</p><p>$\quad$ $\quad$ M（服务时间分布）</p><p>$\quad$ $\quad$ $\quad$ 帧长度服从指数分布，平均长度1&#x2F;m 位&#x2F;帧</p><p>$\quad$ $\quad$ $\quad$ 信道容量为C 位&#x2F;秒，则信道服务率为mC 帧&#x2F;秒</p><p>$\quad$ $\quad$ 1（并列服务台个数）</p><p><img src="/../CNP/CN1438.png"></p><h5 id="子信道的平均延迟"><a href="#子信道的平均延迟" class="headerlink" title="子信道的平均延迟"></a>子信道的平均延迟</h5><p><img src="/../CNP/CN1439.png"></p><h5 id="静态分配的特点"><a href="#静态分配的特点" class="headerlink" title="静态分配的特点"></a>静态分配的特点</h5><p>$\quad$ 问题</p><p>$\quad$ $\quad$ 资源分配不合理，不满足用户对资源占用的不同需求</p><p>$\quad$ $\quad$ 有资源浪费，效率低</p><p>$\quad$ $\quad$ 延迟时间增大N倍</p><p>$\quad$ 适用情况</p><p>$\quad$ $\quad$ 适于用户数量少且用户数目固定的情况</p><p>$\quad$ $\quad$ 适于通信量大且流量稳定的情况</p><p>$\quad$ $\quad$ 不适用于突发性业务的情况</p><p>$\quad$ 设计动态分配的方法</p><p>$\quad$ $\quad$ 目的1：更好地满足需求</p><p>$\quad$ $\quad$ 目的2：提高信道利用率</p><h5 id="第三种信道划分：CDMA：Code-Division-Multiple-Access"><a href="#第三种信道划分：CDMA：Code-Division-Multiple-Access" class="headerlink" title="第三种信道划分：CDMA：Code Division Multiple Access"></a>第三种信道划分：CDMA：Code Division Multiple Access</h5><p>$\quad$ 为每个站点分配一种编码</p><p>$\quad$ 即使冲突发生，接收方也能进行解码</p><p>$\quad$ 主要用于无线通信（后续无线部分会讲到</p><h4 id="随机访问"><a href="#随机访问" class="headerlink" title="随机访问"></a>随机访问</h4><h6 id="随机访问协议"><a href="#随机访问协议" class="headerlink" title="随机访问协议"></a>随机访问协议</h6><p>$\quad$ 当任意站点有数据要发送时</p><p>$\quad$ $\quad$ 以信道带宽R全速发送</p><p>$\quad$ $\quad$ 不需要事先协调</p><p>$\quad$ 当2个或更多站点同时发送时，产生冲突</p><p>$\quad$ 随机访问的多路信道控制、关注:</p><p>$\quad$ $\quad$ 冲突检测</p><p>$\quad$ $\quad$ 从冲突中恢复 (如：等待一段时间后重发)</p><p>$\quad$ 典型例子:</p><p>$\quad$ $\quad$ 纯ALOHA</p><p>$\quad$ $\quad$ 时隙ALOHA（slotted ALOHA）</p><p>$\quad$ $\quad$ CSMA</p><p>$\quad$ $\quad$ CSMA&#x2F;CD</p><p>$\quad$ $\quad$ CSMA&#x2F;CA</p><h6 id="随机访问概念模型"><a href="#随机访问概念模型" class="headerlink" title="随机访问概念模型"></a>随机访问概念模型</h6><p>$\quad$ 信道始终处于三种状态之一</p><p>$\quad$ $\quad$ 传输周期：一个站点使用信道，其他站点禁止使用</p><p>$\quad$ $\quad$ 竞争周期：所有站点都有权尝试使用信道</p><p>$\quad$ $\quad$ 空闲周期：所有站点都不使用信道</p><p><img src="/../CNP/CN1440.png"></p><h5 id="ALOHA类"><a href="#ALOHA类" class="headerlink" title="ALOHA类"></a>ALOHA类</h5><h6 id="纯ALOHA协议工作原理"><a href="#纯ALOHA协议工作原理" class="headerlink" title="纯ALOHA协议工作原理"></a>纯ALOHA协议工作原理</h6><p>$\quad$ 原理：想发就发！</p><p>$\quad$ $\quad$ 每个站点收到上层数据包，立即向信道发送</p><p>$\quad$ $\quad$ 没有任何同步或信道检测</p><p>$\quad$ 特点</p><p>$\quad$ $\quad$ 冲突：某个时刻有两个或以上的帧</p><p>$\quad$ $\quad$ 随时可能冲突</p><p>$\quad$ $\quad$ 冲突的帧被完全破坏</p><p>$\quad$ $\quad$ 破坏了的帧要重传</p><p><img src="/../CNP/CN1441.png"></p><h6 id="纯ALOHA的效率"><a href="#纯ALOHA的效率" class="headerlink" title="纯ALOHA的效率"></a>纯ALOHA的效率</h6><p>$\quad$ 效率的指标: N个站点时，信道传输成功的概率</p><p>$\quad$ 假设:</p><p>$\quad$ $\quad$ 传输时间为1单位时间</p><p>$\quad$ $\quad$ N个站点，每个站点在单位时间内的传输概率为p</p><p><img src="/../CNP/CN1442.png"></p><p><strong>另一种计算：</strong></p><p>$\quad$ 定义</p><p>$\quad$ $\quad$ 帧时：发送一个标准长的帧所需的时间</p><p>$\quad$ 服从泊松分布</p><p>$\quad$ $\quad$ 一个帧时内用户产生新帧：均值N个</p><p>$\quad$ $\quad$ 一个帧时内信道中产生的帧（包括重传）：均值G个</p><p>$\quad$ 分析：</p><p>$\quad$ $\quad$ G &gt;&#x3D; N，轻载G&#x3D;N（无冲突），重载G&gt;N（冲突&#x2F;重传）</p><p>$\quad$ 概率</p><p>$\quad$ $\quad$ Pr[k] &#x3D; Gke-G &#x2F; k! (一个帧时内信道中产生k个帧，泊松分布)</p><p>$\quad$ $\quad$ Pr[k&#x3D;0] &#x3D; e-G （一个帧时内信道中产生0个帧）</p><p>$\quad$ 吞吐量(Throughout) S</p><p>$\quad$ $\quad$ 在帧时T内发送成功的平均帧数。</p><p>$\quad$ $\quad$ $\quad$ 显然，0&lt;S&lt;1</p><p>$\quad$ $\quad$ S &#x3D; 1时分组一个接一个地发送出去，帧之间没有空隙。一般用S接近于1的程度来衡量信道的利用率</p><p>$\quad$ G的物理意义：运载负载(Carried load)，又称网络负载</p><p>$\quad$ $\quad$ 帧时T内所有通信站总共发送的帧平均值(包括原发和重发的分组)</p><p>$\quad$ $\quad$ 显然，G≧S，只有在不发生冲突时G才等于S。当重负载(G&gt;&gt;1) 时，冲突频繁</p><p>$\quad$ P0：P0是一帧发送成功(即未发生冲突)的概率，就是发送成功的分组在已发送分组的总数中所占的比例</p><p>$\quad$ $\quad$ S &#x3D; G x P0</p><p>$\quad$ 如何计算传输成功的概率P0？</p><p>$\quad$ $\quad$ 单向传播延迟（第一个bit发出到最后一个bit到达）：D</p><p>$\quad$ $\quad$ 冲突危险期：2D</p><p>$\quad$ $\quad$ $\quad$ 生成帧均值：2G</p><p>$\quad$ $\quad$ $\quad$ 不遭受冲突的概率：P0&#x3D;e-2G</p><p><img src="/../CNP/CN1443.png"></p><p>$\quad$ P0的含义是在连续两个T的时间内都没有其它帧生成的概率，即连续两个T的时间内都生成0帧的概率之乘积</p><p>$\quad$ 生成0帧的概率(即不生成帧的概率)，得：</p><p>$\quad$ $\quad$ Pr[k&#x3D;0] &#x3D; e-G</p><p>$\quad$ $\quad$ $\quad$ 注意：P0与Pr[k&#x3D;0]是两个完全不同的概念。</p><p>$\quad$ 所以：P0&#x3D; Pr[k&#x3D;0]* Pr[k&#x3D;0] &#x3D; (e-G)2&#x3D; e-2G</p><p><img src="/../CNP/CN1444.png"></p><h6 id="分隙ALOHA"><a href="#分隙ALOHA" class="headerlink" title="分隙ALOHA"></a>分隙ALOHA</h6><p>$\quad$ 假设</p><p>$\quad$ $\quad$ 所有帧大小一样</p><p>$\quad$ $\quad$ 时间划分为等长的时间槽，每个时间槽刚好可以传输1个帧</p><p>$\quad$ $\quad$ 站点只能在时间槽开始时发起传输</p><p>$\quad$ $\quad$ $\quad$ 冲突只在时间槽起点发生</p><p>$\quad$ $\quad$ 所有站点的时钟是同步的</p><p>$\quad$ 操作</p><p>$\quad$ $\quad$ 当站点有帧需要发送时，在下一个时间槽开始时进行传输</p><p>$\quad$ $\quad$ $\quad$ 如果直到传输完毕都没有冲突，则完成</p><p>$\quad$ $\quad$ $\quad$ 如果发生冲突，以概率p在下一时间槽重传</p><p><img src="/../CNP/CN1445.png"></p><h6 id="分隙ALOHA的效率"><a href="#分隙ALOHA的效率" class="headerlink" title="分隙ALOHA的效率"></a>分隙ALOHA的效率</h6><p>$\quad$ 效率的指标: N个站点时，信道传输成功的概率</p><p>$\quad$ 假设:</p><p>$\quad$ $\quad$ 传输时间为1单位时间</p><p>$\quad$ $\quad$ N个站点，每个站点在单位时间内的传输概率为p</p><p><img src="/../CNP/CN1446.png"></p><p><strong>基于泊松模型计算</strong></p><p><img src="/../CNP/CN1447.png"></p><h6 id="小结两种ALOHA协议"><a href="#小结两种ALOHA协议" class="headerlink" title="小结两种ALOHA协议"></a>小结两种ALOHA协议</h6><p><img src="/../CNP/CN1448.png"></p><h5 id="CSMA类"><a href="#CSMA类" class="headerlink" title="CSMA类"></a>CSMA类</h5><p>$\quad$ CSMA：Carrier Sense Multiple Access</p><p>$\quad$ 特点：“先听后发”</p><p>$\quad$ $\quad$ 如果信道空闲，则发送</p><p>$\quad$ $\quad$ 如果信道忙，则推迟发送</p><p>$\quad$ 类比：会议上有人说话时，不要打断</p><p>$\quad$ 如侦听到介质上无数据发送才发送，发送后还会发生冲突吗？</p><p>$\quad$ $\quad$ 肯定会！</p><p>$\quad$ $\quad$ 两种情形</p><p>$\quad$ $\quad$ $\quad$ （1）刚好同时传送；（2）来自其他站点的传播延迟时间</p><h6 id="非持续式CSMA"><a href="#非持续式CSMA" class="headerlink" title="非持续式CSMA"></a>非持续式CSMA</h6><p>$\quad$ 特点</p><p>$\quad$ $\quad$ 经侦听，如果介质空闲，开始发送</p><p>$\quad$ $\quad$ 如果介质忙，则等待一个随机分布的时间，然后重复步骤①</p><p>$\quad$ 好处</p><p>$\quad$ $\quad$ 等待一个随机时间可以减少再次碰撞冲突的可能性</p><p>$\quad$ 缺点</p><p>$\quad$ $\quad$ 等待时间内介质上如果没有数据传送，这段时间是浪费的</p><h6 id="1-持续式CSMA"><a href="#1-持续式CSMA" class="headerlink" title="1-持续式CSMA"></a>1-持续式CSMA</h6><p>$\quad$ 步骤</p><p>$\quad$ $\quad$ 1.经侦听，如介质空闲，那么立刻发送</p><p>$\quad$ $\quad$ 2.如介质忙，持续侦听，一旦空闲重复1</p><p>$\quad$ 好处：持续式的延迟时间要少于非持续式</p><p>$\quad$ 仍存在问题：如果两个以上的站等待发送，一旦介质空闲就一定会发生冲突</p><p>$\quad$ $\quad$ 原因：只要空闲就发送，这种方式又被称作1-持续式</p><h6 id="p-持续式CSMA"><a href="#p-持续式CSMA" class="headerlink" title="p-持续式CSMA"></a>p-持续式CSMA</h6><p>$\quad$ 步骤</p><p>$\quad$ $\quad$ 1.经侦听，如介质空闲，那么以 p的概率立刻发送，以(1–p)的概率推迟一个时间单元再进行处理</p><p>$\quad$ $\quad$ 2.如介质忙，持续侦听，一旦空闲重复1</p><p>$\quad$ $\quad$ 3.如果发送已推迟一个时间单元，再重复步骤1</p><p>$\quad$ 注意</p><p>$\quad$ $\quad$ 1-持续式是p-持续式的特例</p><h6 id="冲突检测"><a href="#冲突检测" class="headerlink" title="冲突检测"></a>冲突检测</h6><p>$\quad$ 传播时延导致2个站点不能立即检测到冲突</p><p>$\quad$ 冲突发生时，整个传输都将被浪费</p><p>$\quad$ 冲突概率由传播时延决定</p><p>$\quad$ 动机：冲突仍然可能发生，一旦冲突发生，造成浪费信道</p><p>$\quad$ 原理：“先听后发、边发边听”</p><p>$\quad$ $\quad$ 发送时持续侦听信道</p><p>$\quad$ $\quad$ 一旦传输过程中监听到冲突，立刻中止传输，减少信道浪费</p><p>$\quad$ 类比</p><p>$\quad$ $\quad$ 有礼貌的绅士：说话过程中如果听到其他人也在说话，就马上停下</p><p>$\quad$ 例子</p><p><img src="/../CNP/CN1449.png"></p><h6 id="CSMA-x2F-CD-x3D-1-持续式-冲突检测"><a href="#CSMA-x2F-CD-x3D-1-持续式-冲突检测" class="headerlink" title="CSMA&#x2F;CD &#x3D; 1-持续式 + 冲突检测"></a>CSMA&#x2F;CD &#x3D; 1-持续式 + 冲突检测</h6><p>$\quad$ 流程</p><p>$\quad$ $\quad$ 1.经侦听，如介质空闲，则发送</p><p>$\quad$ $\quad$ 2.如介质忙，持续侦听，一旦空闲立即发送</p><p>$\quad$ $\quad$ 3.发送过程中，进行冲突检测</p><p>$\quad$ $\quad$ 4.如果发生冲突，立即中止发送</p><p>$\quad$ $\quad$ 5.等待一个随机分布的时间再重复步骤1</p><p>$\quad$ 注意</p><p>$\quad$ $\quad$ 非持续式、1-持续式、p-持续式关注的是发送前的操作</p><p>$\quad$ $\quad$ 冲突检测关注的是发送后的操作</p><p>$\quad$ $\quad$ 因此，非持续式、1-持续式与p-持续式都可以选择与冲突检测进行结合</p><p>$\quad$ $\quad$ 实际的CSMA&#x2F;CD，特指1-持续式 + 冲突检测</p><h6 id="中止传输"><a href="#中止传输" class="headerlink" title="中止传输"></a>中止传输</h6><p>$\quad$ 中止发送后，发送Jam（强化）信号</p><p>$\quad$ $\quad$ t4时刻：甲检测到冲突，发送Jam</p><p>$\quad$ $\quad$ t3时刻：乙检测到冲突，发送Jam</p><p>$\quad$ Jam信号告知其他站点：信道内将有数据要传</p><p><img src="/../CNP/CN1450.png"></p><h6 id="冲突窗口"><a href="#冲突窗口" class="headerlink" title="冲突窗口"></a>冲突窗口</h6><p>$\quad$ 冲突窗口：从发出帧到检测发现冲突所需要的最长时间</p><p>$\quad$ $\quad$ 意味着发出后需要侦听一个冲突窗口才能确保没有冲突</p><p>$\quad$ 数值上：等于最远两站传播时间的两倍，即2D（D是单边延迟）</p><p>$\quad$ $\quad$ 2D相当于1个来回传播延迟RTT：Round Trip Time</p><h6 id="CSMA-x2F-CD的效率"><a href="#CSMA-x2F-CD的效率" class="headerlink" title="CSMA&#x2F;CD的效率"></a>CSMA&#x2F;CD的效率</h6><p><img src="/../CNP/CN1451.png"></p><h4 id="轮流协议"><a href="#轮流协议" class="headerlink" title="轮流协议"></a>轮流协议</h4><p>$\quad$ 信道划分:</p><p>$\quad$ $\quad$ 高负载时：信道利用率高、保证公平</p><p>$\quad$ $\quad$ 低负载时：利用率低，即使只有1个站点需要发数据，也只能用1&#x2F;N带宽$\quad$ 随机访问</p><p>$\quad$ $\quad$ 低负载时：利用率高</p><p>$\quad$ $\quad$ 高负载时：冲突严重</p><p>$\quad$ 轮流协议：将两者优势结合</p><p>$\quad$ $\quad$ 轮询协议</p><p>$\quad$ $\quad$ 令牌协议</p><p>$\quad$ $\quad$ 位图协议</p><p>$\quad$ $\quad$ 二进制倒计数协议</p><p>$\quad$ $\quad$ 有限竞争协议：自适应树</p><h6 id="轮询协议"><a href="#轮询协议" class="headerlink" title="轮询协议"></a>轮询协议</h6><p>$\quad$ 在站点间选择一个主节点</p><p>$\quad$ 主节点给其他站点分配信道使用权</p><p>$\quad$ $\quad$ 通常轮流通知每个站点，可以传输多少帧</p><p>$\quad$ $\quad$ 传输完成后，通知下一个站点</p><p>$\quad$ 问题:</p><p>$\quad$ $\quad$ 轮询本身占用带宽</p><p>$\quad$ $\quad$ 通知引入延迟</p><p>$\quad$ $\quad$ 单点故障</p><h6 id="令牌传递"><a href="#令牌传递" class="headerlink" title="令牌传递"></a>令牌传递</h6><p>$\quad$ 令牌：发送权限</p><p>$\quad$ $\quad$ 只有获得令牌的站点可以发送数据</p><p>$\quad$ $\quad$ 令牌通过特殊的令牌消息进行传递</p><p>$\quad$ 将站点组织成一定结构，使得可以安排顺序</p><p>$\quad$ $\quad$ 令牌环：环形拓扑</p><p>$\quad$ $\quad$ 除了环，也可以运行在其它拓扑上，如令牌总线</p><p>$\quad$ 令牌的运行：</p><p>$\quad$ $\quad$ 一个站点获取到令牌后，就可以发送帧，然后把令牌交给下一个站点</p><p>$\quad$ $\quad$ 如果没有帧要发，直接传递令牌</p><p>$\quad$ 缺点：</p><p>$\quad$ $\quad$ 令牌的维护代价</p><p>$\quad$ $\quad$ 令牌本身的可靠性</p><h6 id="位图协议"><a href="#位图协议" class="headerlink" title="位图协议"></a>位图协议</h6><p>$\quad$ 竞争期：在自己的时槽内发送竞争比特</p><p>$\quad$ $\quad$ 举手示意资源预留</p><p>$\quad$ 传输期：按序发送</p><p>$\quad$ $\quad$ 明确的使用权，避免了冲突</p><p><img src="/../CNP/CN1452.png"></p><p>$\quad$ 假设</p><p>$\quad$ $\quad$ 有N个站点，需N个时隙，每帧d比特</p><p>$\quad$ 信道利用率</p><p>$\quad$ $\quad$ k个站点需要实际发送数据，利用率为 kd &#x2F; (kd + N)</p><p>$\quad$ $\quad$ 在低负荷条件下（k &lt;&lt; N）：d&#x2F;(d+N) ，N越大，站点越多，利用率越低</p><p>$\quad$ $\quad$ 在高负荷条件下（k ≈ N）：d&#x2F;(d+1)，接近100%</p><p>$\quad$ 缺点</p><p>$\quad$ $\quad$ 位图协议无法考虑优先级</p><h6 id="二进制倒计数协议"><a href="#二进制倒计数协议" class="headerlink" title="二进制倒计数协议"></a>二进制倒计数协议</h6><p>$\quad$ 站点：编序号，序号长度相同</p><p>$\quad$ 竞争期：有数据发送的站点从高序号到低序号排队，高者得到发送权</p><p>$\quad$ $\quad$ 每个站点发送序号中的某1位比特</p><p>$\quad$ $\quad$ 如果发现有更高优先级的站点也要发送（自身比特0，其他站点比特1），则放弃</p><p>$\quad$ $\quad$ 最后决出优胜站点，进行发送</p><p>$\quad$ 特点：高序号站点优先</p><p>$\quad$ $\quad$ 好事还是坏事？</p><p><img src="/../CNP/CN1453.png"></p><p>$\quad$ N个站的二进制编码所需位数是log2N位，每帧d比特</p><p>$\quad$ 信道的利用率为：d&#x2F;(d+Nlog2N)</p><h6 id="有限竞争协议"><a href="#有限竞争协议" class="headerlink" title="有限竞争协议"></a>有限竞争协议</h6><p>$\quad$ 有限竞争协议利用竞争协议和无冲突协议的优势</p><p>$\quad$ $\quad$ 在低负荷时：使用竞争法，以减少延迟时间</p><p>$\quad$ $\quad$ 在高负荷时：使用无冲突法，以获得高的信道效率。</p><p>$\quad$ 自适应树搜索是一种有限竞争技术</p><p>$\quad$ $\quad$ 在一次成功传输后的第一个竞争时隙，所有站点同时竞争</p><p>$\quad$ $\quad$ 如果只有一个站点申请，则获得信道</p><p>$\quad$ $\quad$ 否则在下一竞争时隙，有一半站点参与竞争（递归），下一时隙由另一半站点参与竞争</p><p>$\quad$ $\quad$ 所有站点构成一棵完全二叉树</p><p><img src="/../CNP/CN1454.png"></p><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>CN</category>
      
      <category>链路层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CN</tag>
      
      <tag>链路层</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络层- IPv6、其他网路层技术</title>
    <link href="/2023/12/06/%E7%BD%91%E7%BB%9C%E5%B1%82-%20IPv6%E3%80%81%E5%85%B6%E4%BB%96%E7%BD%91%E8%B7%AF%E5%B1%82%E6%8A%80%E6%9C%AF/"/>
    <url>/2023/12/06/%E7%BD%91%E7%BB%9C%E5%B1%82-%20IPv6%E3%80%81%E5%85%B6%E4%BB%96%E7%BD%91%E8%B7%AF%E5%B1%82%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<p> 对应 北京大学计算机网络课程第四讲第五部分<br> 参考教材计算机网络-自顶向下方法</p><span id="more"></span><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="网络层-IPv6、其他网路层技术"><a href="#网络层-IPv6、其他网路层技术" class="headerlink" title="网络层- IPv6、其他网路层技术"></a>网络层- IPv6、其他网路层技术</h2><h3 id="IPv6协议"><a href="#IPv6协议" class="headerlink" title="IPv6协议"></a>IPv6协议</h3><p>$\quad$ IPv6（Internet Protocol version 6）是IETF设计用于替代IPv4的下一代协议</p><p>$\quad$ 初始动机：应付“32-bit地址空间耗尽”问题（CIDR和NAT都无法从根本上解决地址短缺问题），增加地址空间</p><p>$\quad$ 后续动机</p><p>$\quad$ $\quad$ 简化头部，加快处理与转发</p><p>$\quad$ $\quad$ 提升服务质量</p><h6 id="IPv6地址"><a href="#IPv6地址" class="headerlink" title="IPv6地址"></a>IPv6地址</h6><p>$\quad$ IPv6 地址</p><p>$\quad$ $\quad$ 地址长度为128bit，是IPv4地址长度的4倍</p><p>$\quad$ $\quad$ IPv6地址空间数量约为3*1038</p><p>$\quad$ $\quad$ IPv6地址表示法，冒分十六进制，x:x:x:x:x:x:x:x</p><p>$\quad$ $\quad$ $\quad$ 简化方法：每个x前面的0可省略，可把连续的值为0的x表示为“::”, 且“::”只能出现1次</p><p>$\quad$ $\quad$ $\quad$ 简化前地址，2001:0DA8:0000:0000:200C:0000:0000:00A5</p><p>$\quad$ $\quad$ $\quad$ 简化后地址，2001:DA8:0000:0000:200C::A5</p><p>$\quad$ IPv6地址分类</p><p>$\quad$ $\quad$ 未指定地址（::&#x2F;128），不能分配给任何节点</p><p>$\quad$ $\quad$ 回环地址（::1&#x2F;128），表示节点自己，不分配，类似IPv4中的127.0.0.1</p><p>$\quad$ $\quad$ 组播地址（FF00::&#x2F;8）</p><p>$\quad$ $\quad$ 链路本地地址（FE80::&#x2F;10），也称为Link-local地址，仅在本地链路上使用，网络设备根据接口MAC地址自动生成</p><p>$\quad$ $\quad$ 全局单播地址，其它地址</p><p>$\quad$ IPv6地址配置方式</p><p>$\quad$ $\quad$ 手动配置</p><p>$\quad$ $\quad$ DHCPv6（IPv6动态主机配置协议）</p><p>$\quad$ $\quad$ 无状态地址自动配置，基于邻居结点IPv6前缀信息，结合自己的链路层地址生成IPv6地址</p><h6 id="IP数据报文"><a href="#IP数据报文" class="headerlink" title="IP数据报文"></a>IP数据报文</h6><p>$\quad$ 固定40字节头部长度</p><p>$\quad$ 不允许传输途中分片(fragmentation)</p><h5 id="IPv6头部"><a href="#IPv6头部" class="headerlink" title="IPv6头部"></a>IPv6头部</h5><p>$\quad$ 版本：4bit，协议版本号，值为6</p><p>$\quad$ 流量类型：8bit，区分数据包的服务类别或优先级</p><p>$\quad$ 流标签：20bit，标识同一个数据流</p><p>$\quad$ 有效载荷长度：16bit ，IPv6报头之后载荷的字节数（含扩展头），最大值64K</p><p>$\quad$ 下一个首部：8bit ，IPv6报头后的协议类型，可能是TCP&#x2F;UDP&#x2F;ICMP等，也可能是扩展头</p><p>$\quad$ 跳数限制：8bit ，类似IPv4的TTL，每次转发跳数减1，值为0时包将会被丢弃</p><p>$\quad$ 源地址： 128bit ，标识该报文的源地址</p><p>$\quad$ 目的地址： 128bit ，标识该报文的目的地址</p><p><img src="/../CNP/CN1301.png"></p><h6 id="头部字段分析"><a href="#头部字段分析" class="headerlink" title="头部字段分析"></a>头部字段分析</h6><p>$\quad$ IPv6头部长度固定40字节</p><p>$\quad$ $\quad$ 所有“选项”字段都在IPv6扩展头部分（位于头部字段后面），通过“下一个首部”字段表明</p><p>$\quad$ 与IPv4头部的比较</p><p>$\quad$ $\quad$ 去除“首部长度”（首部长度固定为40字节）</p><p>$\quad$ $\quad$ 去除“首部校验和”（传输层校验会涉及伪头部信息），提升转发速度</p><p>$\quad$ $\quad$ 去除分片字段：“标识”“标志”“片偏移”，移至扩展头（分段头）</p><p>$\quad$ IPv6分片机制</p><p>$\quad$ $\quad$ IPv6分组不能在传输途中分片，只在源端进行分片</p><p>$\quad$ $\quad$ IPv6设计了专门的分片扩展头，分片字段不存在IPv6头部中</p><p>$\quad$ $\quad$ IPv6支持Path MTU发现机制</p><h6 id="IPv6拓展头"><a href="#IPv6拓展头" class="headerlink" title="IPv6拓展头"></a>IPv6拓展头</h6><p>$\quad$ IPv6报文可承载多个扩展头</p><p>$\quad$ 每个扩展头都包含“下一个首部”字段（IPv6首部固定字段也有）</p><p>$\quad$ $\quad$ 可指向下一个扩展头类型</p><p>$\quad$ $\quad$ 或指明传统上层协议类型（最后一个扩展头）： TCP&#x2F;UDP&#x2F;ICMP . . .</p><p>$\quad$ 如有多个扩展头，需按规定顺序出现</p><p>$\quad$ $\quad$ 逐跳选项头，转发路径上每个节点都需检查该扩展头的信息</p><p>$\quad$ $\quad$ 路由头，指明转发途中需经过哪些节点，类似于IPv4的源路由机制</p><p>$\quad$ $\quad$ 分段头，包含类似IPv4分片处理信息：片偏移、“更多段”标志、标识符</p><p>$\quad$ $\quad$ 目的地选项头，目的端系统需要确认的信息</p><h5 id="IPv6-ICMP改进"><a href="#IPv6-ICMP改进" class="headerlink" title="IPv6 ICMP改进"></a>IPv6 ICMP改进</h5><p>$\quad$ IPv6提供新版本ICMP协议，提供新功能</p><p>$\quad$ $\quad$ 不同的Type值和Code值表示不同的消息</p><p>$\quad$ 消息类型1：邻居请求(Neighbor Solicitation，NS)</p><p>$\quad$ $\quad$ 类似于IPv4中的ARP请求报文，获取邻居的链路层地址，验证邻居可达，重复地址检测</p><p>$\quad$ 消息类型2 ：邻居通告(Neighbor Advertisement，NA)</p><p>$\quad$ $\quad$ 类似于IPv4中的ARP应答报文，对NS消息进行响应</p><p>$\quad$ 消息类型3 ：路由器请求(Router Solicitation，RS)</p><p>$\quad$ $\quad$ 端系统通过RS消息向路由器发出请求，请求地址前缀和其他信息，用于节点的自动配置</p><p>$\quad$ 消息类型4 ：路由器通告(Router Advertisement，RA)</p><p>$\quad$ $\quad$ 路由器通过RA消息向端系统发布地址前缀（IPv6地址自动配置）和其他配置信息</p><p>$\quad$ 消息类型5 ：重定向(Redirect)</p><p>$\quad$ $\quad$ 通知主机重新选择正确的下一跳地址（针对某个目的IPv6地址）</p><h5 id="IPv6路由协议"><a href="#IPv6路由协议" class="headerlink" title="IPv6路由协议"></a>IPv6路由协议</h5><p>$\quad$ RIPng for IPv6，RFC 2080，对RIP修改以适应IPv6环境</p><p>$\quad$ $\quad$ 使用路由器的链路本地IPv6地址作为源地址，发送路由更新信息</p><p>$\quad$ OSPFv3 for IPv6，RFC 5340，适应IPv6网络</p><p>$\quad$ $\quad$ 使用路由器的链路本地IPv6地址作为源地址，并作为下一跳地址</p><p>$\quad$ $\quad$ OSPFv3有7种类型的LSA，新增Link LSA和Intra Area Prefix LSA</p><p>$\quad$ MP-BGP(Multi-Protocol BGP)，RFC 4760，支持多种网络层协议（IPv6和IPX）</p><p>$\quad$ $\quad$ MP-BGP向前兼容，并支持组播</p><p>$\quad$ $\quad$ BGP连接可以是IPv4或IPv6，报文内可传递其它网络协议的路由信息</p><p>$\quad$ $\quad$ 多协议可达NLRI描述了到达目的地的信息：地址属于哪个网络层协议，下一跳地址</p><h4 id="IPv4到IPv6迁移及过滤技术"><a href="#IPv4到IPv6迁移及过滤技术" class="headerlink" title="IPv4到IPv6迁移及过滤技术"></a>IPv4到IPv6迁移及过滤技术</h4><p>$\quad$ IPv4协议和IPv6协议并不兼容，迁移可能经历很长时间</p><p>$\quad$ $\quad$ 涉及：互联网用户、互联网服务提供商（ISP）、互联网内容提供商（ICP）、网络设备厂家</p><p>$\quad$ IPv4&#x2F;IPv6过渡技术的关键要素</p><p>$\quad$ $\quad$ 尽量保证端到端透明原则</p><p>$\quad$ $\quad$ 高效、可行的编址及地址规划</p><p>$\quad$ $\quad$ 路由可扩展性，避免路由表膨胀（消耗转发资源 ）</p><p>$\quad$ $\quad$ 状态维护，减少因为过渡机制引起的状态维护，如IPv4-IPv6映射关系</p><p>$\quad$ 主流过渡技术</p><p>$\quad$ $\quad$ 隧道技术</p><p>$\quad$ $\quad$ 翻译技术</p><h5 id="隧道技术"><a href="#隧道技术" class="headerlink" title="隧道技术"></a>隧道技术</h5><p>$\quad$ 2个相同类型网络的设备，跨越中间异构类型网络进行通信</p><p>$\quad$ $\quad$ 将一种网络的数据包作为另一种网络的数据载荷进行封装</p><p><img src="/../CNP/CN1302.png"></p><p><img src="/../CNP/CN1303.png"></p><p>$\quad$ 报文长度在传输途中增大导致分片问题</p><p>$\quad$ $\quad$ 途中分片与重组对传输性能影响较大</p><p>$\quad$ 解决方法</p><p>$\quad$ $\quad$ 提前分片，需要Path MTU发现机制</p><p><img src="/../CNP/CN1304.png"></p><h5 id="翻译技术"><a href="#翻译技术" class="headerlink" title="翻译技术"></a>翻译技术</h5><p><img src="/../CNP/CN1305.png"></p><h6 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h6><p>$\quad$ 破坏互联网端到端原则</p><p>$\quad$ $\quad$ 通信双方只看到通信对端在本网络对应的地址</p><p>$\quad$ $\quad$ 翻译网关处理传输层、应用层数据（上层数据无法透明传输）</p><p>$\quad$ 异构地址寻址问题</p><p>$\quad$ $\quad$ 通信双方至少有一方需感知本次通信涉及翻译技术</p><p>$\quad$ $\quad$ 域名访问需DNS服务支撑</p><p>$\quad$ 应用层内嵌IP地址</p><p>$\quad$ $\quad$ 部分应用层协议内嵌IP地址，将使翻译技术实施难度极大</p><p>$\quad$ 翻译导致报文变长可能导致分片问题，影响转发性能</p><h3 id="其他类型网络层技术"><a href="#其他类型网络层技术" class="headerlink" title="其他类型网络层技术"></a>其他类型网络层技术</h3><p>$\quad$ 现有Internet：无连接的分组交换服务</p><p>$\quad$ $\quad$ 不需要提前建立连接</p><p>$\quad$ $\quad$ 尽力而为：不提供任何服务质量承诺</p><p>$\quad$ $\quad$ 简单、灵活、成本低</p><p>$\quad$ 基于Internet仍有技术提供不同类型的服务</p><p>$\quad$ $\quad$ 基于Internet的服务质量保障</p><p>$\quad$ $\quad$ 基于Internet的面向连接服务</p><h5 id="网络服务质量"><a href="#网络服务质量" class="headerlink" title="网络服务质量"></a>网络服务质量</h5><p>$\quad$ 网络服务质量？（QoS, Quality of Service）是网络在传输数据流时要满足一系列服务请求，具体可以量化为带宽、时延、抖动、丢包率等性能指标</p><p>$\quad$ QoS针对各种业务的不同需求，为其提供端到端的服务质量保证。在有限的带宽资源下，它允许不同的流量不平等地竞争网络资源，语音、视频和重要的数据应用在网络设备中可以优先得到服务</p><p>$\quad$ 常用的网络服务质量机制包括：数据包调度；流量工程；流量整形：漏桶算法、令牌桶算法；综合服务；区分服务</p><h6 id="数据包调度"><a href="#数据包调度" class="headerlink" title="数据包调度"></a>数据包调度</h6><p>$\quad$ 路由器输出端口决定：把缓冲区中的哪些数据包发送到输出链路上</p><p>$\quad$ $\quad$ 先来先服务FCFS（First-Come First-Serve）</p><p>$\quad$ $\quad$ 公平队列算法（Fair Queueing）</p><p>$\quad$ $\quad$ 加权公平队列算法（Weighted Fair Queueing）</p><p>$\quad$ $\quad$ 优先级调度（Priority Scheduling）</p><p><img src="/../CNP/CN1306.png"></p><h6 id="流量工程"><a href="#流量工程" class="headerlink" title="流量工程"></a>流量工程</h6><p>$\quad$ 流量工程：根据对传输流量的预测，规划流量的传输路径</p><p>$\quad$ $\quad$ 目的：提高带宽利用率、避免拥塞</p><p>$\quad$ 通常需要线性规划、网络流算法</p><p>$\quad$ 需要其他技术（如MPLS或者SDN）配合，进行流量区分</p><h6 id="流量整形"><a href="#流量整形" class="headerlink" title="流量整形"></a>流量整形</h6><p>$\quad$ 流量整形(traffic shaping)：其作用是限制流出某一网络的某一连接的流量与突发，使这类报文以比较均匀的速度向外发送</p><p>$\quad$ 流量整形算法包括漏桶算法和令牌桶算法</p><p>$\quad$ $\quad$ 漏桶算法（Leaky Bucket Algorithm）：</p><p>$\quad$ $\quad$ $\quad$ 平滑网络上的突发流量</p><p>$\quad$ $\quad$ $\quad$ 突发流量可以被整形以便为网络提供一个稳定的流量</p><p>$\quad$ $\quad$ 令牌桶算法（Token Bucket Algorithm）：</p><p>$\quad$ $\quad$ $\quad$ 允许突发数据的发送，但控制流速</p><p><img src="/../CNP/CN1308.png"><img src="/../CNP/CN1307.png"></p><h6 id="综合服务"><a href="#综合服务" class="headerlink" title="综合服务"></a>综合服务</h6><p>$\quad$ 特点1：（面向连接）基于资源预留协议RSVP，在主机间建立传输流的连接</p><p>$\quad$ 特点2：（预留资源）逐节点建立或拆除流的状态和资源预留状态，根据QoS进行路由</p><p>$\quad$ 要求：需要所有的路由器支持综合服务，在控制路径上处理每个流的消息，维护每个流的路径状态和资源预留状态，在路径上执行基于流的分类、调度、管理</p><p>$\quad$ 现实：难以实现</p><h6 id="区分服务"><a href="#区分服务" class="headerlink" title="区分服务"></a>区分服务</h6><p>$\quad$ 在IP报头的8位区分服务字段（DS字段）中使用6位区分服务码点（DSCP）进行分组分类，指明分组的类型</p><p>$\quad$ 路由节点在转发这种包的时候，只需根据不同的DSCP选择相应的调度和转发服务即可</p><p><img src="/../CNP/CN1309.png"></p><h4 id="面向连接服务"><a href="#面向连接服务" class="headerlink" title="面向连接服务"></a>面向连接服务</h4><p>$\quad$ 面向连接服务：如打电话</p><p>$\quad$ $\quad$ 通信之间先建立逻辑连接：在此过程中，如有需要，可以预留网络资源</p><p>$\quad$ $\quad$ 结合使用可靠传输的网络协议，保证所发送的分组无差错按序到达终点</p><h5 id="虚电路"><a href="#虚电路" class="headerlink" title="虚电路"></a>虚电路</h5><p>$\quad$ 虚电路是逻辑连接，建立在Internet分组交换之上</p><p>$\quad$ $\quad$ 虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接</p><p>$\quad$ $\quad$ 注意，电路交换的电话通信是先建立了一条真正的连接</p><p>$\quad$ $\quad$ 因此，虚电路和电路交换的连接只是类似，但并不完全相同</p><h6 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h6><p><img src="/../CNP/CN1310.png"></p><h6 id="转发策略"><a href="#转发策略" class="headerlink" title="转发策略"></a>转发策略</h6><p>$\quad$ 基于分组标签，即虚电路号</p><p><img src="/../CNP/CN1311.png"></p><h6 id="面向连接的虚电路"><a href="#面向连接的虚电路" class="headerlink" title="面向连接的虚电路"></a>面向连接的虚电路</h6><p><img src="/../CNP/CN1312.png"></p><p><img src="/../CNP/CN1313.png"></p><p><img src="/../CNP/CN1314.png"></p><h6 id="与数据包网络的比较"><a href="#与数据包网络的比较" class="headerlink" title="与数据包网络的比较"></a>与数据包网络的比较</h6><p><img src="/../CNP/CN1315.png"></p><h5 id="MPLS"><a href="#MPLS" class="headerlink" title="MPLS"></a>MPLS</h5><p>$\quad$ MPLS (MultiProtocol Label Switching)全称是多协议标签交换</p><p>$\quad$ $\quad$ 多协议表示在 MPLS 的上层可以采用多种协议，例如：IP，IPv6、IPX</p><p>$\quad$ $\quad$ 达到“链路虚拟化”的目的</p><p>$\quad$ 思想：基于IP转发 -&gt; 基于标签转发</p><p>$\quad$ $\quad$ 标签是指每个分组被分配一个标签，路由器根据该标签对分组进行转发</p><p>$\quad$ $\quad$ 交换是指标签的交换，MPLS 报文交换和转发是基于标签的</p><p>$\quad$ MPLS 设计初衷为了提升查找速度</p><p>$\quad$ MPLS 主要有以下三个方面的应用</p><p>$\quad$ $\quad$ 面向连接的服务质量管理</p><p>$\quad$ $\quad$ 流量工程，平衡网络负载</p><p>$\quad$ $\quad$ 虚拟专用网VPN</p><h6 id="报文结构"><a href="#报文结构" class="headerlink" title="报文结构"></a>报文结构</h6><p>$\quad$ 给 IP 数据报加标签”其实就是在链路层的帧首部和IP数据报的首部之间插入一个 4 字节的 MPLS 首部</p><p>$\quad$ MPLS又称为2.5层协议</p><p><img src="/../CNP/CN1316.png"></p><h6 id="核心要素"><a href="#核心要素" class="headerlink" title="核心要素"></a>核心要素</h6><p>$\quad$ 标签交换路由器LSR</p><p>$\quad$ $\quad$ 支持MPLS的路由器</p><p>$\quad$ $\quad$ 具备标签交换、路由选择两种功能</p><p>$\quad$ MPLS域</p><p>$\quad$ $\quad$ 所有相邻的支持MPLS技术的路由器构成的区域</p><p>$\quad$ 标签分配协议LDP</p><p>$\quad$ $\quad$ 用来在LSR之间建立LDP会话并交换Label映射信息</p><p>$\quad$ 标签</p><p>$\quad$ $\quad$ 标签仅仅在两个LSR 之间才有意义</p><p>$\quad$ $\quad$ LSR会维护一张转发表</p><p>| 入接口　| 　入标记　|　出接口　|　出标记　|</p><p>| ———– | ———– |———– |———– |</p><p>| 0 | 　3　|　1　| 1 |</p><p>$\quad$ $\quad$ 表项含义：从入接口 0 收到一个入标记为 3 的IP 数据报，转发时，应当把该IP数据报从出接口 1 转发出去，同时把标记对换为 1</p><p><img src="/../CNP/CN1317.png"></p><h6 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h6><p>$\quad$ 加标签</p><p>$\quad$ $\quad$ 在 MPLS 域的入口处，给每一个 IP 数据报加上 标签，然后对加上标记的 IP 数据报用硬件进行转发</p><p>$\quad$ 标签交换</p><p>$\quad$ $\quad$ MPLS域内每台路由器，对加上标记的 IP 数据报修改标签并转发称为标签交换</p><p>$\quad$ 去标签</p><p>$\quad$ $\quad$ 当分组离开 MPLS 域时，MPLS 出口路由器把分组的标签去除。后续按照一般IP分组的转发方法进行转发</p><h6 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h6><p><img src="/../CNP/CN1318.png"></p><h6 id="MPLS转发等价类"><a href="#MPLS转发等价类" class="headerlink" title="MPLS转发等价类"></a>MPLS转发等价类</h6><p>$\quad$ 不可能对每个报文分配各自标签</p><p>$\quad$ 如果一组报文在网络上被以同样的方式处理，则构成一个转发等价类FEC</p><p>$\quad$ 通常对一个FEC分配唯一的标签</p><p>$\quad$ FEC有多种定义方式</p><p>$\quad$ $\quad$ 属于某特定组的组播报文</p><p>$\quad$ $\quad$ 目的IP地址匹配了一个特定前缀的报文</p><p>$\quad$ $\quad$ 有相同QoS策略的报文</p><p>$\quad$ $\quad$ 属于同一个VPN的报文（MPLS VPN中）</p><p>$\quad$ $\quad$ 报文的目的IP地址属于BGP学习到的路由，并且下一跳相同</p><p>$\quad$ $\quad$ 其他</p><h5 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h5><p>$\quad$ 许多机构希望建立专用网络</p><p>$\quad$ $\quad$ 连接该机构各部分网络</p><p>$\quad$ $\quad$ 与Internet隔离的路由器、链路、以及DNS、DHCP等基础服务</p><p>$\quad$ $\quad$ 缺点：代价昂贵</p><p>$\quad$ 虚拟专用网（Virtual Private Network，VPN）</p><p>$\quad$ $\quad$ 建立在Internet之上</p><p>$\quad$ $\quad$ 通过加密与认证机制，保持逻辑上的隔离</p><p>$\quad$ VPN的设计原则</p><p>$\quad$ $\quad$ 安全性、隧道与加密、数据验证、用户验证、防火墙与攻击检测</p><h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6><p>$\quad$ VPN指利用公用网络架设专用网络的远程访问技术</p><p>$\quad$ VPN通过隧道技术在公共网络上模拟出一条点到点的逻辑专线，从而达到安全数据传输的目的</p><p><img src="/../CNP/CN1319.png"></p><h6 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h6><p><img src="/../CNP/CN1320.png"></p><h6 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h6><p><img src="/../CNP/CN1321.png"></p><p><img src="/../CNP/CN1322.png"></p><h6 id="其他实现方式"><a href="#其他实现方式" class="headerlink" title="其他实现方式"></a>其他实现方式</h6><p>$\quad$ 按功能位置</p><p>$\quad$ $\quad$ CPE-based VPN（基于客户端设备）</p><p>$\quad$ $\quad$ Network-based VPN（基于网络）</p><p>$\quad$ 按业务构成</p><p>$\quad$ $\quad$ Access VPN（远程访问虚拟网）</p><p>$\quad$ $\quad$ Intranet VPN（企业内部虚拟网）</p><p>$\quad$ $\quad$ Extranet VPN（企业扩展虚拟网）</p><p>$\quad$ 按实现层次</p><p>$\quad$ $\quad$ 二层隧道VPN（ L2TP 、 PPTP 、 L2F ）</p><p>$\quad$ $\quad$ 三层隧道VPN（GRE、IPSec、MPLS）</p><p>$\quad$ $\quad$ 传输层隧道VPN（SSL、TLS）</p><p>$\quad$ 按组网模型</p><p>$\quad$ $\quad$ VPDN：Virtual Private Dial Networks（虚拟专用拨号网络）</p><p>$\quad$ $\quad$ VPRN：Virtual Private Routed Networks（虚拟专用路由网络）</p><p>$\quad$ $\quad$ VPLS：Virtual Private LAN Segment（虚拟专用LAN 网段）</p><p>$\quad$ $\quad$ VLL：Virtual Leased Lines（虚拟租用线）</p><h3 id="Segment-Routing与SRv6"><a href="#Segment-Routing与SRv6" class="headerlink" title="Segment Routing与SRv6"></a>Segment Routing与SRv6</h3><h6 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h6><p><img src="/../CNP/CN1323.png"></p><h6 id="Segment"><a href="#Segment" class="headerlink" title="Segment"></a>Segment</h6><p><img src="/../CNP/CN1324.png"></p><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>CN</category>
      
      <category>网络层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CN</tag>
      
      <tag>网络层</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络层 - 软件定义网络</title>
    <link href="/2023/11/30/%E7%BD%91%E7%BB%9C%E5%B1%82-%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C/"/>
    <url>/2023/11/30/%E7%BD%91%E7%BB%9C%E5%B1%82-%E8%BD%AF%E4%BB%B6%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<p> 对应 北京大学计算机网络课程第四讲第四部分<br> 参考教材计算机网络-自顶向下方法</p><span id="more"></span><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="网络层-软件定义网络SDN"><a href="#网络层-软件定义网络SDN" class="headerlink" title="网络层-软件定义网络SDN"></a>网络层-软件定义网络SDN</h2><h6 id="传统网络数据平面的缺陷"><a href="#传统网络数据平面的缺陷" class="headerlink" title="传统网络数据平面的缺陷"></a>传统网络数据平面的缺陷</h6><p>$\quad$ 传统的网络设备：数据平面硬件、操作系统和网络应用三部分紧耦合，形成封闭的系统；互相之间不兼容，难以配置和管理</p><p>$\quad$ 传统网络不可编程，很难实现高效、按需的数据传输</p><p>$\quad$ 路由器以接力棒的形式不断向邻居结点传播消息：效率低</p><p>$\quad$ $\quad$ 距离向量（DV）算法：收敛时间长，甚至可能遇到无穷计数问题</p><p>$\quad$ $\quad$ 链路状态（LS）算法：链路信息传播时间长</p><p>$\quad$ 现代网络设备数量不断增加</p><p>$\quad$ $\quad$ 划分自治系统（AS）与区域无法从根本上解决问题</p><h6 id="流量工程："><a href="#流量工程：" class="headerlink" title="流量工程："></a>流量工程：</h6><p>$\quad$ 根据对传输流量的预测，规划流量的传输路径</p><p>$\quad$ 目的：提高带宽利用率、避免拥塞</p><p>$\quad$ 通常需要线性规划、网络流算法</p><p>$\quad$ $\quad$ 基于最短路的路由：对单个路由器局部最优，但未必全局最优</p><p><img src="/../CNP/CN1201.png"></p><p>$\quad$ 问题1: 如何让 u-to-z 的流量经过路径 uvwz, x-to-z 的经过路径 xwyz?</p><p>$\quad$ $\quad$ 方案a：采用基于最短路的传统路由，调整路径代价（：将ux, vx设置为无穷大）</p><p>$\quad$ $\quad$ $\quad$ 并不总是可行</p><p>$\quad$ $\quad$ 方案b：采用新的流量工程方法计算路径</p><p>$\quad$ $\quad$ $\quad$ 需要更多输入数据（如“源-目标”主机的流量信息）</p><p>$\quad$ $\quad$ $\quad$ 传统分布式路由器架构：实现困难、代价巨大</p><p>$\quad$ 问题2: 如何让 u-to-z 的流量划分到 uvwz 与 uxyz 两条路径进行传输</p><p>$\quad$ $\quad$ 传统基于最短路的路由算法无法计算得到该结果</p><p>$\quad$ 问题3: 如何让路由器w区别对待红色与绿色两组流量</p><p>$\quad$ $\quad$ 基于目的地址转发的传统路由方式无法区分</p><h3 id="软件定义网络"><a href="#软件定义网络" class="headerlink" title="软件定义网络"></a>软件定义网络</h3><p>$\quad$ 传统Internet的网络层：通过多个独立路由器分布式实现，同时运行数据平面与控制平面</p><p>$\quad$ $\quad$ 转发：IP协议</p><p>$\quad$ $\quad$ 路由：通用协议（OSPF，BGP）或设备厂商专有协议</p><p>$\quad$ $\quad$ 管理接口：设备厂商专有接口</p><p>$\quad$ 除了路由器，网络层还包含大量其他设备</p><p>$\quad$ $\quad$ 防火墙</p><p>$\quad$ $\quad$ NAT设备</p><p>$\quad$ $\quad$ 负载均衡设备</p><h6 id="技术要点"><a href="#技术要点" class="headerlink" title="技术要点"></a>技术要点</h6><p><img src="/../CNP/CN1202.png"></p><h6 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h6><p>（数据平面）数据平面与控制平面分离：数据平面提供开放接口</p><p>$\quad$ $\quad$ 允许对网络设备进行“编程”</p><p>（控制平面）中心化控制器：全局网络视角，更好的网络管理</p><p>$\quad$ $\quad$ 加快链路状态传播 and&#x2F;or 路由收敛速度</p><p>$\quad$ $\quad$ 支持流量工程：全局更优的路径选择</p><p>$\quad$ $\quad$ 避免路由器故障导致的网络配置错误</p><p>$\quad$ $\quad$ 让网络编程更加容易</p><h6 id="SDN交换机"><a href="#SDN交换机" class="headerlink" title="SDN交换机"></a>SDN交换机</h6><p>$\quad$ 简单、高性能的交换机架构</p><p>$\quad$ $\quad$ 流表架构：“流量匹配-动作”</p><p>$\quad$ $\quad$ 实现通用的数据平面处理功能</p><p>$\quad$ 交换机流表提供API (e.g., OpenFlow)</p><p>$\quad$ $\quad$允许程序定义部分流表功能</p><p>$\quad$ 流表由控制器计算并安装</p><p>$\quad$ 交换机流表与控制器通过开放协议交互(e.g., OpenFlow)</p><p>$\quad$ 网络中的SDN交换机可以来自不同产商</p><h6 id="SDN控制器（网络操作系统）"><a href="#SDN控制器（网络操作系统）" class="headerlink" title="SDN控制器（网络操作系统）"></a>SDN控制器（网络操作系统）</h6><p>$\quad$ 维护全网状态信息</p><p>$\quad$ 与数据平面SDN交换机交互</p><p>$\quad$ $\quad$ 通过“南向接口（southbound API)”，如OpenFlow</p><p>$\quad$ 为上层网络应用提供接口</p><p>$\quad$ $\quad$ 称为“北向接口（northbound API)”</p><p>$\quad$ 以分布式系统的形式实现</p><p>$\quad$ $\quad$ 高性能、可扩展、故障容错</p><p>$\quad$ 可以与SDN交换机来自于不同产商</p><h6 id="SDN应用程序"><a href="#SDN应用程序" class="headerlink" title="SDN应用程序"></a>SDN应用程序</h6><p>$\quad$ 基于北向接口，实现各类网络功能</p><p>$\quad$ 可以由第三方开发者提供</p><p>$\quad$ $\quad$ 不仅仅是网络设备产商</p><h4 id="数据平面"><a href="#数据平面" class="headerlink" title="数据平面"></a>数据平面</h4><p>$\quad$ 每个路由器维护一张流表（flow table） ，流表由控制器计算后写入每个路由器</p><p><img src="/../CNP/CN1203.png"></p><h5 id="OpenFlow"><a href="#OpenFlow" class="headerlink" title="OpenFlow"></a>OpenFlow</h5><p>$\quad$ 目前最流行的流表结构是OpenFlow所定义的流表</p><p>$\quad$ $\quad$ 最早的SDN技术</p><p>$\quad$ OpenFlow的流表项由4部分组成</p><p>$\quad$ $\quad$ 模式：报文头中的匹配值</p><p>$\quad$ $\quad$ 动作：对于成功匹配的报文所进行的操作，包括转发、修改、丢弃、送往控制器</p><p>$\quad$ $\quad$ 优先级：当一个报文有多个匹配成功项时，定义优先顺序</p><p>$\quad$ $\quad$ 计数器：报文数、字节数</p><p><img src="/../CNP/CN1204.png"></p><h6 id="抽象能力"><a href="#抽象能力" class="headerlink" title="抽象能力"></a>抽象能力</h6><p><img src="/../CNP/CN1205.png"></p><h6 id="转发表配置"><a href="#转发表配置" class="headerlink" title="转发表配置"></a>转发表配置</h6><p><img src="/../CNP/CN1206.png"></p><h6 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h6><p><img src="/../CNP/CN1207.png"></p><h4 id="控制平面"><a href="#控制平面" class="headerlink" title="控制平面"></a>控制平面</h4><h6 id="控制器架构"><a href="#控制器架构" class="headerlink" title="控制器架构"></a>控制器架构</h6><p><img src="/../CNP/CN1208.png"></p><h5 id="OpenFlow协议"><a href="#OpenFlow协议" class="headerlink" title="OpenFlow协议"></a>OpenFlow协议</h5><p>$\quad$ 用于控制器与支持OpenFlow的交换机交互</p><p>$\quad$ 使用TCP传输消息</p><p>$\quad$ $\quad$ 可选项：加密消息</p><p>$\quad$ OpenFlow定义了2类消息</p><p>$\quad$ $\quad$ 控制器 -&gt; 交换机</p><p>$\quad$ $\quad$ 交换机 -&gt; 控制器</p><h6 id="控制器-gt-交换机"><a href="#控制器-gt-交换机" class="headerlink" title="控制器-&gt;交换机"></a>控制器-&gt;交换机</h6><p>$\quad$ 读状态: 控制器查询交换机状态或数据，交换机需回复</p><p>$\quad$ 配置: 控制器设置交换机相关参数</p><p>$\quad$ 修改状态: 添加、删除、修改交换机流表项</p><p>$\quad$ Packet-out: 控制器通过交换机某个接口，发送数据报，即流量注入</p><h6 id="交换机-gt-控制器"><a href="#交换机-gt-控制器" class="headerlink" title="交换机-&gt;控制器"></a>交换机-&gt;控制器</h6><p>$\quad$ 流删除：通知流表项已经删除</p><p>$\quad$ $\quad$ 流表项删除由控制器触发，或者超过存货周期</p><p>$\quad$ 端口状态: 上报交换机某个状态或统计信息</p><p>$\quad$ Packet-in: 将报文发送给控制器（通常用于匹配失败的报文）</p><h4 id="数据平面-x2F-控制平面整体"><a href="#数据平面-x2F-控制平面整体" class="headerlink" title="数据平面&#x2F;控制平面整体"></a>数据平面&#x2F;控制平面整体</h4><p><img src="/../CNP/CN1209.png"></p><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>CN</category>
      
      <category>网络层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CN</tag>
      
      <tag>网络层</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络层 - 路由</title>
    <link href="/2023/11/21/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E8%B7%AF%E7%94%B1/"/>
    <url>/2023/11/21/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E8%B7%AF%E7%94%B1/</url>
    
    <content type="html"><![CDATA[<p> 对应 北京大学计算机网络课程第四讲第三部分<br> 参考教材计算机网络-自顶向下方法</p><span id="more"></span><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="网络层-路由"><a href="#网络层-路由" class="headerlink" title="网络层-路由"></a>网络层-路由</h2><h3 id="网络路由"><a href="#网络路由" class="headerlink" title="网络路由"></a>网络路由</h3><h6 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h6><p>$\quad$ 为每对（发送主机，接收主机）找到“好的”网络传输路径</p><p>$\quad$ 路径：一系列连接发送主机与接收主机的路由器，用于传输数据报文</p><p>$\quad$ 好路径标准</p><p>$\quad$ $\quad$ 低开销</p><p>$\quad$ $\quad$ 速度快</p><p>$\quad$ $\quad$ 拥塞少</p><h6 id="网络的图抽象"><a href="#网络的图抽象" class="headerlink" title="网络的图抽象"></a>网络的图抽象</h6><p><img src="/../CNP/CN1101.png"></p><h6 id="基于最短路的路由算法"><a href="#基于最短路的路由算法" class="headerlink" title="基于最短路的路由算法"></a>基于最短路的路由算法</h6><p>$\quad$ 最短路径算法：计算每个结点到其他所有结点的最短路径</p><p>$\quad$ 所有的源节点到一个指定目标节点的最优路径的集合构成一棵以目标节点为根的树</p><p>$\quad$ $\quad$ 称为汇集树（sink tree）</p><p>$\quad$ 经典的最短路径算法</p><p>$\quad$ $\quad$ Dijkstra算法</p><p>$\quad$ $\quad$ Bellman-Ford算法</p><p>$\quad$ 应用经典算法时，还需要考虑现实情形：</p><p>$\quad$ $\quad$ 简单性：每台路由器计算与存储资源有限</p><p>$\quad$ $\quad$ 异步性：各个路由器独立、异步工作</p><p>$\quad$ $\quad$ 鲁棒性：网络状态不断变化，甚至可能发生结点与链路故障</p><p>$\quad$ $\quad$ 公平性：每条路径不会过多消耗带宽等资源</p><p>$\quad$ 路由算法分类</p><p>$\quad$ $\quad$ 全局:</p><p>$\quad$ $\quad$ $\quad$ 每个路由器都有完整的网络拓扑与链路开销等信息</p><p>$\quad$ $\quad$ $\quad$ 链路状态算法（基于Dijkstra算法）</p><p>$\quad$ $\quad$ 局部:</p><p>$\quad$ $\quad$ $\quad$ 每个路由器只知道邻居结点，以及到邻居结点的链路开销</p><p>$\quad$ $\quad$ $\quad$ 需要结点与邻居不断交换信息，并反复迭代更新</p><p>$\quad$ $\quad$ $\quad$ 距离向量算法（基于Bellman-Ford算法）</p><h3 id="路由选择算法"><a href="#路由选择算法" class="headerlink" title="路由选择算法"></a>路由选择算法</h3><h4 id="距离向量算法"><a href="#距离向量算法" class="headerlink" title="距离向量算法"></a>距离向量算法</h4><p><img src="/../CNP/CN1102.png"></p><h6 id="单机Bellman-Ford算法"><a href="#单机Bellman-Ford算法" class="headerlink" title="单机Bellman-Ford算法"></a>单机Bellman-Ford算法</h6><p><img src="/../CNP/CN1103.png"></p><h5 id="距离向量算法-1"><a href="#距离向量算法-1" class="headerlink" title="距离向量算法"></a>距离向量算法</h5><p>$\quad$ 从单机Bellman-Ford到分布式更新</p><p>$\quad$ 数据的分布式：将单机算法维护的信息分散到各个结点</p><p>$\quad$ 计算的分布式：将算法更新操作分散到各个结点</p><h6 id="数据分布式"><a href="#数据分布式" class="headerlink" title="数据分布式"></a>数据分布式</h6><p>$\quad$ 每个结点x维护信息</p><p>$\quad$ $\quad$ 到达每个邻居结点v的开销：c(x,v)</p><p>$\quad$ $\quad$ 距离向量（DV）：$Dx &#x3D; [Dx(y): y є N ]$，该结点x到网络中所有其他结点y的最小代价的估计值</p><p><img src="/../CNP/CN1104.png"></p><p>$\quad$ 每个邻居结点v的距离向量，即对于所有邻居v，结点x保存$Dv &#x3D; [Dv(y): y є N]$</p><h6 id="计算分布式"><a href="#计算分布式" class="headerlink" title="计算分布式"></a>计算分布式</h6><p>$\quad$ 每个结点不断重复:</p><p>$\quad$ $\quad$ （发送）每个节点向邻居发送它自己到某些节点的距离向量</p><p>$\quad$ $\quad$ （接收）当节点x接收到来自邻居y的新DV估计，更新所保存的y的DV信息</p><p><img src="/../CNP/CN1105.png"></p><p>$\quad$ $\quad$ （计算）使用B-F方程更新其自己的DV :Dx(y) ← minv{c(x,v) + Dv(y)}  for each node y ∊ N</p><p>$\quad$ $\quad$ 上述过程迭代执行，Dx(y)收敛为实际最小费用 dx(y)</p><h6 id="算法特点"><a href="#算法特点" class="headerlink" title="算法特点"></a>算法特点</h6><p>$\quad$ 异步：结点迭代频率不需要一致</p><p>$\quad$ 迭代：每次某个结点上的迭代有2种触发</p><p>$\quad$ $\quad$ 本地链路代价发生改变</p><p>$\quad$ $\quad$ 收到来自邻居的DV更新</p><p>$\quad$ 分布式：结点直接互相协作</p><p>$\quad$ $\quad$ 每个结点当且仅当DV信息发生变化时通知其他结点</p><p>$\quad$ $\quad$ 邻居结点根据需要通知自己的邻居<img src="/../CNP/CN1106.png"></p><p><img src="/../CNP/CN1107.png"></p><h6 id="链路状态改变：代价变小"><a href="#链路状态改变：代价变小" class="headerlink" title="链路状态改变：代价变小"></a>链路状态改变：代价变小</h6><p><img src="/../CNP/CN1108.png"></p><h6 id="链路状态改变：代价变大"><a href="#链路状态改变：代价变大" class="headerlink" title="链路状态改变：代价变大"></a>链路状态改变：代价变大</h6><p><img src="/../CNP/CN1109.png"></p><p><img src="/../CNP/CN1110.png"></p><p><img src="/../CNP/CN1111.png"></p><p><img src="/../CNP/CN1112.png"></p><p><img src="/../CNP/CN1113.png"></p><h6 id="链路状态改变：毒性逆转"><a href="#链路状态改变：毒性逆转" class="headerlink" title="链路状态改变：毒性逆转"></a>链路状态改变：毒性逆转</h6><p><img src="/../CNP/CN1114.png"></p><p>$\quad$ 毒性逆转无法解决一般性的无穷计数问题</p><h5 id="链路状态算法"><a href="#链路状态算法" class="headerlink" title="链路状态算法"></a>链路状态算法</h5><p>$\quad$ 基于Dijkstra算法</p><p>$\quad$ 每个结点都知道网络拓扑与链路开销</p><p>$\quad$ $\quad$ 通过链路状态广播得到</p><p>$\quad$ $\quad$ 所有结点都有相同的信息</p><p>$\quad$ 每个结点计算以自己为源节点，到其他所有结点的最短路径</p><p>$\quad$ $\quad$ 生成该结点的转发表</p><p>$\quad$ 符号:</p><p>$\quad$ $\quad$ c(x,y): x到y的链路开销，∞表示2个结点之间没有边</p><p>$\quad$ $\quad$ D(v): 当前到达目的结点v的路径代价</p><p>$\quad$ $\quad$ p(v): 到达目的结点v的上一跳结点</p><p>$\quad$ $\quad$ N’ : 最短路已经确定的结点集合</p><h6 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h6><p><img src="/../CNP/CN1115.png"></p><h5 id="链路状态算法-1"><a href="#链路状态算法-1" class="headerlink" title="链路状态算法"></a>链路状态算法</h5><p>$\quad$ 链路状态（Link State）路由可分为五个部分：</p><p>$\quad$ $\quad$ 1. 发现邻居，了解他们的网络地址；</p><p><img src="/../CNP/CN1116.png"></p><p>$\quad$ $\quad$ 2. 设置到每个邻居的成本度量；</p><p>$\quad$ $\quad$ $\quad$ 开销&#x2F;度量&#x2F;代价：</p><p>$\quad$ $\quad$ $\quad$ $\quad$ 自动发现设置或人工配置</p><p>$\quad$ $\quad$ $\quad$ $\quad$ 度量：带宽、跳数、延迟、负载、可靠性等</p><p>$\quad$ $\quad$ $\quad$ 常用度量：链路带宽（反比）</p><p>$\quad$ $\quad$ $\quad$ $\quad$ 例如：1-Gbps以太网的代价为1，100-Mbps以太网的代价为10</p><p>$\quad$ $\quad$ $\quad$ 可选度量：延迟</p><p>$\quad$ $\quad$ $\quad$ $\quad$ 发送一个echo包，另一端立即回送一个应答</p><p>$\quad$ $\quad$ $\quad$ $\quad$ 通过测量往返时间RTT，可以获得一个合理的延迟估计值</p><p>$\quad$ $\quad$ 3. 构造一个分组，分组中包含最新的链路信息；</p><p>$\quad$ $\quad$ $\quad$ 构造链路状态分组（link state packet，LSP）</p><p>$\quad$ $\quad$ $\quad$ $\quad$ 发送方标识</p><p>$\quad$ $\quad$ $\quad$ $\quad$ 序列号</p><p>$\quad$ $\quad$ $\quad$ $\quad$ 年龄（存活时间）</p><p>$\quad$ $\quad$ $\quad$ $\quad$ 邻居列表：包含邻居与对应的链路开销</p><p><img src="/../CNP/CN1117.png"></p><p>$\quad$ $\quad$ 4. 将此分组发送给其他的路由器；</p><p>$\quad$ $\quad$ $\quad$ 每个LSP分组包含一个序列号，且递增</p><p>$\quad$ $\quad$ $\quad$ 路由器记录所收到的所有（源路由器、序列号）对</p><p>$\quad$ $\quad$ $\quad$ 当一个新分组到达时，路由器根据记录判断：</p><p>$\quad$ $\quad$ $\quad$ $\quad$ 如果是新分组，洪泛广播</p><p>$\quad$ $\quad$ $\quad$ $\quad$ 如果是重复分组，丢弃</p><p>$\quad$ $\quad$ $\quad$ $\quad$ 如果是过时分组，拒绝</p><p>$\quad$ $\quad$ 5. 计算到其他路由器的最短路径：Dijkstra算法</p><p><img src="/../CNP/CN1118.png"></p><h5 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h5><p><img src="/../CNP/CN1119.png"></p><h3 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h3><h4 id="层次路由"><a href="#层次路由" class="headerlink" title="层次路由"></a>层次路由</h4><h6 id="层次路由-产生原因"><a href="#层次路由-产生原因" class="headerlink" title="层次路由-产生原因"></a>层次路由-产生原因</h6><p>$\quad$ 现实情况：</p><p>$\quad$ $\quad$ 地址分配往往是不连续的，难以进行高效的地址聚合</p><p>$\quad$ $\quad$ 每个网络的网络管理员有自己的管理方法和思路，并不希望每个路由器都干涉本网络内部的地址分配等问题</p><p>$\quad$ 层次路由可以解决：</p><p>$\quad$ $\quad$ 网络扩展性问题：当网络扩大时，控制路由表条目和路由表存储空间的增长</p><p>$\quad$ $\quad$ 管理的自治问题：网络管理员可以控制和管理自己网络的路由，不需要连续地址空间</p><h6 id="层次路由-基本思路"><a href="#层次路由-基本思路" class="headerlink" title="层次路由-基本思路"></a>层次路由-基本思路</h6><p>$\quad$ 互联网由大量不同的网络互连，每个管理机构控制的网络是自治的</p><p>$\quad$ 自治系统（AS，Autonomous System）</p><p>$\quad$ $\quad$ 一个管理机构控制之下的网络</p><p>$\quad$ $\quad$ 一个AS内部通常使用相同的路由算法&#x2F;路由协议，使用统一的路由度量（跳数、带宽、时延 …）</p><p>$\quad$ $\quad$ 不同的AS可以使用不同的路由算法&#x2F;路由协议</p><p>$\quad$ $\quad$ 每个AS有一个全球唯一的ID号：AS ID</p><p>$\quad$ 自治系统内的还可以进一步划分层次</p><p>$\quad$ 自治系统内部使用内部网关路由协议，Interior Gateway Protocols (IGP)</p><p>$\quad$ $\quad$ 每个自治系统域内路由算法可不同</p><p>$\quad$ $\quad$ 典型IGP协议：OSPF，RIP，IS-IS，IGRP，EIGRP……</p><p>$\quad$ 自治系统之间之间使用外部网关路由协议，Exterior Gateway Protocols (EGP)</p><p>$\quad$ $\quad$ 各自治系统域之间的路由需统一</p><p>$\quad$ $\quad$ 典型EGP协议：BGP</p><h6 id="层次路由-效果"><a href="#层次路由-效果" class="headerlink" title="层次路由-效果"></a>层次路由-效果</h6><p><img src="/../CNP/CN1120.png"></p><h4 id="AS内部路由：OSPF（对应链路状态算法）、RIP（对应距离向量算法）"><a href="#AS内部路由：OSPF（对应链路状态算法）、RIP（对应距离向量算法）" class="headerlink" title="AS内部路由：OSPF（对应链路状态算法）、RIP（对应距离向量算法）"></a>AS内部路由：OSPF（对应链路状态算法）、RIP（对应距离向量算法）</h4><h5 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h5><p>$\quad$ OSPF（Open Shortest Path First）开放最短路径优先协议于1989 年开发</p><p>$\quad$ 采用分布式的链路状态算法</p><p><img src="/../CNP/CN1121.png"></p><p>$\quad$ OSPF协议的基本思想</p><p>$\quad$ $\quad$ 向本自治系统中所有路由器洪泛信息</p><p>$\quad$ $\quad$ 发送的信息：与本路由器相邻的所有路由器的链路状态</p><p>$\quad$ $\quad$ 只有当链路状态发生变化时路由器才用洪泛法发送此信息</p><h6 id="区域"><a href="#区域" class="headerlink" title="区域"></a>区域</h6><p>$\quad$ OSPF将AS内路由器进一步划分为区域</p><p>$\quad$ $\quad$ 一个区域是一组路由器及它们内部链路构成的子图(subgraph)</p><p>$\quad$ 区域内部同步完整的区域内链路，区域之间只同步区域间链路</p><p>$\quad$ 使用层次结构的区域划分，上层的区域叫做主干区域 (backbone area)，其他区域都必须与主干区域相连</p><p>$\quad$ 非主干区域之间不允许直接发布区域间路由信息</p><p>$\quad$ 区域也不能太大，在一个区域内的路由器最好不超过 200 个</p><p>$\quad$ 划分区域可以缩小链路状态传输规模，减少网络流量</p><p><img src="/../CNP/CN1122.png"></p><h6 id="链路状态同步"><a href="#链路状态同步" class="headerlink" title="链路状态同步"></a>链路状态同步</h6><p>$\quad$ “链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的“度量”(metric)</p><p>$\quad$ $\quad$ OSPF度量值一般包括费用、距离、时延、带宽等</p><p>$\quad$ 由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个链路状态数据库LSDB</p><p>$\quad$ LSDB数据库：区域内的拓扑结构图，它在区域内是一致的</p><p>$\quad$ $\quad$ 区域：AS进一步划分后的路由器子集</p><p>$\quad$ $\quad$ 数据库条目：Link State Advertisement，LSA</p><p>$\quad$ $\quad$ 链路状态数据库的同步：所有路由器数据库达成一致的过程</p><h6 id="邻居状态机"><a href="#邻居状态机" class="headerlink" title="邻居状态机"></a>邻居状态机</h6><p>$\quad$ 两个相邻路由器的关系分为两种</p><p>$\quad$ $\quad$ 邻居（neighboring)</p><p>$\quad$ $\quad$ 完全邻接（adjacent）</p><p>$\quad$ 邻居</p><p>$\quad$ $\quad$ 互相知道存在链路相连</p><p>$\quad$ $\quad$ 由hello报文发现</p><p>$\quad$ 完全邻接</p><p>$\quad$ $\quad$ 路由状态数据库完成同步</p><p>$\quad$ $\quad$ 并非所有的邻居关系都是邻接关系</p><p>$\quad$ OSPF：通过一系列报文交互，为相邻路由器最终确立完全邻接关系</p><h6 id="五种报文"><a href="#五种报文" class="headerlink" title="五种报文"></a>五种报文</h6><p>$\quad$ Hello 报文</p><p>$\quad$ $\quad$ 最常用的一种报文，用于发现、维护邻居关系</p><p>$\quad$ 数据库描述（Database Description, DD）报文</p><p>$\quad$ $\quad$ 用于描述自己的LSDB</p><p>$\quad$ $\quad$ 内容包括LSDB 中每一条LSA 的Header 头部，对端路由器根据LSA Header 就可以判断出是否已有这条LSA</p><p>$\quad$ 链路状态请求（LSA Request, LSR）报文</p><p>$\quad$ $\quad$ 用于请求缺少的LSA，内容包括所需要的LSA 的摘要</p><p>$\quad$ 链路状态更新（LSA Update, LSU）报文</p><p>$\quad$ $\quad$ 用于向对端路由器发送所需要的LSA, 内容是多条LSA（全部内容）的集合</p><p>$\quad$ 链路状态确认（Link State Acknowledgment, LSACK）报文</p><p>$\quad$ $\quad$ 用来对接收到的LSU 报文进行确认</p><h6 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h6><p><img src="/../CNP/CN1123.png"></p><h6 id="报文交互"><a href="#报文交互" class="headerlink" title="报文交互"></a>报文交互</h6><p>$\quad$ 目的：发现邻居（邻居状态）+ 数据库同步（完全邻接状态）</p><p>$\quad$ 交互过程可以用状态机描述</p><p><img src="/../CNP/CN1124.png"></p><p>$\quad$ 发现邻居</p><p>$\quad$ $\quad$ 使用HELLO报文</p><p>$\quad$ $\quad$ 试图建立邻居关系</p><p>$\quad$ $\quad$ 最终，完成一对路由器间邻居关系的建立（Init状态）</p><p><img src="/../CNP/CN1126.png"></p><p>$\quad$ Exchange状态：交换数据库描述</p><p>$\quad$ $\quad$ 交换时，选择一个服务器为Master，另一个为Slave</p><p>$\quad$ $\quad$ 以Master的序列号为准</p><p>$\quad$ $\quad$ DD报文包含LSA的头部信息，用来描述LSDB的摘要信息</p><p>$\quad$ Loading状态：同步数据库内容，建立完全邻接关系</p><p>$\quad$ $\quad$ LSR用于向对方请求所需的LSA</p><p>$\quad$ $\quad$ LSU用于向对方发送其所需要的LSA</p><p>$\quad$ $\quad$ LSACK用于向对方发送收到LSA的确认</p><p>$\quad$ Full状态：完全邻接关系建立完毕</p><p><img src="/../CNP/CN1125.png"></p><h6 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h6><p>$\quad$ OSPF的特点：适合大型网络</p><p>$\quad$ $\quad$ 支持无类域间路由（CIDR）</p><p>$\quad$ $\quad$ 无路由自环</p><p>$\quad$ $\quad$ 收敛速度快</p><p>$\quad$ $\quad$ 支持多条等值路由</p><p>$\quad$ $\quad$ 计算、存储开销大（Dijkstra算法、LSDB数据库）</p><h5 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h5><p>$\quad$ 路由选择协议RIP（ Routing Information Protocol）是基于距离矢量算法的协议</p><p>$\quad$ 使用跳数衡量到达目的网络的距离</p><p>$\quad$ $\quad$ RIP 认为一个好的路由就是它通过的路由器的数目少，即“距离短”</p><p>$\quad$ $\quad$ RIP 一条路径最多只能包含 15 个路由器</p><p>$\quad$ RIP协议的基本思想</p><p>$\quad$ $\quad$ 仅和相邻路由器交换信息</p><p>$\quad$ $\quad$ 路由器交换的内容是自己的路由表</p><p>$\quad$ $\quad$ 周期性更新：30s</p><h6 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h6><p><img src="/../CNP/CN1127.png"></p><p><img src="/../CNP/CN1128.png"></p><h6 id="报文格式-1"><a href="#报文格式-1" class="headerlink" title="报文格式"></a>报文格式</h6><p><img src="/../CNP/CN1129.png"></p><h6 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h6><p>$\quad$ RIP协议的特点</p><p>$\quad$ $\quad$ 算法简单，易于实现</p><p>$\quad$ $\quad$ 收敛慢</p><p>$\quad$ $\quad$ 需要交换的信息量较大</p><p>$\quad$ RIP协议的适用场合</p><p>$\quad$ $\quad$ 中小型网络</p><p>$\quad$ RIP协议的防环路机制</p><p>$\quad$ $\quad$ 毒性反转</p><p>$\quad$ $\quad$ 水平分割</p><p>$\quad$ $\quad$ 其他</p><h4 id="AS之间路由：BGP"><a href="#AS之间路由：BGP" class="headerlink" title="AS之间路由：BGP"></a>AS之间路由：BGP</h4><h6 id="AS之间路由要解决的问题"><a href="#AS之间路由要解决的问题" class="headerlink" title="AS之间路由要解决的问题"></a>AS之间路由要解决的问题</h6><p>$\quad$ 规模问题</p><p>$\quad$ $\quad$ 全球AS数量：5万+</p><p>$\quad$ $\quad$ AS路由器数量：百万级别</p><p>$\quad$ $\quad$ 仍在增长</p><p>$\quad$ 策略问题</p><p>$\quad$ $\quad$ 各个AS认可的链路代价不一致</p><p>$\quad$ $\quad$ 每个AS：不仅决定将流量发往何处，还需考虑哪些流量可以发到自身（然后转发）</p><p>$\quad$ AS内路由不可行</p><p>$\quad$ $\quad$ 链路状态算法、距离向量算法：基于最短路</p><p>$\quad$ $\quad$ $\quad$ AS之间，“最短”缺乏共识定义</p><p>$\quad$ $\quad$ 计算开销</p><p>$\quad$ $\quad$ $\quad$ 链路状态：维护全网拓扑、计算全网最短路</p><p>$\quad$ $\quad$ $\quad$ 距离向量：收敛时间长</p><h5 id="BGP-网关路由协议"><a href="#BGP-网关路由协议" class="headerlink" title="BGP-网关路由协议"></a>BGP-网关路由协议</h5><p>$\quad$ 路由协议</p><p>$\quad$ $\quad$ 内部网关协议 IGP： 有 RIP 和、OSPF、ISIS 等多种具体的协议</p><p>$\quad$ $\quad$ 外部网关协议 EGP：目前使用的协议就是 BGP</p><p>$\quad$ 边界网关协议BGP (Border Gateway Protocol)</p><p>$\quad$ $\quad$ 目前互联网中唯一实际运行的自治域间的路由协议</p><p>$\quad$ BGP功能</p><p>$\quad$ $\quad$ eBGP：从相邻的AS获得网络可达信息</p><p>$\quad$ $\quad$ iBGP： 将网络可达信息传播给AS内的路由器</p><p>$\quad$ $\quad$ 基于网络可达信息和策略决定到其他网络的“最优”路由</p><h6 id="eBGP-amp-iBGP连接"><a href="#eBGP-amp-iBGP连接" class="headerlink" title="eBGP&amp;iBGP连接"></a>eBGP&amp;iBGP连接</h6><p><img src="/../CNP/CN1130.png"></p><h6 id="路径通告"><a href="#路径通告" class="headerlink" title="路径通告"></a>路径通告</h6><p>$\quad$ BGP路由器之间建立TCP连接，通告路径：</p><p>$\quad$ BGP会话: 两个BGP路由器通过TCP连接交换BGP报文</p><p>$\quad$ $\quad$ 通告到不同网络前缀的路径，即路径向量协议</p><p>$\quad$ 路径向量：由一系列AS组成的序列</p><p>$\quad$ $\quad$ 例：当AS3的路由器3a向AS2的路由器2c通告路径”AS3, X”时，AS3向AS2承诺它会向X转发数据包</p><p><img src="/../CNP/CN1131.png"></p><p><img src="/../CNP/CN1132.png"></p><p><img src="/../CNP/CN1133.png"></p><p>$\quad$ 一个路径通告信息经过的结点数是自治系统数的量级</p><p>$\quad$ 每一个自治系统边界路由器的数目是很少的</p><p>$\quad$ 一个AS在BGP刚刚运行时，向相邻AS获取整个BGP路由表</p><p>$\quad$ $\quad$ 以后只需要在发生变化时更新有变化的部分</p><p>$\quad$ BGP为每个AS提供：</p><p>$\quad$ $\quad$ 从邻居AS获取网络可达信息 ( eBGP协议 )</p><p>$\quad$ $\quad$ 传播可达信息给所有的域内路由器 ( iBGP协议 )</p><p>$\quad$ $\quad$ 根据“可达信息”和“策略”决定路由</p><h6 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h6><p>$\quad$ BGP通过TCP的179端口进行路径通告</p><p>$\quad$ BGP报文包括</p><p>$\quad$ $\quad$ Open报文：用于建立BGP对等体（peer）之间的会话连接，协商BGP参数（该过程需要认证）</p><p>$\quad$ $\quad$ Update报文：通告&#x2F;撤销路径</p><p>$\quad$ $\quad$ Keepalive报文：用于保持BGP会话连接</p><p>$\quad$ $\quad$ Notification报文：用于差错报告和关闭BGP连接</p><h6 id="路径属性"><a href="#路径属性" class="headerlink" title="路径属性"></a>路径属性</h6><p>$\quad$ BGP路径：路径前缀（目的网络）+属性</p><p>$\quad$ 两个重要属性</p><p>$\quad$ $\quad$ AS路径（AS-PATH）：想要到达某个目的网络，需要经过的所有AS号；如：AS 67, AS 17</p><p>$\quad$ $\quad$ 下一跳（NEXT-HOP）：说明路由信息对应的下一跳IP地址</p><p>$\quad$ 网关路由器接收到路由通告时，通过既定策略采纳或拒绝(accept&#x2F; decline)</p><h6 id="转发表"><a href="#转发表" class="headerlink" title="转发表"></a>转发表</h6><p><img src="/../CNP/CN1134.png"></p><h6 id="路由策略"><a href="#路由策略" class="headerlink" title="路由策略"></a>路由策略</h6><p>$\quad$ 路由器可能从多个对等体收到针对同一目的IP的路由</p><p>$\quad$ 需要选择一条最佳路由</p><p>$\quad$ 选择规则：自上向下，依次排序</p><p>$\quad$ $\quad$ 本地偏好值属性：政策决策</p><p>$\quad$ $\quad$ 最短的AS-PATH</p><p>$\quad$ $\quad$ 最近的NEXT-HOP路由器</p><p>$\quad$ $\quad$ 附加标准…</p><p>$\quad$ $\quad$ 最低路由器ID</p><p><strong>AS间策略</strong></p><p>$\quad$ 路由器使用策略决定接受或拒绝接收到的路由通告</p><p>$\quad$ 路由器也会基于策略决定是否向其他相邻AS通告路径信息</p><p>$\quad$ 例如：X连接到两个提供者网络（dual-homed）</p><p><img src="/../CNP/CN1135.png"></p><p>$\quad$ $\quad$ X为用户网络，X不希望从B到C的数据包经过X</p><p>$\quad$ $\quad$ X则不向B通告到C的路由</p><p>$\quad$ $\quad$ A向B通告路径AW</p><p>$\quad$ $\quad$ B通告到目的W的路径为BAW</p><p>$\quad$ $\quad$ B是否向C通告路径BAW</p><p>$\quad$ $\quad$ $\quad$ 由于W和C都不是B的用户，B要迫使C通过A路由到W</p><p>$\quad$ $\quad$ $\quad$ B只路由来自于或到达其用户的数据包</p><p><strong>AS内策略</strong></p><p>$\quad$ 各个AS决定</p><p>$\quad$ 实际常用：“热土豆（Hot Potato)策略”</p><p>$\quad$ $\quad$ 选择最近的BGP出口，即最小化报文在本AS停留时间</p><h4 id="其他路由技术"><a href="#其他路由技术" class="headerlink" title="其他路由技术"></a>其他路由技术</h4><h5 id="广播路由"><a href="#广播路由" class="headerlink" title="广播路由"></a>广播路由</h5><p>$\quad$ 广播（Broadcasting）：源主机同时给全部目标地址发送同一个数据包</p><p>$\quad$ 例：服务器希望将视频广播给3个网络中的所有30个用户，有哪些办法？</p><h6 id="方法1：给每个主机单独发送一个数据包"><a href="#方法1：给每个主机单独发送一个数据包" class="headerlink" title="方法1：给每个主机单独发送一个数据包"></a>方法1：给每个主机单独发送一个数据包</h6><p>$\quad$ 效率低、浪费带宽</p><p>$\quad$ Server需要知道每个目的地址</p><h6 id="方法2：多目标路由（multi-destination-routing）"><a href="#方法2：多目标路由（multi-destination-routing）" class="headerlink" title="方法2：多目标路由（multi-destination routing）"></a>方法2：多目标路由（multi-destination routing）</h6><p>$\quad$ 在需要转发的路由器线路复制一次该数据报</p><p>$\quad$ 网络利用率高</p><p>$\quad$ Server依然需要知道所有的目的地址</p><h6 id="方法3：泛洪（flooding）"><a href="#方法3：泛洪（flooding）" class="headerlink" title="方法3：泛洪（flooding）"></a>方法3：泛洪（flooding）</h6><p>$\quad$ 一种将数据包发送到所有网络节点的简单方法</p><p>$\quad$ 将每个进入数据包发送到除了进入线路外的每条出去线路</p><p>$\quad$ 用途</p><p>$\quad$ $\quad$ 保证性：一种有效广播手段，可确保数据包被传送到网络中每个节点</p><p>$\quad$$\quad$ 容错性：即使大量路由器被损坏，也能找到一条路径（如果存在）</p><p>$\quad$ $\quad$ 简单性：仅需知道自己的邻居</p><p>$\quad$ <strong>无控制的泛洪</strong></p><p>$\quad$ $\quad$ 实现广播最显而易见的技术</p><p>$\quad$ $\quad$ 环路可能导致广播风暴</p><p>$\quad$ $\quad$ 路由器可能收到多个副本</p><p>$\quad$ $\quad$ 节点需要跟踪已泛洪的数据包以阻止洪泛</p><p>$\quad$ $\quad$ 即使利用跳数来限制，也会出现成倍爆炸</p><p><img src="/../CNP/CN1136.png"></p><p>$\quad$ <strong>受控制的泛洪（每个路由器进行有选择的泛洪）</strong></p><p>$\quad$ $\quad$ <em>序号控制泛洪（sequence-number-controlled flooding）</em></p><p>$\quad$ $\quad$ $\quad$ 广播数据包X从接口1到达路由器R</p><p>$\quad$ $\quad$ $\quad$ R查看数据包来源S和广播序号n，比对R的序号表</p><p>$\quad$ $\quad$ $\quad$ 序号表中有该数据包的记录吗？</p><p>$\quad$ $\quad$ $\quad$ $\quad$ 是，丢弃（曾经已经收到并转发过）</p><p>$\quad$ $\quad$ $\quad$ $\quad$ 否，在序号表中记录，并在接口2和3转发</p><p><img src="/../CNP/CN1137.png"></p><p>$\quad$ $\quad$ <em>逆向路径转发(reverse path forwarding, RPF)</em></p><p>$\quad$ $\quad$ $\quad$ 假设R的路由表中表示了到达各网络的最优路径</p><p>$\quad$ $\quad$ $\quad$ 广播数据包X从接口1到达路由器R</p><p>$\quad$ $\quad$ $\quad$ R查看数据包来源S，比对R的路由表</p><p>$\quad$ $\quad$ $\quad$ X的来源是N1吗？</p><p>$\quad$ $\quad$ $\quad$ $\quad$ 是 -&gt; X是从最佳路径来的，向接口2和接口3转发</p><p>$\quad$ $\quad$ $\quad$ $\quad$ 否 -&gt; X是重复包，丢弃</p><p><img src="/../CNP/CN1138.png"></p><h6 id="方法4-生成树"><a href="#方法4-生成树" class="headerlink" title="方法4:生成树"></a>方法4:生成树</h6><p>$\quad$ 源节点向所有属于该生成树的特定链路发送分组</p><p>$\quad$ 改进了逆向路径转发</p><p>$\quad$ 没有环路</p><p>$\quad$ 最佳使用带宽</p><p>$\quad$ 最少副本，消除了冗余分组</p><p>$\quad$ 一个路由器可以不必知道整颗树，只需要知道在一颗树中的邻居即可</p><p><img src="/../CNP/CN1139.png"></p><h5 id="组播路由"><a href="#组播路由" class="headerlink" title="组播路由"></a>组播路由</h5><p>$\quad$ 组播（multicasting）：源主机给网络中的一部分目标用户发送数据包</p><p>$\quad$ 组播（multicasting）路由算法的目标：</p><p>$\quad$ $\quad$ 为每个组建立转发树（到达该组所有成员的路径树）</p><p>$\quad$ $\quad$ 每个组成员应当只收到多播分组的一个拷贝</p><p>$\quad$ $\quad$ 非本组成员不应收到多播分组</p><p>$\quad$ $\quad$ 从源节点到每一个组成员节点的路径应当是最佳的（最短路径</p><p><img src="/../CNP/CN1140.png"></p><h6 id="步骤1："><a href="#步骤1：" class="headerlink" title="步骤1："></a>步骤1：</h6><p>$\quad$ 确定组成员边缘路由器通过与主机交互，了解到从它的某个端口可以到达哪些组的成员——主机与路由器之间的组成员关系协议</p><p>$\quad$ IGMP (Internet Group Management Protocol）</p><p>$\quad$ $\quad$ 主机可以加入或者退出组播组</p><p>$\quad$ $\quad$ 路由器查询该子网的组播组成员</p><p><img src="/../CNP/CN1141.png"></p><p><img src="/../CNP/CN1142.png"></p><h6 id="步骤2：生成树"><a href="#步骤2：生成树" class="headerlink" title="步骤2：生成树"></a>步骤2：生成树</h6><p>$\quad$ 建立在我们已经学习过的广播路由方案基础之上</p><p>$\quad$ 数据包沿生成树发送</p><p>$\quad$ 源点树：为每个组播源计算生成树</p><p>$\quad$ $\quad$ 构建源点树协议： MOSPF、 DVMRP、 PIM-DM</p><p>$\quad$ $\quad$ 基于源点树（source-based trees）存在的问题：</p><p>$\quad$ $\quad$ $\quad$ 大型网络中，组播源很多时，路由器需生成多颗棵树，工作量巨大</p><p>$\quad$ $\quad$ $\quad$ 路由器需要大量空间来存储多颗树</p><p><img src="/../CNP/CN1143.png"></p><p>$\quad$ 核心树：多个组播源共享组成共享树</p><p>$\quad$ $\quad$ 选择一部分结点作为核心，所有流量先汇聚到核心，再进行分发</p><p>$\quad$ $\quad$ 实线为核心树实际使用的链路，虚线为没有用到的链路</p><p>$\quad$ $\quad$ 存在的问题：</p><p>$\quad$ $\quad$ $\quad$ 可能无法达到最优</p><p>$\quad$ $\quad$ $\quad$ 如果只有一个发送者，将发送者作为核心是最优的</p><p><img src="/../CNP/CN1145.png"></p><h6 id="应用部署"><a href="#应用部署" class="headerlink" title="应用部署"></a>应用部署</h6><p><img src="/../CNP/CN1146.png"></p><h5 id="选播路由"><a href="#选播路由" class="headerlink" title="选播路由"></a>选播路由</h5><p>$\quad$ 将数据包传送给最近的一个组成员</p><p>$\quad$ 在有多个服务器的情况下，用户希望快速获得正确信息，而不在乎从哪个服务器获得</p><p>$\quad$ 与单播、广播、组播的区别</p><p><img src="/../CNP/CN1147.png">Ø$\quad$ 选播的典型应用：DNS</p><p>$\quad$ $\quad$ 在没有指定DNS服务器的情况下，用户将始终连接到“最接近”(从路由协议角度来看) 服务器，可以减少延迟，并提供一定程度的负载平衡</p><p>$\quad$ $\quad$ 可以提供一定程度的高可用性，一旦服务器发生故障，用户请求将无缝转发到下一个最接近的DNS实例，而无需任何手动干预或重新配置</p><p>$\quad$ $\quad$ 可以水平缩放，如果一台服务器负载过重，只需在一个位置部署另一台服务器，以承担一部分重载服务器的请求，且不需要客户端配置</p><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>CN</category>
      
      <category>网络层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CN</tag>
      
      <tag>网络层</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络层 - 网络层协议</title>
    <link href="/2023/11/16/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/"/>
    <url>/2023/11/16/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E7%BD%91%E7%BB%9C%E5%B1%82%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<p> 对应 北京大学计算机网络课程第四讲第二部分<br> 参考教材计算机网络-自顶向下方法</p><span id="more"></span><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="网络层-网络协议"><a href="#网络层-网络协议" class="headerlink" title="网络层-网络协议"></a>网络层-网络协议</h2><h6 id="IP协议功能及报头字段"><a href="#IP协议功能及报头字段" class="headerlink" title="IP协议功能及报头字段"></a>IP协议功能及报头字段</h6><p>$\quad$ 网络层基本功能<br>$\quad$ $\quad$ 支持多跳寻路将IP数据报送达目的端：目的IP地址<br>$\quad$ $\quad$ 表明发送端身份：源IP地址<br>$\quad$ $\quad$ 根据IP头部协议类型，提交给不同上层协议处理：协议<br>$\quad$ 其它相关问题<br>$\quad$ $\quad$ 数据报长度大于传输链路的MTU的问题，通过分片机制解决：标识、标志、片偏移<br>$\quad$ $\quad$ 防止循环转发浪费网络资源（路由错误、设备故障…），通过跳数限制解决：生存时间TTL<br>$\quad$ $\quad$ IP报头错误导致无效传输，通过头部机校验解决：首部校验和</p><h3 id="IPV4-协议"><a href="#IPV4-协议" class="headerlink" title="IPV4 协议"></a>IPV4 协议</h3><p>$\quad$ IPv4协议（网际协议版本4），一种无连接的协议，是互联网的核心，也是使用最广泛的网际协议版本，其后继版本为IPv6<br>$\quad$ internet协议执行两个基本功能<br>$\quad$ $\quad$ 寻址(addressing)<br>$\quad$ $\quad$ $\quad$ 用于路由与转发<br>$\quad$ $\quad$ 分片(fragmentation)</p><h5 id="IPV4-数据报格式"><a href="#IPV4-数据报格式" class="headerlink" title="IPV4 数据报格式"></a>IPV4 数据报格式</h5><p>$\quad$ 版本： 4bit ，表示采用的IP协议版本<br>$\quad$ 首部长度： 4bit，表示整个IP数据报首部的长度<br>$\quad$ 区分服务： 8bit ，该字段一般情况下不使用<br>$\quad$ 总长度： 16bit ，表示整个IP报文的长度,能表示的最大字节为2^16-1&#x3D;65535字节<br>$\quad$ 标识： 16bit ， IP软件通过计数器自动产生，每产生1个数据报计数器加1；在ip分片以后，用来标识同一片分片<br>$\quad$ 标志： 3bit，目前只有两位有意义； MF，置1表示后面还有分片，置0表示这是数据报片的最后1个；DF，不能分片标志，置0时表示允许分片<br>$\quad$ 片偏移： 13bit，表示IP分片后，相应的IP片在总的IP片的相对位置<br>$\quad$ 生存时间TTL(Time To Live) ：8bit,表示数据报在网络中的生命周期，用通过路由器的数量来计量，即跳数（每经过一个路由器会减1）<br>$\quad$ 协议：8bit，标识上层协议（TCP&#x2F;UDP&#x2F;ICMP…）<br>$\quad$ 首部校验和：16bit ，对数据报首部进行校验，不包括数据部分<br>$\quad$ 源地址：32bit，标识IP片的发送源IP地址<br>$\quad$ 目的地址：32bit，标识IP片的目的地IP地址<br>$\quad$ 选项：可扩充部分，具有可变长度，定义了安全性、严格源路由、松散源路由、记录路由、时间戳等选项<br>$\quad$ 填充：用全0的填充字段补齐为4字节的整数倍<br><img src="/../CNP/CN1001.png"></p><h6 id="数据报分片"><a href="#数据报分片" class="headerlink" title="数据报分片"></a>数据报分片</h6><p>$\quad$ MTU（Maximum Transmission Unit）, 最大传输单元<br>$\quad$ $\quad$ 链路MTU<br>$\quad$ $\quad$ 路径MTU (Path MTU)<br>$\quad$ 分片策略<br>$\quad$ $\quad$ 允许途中分片：根据下一跳链路的MTU实施分片<br>$\quad$ $\quad$ 不允许途中分片：发出的数据报长度小于路径MTU（路径MTU发现机制）<br>$\quad$ 重组策略<br>$\quad$ $\quad$ 途中重组，实施难度太大<br>$\quad$ $\quad$ 目的端重组（Internet采用的策略）<br>$\quad$ $\quad$ 重组所需信息：原始数据报编号、分片偏移量、是否收集所有分片<br><img src="/../CNP/CN1002.png"><br>$\quad$ IPv4分组在传输途中可以多次分片<br>$\quad$ $\quad$ 源端系统，中间路由器<br>$\quad$ 无论是否途中分片，IPv4分片只在目的IP对应的目的端系统进行重组<br>$\quad$ IPv6分片机制有较大变化（见IPv6部分的介绍）</p><h5 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h5><p>$\quad$ IP地址：网络上的每一台主机（或路由器）的每一个接口都会分配一个唯一的32位的标识符<br>$\quad$ 由两个字段组成：网络号（网络地址）+主机号（主机地址）<br>$\quad$ 网络号相同的这块连续IP地址空间称为地址的前缀，或网络前缀</p><h6 id="网络地址"><a href="#网络地址" class="headerlink" title="网络地址"></a>网络地址</h6><p>$\quad$ 接口(interface)：连接主机&#x2F;路由器与物理链路之间的模块<br>$\quad$ $\quad$ 路由器由多个接口<br>$\quad$ $\quad$ 每个主机通常有1-2个接口<br>$\quad$ IP地址按接口分配<br>$\quad$ 接口之间通过链路层技术互相连接<br><img src="/../CNP/CN1003.png"></p><h6 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h6><p>$\quad$ IP地址的书写采用点分十进制记法，其中每一段取值范围为0到255<br>$\quad$ IP地址 &#x3D; 网络地址 + 主机号<br>$\quad$ $\quad$ 子网掩码(subnet mask )，与 IP 地址一一对应，是32 bit 的二进制数，置1表示网络位，置0表示主机位<br>$\quad$ 子网：有相同网络地址的网络接口<br>$\quad$ $\quad$ 子网内的接口可以不需要网络层路由就可以进行数据传输<br>$\quad$ $\quad$ 通过链路层技术<br>$\quad$ 子网划分将一个网络块进行划分以供多个内部网络使用<br>$\quad$ 子网划分使得网络的组织更加灵活、便于维护和管理<br>$\quad$ 子网由接口组成，与主机&#x2F;路由器等设备无关<br>$\quad$ $\quad$ 一个子网内的接口，可能来自不同设备<br>$\quad$ $\quad$ 一个设备的多个接口，可能属于不同子网<br><img src="/../CNP/CN1005.png"></p><h6 id="特殊IP地址"><a href="#特殊IP地址" class="headerlink" title="特殊IP地址"></a>特殊IP地址</h6><p><img src="/../CNP/CN1004.png"></p><h6 id="网络地址任意长度：无类域间路由"><a href="#网络地址任意长度：无类域间路由" class="headerlink" title="网络地址任意长度：无类域间路由"></a>网络地址任意长度：无类域间路由</h6><p>$\quad$ CIDR（Classless Inter-Domain Routing ）<br>$\quad$ $\quad$ 网络地址可以是任意长度<br>$\quad$ $\quad$ 表示：将32位的IP地址划分为前后两个部分，并采用斜线记法，即在IP地址后加上“&#x2F;”，然后再写上网络前缀所占位数</p><p><img src="/../CNP/CN1006.png"><br>$\quad$ CIDR子网内的地址，可以进一步划分为多个子网<br>$\quad$ $\quad$ 对外只暴露1个CIDR网络地址<br>$\quad$ $\quad$ 这种地址的聚合常称为地址聚合（address aggregation）或路由聚合（route aggregation）<br> $\quad$ $\quad$ 子网可以无需更改地址进行迁移<br><img src="/../CNP/CN1009.png"></p><h6 id="网络地址固定长度：分类编址"><a href="#网络地址固定长度：分类编址" class="headerlink" title="网络地址固定长度：分类编址"></a>网络地址固定长度：分类编址</h6><p>$\quad$ 与无类域间相对：网络地址长度固定<br>$\quad$ IP地址共分为A、B、C、D、E五类，A类、B类、C类为单播地址<br><img src="/../CNP/CN1007.png"><br><img src="/../CNP/CN1008.png"></p><h6 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h6><p> $\quad$ 最长前缀匹配（Longest prefix match）<br>$\quad$ $\quad$ CIDR+路由聚合，需要最长前缀匹配<br>$\quad$ 即IP地址与IP前缀匹配时，总是选取子网掩码最长的匹配项<br>$\quad$ 主要用于路由器转发表项的匹配，也应用于ACL规则匹配等</p><h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><h6 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h6><p><img src="/../CNP/CN1010.png"><br><img src="/../CNP/CN1011.png"></p><h4 id="IP包转发"><a href="#IP包转发" class="headerlink" title="IP包转发"></a>IP包转发</h4><h5 id="直接交付（子网内转发）："><a href="#直接交付（子网内转发）：" class="headerlink" title="直接交付（子网内转发）："></a>直接交付（子网内转发）：</h5><p>$\quad$ 与目的主机在同一个IP子网内（使用目的MAC地址）<br>$\quad$ $\quad$ 通过ARP协议获取子网内IP-MAC映射<br><img src="/../CNP/CN1012.png"><br>$\quad$ IP数据包转发：从主机A到主机B<br>$\quad$ $\quad$ 检查目的IP地址的网络号部分<br>$\quad$ $\quad$ 确定主机B与主机A属相同IP网络<br>$\quad$ $\quad$ 将IP数据包封装到链路层帧中，直接发送给主机B<br>$\quad$ $\quad$ $\quad$ 封装时，在帧头部填写A与B的MAC地址</p><h6 id="ARP地址解析"><a href="#ARP地址解析" class="headerlink" title="ARP地址解析"></a>ARP地址解析</h6><p>$\quad$ A已知B的IP地址，需要获得B的MAC地址（物理地址）<br>$\quad$ 如果A的ARP表中缓存有B的IP地址与MAC地址的映射关系，则直接从ARP表获取<br>$\quad$ 如果A的ARP表中未缓存有B的IP地址与MAC地址的映射关系，则A广播包含B的IP地址的ARP query分组<br>$\quad$ $\quad$ 在局域网上的所有节点都可以接收到ARP query<br>$\quad$ B接收到ARP query分组后，将自己的MAC地址发送给A<br>$\quad$ A在ARP表中缓存B的IP地址和MAC地址的映射关系<br>$\quad$ $\quad$ 超时时删除</p><h6 id="ARP工作过程"><a href="#ARP工作过程" class="headerlink" title="ARP工作过程"></a>ARP工作过程</h6><p><img src="/../CNP/CN1014.png"></p><h5 id="间接交付（跨子网转发）："><a href="#间接交付（跨子网转发）：" class="headerlink" title="间接交付（跨子网转发）："></a>间接交付（跨子网转发）：</h5><p>$\quad$ 与目的主机不在同一个IP子网内（使用目的IP地址）<br><img src="/../CNP/CN1013.png"><br><img src="/../CNP/CN1015.png"></p><h4 id="ARP-安全问题"><a href="#ARP-安全问题" class="headerlink" title="ARP 安全问题"></a>ARP 安全问题</h4><p>$\quad$ ARP Spoofing攻击<br>$\quad$ $\quad$ 攻击者随意地发送ARP请求或ARP响应（可以使用任意源IP地址与MAC地址）<br>$\quad$ $\quad$ ARP协议是无状态的：即使受害者之前没发过ARP请求，收到一个ARP响应时，也会更新ARP表<br>$\quad$ $\quad$ $\quad$ 受害者后续数据将被发往攻击者提供的MAC地址<br>$\quad$ $\quad$ 攻击者可以修改自己的IP转发功能，将截获的受害者数据继续转发</p><h3 id="DHCP协议"><a href="#DHCP协议" class="headerlink" title="DHCP协议"></a>DHCP协议</h3><h6 id="IPv4地址如何获取"><a href="#IPv4地址如何获取" class="headerlink" title="IPv4地址如何获取"></a>IPv4地址如何获取</h6><p>$\quad$ 公有IP地址要求全球唯一<br>$\quad$ $\quad$ ICANN（Internet Corporation for Assigned Names and Numbers）即互联网名字与编号分配机构向ISP分配，ISP再向所属机构或组织逐级分配<br>$\quad$ 静态设定<br>$\quad$ $\quad$ 申请固定IP地址，手工设定，如路由器、服务器<br>$\quad$ 动态获取<br>$\quad$ $\quad$ 使用DHCP协议或其他动态配置协议<br>$\quad$ $\quad$ 当主机加入IP网络，允许主机从DHCP服务器动态获取IP地址<br>$\quad$ $\quad$ 可以有效利用IP地址，方便移动主机的地址获取<br>$\quad$ $\quad$ 也可以申请延长IP地址的占用</p><h6 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h6><p><img src="/../CNP/CN1016.png"></p><h6 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h6><p><img src="/../CNP/CN1017.png"></p><h6 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h6><p>$\quad$ DHCP 客户从UDP端口68以广播形式向服务器发送发现报文  (DHCP DISCOVER)<br>$\quad$ DHCP 服务器广播或单播发出提供报文（DHCP OFFER）<br>$\quad$ DHCP 客户从多个DHCP服务器中选择一个，并向其以广播形式发送DHCP请求报文（DHCP REQUEST）<br>$\quad$ 被选择的DHCP服务器广播或单播发送确认报文（DHCP ACK）<br><img src="/../CNP/CN1018.png"><br><img src="/../CNP/CN1019.png"><br><img src="/../CNP/CN1020.png"></p><h6 id="DHCP安全问题"><a href="#DHCP安全问题" class="headerlink" title="DHCP安全问题"></a>DHCP安全问题</h6><p>$\quad$ DHCP耗竭攻击（DHCP Starvation Attack）<br>$\quad$ $\quad$ 攻击者短时间内发送大量DHCP请求，将子网内可用IP地址全部占用<br>$\quad$ $\quad$ 后续主机无法获取新IP地址<br>$\quad$ 流氓DHCP（Rogue DHCP attack ）<br>$\quad$ $\quad$ （通常在DHCP耗竭攻击之后）<br>$\quad$ $\quad$ 攻击者启动自己的DHCP服务，给网络中的其他主机提供虚假的配置，包括DNS服务器IP与网关IP</p><h3 id="NAT协议"><a href="#NAT协议" class="headerlink" title="NAT协议"></a>NAT协议</h3><h6 id="网络地址转换"><a href="#网络地址转换" class="headerlink" title="网络地址转换"></a>网络地址转换</h6><p>$\quad$ 网络地址转换(NAT)用于解决IPv4地址不足的问题，是一种将私有（保留）地址转化为公有IP地址的转换技术<br>$\quad$ 私有IP地址：<br>$\quad$ $\quad$ A类地址：10.0.0.0–10.255.255.255<br>$\quad$ $\quad$ B类地址：172.16.0.0–172.31.255.555<br>$\quad$ $\quad$ C类地址：192.168.0.0–192.168.255.255<br>$\quad$ NAT根据不同的IP上层协议进行NAT表项管理<br>$\quad$ $\quad$ TCP，UDP<br>$\quad$ 传输层TCP&#x2F;UDP拥有16-bit 端口号字段<br>$\quad$ $\quad$ 所以一个WAN侧地址可支持60,000+个并行连接</p><h6 id="NAT的优势"><a href="#NAT的优势" class="headerlink" title="NAT的优势"></a>NAT的优势</h6><p>$\quad$ 节省合法地址，减少地址冲突<br>$\quad$ 灵活连接Internet<br>$\quad$ 保护局域网的私密性</p><h6 id="NAT工作机制"><a href="#NAT工作机制" class="headerlink" title="NAT工作机制"></a>NAT工作机制</h6><p><img src="/../CNP/CN1021.png"><br><img src="/../CNP/CN1022.png"></p><p>$\quad$ 出数据报：外出数据报用NAT IP地址(全局), 新port # 替代  源IP地址(私有), port #<br>$\quad$ NAT转换表：每个 (源IP地址, port #)到(NAT IP地址, 新port #) 映射项<br>$\quad$ 入数据报：对每个入数据报的地址字段用存储在NAT表中的(源IP地址, port #)替代对应的 (NAT IP地址, 新port #)<br><img src="/../CNP/CN1023.png"></p><h6 id="问题或缺点"><a href="#问题或缺点" class="headerlink" title="问题或缺点"></a>问题或缺点</h6><p>$\quad$ 违反了IP的结构模型，路由器处理传输层协议<br>$\quad$ 违反了端到端的原则<br>$\quad$ 违反了最基本的协议分层规则<br>$\quad$ 不能处理IP报头加密<br>$\quad$ 新型网络应用的设计者必须要考虑 NAT场景，如 P2P应用程序</p><h3 id="ICMP协议"><a href="#ICMP协议" class="headerlink" title="ICMP协议"></a>ICMP协议</h3><p>$\quad$ ICMP: 互联网控制报文协议<br>$\quad$ $\quad$ ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告<br>$\quad$ $\quad$ 由主机和路由器用于网络层信息的通信<br>$\quad$ $\quad$ ICMP 报文携带在IP 数据报中： IP上层协议号为1<br>$\quad$ ICMP报文类型<br>$\quad$ $\quad$ ICMP 差错报告报文<br>$\quad$ $\quad$ $\quad$ 终点不可达：不可达主机、不可达网络，无效端口、协议<br>$\quad$ $\quad$ ICMP 询问报文<br>$\quad$ $\quad$ $\quad$ 回送请求&#x2F;回答 (ping使用)</p><h6 id="ICMP报文格式"><a href="#ICMP报文格式" class="headerlink" title="ICMP报文格式"></a>ICMP报文格式</h6><p><img src="/../CNP/CN1024.png"></p><h6 id="报文类型"><a href="#报文类型" class="headerlink" title="报文类型"></a>报文类型</h6><p><img src="/../CNP/CN1025.png"><br><img src="/../CNP/CN1026.png"></p><h6 id="差错报告报文"><a href="#差错报告报文" class="headerlink" title="差错报告报文"></a>差错报告报文</h6><p><img src="/../CNP/CN1027.png"></p><h6 id="Ping"><a href="#Ping" class="headerlink" title="Ping"></a>Ping</h6><p>$\quad$ PING (Packet InterNet Groper)<br>$\quad$ $\quad$ PING 用来测试两个主机之间的连通性<br>$\quad$ $\quad$ PING 使用了 ICMP 回送请求与回送回答报文</p><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>CN</category>
      
      <category>网络层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CN</tag>
      
      <tag>网络层</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络层 - 基本概念，路由器</title>
    <link href="/2023/11/16/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%8C%E8%B7%AF%E7%94%B1%E5%99%A8/"/>
    <url>/2023/11/16/%E7%BD%91%E7%BB%9C%E5%B1%82%20-%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%8C%E8%B7%AF%E7%94%B1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p> 对应 北京大学计算机网络课程第四讲第一部分<br> 参考教材计算机网络-自顶向下方法</p><span id="more"></span><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="网络层-基本概念，路由器"><a href="#网络层-基本概念，路由器" class="headerlink" title="网络层 - 基本概念，路由器"></a>网络层 - 基本概念，路由器</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><img src="/../CNP/CN901.png"></p><h6 id="基本功能"><a href="#基本功能" class="headerlink" title="基本功能"></a>基本功能</h6><p>$\quad$ 网络层：主机-主机间数据传输可达</p><p>$\quad$ $\quad$ 发送端：将传输层数据单元封装在数据包中</p><p>$\quad$ $\quad$ 接收端：解析接收的数据包中，取出传输层数据单元，交付给传输层</p><p>$\quad$ 网络层的数据传输是多跳传输</p><p>$\quad$ $\quad$ 网络层功能存在每台主机和路由器中</p><p>$\quad$ $\quad$ 路由器：检查数据包首部，转发给下一跳（路由器或主机）</p><h5 id="服务模型"><a href="#服务模型" class="headerlink" title="服务模型"></a>服务模型</h5><p>$\quad$ 主机-主机多跳传输有多种服务模型可供选择</p><p>$\quad$ $\quad$ 网络层向传输层提供的接口类型？</p><p>$\quad$ $\quad$ $\quad$ “面向连接”(电路交换）OR“无连接“（分组交换）</p><p>$\quad$ $\quad$ 网络通信的可靠交付服务，谁来负责？</p><p>$\quad$ $\quad$ $\quad$ “网络”OR“端系统”</p><p>$\quad$ $\quad$ 服务质量保障？</p><p>$\quad$ $\quad$ $\quad$ “无保障”OR“性能保障”</p><p><img src="/../CNP/CN902.png"></p><h6 id="Internet-：无连接的数据报服务"><a href="#Internet-：无连接的数据报服务" class="headerlink" title="Internet ：无连接的数据报服务"></a>Internet ：无连接的数据报服务</h6><p>$\quad$ 无连接服务：如寄信</p><p>$\quad$ $\quad$ 不需要提前建立连接</p><p>$\quad$ 数据报服务</p><p>$\quad$ $\quad$ 网络层向上只提供简单灵活无连接的、尽最大努力交付的数据报服务</p><p>$\quad$ $\quad$ 发送分组时不需要先建立连接，每个分组独立发送</p><p>$\quad$ $\quad$ 数据报独立转发，相同源-目的的数据报可能经过不同的路径</p><p>$\quad$ $\quad$ 网络层不提供服务质量的承诺</p><p>$\quad$ 尽力而为交付</p><p>$\quad$ $\quad$ 传输网络不提供端到端的可靠传输服务：丢包、乱序、错误</p><p>$\quad$ $\quad$ 优点：网络的造价大大降低，运行方式灵活，能够适应多种应用</p><p>$\quad$ 数据报可能沿着不同的路径传输，减少网络不可靠带来的影响</p><p><img src="/../CNP/CN903.png"></p><p>$\quad$ 但这样可能会导致接收数据的失序；</p><p>$\quad$ 为避免增加额外的开销进行数据排序，网络并不会完全随意地发送数据，在大多数情况下，仍然是会尽量沿着某一条路径发送。</p><h5 id="网络层关键功能"><a href="#网络层关键功能" class="headerlink" title="网络层关键功能"></a>网络层关键功能</h5><p>$\quad$ 无论哪种网络层服务模型，都依赖于2个核心功能</p><p>$\quad$ 转发</p><p>$\quad$ $\quad$ 将数据报从路由器的输入接口传送到正确的输出接口</p><p>$\quad$ $\quad$ 核心：转发函数</p><p>$\quad$ $\quad$ 类比：旅行时穿过一个城市（城市内部各个车站、机场间移动）</p><p>$\quad$ 路由</p><p>$\quad$ $\quad$ 选择数据报从源端到目的端的路径</p><p>$\quad$ $\quad$ 核心：路由算法与协议</p><p>$\quad$ $\quad$ 类比：规划出发城市到目的城市的旅行路线（城市间移动）</p><h6 id="数据平面与控制平面"><a href="#数据平面与控制平面" class="headerlink" title="数据平面与控制平面"></a>数据平面与控制平面</h6><p>$\quad$ 网络层的转发与路由功能，又把网络层进一步划分为数据平面与控制平面</p><p>$\quad$ $\quad$ 数据平面与控制平面是软件定义网络（SDN）技术兴起后，新引入的术语</p><p>$\quad$ 数据平面：转发功能</p><p>$\quad$ $\quad$ 单个路由器上局部功能</p><p>$\quad$ $\quad$ 每个路由器独立对收到的数据报文执行转发功能</p><p>$\quad$ 控制平面：路由功能</p><p>$\quad$ $\quad$ 全网计算：涉及多个路由器</p><p>$\quad$ $\quad$ 2种实现方式:</p><p>$\quad$ $\quad$ $\quad$ 传统路由算法:</p><p>$\quad$ $\quad$ $\quad$ $\quad$ 多个路由器分布式协作计算</p><p>$\quad$ $\quad$ $\quad$ 软件定义网络(SDN):</p><p>$\quad$ $\quad$ $\quad$ $\quad$ 由中心化控制器负责计算后，通知各个路由器</p><p><img src="/../CNP/CN904.png"></p><p><img src="/../CNP/CN905.png"></p><p><img src="/../CNP/CN906.png"></p><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><p>$\quad$ 路由器是互联网最主要的网络设备，包含2个核心功能</p><p>$\quad$ $\quad$ 控制平面（路由）：运行各种路由协议，学习去往不同目的的转发路径：路由表</p><p>$\quad$ $\quad$ 数据平面（转发）：根据上述路由表，将收到的IP分组转发到正确的下一跳链路</p><h6 id="路由器架构"><a href="#路由器架构" class="headerlink" title="路由器架构"></a>路由器架构</h6><p><img src="/../CNP/CN907.png"></p><h6 id="路由器控制平面"><a href="#路由器控制平面" class="headerlink" title="路由器控制平面"></a>路由器控制平面</h6><p>$\quad$ 路由器可同时运行多个路由协议</p><p>$\quad$ 路由器也可不运行任何路由协议，只使用静态路由和直连路由</p><p>$\quad$ 路由管理根据路由优先级，选择最佳路由，形成核心路由表</p><p>$\quad$ 控制层将核心路由表下发到数据层，形成转发表（FIB）</p><p>$\quad$ 若存在多个“去往同一目的IP”的不同类型路由，路由器根据优先级选择最佳路由</p><p>$\quad$ 优先级数值越小，优先级越高</p><p><img src="/../CNP/CN908.png"></p><h4 id="路由器数据平面"><a href="#路由器数据平面" class="headerlink" title="路由器数据平面"></a>路由器数据平面</h4><p>$\quad$ 路由器中IP报文转发核心功能</p><p>$\quad$ $\quad$ 链路层解封装，IP头部校验</p><p>$\quad$ $\quad$ 获取报文目的IP地址</p><p>$\quad$ $\quad$ 用目的IP地址，基于最长前缀匹配规则查询转发表</p><p>$\quad$ $\quad$ 查询失败，丢弃报文</p><p>$\quad$ $\quad$ 查询成功</p><p>$\quad$ $\quad$ $\quad$ IP头部“TTL”字段值减1，重新计算IP头部“校验和”</p><p>$\quad$ $\quad$ $\quad$ 获取转发出接口和下一跳链路层地址</p><p>$\quad$ $\quad$ $\quad$ 重新进行链路层封装，发送报文</p><p>$\quad$ $\quad$ 注：普通IP报文转发过程中，路由器不查看传输层及以上层协议的内容</p><p>$\quad$ IP报文在路由器转发前后的变化</p><p>$\quad$ $\quad$ 链路层封装更新，IP头部“TTL”减1，IP头部“校验和”更新</p><p>$\quad$ 数据报在不同硬件单元的处理</p><p>$\quad$ $\quad$ 输入端口：接口卡 (interface card)</p><p>$\quad$ $\quad$ $\quad$ 物理层处理、链路层解封装</p><p>$\quad$ $\quad$ $\quad$ 转发表查询（该工作在输入接口卡处理）</p><p>$\quad$ $\quad$ $\quad$ 通过交换结构将报文排队发往目的接口卡（发送过快将产生拥塞）</p><p>$\quad$ $\quad$ 交换结构</p><p>$\quad$ $\quad$ $\quad$ 从输入接口卡发往输出接口卡</p><p>$\quad$ $\quad$ 输出端口：接口卡 (interface card)</p><p>$\quad$ $\quad$ $\quad$ 从交换结构接收报文（排队进行后续处理，到达太快将产生拥塞）</p><p>$\quad$ $\quad$ $\quad$ 链路层封装、物理层处理</p><p>$\quad$ $\quad$ $\quad$ 从输出接口发送报文</p><p><img src="/../CNP/CN909.png"></p><h6 id="路由器拓展知识"><a href="#路由器拓展知识" class="headerlink" title="路由器拓展知识"></a>路由器拓展知识</h6><p>$\quad$ 路由器的端系统角色</p><p>$\quad$ $\quad$ 也作为网络端系统进行协议交互</p><p>$\quad$ $\quad$ $\quad$ 远程网络管理，SNMP</p><p>$\quad$ $\quad$ $\quad$ 远程网络配置，SSH</p><p>$\quad$ $\quad$ $\quad$ 文件传输，FTP，TFTP</p><p>$\quad$ $\quad$ $\quad$ 各种路由协议交互</p><p>$\quad$ $\quad$ 路由器系统包含完整TCP&#x2F;IP协议栈</p><p>$\quad$ $\quad$ $\quad$ 传输层协议</p><p>$\quad$ $\quad$ $\quad$ 应用层协议</p><p>$\quad$ 家用路由器</p><p>$\quad$ $\quad$ 不运行动态路由协议（出口唯一）</p><p>$\quad$ $\quad$ 运行DHCP协议，分配私有IP</p><p>$\quad$ $\quad$ NAT地址转换</p><p>$\quad$ $\quad$ 本地DNS服务</p><p>$\quad$ $\quad$ 用户管理及认证</p><p>$\quad$ $\quad$ 防火墙功能</p><p>$\quad$ $\quad$ 无线AP</p><h5 id="输入端口"><a href="#输入端口" class="headerlink" title="输入端口"></a>输入端口</h5><p><img src="/../CNP/CN910.png"></p><p>$\quad$ 去中心化数据交换：每个数据端口执行独立计算任务</p><p>$\quad$ $\quad$ 处理物理层、链路层信息，获取网络层报文</p><p>$\quad$ $\quad$ 基于报文头部字段，在转发表中查找对应的输出端口，通过交换结构(switch fabric)最终传输到对应输出端口</p><p>$\quad$ $\quad$ $\quad$ 每个输入端口在内存里维护转发表</p><p>$\quad$ $\quad$ $\quad$ 又称“匹配-动作(match-action)”模式</p><p>$\quad$ 优势：每个端口独立工作，达到“线速”</p><p>$\quad$ $\quad$ 线速（line rate)：每个端口的传输带宽</p><p>$\quad$ 如果报文到达速度超过交换结构速度（如：多个输入端口往同一输出端口转发数据）</p><p>$\quad$ $\quad$ 报文将在输入端口队列中缓存</p><p>$\quad$ $\quad$ 缓存溢出后，丢弃后续报文</p><p>$\quad$ 基于转发表的转发策略有2种</p><p>$\quad$ $\quad$ 基于目的地址的转发</p><p>$\quad$ $\quad$ $\quad$ 只根据目的IP地址</p><p>$\quad$ $\quad$ $\quad$ 传统交换机中常用（受限于芯片计算能力）</p><p>$\quad$ $\quad$ 通用转发</p><p>$\quad$ $\quad$ $\quad$ 可以根据数据报文中任意字段的组合</p><h6 id="基于目的地址的转发"><a href="#基于目的地址的转发" class="headerlink" title="基于目的地址的转发"></a>基于目的地址的转发</h6><p><img src="/../CNP/CN911.png"></p><p>$\quad$ 给定目的地址在转发表中进行查找时, 使用匹配到的最长地址前缀</p><p><img src="/../CNP/CN912.png"></p><p>$\quad$ 为什么将目的地址范围表示为前缀的形式？</p><p>$\quad$ $\quad$ 区间表示更能消除歧义，为什么不用区间法？</p><p>$\quad$ 原因：</p><p>$\quad$ $\quad$ 现代网络的性能要求极高</p><p>$\quad$ $\quad$ $\quad$ 转发表查找需要在纳秒级时间内完成</p><p>$\quad$ $\quad$ 现代路由器的转发表实现</p><p>$\quad$ $\quad$ $\quad$ 基于ternary content addressable memories (TCAMs)</p><p>$\quad$ $\quad$ TCAM优势：</p><p>$\quad$ $\quad$ $\quad$ 可以对所有地址并行匹配，无论转发表多大只消耗1个时钟周期</p><p>$\quad$ $\quad$ $\quad$ 每个bit支持3类匹配值：0，1，dont care</p><p>$\quad$ $\quad$ $\quad$ Cisco Catalyst交换机: TCAM支持百万级表项</p><h6 id="缓冲队列"><a href="#缓冲队列" class="headerlink" title="缓冲队列"></a>缓冲队列</h6><p>$\quad$ 交换核心或输出端口速度低于多个输入端口到达速率之和 -&gt; 在输入端口排队</p><p>$\quad$ $\quad$ 甚至导致排队延迟与丢包</p><p>$\quad$ 排头阻塞（Head-of-the-Line blocking, HOL blocking):</p><p>$\quad$ $\quad$ 队列中的报文，导致后续报文也需等待，即便后续报文对应的输出端口是空闲的</p><p><img src="/../CNP/CN913.png"></p><h5 id="交换结构"><a href="#交换结构" class="headerlink" title="交换结构"></a>交换结构</h5><p>$\quad$ 交换结构：将报文从输入端口的缓冲队列传输到正确的输出端口</p><p>$\quad$ 交换速率：所有输入端口到输入端口的总速率</p><p>$\quad$ $\quad$ N个输入端口，则期望的交换速率为N倍线速</p><p>$\quad$ 3种典型的交换结构</p><p><img src="/../CNP/CN914.png"></p><h6 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h6><p>$\quad$ 最初的交换机实现</p><p>$\quad$ 交换结构内没有专用芯片，只有一块内存，由控制平面的路由处理器控制</p><p>$\quad$ $\quad$ 路由处理器不仅负责路由功能，还负责转发功能</p><p>$\quad$ 交换流程</p><p>$\quad$ $\quad$ 报文到达输入端口时，产生中断信号通知路由处理器</p><p>$\quad$ $\quad$ 路由处理器将报文复制到内存中，查询对应输出端口，再将报文复制到输出端口</p><p>$\quad$ 性能瓶颈：内存拷贝</p><p><img src="/../CNP/CN915.png"></p><h6 id="共享总线"><a href="#共享总线" class="headerlink" title="共享总线"></a>共享总线</h6><p>$\quad$ 数据包从输入端口直接到达输出端口，无需处理器干预</p><p>$\quad$ 实现方式</p><p>$\quad$ $\quad$ 输入端口通过转发表后，给报文附加上“标签”，表明输出端口</p><p>$\quad$ $\quad$ 带标签的报文通过总线广播至所有输出端口</p><p>$\quad$ $\quad$ 每个输出端口通过标签判断报文是不是属于自己的，不属于则忽略</p><p>$\quad$ 性能：总线1次只能广播1个报文，交换速率受总线带宽制约</p><p>$\quad$ $\quad$ Cisco 5600交换机：32Gbps交换速率</p><h6 id="纵横式Crossbar"><a href="#纵横式Crossbar" class="headerlink" title="纵横式Crossbar"></a>纵横式Crossbar</h6><p>$\quad$ 使用2N条总线连接N个输入端口与N个输出端口</p><p>$\quad$ $\quad$ 交叉点为控制点可以开启或闭合</p><p>$\quad$ 优势：不重叠的交换路径，可以并行工作</p><p>$\quad$ $\quad$ 如：A-&gt;Y，B-&gt;X</p><p>$\quad$ $\quad$ Cisco 12000路由器: 60 Gbps交换速率</p><p>$\quad$ 更复杂交换结构</p><p>$\quad$ $\quad$ 多级、分布式的交换结构</p><h5 id="输出端口"><a href="#输出端口" class="headerlink" title="输出端口"></a>输出端口</h5><p>$\quad$ 缓冲队列：交换结构的数据超过发送数据时</p><p>$\quad$ $\quad$ 与输入端口不同，可以不是FIFO模式</p><p>$\quad$ 队列调度：从缓冲队列中选择数据报文</p><p>$\quad$ $\quad$ 性能考虑：选择对网络性能最好的</p><p>$\quad$ $\quad$ 公平性考虑：网络中立原则</p><p><img src="/../CNP/CN916.png"></p><p>$\quad$ 输出端口的缓冲队列，也可能造成排队延迟甚至丢包</p><p><img src="/../CNP/CN917.png"></p><h6 id="缓冲区大小"><a href="#缓冲区大小" class="headerlink" title="缓冲区大小"></a>缓冲区大小</h6><p>$\quad$ RFC 3439 建议:“典型”RTT (250 ms) 乘以链路带宽 C</p><p>$\quad$ $\quad$ 若C &#x3D; 10 Gpbs，缓冲区大小2.5 Gbit</p><p>$\quad$ 实际建议: 交换机的报文分为N个流，则缓冲区大小为$RTT·C&#x2F;sqrt(N)$</p><p>$\quad$ $\quad$ 流：相同网络地址的报文构成1个流</p><p>$\quad$ $\quad$ 二元组流：源IP地址+目的IP地址</p><p>$\quad$ $\quad$ 五元组流：源IP地址+目的IP地址 + 源端口号 + 目的端口号 + 传输层类型（TCP or UDP)</p><h6 id="调度机制"><a href="#调度机制" class="headerlink" title="调度机制"></a>调度机制</h6><p>$\quad$ 目标：从输出端口的缓冲队列选择一个数据报文发送到链路上</p><p>$\quad$ 先进先出（FIFO）调度：根据入队顺序发送</p><p>$\quad$ $\quad$ 简单，但仍有问题需要考虑</p><p>$\quad$ $\quad$ 缓冲区溢出时，如何选择丢弃报文</p><p>$\quad$ $\quad$ $\quad$ Tail drop：丢弃新来的报文</p><p>$\quad$ $\quad$ $\quad$ Priority drop：根据优先级丢弃报文</p><p>$\quad$ $\quad$ $\quad$ Random drop：随机丢弃</p><p><img src="/../CNP/CN918.png"></p><p>$\quad$ 基于优先级调度（priority scheduling)：将数据报文分为不同优先级</p><p>$\quad$ $\quad$ 根据数据报文头部字段判断优先级（如IP地址，端口号）</p><p>$\quad$ $\quad$ 具体优先级由安全或者性能因素考虑</p><p>$\quad$ $\quad$ 总是先发送高优先级报文</p><p>$\quad$ 实现：多个队列对应不同优先级</p><p>$\quad$ $\quad$ 为简化芯片设计，不采用复杂数据结构（如二叉堆）</p><p>$\quad$ 缺点：公平性</p><p><img src="/../CNP/CN919.png"></p><p>$\quad$ 轮询调度（round robin scheduling）</p><p>$\quad$ $\quad$ 将报文分类，进入多个队列</p><p>$\quad$ $\quad$ 在队列间轮询，若队列中存在报文，则发送</p><p><img src="/../CNP/CN920.png"></p><p>$\quad$ 加权公平队列(weighted fair queuing, WFQ)</p><p>$\quad$ $\quad$ 更一般化的轮询方式</p><p>$\quad$ $\quad$ 每个队列拥有权重值</p><p>$\quad$ $\quad$ 轮询时考虑权重：权重高的队列，轮询到的次数更多</p><p><img src="/../CNP/CN921.png"></p><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>CN</category>
      
      <category>网络层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CN</tag>
      
      <tag>网络层</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>传输层-新型传输层协议</title>
    <link href="/2023/11/08/%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%96%B0%E5%9E%8B%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE/"/>
    <url>/2023/11/08/%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%96%B0%E5%9E%8B%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<p> 对应 北京大学计算机网络课程第三讲第五部分<br> 参考教材计算机网络-自顶向下方法</p><span id="more"></span><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="新型传输层协议"><a href="#新型传输层协议" class="headerlink" title="新型传输层协议"></a>新型传输层协议</h2><h4 id="DCCP"><a href="#DCCP" class="headerlink" title="DCCP"></a>DCCP</h4><h6 id="UDP的问题"><a href="#UDP的问题" class="headerlink" title="UDP的问题"></a>UDP的问题</h6><p>$\quad$ 一些容忍少量丢包、但延迟敏感的应用，适合采用UDP传输：</p><p>$\quad$ $\quad$ 如视频会议、在线游戏等</p><p>$\quad$ 然而，UDP没有拥塞控制机制：</p><p>$\quad$ $\quad$ 拥塞发生时，UDP既感知不到拥塞，也不会降低其发送速率，从而影响应用性能，也影响网络的整体性能</p><p>$\quad$ $\quad$ 对TCP协议极不友好，损害网络公平性（TCP让出的带宽都被UDP占了）</p><h6 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h6><p>$\quad$ 给UDP增加拥塞控制机制</p><p>$\quad$ DCCP&#x3D;UDP+拥塞控制</p><p>$\quad$ $\quad$ 增加ACK报文、包序列号、面向连接等拥塞控制手段</p><p>$\quad$ DCCP提供不可靠数据报流服务：</p><p>$\quad$ $\quad$ UDP报文段可能丢失、乱序到达</p><p>$\quad$ $\quad$ 无流量控制</p><p>$\quad$ DCCP提供模块化的拥塞控制：</p><p>$\quad$ $\quad$ 应用可以根据需要，选择不同的拥塞控制机制</p><h6 id="DCCP的报文格式"><a href="#DCCP的报文格式" class="headerlink" title="DCCP的报文格式"></a>DCCP的报文格式</h6><p><img src="/../CNP/CN801.png"></p><h6 id="DCCP的报文类型"><a href="#DCCP的报文类型" class="headerlink" title="DCCP的报文类型"></a>DCCP的报文类型</h6><p><img src="/../CNP/CN802.png"></p><h6 id="DCCP-连接"><a href="#DCCP-连接" class="headerlink" title="DCCP 连接"></a>DCCP 连接</h6><p>$\quad$ DCCP是面向连接的，两个主机之间有一个全双工连接：</p><p>$\quad$ $\quad$ 由两个方向的半连接组成</p><p>$\quad$ $\quad$ 以A to B方向的半连接为例</p><p>$\quad$ $\quad$ $\quad$ A向B发送Data报文段</p><p>$\quad$ $\quad$ $\quad$ B向A发送ACK报文段</p><p><img src="/../CNP/CN803.png"></p><p>$\quad$ 同一方向的ACK段和Data段可以合并成DataAck报文段</p><h6 id="DCP的交互流程"><a href="#DCP的交互流程" class="headerlink" title="DCP的交互流程"></a>DCP的交互流程</h6><p><img src="/../CNP/CN804.png"></p><h6 id="DCCP可靠传输"><a href="#DCCP可靠传输" class="headerlink" title="DCCP可靠传输"></a>DCCP可靠传输</h6><p>$\quad$ SeqNum与ACK只是用来拥塞控制，不要求可靠传输</p><p>$\quad$ 接收方：ACK可以不含序列号（如CCID3，只反馈丢包率）</p><p>$\quad$ 发送方：发现丢包也没有义务</p><h5 id="DCCP的拥塞控制机制"><a href="#DCCP的拥塞控制机制" class="headerlink" title="DCCP的拥塞控制机制"></a>DCCP的拥塞控制机制</h5><p>$\quad$ DCCP连接支持拥塞控制，应用可以根据需要选择不同的拥塞控制机制：</p><p>$\quad$ $\quad$ 组成一个连接的两个半连接，可以选择不同的拥塞控制机制</p><p>$\quad$ 不同的拥塞控制机制由一个1字节的CCID来标识，连接建立时两个终端协商确定</p><p>$\quad$ 目前DCCP的RFC文档定义了两个CCID，分别是2和3，其余的值保留</p><h6 id="TCP-like-Congestion-Control（CCID2）"><a href="#TCP-like-Congestion-Control（CCID2）" class="headerlink" title="TCP-like Congestion Control（CCID2）"></a>TCP-like Congestion Control（CCID2）</h6><p>$\quad$ 发送方维持一个发送窗口，并且不停地发包，直到没有可用的发送窗口</p><p>$\quad$ 接收方对收到的包回复ACK报文，包括一段时间内收到的所有包的序号（用于支持SACK机制）</p><p>$\quad$ 丢包或者ECN标记表示出现拥塞，此时发送端需要将发送窗口减半</p><h6 id="TCP-Friendly-Rate-Control（CCID3）"><a href="#TCP-Friendly-Rate-Control（CCID3）" class="headerlink" title="TCP-Friendly Rate Control（CCID3）"></a>TCP-Friendly Rate Control（CCID3）</h6><p>$\quad$ 接收方计算丢包率，报告给发送方</p><p>$\quad$ 发送方根据丢包率计算发送速率，并根据发送速率发包</p><p>$\quad$ 相比而言，CCID3可以更平滑地调节发包速率</p><h4 id="MPTCP"><a href="#MPTCP" class="headerlink" title="MPTCP"></a>MPTCP</h4><p>$\quad$ 传统TCP协议仅支持单路径传输，即只能利用终端主机上的一个网络接口传输数据</p><p>$\quad$ 随着接入技术的发展，同时具备多个网络接口的网络设备已经越来越普及，多路径传输更适合当前的网络环境</p><p>$\quad$ 多路径TCP协议（MPTCP）应运而生，它可将单一数据流切分为若干子流，同时利用多条路径进行传输</p><h6 id="MPTCP的优势"><a href="#MPTCP的优势" class="headerlink" title="MPTCP的优势"></a>MPTCP的优势</h6><p>$\quad$ 多径带宽聚合</p><p>$\quad$ $\quad$ 终端设备可以聚合不同路径上的可用带宽，以获得更高的网络带宽</p><p>$\quad$ 提升传输的可靠性</p><p>$\quad$ $\quad$ 使用多条路径传输数据，可以有效避免因单条路径性能恶化或中断导致的应用连接中断</p><p>$\quad$ 支持链路的平滑切换</p><p>$\quad$ $\quad$ 多路径传输方式允许终端在不同接入网络间快速、平滑地切换，选取当前链路质量最好的路径传输数据</p><h6 id="MPTCP在网络体系结构中的位置"><a href="#MPTCP在网络体系结构中的位置" class="headerlink" title="MPTCP在网络体系结构中的位置"></a>MPTCP在网络体系结构中的位置</h6><p>$\quad$ MPTCP位于套接字和TCP之间：</p><p>$\quad$ $\quad$ 应用程序通过套接字调用MPTCP，MPTCP向应用程序提供单条连接的抽象，因而对应用层透明</p><p>$\quad$ $\quad$ MPTCP可在源主机和目的主机的多对网络接口间分别建立TCP连接，并将数据流分配到多条TCP连接上传输</p><p>$\quad$ $\quad$ MPTCP兼容并扩展了TCP协议：TCP基本头不变，只定义了新的选项，从而对网络层也是透明</p><p><img src="/../CNP/CN805.png"></p><p>$\quad$ MPTCP连接是一个或多个子流的集合：</p><p>$\quad$ $\quad$ 路径：本地主机与远程主机之间可用于建立连接的一个链路序列称为路径，使用四元组&lt;本地IP地址，本地端口，远程IP地址，远程端口&gt;表示</p><p>$\quad$ $\quad$ 子流：在单个路径上运行的 TCP 流称为子流，是MPTCP连接的组成部分</p><h5 id="MPTCP连接管理"><a href="#MPTCP连接管理" class="headerlink" title="MPTCP连接管理"></a>MPTCP连接管理</h5><p>$\quad$ 用于MPTCP连接管理的新字段：</p><p>$\quad$ $\quad$ MP_CAPABLE：建立MPTCP连接</p><p>$\quad$ $\quad$ MP_JOIN：附加新的子流到已有连接</p><p>$\quad$ $\quad$ ADD_ADDR：新增可用路径</p><p>$\quad$ $\quad$ REMOVE_ADDR：删除路径</p><p>$\quad$ $\quad$ MP_FASTCLOSE：关闭所有子流</p><p>$\quad$ 如何建立MPTCP连接：</p><p>$\quad$ $\quad$ 首先初始化一条MPTCP连接（与建立常规TCP连接的过程相似）</p><p>$\quad$ $\quad$ 然后将MPTCP的其它子流附加到已经存在的MPTCP连接上</p><p><img src="/../CNP/CN806.png"></p><h6 id="初始化MPTCP连接"><a href="#初始化MPTCP连接" class="headerlink" title="初始化MPTCP连接"></a>初始化MPTCP连接</h6><p><img src="/../CNP/CN807.png"></p><h6 id="附加子流到MPTCP连接上"><a href="#附加子流到MPTCP连接上" class="headerlink" title="附加子流到MPTCP连接上"></a>附加子流到MPTCP连接上</h6><p><img src="/../CNP/CN808.png"></p><h6 id="MPTCP路径管理和关闭连接"><a href="#MPTCP路径管理和关闭连接" class="headerlink" title="MPTCP路径管理和关闭连接"></a>MPTCP路径管理和关闭连接</h6><p><img src="/../CNP/CN809.png"></p><h5 id="MPTCP的数据调度"><a href="#MPTCP的数据调度" class="headerlink" title="MPTCP的数据调度"></a>MPTCP的数据调度</h5><p>$\quad$ 在多路径传输中，发送端将属于同一个数据流的数据包调度到不同的路径上传输，由于不同路径的差异，这些数据包往往无法按照发送顺序到达接收端</p><p>$\quad$ 乱序到达的数据包需暂存在接收缓存中，直到接收缓中的数据包能够按序交付给上层应用，这既影响了数据传输的实时性，又影响了网络的吞吐量</p><p>$\quad$ MPTCP根据拥塞窗口大小及路径延迟，将数据按比例分配给各个子流，尽力保证数据包按序到达接收端，降低数据乱序到达对网络性能产生的不利影响</p><h5 id="MPTCP的拥塞机制"><a href="#MPTCP的拥塞机制" class="headerlink" title="MPTCP的拥塞机制"></a>MPTCP的拥塞机制</h5><p>$\quad$ IETF MPTCP工作组提出的拥塞控制的设计目标</p><p>$\quad$ $\quad$ 提升吞吐量：多路径TCP连接的各个子流获得的总吞吐量，不应低于其最优路径上单路径TCP连接的吞吐量</p><p>$\quad$ $\quad$ 公平性：多路径TCP连接在同一网络瓶颈处的多个子流，不能过多地侵占其它单路径TCP连接的带宽</p><p>$\quad$ $\quad$ 均衡拥塞：多路径TCP连接应能在满足前两个准则的情况下，实现各个子流之间的负载均衡，尽可能将拥塞路径上的流量迁移到较好的路径上</p><p>$\quad$ 公平性是关注的重点，MPTCP采用的是网络公平性原则</p><p>$\quad$ $\quad$ 举例：假设MPTCP的两个子流与一个常规TCP流共享一个网络瓶颈，则MPTCP两个子流获得的带宽应为瓶颈带宽的1&#x2F;2，而不是2&#x2F;3，这样才能保证MPTCP连接对常规TCP连接的友好性</p><p>$\quad$ MPTCP实现网络公平性准则的方法：</p><p>$\quad$ $\quad$ 限制各个子流窗口增长速度的总和，不超过单路径TCP连接的窗口增长速度</p><p>$\quad$ $\quad$ 从而，MPTCP连接通过各子流获得的总吞吐量和单路径TCP连接获得的吞吐量相当</p><h4 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h4><h6 id="TCP存在的问题"><a href="#TCP存在的问题" class="headerlink" title="TCP存在的问题"></a>TCP存在的问题</h6><p>$\quad$ TCP 实现在操作系统内核中</p><p>$\quad$ $\quad$ 作为传输优化的最终受益者，应用无法对TCP进行修改</p><p>$\quad$ $\quad$ 操作系统的更新往往跟不上应用的需求和节奏</p><p>$\quad$ TCP体系握手时延大</p><p>$\quad$ $\quad$ 互联网上的大趋势：低时延需求越来越强烈；加密流量占比越来越大</p><p>$\quad$ $\quad$ TLS(传输层安全性协议)+TCP的体系握手时延很大，传输前需要3个RTT进行握手</p><p>$\quad$ TCP多流复用存在队头阻塞问题</p><p>$\quad$ $\quad$ 当前的应用普遍比较复杂，常需要同时传输多个元素：例如：网页传输中，每个单独的图片即为一个数据流，不同数据流之间相互独立。为每个数据建立一个TCP连接很低效（尤其对于小流，单独建立连接成本高昂），因此出现了多流复用</p><p>$\quad$ $\quad$ TCP传输需要保持有序性：出现丢包时，后面的数据需要等丢失的包重传完成才能使用，这就导致了队头阻塞</p><h6 id="QUIC在网络体系结构中的位置"><a href="#QUIC在网络体系结构中的位置" class="headerlink" title="QUIC在网络体系结构中的位置"></a>QUIC在网络体系结构中的位置</h6><p>$\quad$ 传统的传输架构</p><p>$\quad$ $\quad$ TCP提供数据传输服务</p><p>$\quad$ $\quad$ TLS（传输层安全性协议）对数据进行加密</p><p>$\quad$ $\quad$ HTTP协议定义如何发起请求-响应请求</p><p>$\quad$ $\quad$ 应用在HTTP之上实现</p><p>$\quad$ 基于QUIC的传输架构</p><p>$\quad$ $\quad$ QUIC替代TCP、TLS和部分HTTP的功能</p><p>$\quad$ QUIC实现在用户态中</p><p>$\quad$ $\quad$ 底层基于UDP实现</p><p>$\quad$ $\quad$ 拥塞控制是模块化的，可以方便地使用各种TCP拥塞控制算法，如CUBIC等</p><p><img src="/../CNP/CN810.png"></p><h6 id="QUIC包格式"><a href="#QUIC包格式" class="headerlink" title="QUIC包格式"></a>QUIC包格式</h6><p>$\quad$ 部分相关字段：</p><p>$\quad$ $\quad$ 连接标识符(Connection ID)：</p><p>用于对连接进行表示和识别</p><p>$\quad$ $\quad$ 包号(Packet Number)：单调递增,</p><p>即同一个连接中，每个QUIC包的包号都不一样</p><p>$\quad$ QUIC底层使用UDP进传输</p><p>$\quad$ $\quad$ QUIC包作为UDP的数据载荷</p><p>$\quad$ $\quad$ IANA（互联网数字分配机构）建议QUIC使用UDP的443端口</p><p><img src="/../CNP/CN811.png"></p><h6 id="连接时建立时延优化"><a href="#连接时建立时延优化" class="headerlink" title="连接时建立时延优化"></a>连接时建立时延优化</h6><p><img src="/../CNP/CN812.png"></p><h6 id="QUIC多数据流"><a href="#QUIC多数据流" class="headerlink" title="QUIC多数据流"></a>QUIC多数据流</h6><p>$\quad$ TCP：1个连接1对双向字节流</p><p>$\quad$ QUIC：多字节流</p><p>$\quad$ $\quad$ 一个QUIC连接，可以用于传输多个字节流（streams）</p><p>$\quad$ $\quad$ 每个QUIC报文，甚至可以包含来自多个stream的数据</p><p><img src="/../CNP/CN813.png"></p><h6 id="无队头阻塞的多流复用"><a href="#无队头阻塞的多流复用" class="headerlink" title="无队头阻塞的多流复用"></a>无队头阻塞的多流复用</h6><p>$\quad$ TCP多流复用时的队头阻塞问题</p><p>$\quad$ $\quad$ TCP为保持数据的有序性，出现丢包时，会等待该数据到达后，再提交给上层应用</p><p>$\quad$ $\quad$ 多流复用时，某个数据流的数据包丢失，会使得TCP连接上所有数据流都需要等待</p><p>$\quad$ QUIC对队头阻塞问题的解决</p><p>$\quad$ $\quad$ 在单个连接中，建立相互独立的多个QUIC流，某个流的数据包丢失不影响其它流的数据交付</p><p>$\quad$ $\quad$ 分析：TCP保证了整个连接的数据交付的有序性（有序）; QUIC利用了各个流相互独立的特性，仅保持了流内部数据的有序性（部分有序），减少了不必要的等待</p><p>$\quad$ $\quad$ 同时限制：单个流对接收端缓冲区的占用不能超过阈值</p><h6 id="明确的包序号和更精确的RTT"><a href="#明确的包序号和更精确的RTT" class="headerlink" title="明确的包序号和更精确的RTT"></a>明确的包序号和更精确的RTT</h6><p>$\quad$ TCP中Seq的作用</p><p>$\quad$ $\quad$ ACK将Seq用于ACKNum，确认接收成功</p><p>$\quad$ $\quad$ 接收端交付数据时，判断重复数据与顺序</p><p>$\quad$ QUIC：是否还使用同样作用的seq？</p><p>$\quad$ $\quad$ 一个packet包含多个stream的frame</p><p>$\quad$ $\quad$ 各个stream独立交付</p><p>$\quad$ 因此，QUIC分离确认接收与向上层交付数据</p><p>$\quad$ $\quad$ Packet Number：ACK中确认packet接收</p><p><img src="/../CNP/CN814.png"></p><p>$\quad$ TCP重传歧义的问题：</p><p>$\quad$ $\quad$ TCP的重传包使用和原包相同的序号，因此可能某一序号被用了不止一次</p><p>$\quad$ $\quad$ TCP收到这一序号的ACK时，无法判断是针对哪个包的ACK，从而影响后续操作，如测量RTT的大小</p><p>$\quad$ QUIC解决重传歧义的方法：</p><p>$\quad$ $\quad$ QUIC的packet number单调递增，对于重传包也会递增packet number</p><p>$\quad$ $\quad$ 每个packet number只会出现一次，ACK没有歧义！</p><p>$\quad$ $\quad$ QUIC接收端记录收到包与发出ACK之间的时延，并发馈给发送端，方便发送端更准确地测量RTT</p><h6 id="IP地址-x2F-端口切换无需重新建立连接"><a href="#IP地址-x2F-端口切换无需重新建立连接" class="headerlink" title="IP地址&#x2F;端口切换无需重新建立连接"></a>IP地址&#x2F;端口切换无需重新建立连接</h6><p>$\quad$ IP地址&#x2F;端口发生变化时，TCP连接会断开</p><p>$\quad$ $\quad$ 例如手机WIFI断开时，常常自动转而使用移动信号</p><p>$\quad$ $\quad$ 此时，TCP会断连，需要应用进行处理</p><p>$\quad$ QUIC支持IP&#x2F;端口切换</p><p>$\quad$ $\quad$ QUIC使用Connection ID来表示每个连接</p><p>$\quad$ $\quad$ IP地址或端口的变化不影响对原有连接的识别</p><p>$\quad$ $\quad$ 客户IP地址或端口发生变化时，QUIC可以快速恢复</p><p>$\quad$ 由传输层对连接的切换进行管理</p><p>$\quad$ $\quad$ 更符合互联网体系结构</p><p>$\quad$ $\quad$ 不再需要应用重复造轮子</p><h6 id="QUIC易于部署和更新"><a href="#QUIC易于部署和更新" class="headerlink" title="QUIC易于部署和更新"></a>QUIC易于部署和更新</h6><p>$\quad$ 整个QUIC包被加密传输</p><p>$\quad$ $\quad$ 保护用户数据隐私</p><p>$\quad$ $\quad$ 避免被中间设备识别和修改</p><p>$\quad$ QUIC在用户态实现</p><p>$\quad$ $\quad$ 与操作系统解耦，从而能和应用一同快速迭代</p><p>$\quad$ $\quad$ 如：预留接口，用户自定义拥塞控制</p><p>$\quad$ 版本协商机制</p><p>$\quad$ $\quad$ 由于QUIC的快速迭代特性，会同时存在众多QUIC版本</p><p>$\quad$ $\quad$ 客户需要和服务器进行版本协商（不引入额外时延的协商机制</p><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>CN</category>
      
      <category>传输层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CN</tag>
      
      <tag>传输层</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>传输层-新型拥塞控制</title>
    <link href="/2023/11/01/%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%96%B0%E5%9E%8B%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"/>
    <url>/2023/11/01/%E4%BC%A0%E8%BE%93%E5%B1%82-%E6%96%B0%E5%9E%8B%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p> 对应 北京大学计算机网络课程第三讲第四部分<br> 参考教材计算机网络-自顶向下方法</p><span id="more"></span><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="新型拥塞控制"><a href="#新型拥塞控制" class="headerlink" title="新型拥塞控制"></a>新型拥塞控制</h2><p>$\quad$ 慢启动只占据TCP很小部分，大部分拥塞控制技术关注拥塞避免与快速恢复</p><p>$\quad$ 要素1：端系统能观察到什么?</p><p>$\quad$ $\quad$ 检测拥塞</p><p>$\quad$ 要素2：端系统可以改变什么?</p><p>$\quad$ $\quad$ 响应拥塞：</p><p>$\quad$ $\quad$ 一旦观测到拥塞，降低发送速率</p><p>$\quad$ $\quad$ 但是，如果网络条件发生改变</p><p>$\quad$ $\quad$ $\quad$ 如：网络带宽变大</p><p>$\quad$ $\quad$ $\quad$ … 保持低发送速率将影响</p><p>$\quad$ $\quad$ 因此，一旦检测到拥塞不再存在</p><p>$\quad$ $\quad$ $\quad$ 增加速率（每次一点点）</p><p>$\quad$ $\quad$ $\quad$ 观察报文是否能正常传输</p><h3 id="拥塞控制改进"><a href="#拥塞控制改进" class="headerlink" title="拥塞控制改进"></a>拥塞控制改进</h3><h4 id="慢启动优化"><a href="#慢启动优化" class="headerlink" title="慢启动优化"></a>慢启动优化</h4><p>$\quad$ 慢启动阶段的主要优化目标：CWND的初始化</p><p>$\quad$ $\quad$ CWND &#x3D; 1 MSS (Tahoe)</p><p>$\quad$ $\quad$ Linux 2.6 (RFC 3390) CWND depends on MSS</p><p>$\quad$ $\quad$ Linux 3.0 (RFC 6928) CWND &#x3D; 10 MSS</p><h4 id="TCP-New-Reno-SACK"><a href="#TCP-New-Reno-SACK" class="headerlink" title="TCP New Reno,SACK"></a>TCP New Reno,SACK</h4><p>$\quad$ 思想：快速恢复阶段，针对同时多个丢包优化</p><p>$\quad$ $\quad$ 当sender收到了3个重复ACK，进入快速重传模式，重传重复ACK指示的那个包</p><p>$\quad$ $\quad$ $\quad$ 如果只有这一个包丢了，那么重传这个包且收到新ACK时，期望新ACK会把所有重传前数据进行确认</p><p>$\quad$ $\quad$ $\quad$ 否则（新ACK没对所有重传前数据确认），说明有多个包丢了,我们叫这个新ACK为Partial ACK</p><p>$\quad$ $\quad$ 一旦发现Partial ACK，sender就可以推理出有多个包被丢了</p><p>$\quad$ $\quad$ $\quad$ 继续重传未被确认的第一个包，直到再也收不到了Partial ACK，才结束Fast Recovery</p><h5 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h5><p>$\quad$ 重传data[1]前，已发数据data[0]-data[12]</p><p>$\quad$ 收到ack[3]，说明除了data[1]，还有其他数据丢失</p><p>$\quad$ 继续处于快速恢复阶段，重传data[4]</p><p><img src="/../CNP/CN701.png"></p><p>$\quad$ TCP New Reno仍存在问题：</p><p>  $\quad$ 每个RTT只能判断并重传1个丢包</p><h5 id="SACK"><a href="#SACK" class="headerlink" title="SACK"></a>SACK</h5><p>$\quad$ SACK(选择重传)机制：一次性通知多个丢包</p><p>$\quad$ $\quad$ SACK出现在TCP头Option字段</p><p><img src="/../CNP/CN702.png"></p><p><img src="/../CNP/CN703.png"></p><p>$\quad$ Left Edge表示已收到的不连续块的第一个序号，Right Edge表示已收到的不连续块的最后一个序号+1，即左闭右开区间</p><p>$\quad$ 通过ACK和SACK信息，发送方就可以确定接收方具体没有收到的数据就是从ACK到最大SACK信息之间的那些空洞的序号</p><p>$\quad$ TCP Option总共不超过40字节，每个序号4字节：1个ACK段最多4组SACK信息</p><h4 id="TCP-BIC"><a href="#TCP-BIC" class="headerlink" title="TCP BIC"></a>TCP BIC</h4><h6 id="经典TCP拥塞控制的性能问题"><a href="#经典TCP拥塞控制的性能问题" class="headerlink" title="经典TCP拥塞控制的性能问题"></a>经典TCP拥塞控制的性能问题</h6><p>$\quad$ 核心问题：在探测满载窗口的过程中，如何增加拥塞窗口以尽可能利用网络带宽？</p><p>$\quad$ TCP Reno线性增大拥塞窗口，探测当前可用网络带宽，即每经过一个RTT，拥塞窗口增加一个MSS（拥塞避免）</p><p>$\quad$ 当端到端时延带宽乘积（BDP）较大时，拥塞窗口增长过慢，导致信道无法满载</p><p><img src="/../CNP/CN704.png"></p><h5 id="Binary-Increase-Congestion"><a href="#Binary-Increase-Congestion" class="headerlink" title="Binary Increase Congestion"></a>Binary Increase Congestion</h5><p>$\quad$ BIC算法发现这么多的拥塞控制算法都在努力找一个合适的cwnd，本质就是一个搜索的过程，因此BIC算法的核心思想使用二分查找来搜索合适的cwnd</p><p>$\quad$ Linux在采用CUBIC之前的默认算法</p><h6 id="二分查找过程"><a href="#二分查找过程" class="headerlink" title="二分查找过程"></a>二分查找过程</h6><p>$\quad$ 思想</p><p>$\quad$ $\quad$ 如果发生丢包的时候，窗口的大小是W1，那么要保持线路满载却不丢包，实际的窗口最大值应该在W1以下</p><p>$\quad$ $\quad$ $\quad$ 初始化Wmax&#x3D;W1</p><p>$\quad$ $\quad$ 如果丢包后将窗口乘性减到了W2后，成功收到重传报文的ACK，那么实际的窗口值应该在W2以上 (Wmin)</p><p>$\quad$ $\quad$ $\quad$ 初始化Wmin&#x3D;W2</p><p>$\quad$ ACK驱动的查找：每经过一个RTT，若无丢包发生，便将窗口设置到Wmax和Wmin的中点，一直持续到接近Wmax</p><p>$\quad$ $\quad$ 更新Wmin</p><h6 id="更新上下界：Smax和Smin"><a href="#更新上下界：Smax和Smin" class="headerlink" title="更新上下界：Smax和Smin"></a>更新上下界：Smax和Smin</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-keyword">while</span> (Wmin &lt;= Wmax) &#123;<br><br>  <br><br>    inc = (Wmin+Wmax)/<span class="hljs-number">2</span> - cwnd;<br><br>  <br><br>  <span class="hljs-keyword">if</span> (inc &gt; Smax)<br><br>  <br><br>           inc = Smax;<br><br>  <br><br>  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (inc &lt; Smin)<br><br>  <br><br>           inc = Smin;<br><br>  <br><br>  cwnd = cwnd + inc * MSS / cwnd;<br><br>  <br><br>  <span class="hljs-keyword">if</span> (no packet losses)<br><br>  <br><br>           Wmin = cwnd;<br><br>  <br><br>  <span class="hljs-keyword">else</span><br><br>  <br><br>           <span class="hljs-keyword">break</span>;<br><br>  <br><br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="当cwnd超过WMAX"><a href="#当cwnd超过WMAX" class="headerlink" title="当cwnd超过WMAX"></a>当cwnd超过WMAX</h6><p>$\quad$ 既然cwnd度过了Wmax都没有丢包，说明新的Wmax还没有达到</p><p>$\quad$ BIC采取了一种非常简单直接的方法：按照逼近Wmax的路径倒回去，即采用与之对称的方案</p><h6 id="TCP-BIC性能"><a href="#TCP-BIC性能" class="headerlink" title="TCP-BIC性能"></a>TCP-BIC性能</h6><p><img src="/../CNP/CN705.png"></p><h6 id="BIC的不公平性"><a href="#BIC的不公平性" class="headerlink" title="BIC的不公平性"></a>BIC的不公平性</h6><p><img src="/../CNP/CN706.png"></p><h4 id="TCP-CUBIC"><a href="#TCP-CUBIC" class="headerlink" title="TCP CUBIC"></a>TCP CUBIC</h4><p>$\quad$ WHY？</p><p>$\quad$ 原因1：延迟ACK以及ACK丢失的问题，BIC算法实际实现要比理论情况复杂很多</p><p>$\quad$ 原因2：BIC容易导致不公平性</p><p>$\quad$ 核心思想：</p><p>$\quad$ $\quad$ 窗口增长函数仅仅取决于当前距离上次丢包经过的时间t</p><p>$\quad$ $\quad$ 从而，窗口增长完全独立于网络的时延RTT</p><p>$\quad$ CUBIC的RTT独立性质使得CUBIC能够在多条共享瓶颈链路的TCP连接之间保持良好的RTT公平性</p><h6 id="该进"><a href="#该进" class="headerlink" title="该进"></a>该进</h6><p>$\quad$ CUBIC将BIC算法连续化，用三次函数拟合BIC算法曲线（CUBIC名字的由来）</p><p>$\quad$ 拥塞窗口成为距上次丢包的时间t 的函数</p><p>$\quad$ $\quad$ 不再根据RTT间隔来确定调整窗口的时机，避免了RTT不公平问题</p><p>$\quad$ 三次函数增长分为两个阶段：</p><p>$\quad$ $\quad$ Steady State Behavior阶段：以凹函数增长逼近最近一次丢包时窗口</p><p>$\quad$ $\quad$ Max probing阶段：以凸函数增长探测当前满载窗口</p><p>$\quad$ 绝大多数时间内，拥塞窗口都在Wmax附近，保持了较高的发送效率</p><p><img src="/../CNP/CN707.png"></p><p>$\quad$ C越大，探测到最大窗口的时间越短，决定了对称区间的高度</p><p>$\quad$ 区间起始时刻为最近一次检测到丢包的时间</p><p>$\quad$ 对称区间的宽度不再依赖于ACK</p><h4 id="TCP-Vegas，TCP-Westwood"><a href="#TCP-Vegas，TCP-Westwood" class="headerlink" title="TCP Vegas，TCP Westwood"></a>TCP Vegas，TCP Westwood</h4><h6 id="Vegas"><a href="#Vegas" class="headerlink" title="Vegas"></a>Vegas</h6><p>$\quad$ 核心思想是用RTT的值来影响拥塞窗口，而不是通过丢包</p><p>$\quad$ 没有大规模部署，但在轻量级系统中比较受关注</p><p>$\quad$ 具体方案</p><p>$\quad$ $\quad$ 监控RTT来计算一个RTT</p><p>$\quad$ $\quad$ 通过RTT来估计当前的实际吞吐量</p><p>$\quad$ $\quad$ 如果cwnd低于某个阈值，线性地增加cwnd</p><p>$\quad$ $\quad$ 如果实际吞吐量比我们的期望吞吐量要小很多，线性地减少cwnd</p><p>$\quad$ $\quad$ 重传改进：计算出来的RTT大于Timeout，直接重传</p><p><img src="/../CNP/CN708.png"></p><h6 id="Westwood"><a href="#Westwood" class="headerlink" title="Westwood"></a>Westwood</h6><p>$\quad$ 主要运用于无线网络</p><p>$\quad$ 核心思想：</p><p>$\quad$ $\quad$ 通过在发送端持续不断的检测ack的到达速率来进行带宽估计</p><p>$\quad$ $\quad$ 当拥塞发生时用带宽估计值来调整拥塞窗口和慢启动阈值</p><h4 id="TCP-BBR"><a href="#TCP-BBR" class="headerlink" title="TCP BBR"></a>TCP BBR</h4><h6 id="拥塞与瓶颈链路带宽"><a href="#拥塞与瓶颈链路带宽" class="headerlink" title="拥塞与瓶颈链路带宽"></a>拥塞与瓶颈链路带宽</h6><p>$\quad$ 瓶颈链路带宽BtlBw，决定了端到端路径上的最大数据投递速率</p><p>$\quad$ 当数据量到达瓶颈链路BDP时，在瓶颈链路处形成排队，导致RTT延长(甚至超时)</p><p>$\quad$ 当数据量持续增加到BDP + BufferSize时，就开始丢包</p><p><img src="/../CNP/CN709.png"></p><h5 id="Bottleneck-Bandwidth-and-Round-trip-propagation-time"><a href="#Bottleneck-Bandwidth-and-Round-trip-propagation-time" class="headerlink" title="Bottleneck Bandwidth and Round-trip propagation time"></a>Bottleneck Bandwidth and Round-trip propagation time</h5><p>$\quad$ BDP&#x3D;BtlBw × Rtprop</p><p>$\quad$ $\quad$ 瓶颈链路带宽BtlBw：不会引起路由器缓存排队的最大发送速率</p><p>$\quad$ $\quad$ RTprop：”发送端-接收端”整个路径往返时间</p><p>$\quad$ BDP物理含义：瓶颈链路装满时，整个网络管道里的数据量</p><p>$\quad$ $\quad$ 包含瓶颈链路与其他链路</p><p>$\quad$ 传统TCP拥塞控制</p><p>$\quad$ $\quad$ 以丢包事件为驱动，探测阶段将瓶颈链路上的缓冲区填满直至丢包，并以此为依据判断是否进行被动的乘性减小</p><p>$\quad$ $\quad$ 目标：认为BDP + BtlneckBufSize是最优窗口大小</p><p><img src="/../CNP/CN710.png"></p><h6 id="BBR"><a href="#BBR" class="headerlink" title="BBR"></a>BBR</h6><p>$\quad$ 目标：认为BDP是最优窗口大小</p><p>$\quad$ 相比于传统TCP，BBR的目标更有优势</p><p>$\quad$ $\quad$ 相同的吞吐量</p><p>$\quad$ $\quad$ 更低的延迟、更小的丢包风险</p><p>$\quad$ 核心思想</p><p>$\quad$ $\quad$ 获知当前BDP，将cwnd往BDP调整</p><p>$\quad$ BDP&#x3D;BtlBw × Rtprop</p><p>$\quad$ $\quad$ 问题转化为，求当前BtlBw与Rtprop</p><p><strong>Max BW和min RTT不能同时被测得</strong></p><p>$\quad$ 要测量最大带宽，就要把瓶颈链路填满，此时buffer中存在排队分组，延迟较高</p><p>$\quad$ 要测量最低延迟，就要保证链路队列为空，网络中分组越少越好，cwnd较小</p><p><strong>解决方案：BDP点的近似检测</strong></p><p>$\quad$ 用过去10秒内的最小RTT（min RTT）和最大投递率（max BW），分别近似RTprop和BtlBw，并依据这两个值估算当前BDP</p><p><img src="/../CNP/CN711.png"></p><p>$\quad$ 启动阶段</p><p>$\quad$ $\quad$ 当连接建立时，类似TCP的慢启动，指数增加发送速率，尽可能快地占满管道</p><p>$\quad$ $\quad$ 若经过三次发现投递率不再增长，说明已达到BtlBw，瓶颈链路处分组已开始排队（事实上此时已经多发了数据）<img src="/../CNP/CN712.png"></p><p>$\quad$ 排空阶段</p><p>$\quad$ $\quad$ 指数降低发送速率（相当于是startup的逆过程），将多占的数据慢慢排空<img src="/../CNP/CN713.png"></p><p>$\quad$ 瓶颈带宽探测（PROBE_BW）</p><p>$\quad$ $\quad$ 进入稳定状态后, 先在一个RTT内增加发送速率，探测最大带宽</p><p>$\quad$ $\quad$ 如果RTT增大（发生排队），再减小发送速率，排空前一个RTT多发出来的包</p><p>$\quad$ $\quad$ 后面6个RTT使用更新后的估计带宽发送<img src="/../CNP/CN714.png"></p><p>$\quad$ 时延探测</p><p>$\quad$ $\quad$ 每过10秒且RTT未更新，就进入RTprop探测阶段</p><p>$\quad$ $\quad$ 在这段占200ms(全过程2%的时间内)，cwnd固定为4个包</p><p>$\quad$ $\quad$ 测得的RTprop作为基准，在瓶颈带宽探测阶段判断是否发生排队</p><p>$\quad$ $\quad$ 为抵消此阶段牺牲的发送速率，延迟探测后快速增加发送速率，保障瓶颈带宽观测<img src="/../CNP/CN715.png"></p><p><strong>BBR状态机</strong></p><p><img src="/../CNP/CN716.png"></p><h4 id="DCTCP"><a href="#DCTCP" class="headerlink" title="DCTCP"></a>DCTCP</h4><p>$\quad$ 针对数据中心的TCP拥塞控制算法</p><h6 id="数据中心的流量特点"><a href="#数据中心的流量特点" class="headerlink" title="数据中心的流量特点"></a>数据中心的流量特点</h6><p><img src="/../CNP/CN717.png"></p><h6 id="数据中心的性能问题"><a href="#数据中心的性能问题" class="headerlink" title="数据中心的性能问题"></a>数据中心的性能问题</h6><p><strong>1.Incast</strong></p><p>$\quad$ 在一个很短的时间内，大量流量同时到达交换机的一个端口，导致缓冲区被占满，最终导致丢包</p><p>$\quad$ 在并发流量很大的情况下，即使每条流的包很小，也会产生Incast问题</p><p><img src="/../CNP/CN718.png"></p><p><strong>2. Queue Buildup</strong></p><p>$\quad$ 长流和短流同时通过交换机的同一个端口时，由于长流占用较多的缓冲区空间，导致短流延迟增大，甚至丢包</p><p><strong>3. Buffer Pressure</strong></p><p>$\quad$ 交换机的不同端口通常共享同一块缓冲区，即使长流和短流通过不同的端口，短流通过的端口也会出现缓冲区不足的问题</p><p><img src="/CNP/CN719.png"></p><h6 id="数据中心协议要求"><a href="#数据中心协议要求" class="headerlink" title="数据中心协议要求"></a>数据中心协议要求</h6><p>$\quad$ 容忍高突发流量</p><p>$\quad$ $\quad$ 在Partition&#x2F;Aggregate通信模式中，所有Worker几乎会在同一时间向Aggregator返回执行结果，产生很高的突发流量</p><p>$\quad$ 低时延</p><p>$\quad$ $\quad$ 数据中心有大量时延敏感的短流，如网页搜索等</p><p>$\quad$ 高吞吐</p><p>$\quad$ $\quad$ 数据中心有大量吞吐敏感的长流，如文件传输、分布式机器学习中神经网络模型参数的传输等</p><h5 id="DCTCP-1"><a href="#DCTCP-1" class="headerlink" title="DCTCP"></a>DCTCP</h5><h6 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h6><p>$\quad$ 根据网络拥塞程度精细地减小发送窗口：</p><p>$\quad$ $\quad$ 一旦发现拥塞，发送窗口减至原窗口的（1-α&#x2F;2），α 反映了拥塞程度</p><p>$\quad$ $\quad$ 传统TCP中 α总为1</p><p>$\quad$ 拥塞程度的衡量：ECN标记（explicit congestion notification）</p><p>$\quad$ $\quad$ 当交换机队列的瞬时长度超过某个阈值时，交换机在报文头设置ECN标记</p><p>$\quad$ $\quad$ 使用显式的拥塞反馈能够更好地控制突发流量</p><h6 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h6><p>$\quad$ 交换机</p><p>$\quad$ $\quad$ 当队列长度超过K时，给随后到来的包标记ECN</p><p>$\quad$ 接收端</p><p>$\quad$ $\quad$ 仅当ECN报文出现或消失时才立即发送ACK，否则采取Delay ACK的策略<img src="/../CNP/CN720.png"></p><p>$\quad$ 发送端</p><p>$\quad$ $\quad$ 每个RTT更新一次发送窗口</p><p>$\quad$ $\quad$ α←(1-g)α+αF，这个值反应了拥塞程度</p><p>$\quad$ $\quad$ 其中F&#x3D;(# of marked ACKs)&#x2F;(Total # of ACKs)</p><p>$\quad$ $\quad$ Cwnd←(1-α&#x2F;2)∗Cwnd</p><h6 id="和TCP比较"><a href="#和TCP比较" class="headerlink" title="和TCP比较"></a>和TCP比较</h6><p>$\quad$ 交换机中的队列长度：</p><p>$\quad$ $\quad$ DCTCP能将队列长度稳定地维持在一个很低的水平</p><p>$\quad$ $\quad$ 而TCP的队列长度不仅高，而且波动很大</p><p>$\quad$ 因此，DCTCP更适用于现代数据中心</p><p><img src="/../CNP/CN721.png"></p><h6 id="为什么DCTCP能取得良好性能"><a href="#为什么DCTCP能取得良好性能" class="headerlink" title="为什么DCTCP能取得良好性能"></a>为什么DCTCP能取得良好性能</h6><p>$\quad$ 容忍高突发流量</p><p>$\quad$ $\quad$ DCTCP维持了较低的队列长度，可以留出较大的缓冲区给突发流量</p><p>$\quad$ $\quad$ 采用标记策略，使得发送端在丢包之前就感知到拥塞</p><p>$\quad$ 低时延</p><p>$\quad$ $\quad$ 由于队列长度较短，也减少了包在队列中的排队时延</p><p>$\quad$ 高吞吐</p><p>$\quad$ $\quad$ DCTCP根据拥塞程度精确调节窗口，使得发送窗口的变化比较平滑，不会出现吞吐量骤降的情形</p><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>CN</category>
      
      <category>传输层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CN</tag>
      
      <tag>传输层</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>传输层 -连接管理，流量控制，拥塞控制</title>
    <link href="/2023/10/31/%E4%BC%A0%E8%BE%93%E5%B1%82%20-%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86%EF%BC%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%EF%BC%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"/>
    <url>/2023/10/31/%E4%BC%A0%E8%BE%93%E5%B1%82%20-%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86%EF%BC%8C%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%EF%BC%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p> 对应 北京大学计算机网络课程第三讲第三部分<br> 参考教材计算机网络-自顶向下方法</p><span id="more"></span><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="传输层-连接管理，流量控制，拥塞控制"><a href="#传输层-连接管理，流量控制，拥塞控制" class="headerlink" title="传输层 -连接管理，流量控制，拥塞控制"></a>传输层 -连接管理，流量控制，拥塞控制</h2><p><img src="/../CNP/CN601.png"></p><h3 id="TCP报文格式"><a href="#TCP报文格式" class="headerlink" title="TCP报文格式"></a>TCP报文格式</h3><h4 id="TCP报文段结构"><a href="#TCP报文段结构" class="headerlink" title="TCP报文段结构"></a>TCP报文段结构</h4><p><img src="/../CNP/CN602.png"></p><h4 id="重要的TCP选项"><a href="#重要的TCP选项" class="headerlink" title="重要的TCP选项"></a>重要的TCP选项</h4><p>$\quad$ 最大段长度（MSS）：</p><p>$\quad$ $\quad$ TCP段(segment)中可以携带的最大数据字节数</p><p>$\quad$ $\quad$ 建立连接时，每个主机可声明自己能够接受的MSS</p><p>$\quad$ $\quad$ 通常以太网：1460字节</p><p>$\quad$ $\quad$ $\quad$ 若对端没有声明，根据网络层类型设置：IPv4缺省值536字节，IPv6缺省值1220</p><p>$\quad$ 窗口比例因子（window scale）：</p><p>$\quad$ $\quad$ 建立连接时，双方可以协商一个窗口比例因子</p><p>$\quad$ $\quad$ 实际接收窗口大小 &#x3D; window size * 2^window scale</p><p>$\quad$ 选择确认（SACK）：</p><p>$\quad$ $\quad$ 最初的TCP协议只使用累积确认</p><p>$\quad$ $\quad$ 改进的TCP协议引入选择确认，允许接收端指出缺失的数据字节</p><h4 id="发送序号和确认序号"><a href="#发送序号和确认序号" class="headerlink" title="发送序号和确认序号"></a>发送序号和确认序号</h4><p><img src="/../CNP/CN603.png"></p><h3 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h3><p>$\quad$ 建立一条TCP连接需要确定两件事：</p><p>$\quad$ $\quad$ 双方都同意建立连接（知晓另一方想建立连接）</p><p>$\quad$ $\quad$ 初始化连接参数（序号，MSS等）</p><h5 id="两次握手建立连接"><a href="#两次握手建立连接" class="headerlink" title="两次握手建立连接"></a>两次握手建立连接</h5><p>$\quad$ 问题:</p><p>$\quad$ $\quad$ 在网络中，2次握手总是可行的吗？</p><p>$\quad$ 在一个不可靠的网络中，总会有一些意外发生：</p><p>$\quad$ $\quad$ 包传输延迟变化很大</p><p>$\quad$ $\quad$ 存在重传的报文段</p><p>$\quad$ $\quad$ 存在报文重排序</p><p><img src="/../CNP/CN604.png"></p><h5 id="三次握手建立连接"><a href="#三次握手建立连接" class="headerlink" title="三次握手建立连接"></a>三次握手建立连接</h5><p><img src="/../CNP/CN605.png"></p><p>$\quad$ 1.客户TCP发送SYN 报文段（SYN&#x3D;1, ACK&#x3D;0）</p><p>$\quad$ $\quad$ 给出客户选择的起始序号</p><p>$\quad$ $\quad$ 不包含数据</p><p>$\quad$ 2.服务器TCP发送SYNACK报文段（SYN&#x3D;ACK&#x3D;1）（服务器端分配缓存和变量）</p><p>$\quad$ $\quad$ 给出服务器选择的起始序号</p><p>$\quad$ $\quad$ 确认客户的起始序号</p><p>$\quad$ $\quad$ 不包含数据</p><p>$\quad$ 3.客户发送ACK报文段（SYN&#x3D;0，ACK&#x3D;1）（客户端分配缓存和变量）</p><p>$\quad$ $\quad$ 确认服务器的起始序号</p><p>$\quad$ $\quad$ 可能包含数据</p><h6 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h6><p><img src="/../CNP/CN606.png"></p><h6 id="避免失败情形"><a href="#避免失败情形" class="headerlink" title="避免失败情形"></a>避免失败情形</h6><p><img src="/../CNP/CN607.png"></p><h5 id="如何选择起始序号"><a href="#如何选择起始序号" class="headerlink" title="如何选择起始序号"></a>如何选择起始序号</h5><p>$\quad$ 为什么起始序号不从0开始？</p><p>$\quad$ $\quad$ 若在不同的时间、在同一对套接字之间建立了连接，则新、旧连接上的序号有重叠，旧连接上重传的报文段会被误以为是新连接上的报文段</p><p>$\quad$ 可以随机选取起始序号吗？</p><p>$\quad$ $\quad$ 若在不同的时间、在同一对套接字之间建立了连接，且新、旧连接上选择的起始序号x和y相差不大，那么新、旧连接上传输的序号仍然可能重叠</p><p>$\quad$ 结论：必须避免新、旧连接上的序号产生重叠</p><h6 id="基于时钟的起始序号选取算法"><a href="#基于时钟的起始序号选取算法" class="headerlink" title="基于时钟的起始序号选取算法"></a>基于时钟的起始序号选取算法</h6><p>$\quad$ 每个主机使用一个时钟，以二进制计数器的形式工作，每隔ΔT时间计数器加1</p><p>$\quad$ 新建一个连接时，以本地计数器值的最低32位作为起始序号</p><p>$\quad$ 该方法确保连接的起始序号随时间单调增长</p><p>$\quad$ ΔT取较小的值（4微秒）：</p><p>$\quad$ $\quad$ 确保发送序号的增长速度，不会超过起始序号的增长速度</p><p>$\quad$ 使用较长的字节序号（32位）：</p><p>$\quad$ $\quad$ 确保序号回绕的时间远大于分组在网络中的最长寿命</p><h5 id="关闭TCP连接"><a href="#关闭TCP连接" class="headerlink" title="关闭TCP连接"></a>关闭TCP连接</h5><p>$\quad$ 客户端、服务器都可以主动关闭连接</p><p>$\quad$ $\quad$ 通过在TCP segment中设置FIN bit &#x3D; 1</p><p>$\quad$ FIN消息需要被确认</p><p>$\quad$ $\quad$ 一旦发送FIN，就不能再发送数据，只能接收数据</p><p>$\quad$ $\quad$ 一旦收到对方的FIN之后，知道对方不再发送消息，可以在己方数据发送完后安全关闭</p><p>$\quad$ 四次握手过程：</p><p>$\quad$ $\quad$ 2端各自发送FIN，也各自确认对方的FIN</p><p>$\quad$ 优化：</p><p>$\quad$ $\quad$ FIN与ACK可以一起发送</p><p><img src="/../CNP/CN608.png"></p><h6 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h6><p>$\quad$ 丢包：4次握手均可能丢包</p><p>$\quad$ $\quad$ 处理方式：重传</p><p>$\quad$ 客户端或者服务器端下线</p><p>$\quad$ $\quad$ 另一端不断重试</p><p>$\quad$ $\quad$ 重试失败若干次后：(取决于操作系统实现）</p><p>$\quad$ $\quad$ 放弃连接，or 等待重新建立连接</p><h6 id="状态机-1"><a href="#状态机-1" class="headerlink" title="状态机"></a>状态机</h6><p><img src="/../CNP/CN609.png"></p><h5 id="握手协议的安全隐患"><a href="#握手协议的安全隐患" class="headerlink" title="握手协议的安全隐患"></a>握手协议的安全隐患</h5><h6 id="SYN洪范攻击"><a href="#SYN洪范攻击" class="headerlink" title="SYN洪范攻击"></a>SYN洪范攻击</h6><p>$\quad$ TCP实现的问题：</p><p>$\quad$ $\quad$ 服务器在收到SYN段后，发送SYNACK段，分配资源</p><p>$\quad$ $\quad$ 若未收到ACK段，服务器超时后重发SYNACK段</p><p>$\quad$ $\quad$ 服务器等待一段时间（称SYN超时）后丢弃未完成的连接，SYN超时的典型值为30秒~120秒</p><p>$\quad$ SYN洪泛攻击：</p><p>$\quad$ $\quad$ 攻击者采用伪造的源IP地址，向服务器发送大量的SYN段，却不发送ACK段</p><p>$\quad$ $\quad$ 服务器为维护一个巨大的半连接表耗尽资源，导致无法处理正常客户的连接请求，表现为服务器停止服务</p><h6 id="TCP端口扫描"><a href="#TCP端口扫描" class="headerlink" title="TCP端口扫描"></a>TCP端口扫描</h6><p>$\quad$ TCP端口扫描的原理：</p><p>$\quad$ $\quad$ 扫描程序依次与目标机器的各个端口进行TCP通信</p><p>$\quad$ $\quad$ 根据获得的响应来收集目标机器信息</p><p>$\quad$ SYN扫描：发送端向目标端口发送SYN报文段</p><p>$\quad$ $\quad$ 若收到SYNACK段，表明目标端口上有服务在运行</p><p>$\quad$ $\quad$ 若收到RST段，表明目标端口上没有服务在运行</p><p>$\quad$ $\quad$ 若什么也没收到，表明路径上有防火墙，有些防火墙会丢弃来自外网的SYN报文段</p><p>$\quad$ FIN扫描：试图绕过防火墙，发送端向目标端口发送FIN报文段</p><p>$\quad$ $\quad$ 若收到ACK&#x3D;1、RST&#x3D;1的TCP段，表明目标端口上没有服务在监听</p><p>$\quad$ $\quad$ 若没有响应，表明有服务在监听（RFC 973的规定）</p><p>$\quad$ $\quad$ 有些系统的实现不符合RFC 973规定，如在Microsoft的TCP实现中，总是返回ACK&#x3D;1、RST&#x3D;1的TCP段</p><h3 id="TCP流量控制"><a href="#TCP流量控制" class="headerlink" title="TCP流量控制"></a>TCP流量控制</h3><p>$\quad$ TCP接收端有一个接收缓存：</p><p>$\quad$ $\quad$ 接收端TCP将收到的数据放入接收缓存</p><p>$\quad$ $\quad$ 应用进程从接收缓存中读数据</p><p>$\quad$ $\quad$ 进入接收缓存的数据不一定被立即取走、取完</p><p>$\quad$ $\quad$ 如果接收缓存中的数据未及时取走，后续到达的数据可能会因缓存溢出而丢失</p><p>$\quad$ 流量控制：</p><p>$\quad$ $\quad$ 发送端TCP通过调节发送速率，不使接收端缓存溢出</p><p><img src="/../CNP/CN610.png"></p><h5 id="不需要流量控制的情况"><a href="#不需要流量控制的情况" class="headerlink" title="不需要流量控制的情况"></a>不需要流量控制的情况</h5><p>$\quad$ UDP不保证交付：</p><p>$\quad$ $\quad$ 接收端UDP将收到的报文载荷放入接收缓存</p><p>$\quad$ $\quad$ 应用进程每次从接收缓存中读取一个完整的报文载荷</p><p>$\quad$ $\quad$ 当应用进程消费数据不够快时，接收缓存溢出，报文数据丢失，UDP不负责任</p><p>$\quad$ 因此，UDP不需要流量控制</p><p>$\quad$ 为什么前一节课讨论GBN与SR时不需要流量控制？</p><p>$\quad$ $\quad$ 在GBN与SR中，我们假设“正确、按序到达的分组被立即交付给上层”</p><p>$\quad$ $\quad$ 因此发送方根据确认序号就可以知道哪些分组已经被移出接收窗口</p><p>$\quad$ $\quad$ 但是，现实中的TCP：收到的数据等待应用程序读取</p><h5 id="接收窗口"><a href="#接收窗口" class="headerlink" title="接收窗口"></a>接收窗口</h5><p>$\quad$ 接收缓存中的可用空间称为接收窗口：</p><p>$\quad$ $\quad$ RcvWindow &#x3D;RcvBuffer-(LastByteRcvd - LastByteRead)</p><p>$\quad$ 接收方将RcvWindow放在报头中，向发送方通告接收缓存的可用空间</p><p>$\quad$ 发送方限制未确认的字节数不超过接收窗口的大小，即：</p><p>$\quad$ $\quad$ LastByteSent-LastByteAcked ≦ RcvWindow</p><p>特别是，当接收方通告接收窗口为0时，发送方必须停止发送</p><p><img src="/../CNP/CN611.png"></p><h6 id="非零窗口通告"><a href="#非零窗口通告" class="headerlink" title="非零窗口通告"></a>非零窗口通告</h6><p>$\quad$ 发送方&#x2F;接收方对零窗口的处理：</p><p>$\quad$ $\quad$ 发送方：当接收窗口为0时，发送方必须停止发送</p><p>$\quad$ $\quad$ 接收方：当接收窗口变为非0时，接收方应通告增大的接收窗口</p><p>$\quad$ 在TCP协议中，触发一次TCP传输需要满足以下三个条件之一：</p><p>$\quad$ $\quad$ 应用程序调用</p><p>$\quad$ $\quad$ 超时</p><p>$\quad$ $\quad$ 收到数据</p><p>$\quad$ 对于接收方，只有第三个条件能触发传输</p><p>$\quad$ 问题：当发送方停止发送后，接收方不再收到数据，如何触发接收端发送“非零窗口通告”呢？</p><p>$\quad$ TCP协议规定：</p><p>$\quad$ $\quad$ 发送方收到“零窗口通告”后，可以发送“零窗口探测”报文段</p><p>$\quad$ $\quad$ 从而接收方可以发送包含接收窗口的响应报文段</p><h6 id="零窗口探测的实现"><a href="#零窗口探测的实现" class="headerlink" title="零窗口探测的实现"></a>零窗口探测的实现</h6><p>$\quad$ 发送端收到零窗口通告时，启动一个坚持定时器（Persistent Timer）</p><p>$\quad$ 定时器超时后，发送端发送一个零窗口探测报文段（序号为上一个段中最后一个字节的序号）</p><p>$\quad$ 接收端在响应的报文段中通告当前接收窗口的大小</p><p>$\quad$ 若发送端仍收到零窗口通告，重新启动坚持定时器</p><h6 id="糊涂窗口综合症"><a href="#糊涂窗口综合症" class="headerlink" title="糊涂窗口综合症"></a>糊涂窗口综合症</h6><p>$\quad$ 当数据的发送速度很快、而消费速度很慢时，零窗口探测的简单实现带来以下问题：</p><p>$\quad$ $\quad$ 接收方不断发送微小窗口通告</p><p>$\quad$ $\quad$ 发送方不断发送很小的数据分组</p><p>$\quad$ $\quad$ 大量带宽被浪费</p><p>$\quad$ 解决方案：</p><p>$\quad$ $\quad$ 接收方启发式策略</p><p>$\quad$ $\quad$ 发送方启发式策略</p><p><img src="/../CNP/CN612.png"></p><p><strong>接收方策略</strong></p><p>$\quad$ Clark策略：</p><p>$\quad$ $\quad$ 通告零窗口之后，仅当窗口大小显著增加之后才发送更新的窗口通告</p><p>$\quad$ $\quad$ $\quad$ 即窗口较小时，一直反馈零窗口</p><p>$\quad$ $\quad$ 什么是显著增加：窗口大小达到缓存空间的一半或者一个MSS，取两者的较小值</p><p>$\quad$ 与推迟确认结合：</p><p>$\quad$ $\quad$ 推迟发送ACK（但最多推迟500ms，且至少每隔一个报文段使用正常方式进行确认）</p><p>$\quad$ $\quad$ 寄希望于推迟间隔内有更多数据被消费</p><p><strong>发送方策略</strong></p><p>$\quad$ 发送方避免糊涂窗口综合症的策略：</p><p>$\quad$ $\quad$ 发送方应积聚足够多的数据再发送，以防止发送太短的报文段</p><p>$\quad$ 问题：发送方应等待多长时间？</p><p>$\quad$ $\quad$ 若等待时间不够，报文段会太短</p><p>$\quad$ $\quad$ 若等待时间过久，应用程序的时延会太长</p><p>$\quad$ $\quad$ 更重要的是，TCP不知道应用程序会不会在最近的将来生成更多的数据</p><p>$\quad$ Nagle算法的解决方法：</p><p>$\quad$ $\quad$ 在新建连接上，当应用数据到来时，组成一个TCP段发送（那怕只有一个字节）</p><p>$\quad$ $\quad$ 如果有未确认数据，后续到来的数据放在发送缓存中</p><p>$\quad$ $\quad$ 当（1）数据量达到一个MSS且窗口大小大于等于MSS，或（2）收到所有已发数据的确认</p><p>$\quad$ $\quad$ 用一个TCP段将缓存的字节全部发走</p><p>$\quad$ Nagle算法的优点：</p><p>$\quad$ $\quad$ 适应网络延时、MSS长度、发送方速度的各种组合</p><p>$\quad$ $\quad$ 常规情况下不会降低网络的吞吐量</p><p>$\quad$ Nagle算法缺点：</p><p>$\quad$ $\quad$ 增加延迟，尤其与延迟确认共同使用时</p><p>$\quad$ $\quad$ 不考虑接收端是否真的消费了数据</p><h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><h5 id="网络拥塞"><a href="#网络拥塞" class="headerlink" title="网络拥塞"></a>网络拥塞</h5><p>$\quad$ 起因：大量分组短时间内进入网络，超出网络的处理能力</p><p>$\quad$ 表现：分组延迟增大，网络吞吐量下降，甚至降为0</p><p>$\quad$ 措施：减少分组进入网络（拥塞控制）</p><p>$\quad$ $\quad$ 流量控制：限制发送速度，使不超过接收端的处理能力</p><p>$\quad$ $\quad$ 拥塞控制：限制发送速度，使不超过网络的处理能力</p><h6 id="后果"><a href="#后果" class="headerlink" title="后果"></a>后果</h6><p>$\quad$ 网络拥塞造成：</p><p>$\quad$ $\quad$ 丢包：由路由器缓存溢出造成</p><p>$\quad$ $\quad$ 分组延迟增大：链路接近满载造成</p><p>$\quad$ 大量网络资源用于：</p><p>$\quad$ $\quad$ 重传丢失的分组</p><p>$\quad$ $\quad$ （不必要地）重传延迟过大的分组</p><p>$\quad$ $\quad$ 转发最终被丢弃的分组</p><p>$\quad$ 结果：进入网络的负载很重，网络吞吐量却很低</p><h6 id="控制拥塞的常用方法"><a href="#控制拥塞的常用方法" class="headerlink" title="控制拥塞的常用方法"></a>控制拥塞的常用方法</h6><p>$\quad$ 网络辅助的拥塞控制</p><p>$\quad$ $\quad$ 路由器向端系统提供显式的反馈，例如：</p><p>$\quad$ $\quad$ $\quad$ 设置拥塞指示比特</p><p>$\quad$ $\quad$ $\quad$ 给出发送速率指示</p><p>$\quad$ $\quad$ ATM、X.25采用此类方法</p><p>$\quad$ $\quad$ 现代TCP变种，也会利用网络内部反馈（Explicit Congestion Notification，ECN）进行控制</p><p>$\quad$ 端到端拥塞控制</p><p>$\quad$ $\quad$ 网络层不向端系统提供反馈</p><p>$\quad$ $\quad$ 端系统通过观察丢包和延迟，自行推断拥塞的发生</p><p>$\quad$ $\quad$ 传统TCP采用此类方法</p><h4 id="要解决的问题"><a href="#要解决的问题" class="headerlink" title="要解决的问题"></a>要解决的问题</h4><p>$\quad$ TCP使用端到端拥塞控制机制：</p><p>$\quad$ $\quad$ 发送方根据自己感知的网络拥塞程度，限制其发送速率</p><p>$\quad$ 需要回答三个问题：</p><h5 id="1-发送方如何感知网络拥塞？"><a href="#1-发送方如何感知网络拥塞？" class="headerlink" title="1.发送方如何感知网络拥塞？"></a>1.发送方如何感知网络拥塞？</h5><p>$\quad$ 发送方利用丢包事件感知拥塞：</p><p>$\quad$ $\quad$ 拥塞造成丢包和分组延迟增大</p><p>$\quad$ $\quad$ 无论是实际丢包还是分组延迟过大，对于发送端来说都是丢包了</p><p>$\quad$ 丢包事件包括：</p><p>$\quad$ $\quad$ 重传定时器超时</p><p>$\quad$ $\quad$ 发送端收到3个重复的ACK</p><h5 id="2-发送方采用什么机制来限制发送速率？"><a href="#2-发送方采用什么机制来限制发送速率？" class="headerlink" title="2.发送方采用什么机制来限制发送速率？"></a>2.发送方采用什么机制来限制发送速率？</h5><p>$\quad$ 发送方使用拥塞窗口cwnd限制已发送未确认的数据量:</p><p>LastByteSent-LastByteAcked &lt;&#x3D; cwnd</p><p>$\quad$ cwnd随发送方感知的网络拥塞程度而变化</p><p>$\quad$ 注意：发送方还需要满足（流量控制）</p><p>$\quad$ LastByteSent-LastByteAcked &lt;&#x3D; RcvWindow</p><h5 id="3-发送方感知到网络拥塞后，采取什么策略调节发送速率？"><a href="#3-发送方感知到网络拥塞后，采取什么策略调节发送速率？" class="headerlink" title="3.发送方感知到网络拥塞后，采取什么策略调节发送速率？"></a>3.发送方感知到网络拥塞后，采取什么策略调节发送速率？</h5><p>$\quad$ 总体思路：AIMD</p><p>$\quad$ 乘性减（Multiplicative Decrease）</p><p>$\quad$ $\quad$ 发送方检测到丢包后，将cwnd的大小减半（但不能小于一个MSS）</p><p>$\quad$ $\quad$ 目的：迅速减小发送速率，缓解拥塞</p><p>$\quad$ 加性增（Additive Increase）</p><p>$\quad$ $\quad$ 若无丢包，每经过一个RTT，将cwnd增大一个MSS，直到检测到丢包</p><p>$\quad$ $\quad$ 目的：缓慢增大发送速率，避免振荡</p><p><img src="/../CNP/CN613.png"></p><p>$\quad$ 原则1：正常收到ACK确认意味网络运作良好</p><p>$\quad$ $\quad$ 考虑增大cwnd</p><p>$\quad$ $\quad$ 根据当前cwnd值的大小，可以选择不同的策略</p><p>$\quad$ $\quad$ $\quad$ cwnd较小时，可以激进地增大</p><p>$\quad$ $\quad$ $\quad$ cwnd较大时，可以较为保守</p><p>$\quad$ 原则2：丢包（收到3个重复ACK或超时），意味网络状态较差，考虑降低cwnd</p><p>$\quad$ 实际的拥塞策略由慢启动、拥塞避免、快速恢复3部分组成，近似实现AIMD</p><h6 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h6><p>$\quad$ 当cwnd较小时以什么速率发送数据?</p><p>$\quad$ $\quad$ 如：新建的连接</p><p>$\quad$ 在新建连接上，令cwnd &#x3D; 1 MSS，起始速度&#x3D; MSS&#x2F;RTT</p><p>$\quad$ 采用“加性增”增大发送窗口，太慢！</p><p>$\quad$ $\quad$ 理由：网络中的可用带宽可能远大于MSS&#x2F;RTT</p><p>$\quad$ 慢启动的基本思想：</p><p>$\quad$ $\quad$ 在新建连接上指数增大cwnd</p><p>$\quad$ $\quad$ 直至检测到丢包 or 达到足够大发送速率（此时终止慢启动）</p><p>$\quad$ 慢启动的思想：</p><p>$\quad$ $\quad$ 每经过一个RTT，将cwnd加倍</p><p>$\quad$ 慢启动的具体实施：</p><p>$\quad$ $\quad$ 每收到一个ACK段，cwnd增加一个MSS（大致等价于每个RTT加倍）</p><p>$\quad$ $\quad$ 只要发送窗口允许，发送端可以立即发送下一个报文段</p><p>$\quad$ 特点：</p><p>$\quad$ $\quad$ 以一个很低的速率开始，按指数增大发送速率</p><p>$\quad$ 慢启动比谁“慢”？</p><p>$\quad$ $\quad$ 与无拥塞控制TCP按接收窗口发送数据的策略相比，采用慢启动后发送速率的增长较慢</p><p>$\quad$ 慢启动指数增长到一定程度后，进入拥塞避免阶段</p><p><img src="/../CNP/CN614.png"></p><h6 id="拥塞避免"><a href="#拥塞避免" class="headerlink" title="拥塞避免"></a>拥塞避免</h6><p>$\quad$ 当cwnd增大到一定程度时，此时距离拥塞可能并不遥远</p><p>$\quad$ $\quad$ 继续指数增长，容易导致拥塞</p><p>$\quad$ 解决方案：将指数增长改为线性增长</p><p>$\quad$ $\quad$ 实现：每当收到ACK， cwnd&#x3D;cwnd + MSSx(MSS&#x2F;cwnd)</p><p>$\quad$ $\quad$ 例子：MSS &#x3D; 1460字节，cwnd &#x3D; 14600字节</p><p>$\quad$ $\quad$ $\quad$ 收到第一个ACK，cwnd增加1&#x2F;10 x MSS</p><p>$\quad$ $\quad$ $\quad$ 收到10个ACK后，cwnd大约增加MSS</p><p>$\quad$ 区分慢启动与拥塞避免：维护ssthresh阈值变量</p><p>$\quad$ $\quad$ 当cwnd &lt; ssthresh，为慢启动阶段， cwnd指数增长</p><p>$\quad$ $\quad$ 当cwnd &gt;&#x3D; ssthresh，为拥塞避免阶段，cwnd线性增长</p><p>$\quad$ $\quad$ ssthresh与cwnd一样，也根据网络状态动态调整</p><p>$\quad$ 拥塞避免仍然不断增大cwnd</p><p>$\quad$ $\quad$ 尽管只是线性增长</p><p>$\quad$ 最终，cwnd超过网络可用带宽，进入拥塞状态（以丢包为标志）</p><h6 id="区别不同的个丢包事件"><a href="#区别不同的个丢包事件" class="headerlink" title="区别不同的个丢包事件"></a>区别不同的个丢包事件</h6><p>$\quad$ 丢包的两种情况</p><p>$\quad$ $\quad$ 发送端计时器超时（可靠传输中超时重传）</p><p>$\quad$ $\quad$ 发送端收到3个重复ACK（可靠传输中快速重传）</p><p>$\quad$ 无论慢启动阶段还是拥塞避免阶段，都可能遇到丢包</p><p>$\quad$ $\quad$ 需要更新cwnd，以及ssthresh</p><p>$\quad$ $\quad$ 甚至更改cwnd的计算策略</p><p>$\quad$ 超时和收到3个重复的ACK，它们反映出来的网络拥塞程度是一样的吗？</p><p>$\quad$ $\quad$ 当然不一样！</p><p>$\quad$ $\quad$ 超时：说明网络传输能力很差</p><p>$\quad$ $\quad$ 收到3个重复的ACK：说明网络仍有一定的传输能力</p><p>$\quad$ 因此，可以采用不同的方式处理超时与3个重复ACK</p><h6 id="TCP-Tahoe-amp-TCP-Reno"><a href="#TCP-Tahoe-amp-TCP-Reno" class="headerlink" title="TCP Tahoe &amp; TCP Reno"></a>TCP Tahoe &amp; TCP Reno</h6><p>$\quad$ 1988年，TCP Tahoe 提出了 (1) 慢启动、(2) 拥塞避免、(3) 3个重复ACK判断丢包</p><p>$\quad$ $\quad$ 不区分收到3个重复ACK与超时，两种情况都重新开始慢启动</p><p>$\quad$ 1990年，TCP Reno (RFC 5681) 在 Tahoe 的基础上增加了 (4) 快速恢复</p><p>$\quad$ $\quad$ 收到3个重复的ACK：进入快速恢复阶段</p><p>$\quad$ $\quad$ $\quad$ 将ssthresh降低至cwnd&#x2F;2</p><p>$\quad$ $\quad$ $\quad$ 将cwnd降至当前cwnd&#x2F;2+3</p><p>$\quad$ $\quad$ $\quad$ 采用新机制调节cwnd，直到再次进入慢启动或拥塞避免阶段</p><p>$\quad$ $\quad$ 超时：重新开始慢启动</p><p>$\quad$ $\quad$ $\quad$ 将ssthresh降低至cwnd&#x2F;2</p><p>$\quad$ $\quad$ $\quad$ 将cwnd&#x3D;1MSS</p><p>$\quad$ $\quad$ $\quad$ 使用慢启动增大cwnd至ssthresh</p><p><strong>无快速重传：TCP Tahoe</strong></p><p>$\quad$ 初始cwnd&#x3D;10</p><p><img src="/../CNP/CN615.png"></p><p><strong>有快速重传：TCP Reno</strong></p><p>$\quad$ 初始cwnd&#x3D;10</p><p>$\quad$ 快速重传阶段：</p><p>$\quad$ $\quad$ cwnd增长比拥塞避免阶段快</p><p>$\quad$ $\quad$ 目的：能够发送新数据</p><p><img src="/../CNP/CN616.png"></p><h6 id="快速恢复"><a href="#快速恢复" class="headerlink" title="快速恢复"></a>快速恢复</h6><p>$\quad$ 注意：当收到3个重复ACK时，才进入快速恢复阶段</p><p>$\quad$ $\quad$ 此时cwnd比ssthresh大3</p><p>$\quad$ 情形1：继续收到该重复ACK</p><p>$\quad$ $\quad$ 每次将cwnd增加1个MSS</p><p>$\quad$ 情形2：收到新ACK</p><p>$\quad$ $\quad$ 降低cwnd至ssthresh</p><p>$\quad$ $\quad$ 进入拥塞避免阶段</p><p>$\quad$ 情形3：超时</p><p>$\quad$ $\quad$ 和之前一样</p><h4 id="TCP拥塞控制状态"><a href="#TCP拥塞控制状态" class="headerlink" title="TCP拥塞控制状态"></a>TCP拥塞控制状态</h4><h5 id="事件与动作"><a href="#事件与动作" class="headerlink" title="事件与动作"></a>事件与动作</h5><p><img src="/../CNP/CN617.png"></p><h5 id="状态机-2"><a href="#状态机-2" class="headerlink" title="状态机"></a>状态机</h5><p><img src="/../CNP/CN618.png"></p><h4 id="TCP连接的吞吐量"><a href="#TCP连接的吞吐量" class="headerlink" title="TCP连接的吞吐量"></a>TCP连接的吞吐量</h4><p>$\quad$ 忽略慢启动阶段（该阶段时间很短），只考虑拥塞避免+快速恢复阶段</p><p>$\quad$ $\quad$ 近似AIMD过程</p><p>$\quad$ 令W&#x3D;发生丢包时的拥塞窗口，此时有：</p><p>$\quad$ $\quad$ throughput &#x3D; W&#x2F;RTT</p><p>$\quad$ 发生丢包后调整 cwnd&#x3D;W&#x2F;2（忽略+3），此时有：</p><p>$\quad$ $\quad$ throughput&#x3D;W&#x2F;2RTT</p><p>$\quad$ 假设在TCP连接的生命期内，RTT 和 W几乎不变，有：</p><p>$\quad$ $\quad$ Average throughout&#x3D;0.75 W&#x2F;RTT</p><p><img src="/../CNP/CN619.png"></p><h4 id="TCP的公平性"><a href="#TCP的公平性" class="headerlink" title="TCP的公平性"></a>TCP的公平性</h4><p>$\quad$ 公平性目标:</p><p>$\quad$ $\quad$ 如果K条TCP连接共享某条带宽为R的瓶颈链路，每条连接应具有平均速度R&#x2F;K</p><p><img src="/../CNP/CN620.png"></p><h6 id="TCP的公平性，来自于AIMD"><a href="#TCP的公平性，来自于AIMD" class="headerlink" title="TCP的公平性，来自于AIMD"></a>TCP的公平性，来自于AIMD</h6><p><img src="/../CNP/CN622.png"></p><p><img src="/../CNP/CN626.png"></p><p><img src="/../CNP/CN625.png"></p><p><img src="/../CNP/CN623.png"></p><p><img src="/../CNP/CN624.png"></p><h6 id="为什么TCP是公平的"><a href="#为什么TCP是公平的" class="headerlink" title="为什么TCP是公平的"></a>为什么TCP是公平的</h6><p>$\quad$ 考虑两条竞争的连接（各种参数相同）共享带宽为R的链路:</p><p>$\quad$ $\quad$ 加性增：连接1和连接2按照相同的速率增大各自的拥塞窗口，得到斜率为1的直线</p><p>$\quad$ $\quad$ 乘性减：连接1和连接2将各自的拥塞窗口减半</p><p><img src="/../CNP/CN621.png"></p><h6 id="更复杂的情形"><a href="#更复杂的情形" class="headerlink" title="更复杂的情形"></a>更复杂的情形</h6><p>$\quad$ 若相互竞争的TCP连接具有不同的参数（RTT、MSS等），不能保证公平性</p><p>$\quad$ 若应用（如web）可以建立多条并行TCP连接，不能保证带宽在应用之间公平分配，比如：</p><p>$\quad$ $\quad$ 一条速率为R的链路上有9条连接</p><p>$\quad$ $\quad$ 若新应用建立一条TCP连接，获得速率 R&#x2F;10</p><p>$\quad$ $\quad$ 若新应用建立11条TCP，可以获得速率 0.55R !</p><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>CN</category>
      
      <category>传输层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CN</tag>
      
      <tag>传输层</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>传输层 - 基本概念与UDP</title>
    <link href="/2023/10/20/%E4%BC%A0%E8%BE%93%E5%B1%82%20-%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8EUDP/"/>
    <url>/2023/10/20/%E4%BC%A0%E8%BE%93%E5%B1%82%20-%20%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8EUDP/</url>
    
    <content type="html"><![CDATA[<p> 对应 北京大学计算机网络课程第三讲第一部分<br> 参考教材计算机网络-自顶向下方法</p><span id="more"></span><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="传输层-基本概念与UDP"><a href="#传输层-基本概念与UDP" class="headerlink" title="传输层 - 基本概念与UDP"></a>传输层 - 基本概念与UDP</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>$\quad$ 传输层位于应用层和网络层之间：</p><p>$\quad$ $\quad$ 基于网络层提供的服务，向不同主机上的应用程序提供通信服务</p><p>$\quad$ 从网络的角度：屏蔽应用复杂性</p><p>$\quad$ $\quad$ 按照因特网的“端到端”设计原则：网络设计不需要考虑应用程序</p><p>$\quad$ 站在应用程序的角度：屏蔽底层网络的复杂性</p><p>$\quad$ $\quad$ 应用程序只运行在终端上，即不需要为网络设备编写程序</p><p>$\quad$ $\quad$ 传输层应提供进程之间通信的抽象：即运行在不同终端上的应用进程仿佛是直接连在一起的</p><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><h5 id="与应用层的接口"><a href="#与应用层的接口" class="headerlink" title="与应用层的接口"></a>与应用层的接口</h5><p>$\quad$ 设想在应用程序和网络之间存在一扇“门”：</p><p>$\quad$ $\quad$ 需要发送报文时：发送进程将报文推到门外</p><p>$\quad$ $\quad$ 门外的运输设施（因特网）将报文送到接收进程的门口</p><p>$\quad$ $\quad$ 需要接收报文时：接收进程打开门，即可收到报文</p><p>$\quad$ 在TCP&#x2F;IP网络中，这扇“门”称为套接字（socket），是应用层和传输层的接口，也是应用程序和网络之间的API</p><h5 id="与网络层的接口"><a href="#与网络层的接口" class="headerlink" title="与网络层的接口"></a>与网络层的接口</h5><p>$\quad$ 网络层</p><p>$\quad$ $\quad$ 提供两台主机之间通信接口</p><p>$\quad$ $\quad$ 可能经多跳链路进行数据传输</p><p>$\quad$ 传输层</p><p>$\quad$ $\quad$ 主机上一对应用程序之间通信</p><p>$\quad$ $\quad$ 通过调用网络层接口，并进行必要的增强</p><h4 id="提供的服务"><a href="#提供的服务" class="headerlink" title="提供的服务"></a>提供的服务</h4><p>$\quad$ Internet的网络层提供“尽力而为”的服务：</p><p>$\quad$ $\quad$ 网络层尽最大努力在终端间交付分组，但不提供任何承诺</p><p>$\quad$ $\quad$ 具体来说</p><p>$\quad$ $\quad$ $\quad$ 不保证交付成功</p><p>$\quad$ $\quad$ $\quad$ 不保证按序交付</p><p>$\quad$ $\quad$ $\quad$ 不保证数据完整</p><p>$\quad$ $\quad$ $\quad$ 不保证延迟</p><p>$\quad$ $\quad$ $\quad$ 不保证带宽等</p><p>$\quad$ 传输层的有所为、有所不为:</p><p>$\quad$ $\quad$ 传输层可以通过差错恢复、重排序等手段提供可靠、按序的交付服务</p><p>$\quad$ $\quad$ 但传输层无法提供延迟保证、带宽保证等服务</p><h4 id="协议：UDP与TCP"><a href="#协议：UDP与TCP" class="headerlink" title="协议：UDP与TCP"></a>协议：UDP与TCP</h4><p>$\quad$ 传统Internet提供2种传输层协议供应用层选择</p><p>$\quad$ $\quad$ UDP：最低限度的传输服务：</p><p>$\quad$ $\quad$ $\quad$ 对网络层接口进行最简单的封装</p><p>$\quad$ $\quad$ $\quad$ 主机-主机的数据交付 -&gt; 进程-进程的数据交付</p><p>$\quad$ $\quad$ $\quad$ 发送、接收数据的单位是数据报（应用层需处理报文边界）</p><p>$\quad$ $\quad$ $\quad$ 报文检错</p><p>$\quad$ $\quad$ TCP：最低限度服务 + 增强服务：</p><p>$\quad$ $\quad$ $\quad$ 以字节流的形式发送、接收数据（应用层感受不到报文边界）</p><p>$\quad$ $\quad$ $\quad$ 可靠数据传输</p><p>$\quad$ $\quad$ $\quad$ 流量控制</p><p>$\quad$ $\quad$ $\quad$ 拥塞控制</p><h5 id="套接字对比"><a href="#套接字对比" class="headerlink" title="套接字对比"></a>套接字对比</h5><p>$\quad$ UDP套接字</p><p>$\quad$ $\quad$ 使用&lt;IP地址，端口号&gt;二元组标识UDP套接字</p><p>$\quad$ $\quad$ 服务器使用一个套接字服务所有客户</p><p>$\quad$ TCP套接字</p><p>$\quad$ $\quad$ 使用&lt;源IP地址，目的IP地址，源端口号，目的端口号&gt; 四元组标识连接套接字</p><p>$\quad$ $\quad$ 服务器使用一个监听套接字和多个连接套接字服务多个客户，每个连接套接字服务一个客户</p><h4 id="套接字端口号"><a href="#套接字端口号" class="headerlink" title="套接字端口号"></a>套接字端口号</h4><p>$\quad$ 端口号是套接字标识的一部分：</p><p>$\quad$ $\quad$ 每个套接字在本地关联一个端口号</p><p>$\quad$ $\quad$ 端口号是一个16比特的数</p><p>$\quad$ 端口号的分类：</p><p>$\quad$ $\quad$ 熟知端口：0～1023，由公共域协议使用</p><p>$\quad$ $\quad$ 注册端口：1024～49151，需要向IANA注册才能使用</p><p>$\quad$ $\quad$ 动态和&#x2F;或私有端口：49152～65535，一般程序使用</p><p>$\quad$ 报文段中有两个字段携带端口号</p><p>$\quad$ $\quad$ 源端口号：与发送进程关联的本地端口号</p><p>$\quad$ $\quad$ 目的端口号：与接收进程关联的本地端口号</p><p><img src="/../CNP/CN401.png"></p><h5 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h5><h6 id="自动分配："><a href="#自动分配：" class="headerlink" title="自动分配："></a>自动分配：</h6><p>$\quad$ 创建套接字时不指定端口号</p><p>$\quad$ 由操作系统从49152～65535中分配</p><p>$\quad$ 客户端通常使用这种方法</p><h6 id="使用指定端口号创建套接字："><a href="#使用指定端口号创建套接字：" class="headerlink" title="使用指定端口号创建套接字："></a>使用指定端口号创建套接字：</h6><p>$\quad$ 创建套接字时指定端口号</p><p>$\quad$ 实现公共域协议的服务器应分配保留端口号（0～1023）</p><p>$\quad$ 服务器通常采用这种方法</p><h5 id="复用与分用"><a href="#复用与分用" class="headerlink" title="复用与分用"></a>复用与分用</h5><p>$\quad$ 问题：如何通过端口号，将数据对应到正确的套接字？</p><p>$\quad$ 回答：无论UDP还是TCP，都基于多路复用与分用实现进程-进程数据交付</p><p><img src="/../CNP/CN402.png"></p><p>$\quad$ 复用：</p><p>$\quad$ $\quad$ 发送方传输层将套接字标识置于报文段中，交给网络层</p><p>$\quad$ $\quad$ 类比：快递员将一个学校里的邮件收集齐，交给物流系统</p><p>$\quad$ 分用：</p><p>$\quad$ $\quad$ 接收方传输层根据报文段中的套接字标识，将报文段交付到正确的套接字</p><p>$\quad$ $\quad$ 类比：快递员将每个邮件，交给对应收信人</p><h6 id="UDP分用"><a href="#UDP分用" class="headerlink" title="UDP分用"></a>UDP分用</h6><p>$\quad$ UDP套接字使用&lt;IP地址, 端口号&gt;二元组进行标识</p><p>$\quad$ 接收方传输层收到一个UDP报文段后：</p><p>$\quad$ $\quad$ 检查报文段中的目的端口号，将UDP报文段交付到具有该端口号的套接字</p><p>$\quad$ $\quad$ &lt;目的IP地址，目的端口号&gt; 相同的UDP报文段被交付给同一个套接字，与 &lt;源IP地址，源端口号&gt; 无关</p><p>$\quad$ $\quad$ 报文段中的 &lt;源IP地址，源端口号&gt; 被接收进程用来发送响应报文</p><p><img src="/../CNP/CN403.png"></p><h6 id="TCP分用"><a href="#TCP分用" class="headerlink" title="TCP分用"></a>TCP分用</h6><p>$\quad$ 一个TCP服务器为了同时服务很多个客户，使用两种套接字</p><p>$\quad$ $\quad$ 监听套接字：</p><p>$\quad$ $\quad$ $\quad$ 服务器平时在监听套接字上等待客户的连接请求，该套接字具有众所周知的端口号</p><p>$\quad$ $\quad$ 连接套接字：</p><p>$\quad$ $\quad$ $\quad$ 服务器在收到客户的连接请求后，创建一个连接套接字，但使用原监听端口号</p><p>$\quad$ $\quad$ $\quad$ 每个连接套接字只与一个客户通信，即只接收具有以下四元组的报文段：</p><p>$\quad$ $\quad$ $\quad$ $\quad$ 源IP地址 &#x3D; 客户IP地址，源端口号 &#x3D; 客户套接字端口号</p><p>$\quad$ $\quad$ $\quad$ $\quad$ 目的IP地址 &#x3D; 服务器IP地址，目的端口号 &#x3D; 服务器监听套接字的端口号</p><p>$\quad$ 连接套接字需要使用&lt;源IP地址，目的IP地址，源端口号，目的端口号&gt;四元组进行标识，服务器使用该四元组将TCP报文段交付到正确的连接套接字</p><p><img src="/../CNP/CN404.png"></p><h3 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h3><h4 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h4><p>$\quad$ 网络层提供的服务（best-effort service）：</p><p>$\quad$ $\quad$ 尽最大努力将数据包交付到目的主机</p><p>$\quad$ $\quad$ 不保证投递的可靠性和顺序</p><p>$\quad$ $\quad$ 不保证带宽及延迟要求</p><p>$\quad$ UDP提供的服务：</p><p>$\quad$ $\quad$ 对网络层接口进行最简单的封装：网络层 + 多路复用与分解</p><p>$\quad$ $\quad$ 将主机-主机的数据交付 -&gt; 进程-进程的数据交付</p><p>$\quad$ $\quad$ 报文完整性检查（可选）：检测并丢弃出错的报文</p><p>$\quad$ UDP的实现：</p><p>$\quad$ $\quad$ 复用和分用（必须）</p><p>$\quad$ $\quad$ 报文检错（可选）</p><h4 id="报文结构"><a href="#报文结构" class="headerlink" title="报文结构"></a>报文结构</h4><p>$\quad$ UDP报文：</p><p>$\quad$ $\quad$ 报头：携带协议处理需要的信息</p><p>$\quad$ $\quad$ 载荷（payload）：携带上层数据</p><p>$\quad$ 用于复用和分用的字段：</p><p>$\quad$ $\quad$ 源端口号</p><p>$\quad$ $\quad$ 目的端口号</p><p>$\quad$ 用于检测报文错误的字段：</p><p>$\quad$ $\quad$ 报文总长度</p><p>$\quad$ $\quad$ 校验和（checksum）</p><h5 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h5><p>$\quad$ 校验和字段的作用:  对传输的报文段进行检错</p><p>$\quad$ 发送方:</p><p>$\quad$ $\quad$ 将报文段看成是由16比特整数组成的序列</p><p>$\quad$ $\quad$ 对这些整数序列计算校验和</p><p>$\quad$ $\quad$ 将校验和放到UDP报文段的checksum字段</p><p>$\quad$ 接收方:</p><p>$\quad$ $\quad$ 对收到的报文段进行相同的计算</p><p>$\quad$ $\quad$ 与报文段中的checksum字段进行比较：</p><p>$\quad$ $\quad$ $\quad$ 不相等：说明报文段有错误</p><p>$\quad$ $\quad$ $\quad$ 相等：认为报文段没有错误</p><h6 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h6><p>$\quad$ 步骤一：将数据划分为一系列16-bit整数</p><p>$\quad$ 步骤二：将所有整数相加</p><p>$\quad$ $\quad$ 每次将1个整数与当前和(sum)相加</p><p>$\quad$ $\quad$ 如果相加结果最高位为1（16比特溢出），则将1加到低位16bit部分</p><p>$\quad$ 将最终结果取反</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><br>unsighed <span class="hljs-type">short</span> <span class="hljs-title function_">checksum</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> *buf,<span class="hljs-type">int</span> nword)</span><br><br>&#123;<br><br>usigned <span class="hljs-type">long</span> sum;<br><br><span class="hljs-keyword">for</span>(sum=<span class="hljs-number">0</span>;nword&gt;<span class="hljs-number">0</span>;nword--)<br><br>&#123;<br><br>sum=*buf++;<br><br>sum=(sum&gt;&gt;<span class="hljs-number">16</span>)+(sum&amp;<span class="hljs-number">0xffff</span>);<br><br><span class="hljs-keyword">return</span> ~sum;<br><br>&#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="UDP校验"><a href="#UDP校验" class="headerlink" title="UDP校验"></a>UDP校验</h4><p>$\quad$ 计算UDP校验和时，要包括伪头、UDP头和数据三个部分</p><p>$\quad$ $\quad$ 计算校验和时，checksum字段填0</p><p>$\quad$ UDP伪头信息取自IP报头，包括：</p><p>$\quad$ $\quad$ 源IP地址，目的IP地址</p><p>$\quad$ $\quad$ UDP的协议号</p><p>$\quad$ $\quad$ UDP报文段总长度</p><p>$\quad$ 计算校验和时包含伪头信息，是为了避免由于IP地址错误等造成的误投递</p><p>$\quad$ UDP校验和的使用是可选的，若不计算校验和，该字段填入0</p><p><img src="/../CNP/CN405.png"></p><p>$\quad$ checksum仍有可能检测不出错误</p><p>$\quad$ $\quad$ 如：两个16位整数，在同一个bit位发生0-1翻转</p><p>$\quad$ $\quad$ 此时，由应用层负责发现、处理错误</p><p>$\quad$ 为什么使用checksum</p><p>$\quad$ $\quad$ 传输层发生错误概率非常小</p><p>$\quad$ $\quad$ $\quad$ 链路层一般有检测、纠错功能，已经将大部分网络传输过程中的错误处理了</p><p>$\quad$ $\quad$ $\quad$ 传输层错误，一般来自于主机软件bug or 硬件故障 -&gt; 小概率事件</p><p>$\quad$ $\quad$ 计算开销小</p><h4 id="UDP缓冲区"><a href="#UDP缓冲区" class="headerlink" title="UDP缓冲区"></a>UDP缓冲区</h4><p>$\quad$ 通常端系统实现（如Linux）：无发送缓冲区、有接收缓冲区</p><p>$\quad$ 发送方：从应用层获取的数据，传输层加上UDP头部后直接交给网络层</p><p>$\quad$ $\quad$ 长消息的分片、缓冲依赖于网络层、链路层提供</p><p>$\quad$ 接收方：每个socket一个缓冲区，存储着来自不同发送方的报文</p><p>$\quad$ $\quad$ 每次获得一个报文，下一次接收可能得到的是来自另一个发送方的报文</p><p>$\quad$ $\quad$ 因此，应用层是可以感知到报文边界</p><h4 id="为什么需要UDP"><a href="#为什么需要UDP" class="headerlink" title="为什么需要UDP"></a>为什么需要UDP</h4><p>$\quad$ 应用可以尽可能快地发送报文：</p><p>$\quad$ $\quad$ 无建立连接的延迟</p><p>$\quad$ $\quad$ 不限制发送速率（不进行拥塞控制和流量控制）</p><p>$\quad$ 报头开销小</p><p>$\quad$ 协议处理简单</p><h4 id="UDP适合哪些应用"><a href="#UDP适合哪些应用" class="headerlink" title="UDP适合哪些应用"></a>UDP适合哪些应用</h4><p>$\quad$ 容忍丢包但对延迟敏感的应用：</p><p>$\quad$ $\quad$ 如流媒体</p><p>$\quad$ 以单次请求&#x2F;响应为主的应用：</p><p>$\quad$ $\quad$ 如DNS</p><p>$\quad$ 若应用要求基于UDP进行可靠传输：</p><p>$\quad$ $\quad$ 由应用层实现可靠性</p><hr><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>CN</category>
      
      <category>传输层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CN</tag>
      
      <tag>传输层</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>传输层 - 可靠传输</title>
    <link href="/2023/10/20/%E4%BC%A0%E8%BE%93%E5%B1%82%20-%20%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/"/>
    <url>/2023/10/20/%E4%BC%A0%E8%BE%93%E5%B1%82%20-%20%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93/</url>
    
    <content type="html"><![CDATA[<p> 对应 北京大学计算机网络课程第三讲第二部分<br> 参考教材计算机网络-自顶向下方法</p><span id="more"></span><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="传输层-可靠传输"><a href="#传输层-可靠传输" class="headerlink" title="传输层 - 可靠传输"></a>传输层 - 可靠传输</h2><h4 id="TCP概述"><a href="#TCP概述" class="headerlink" title="TCP概述"></a>TCP概述</h4><p><img src="/../CNP/CN501.png"></p><h5 id="提供的服务"><a href="#提供的服务" class="headerlink" title="提供的服务"></a>提供的服务</h5><p>$\quad$ TCP服务模型：</p><p>$\quad$ $\quad$ 在一对通信的进程之间提供一条理想的字节流管道</p><p>$\quad$ 点到点通信:</p><p>$\quad$ $\quad$ 仅涉及一对通信进程</p><p>$\quad$ 全双工：</p><p>$\quad$ $\quad$ 可以同时双向传输数据</p><p>$\quad$ 可靠、有序的字节流：</p><p>$\quad$ $\quad$ 不保留报文边界</p><h5 id="需要的机制"><a href="#需要的机制" class="headerlink" title="需要的机制"></a>需要的机制</h5><p>$\quad$ 建立连接:</p><p>$\quad$ $\quad$ 通信双方为本次通信建立数据传输所需的状态（套接字、缓存、变量等）</p><p>$\quad$ 可靠数据传输：</p><p>$\quad$ $\quad$ 流水线式发送，报文段检错，丢失重传</p><p>$\quad$ 流量控制:</p><p>$\quad$ $\quad$ 发送方不会令接收方缓存溢出</p><p>$\quad$ 拥塞控制:</p><p>$\quad$ $\quad$ 发送方不会造成网络拥塞</p><h4 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h4><h6 id="不可靠信道"><a href="#不可靠信道" class="headerlink" title="不可靠信道"></a>不可靠信道</h6><p>$\quad$ 外部信号干扰导致比特错误（数据损坏）</p><p>$\quad$ 链路过载导致数据丢失</p><p>$\quad$ 多路径导致乱序</p><h5 id="可靠传输问题"><a href="#可靠传输问题" class="headerlink" title="可靠传输问题"></a>可靠传输问题</h5><p>$\quad$ 保证数据在不可靠信道上完整、正确、有序地从源到目的进行传送</p><p>$\quad$ 可靠传输不仅是TCP中的问题，在网络的各个层次都需要考虑</p><p>$\quad$ $\quad$ OSI模型中的链路层</p><p>$\quad$ $\quad$ 各类基于UDP的应用层协议（如TFTP）</p><p>$\quad$ $\quad$ 5G通信</p><p>$\quad$ $\quad$ 时延敏感网络</p><p>$\quad$ $\quad$ 远程直接内存访问（Remote Direct Memory Access，RDMA）</p><h6 id="本课关注的可靠传输"><a href="#本课关注的可靠传输" class="headerlink" title="本课关注的可靠传输"></a>本课关注的可靠传输</h6><p>$\quad$ 计算机网络中对底层不可靠信道的假设</p><p>$\quad$ $\quad$ 通讯链路会丢失信息</p><p>$\quad$ $\quad$ 消息会发生乱序</p><p>$\quad$ $\quad$ 通讯数据在传输过程中可能发生随机的错误，但能通过校验技术进行检测</p><p>$\quad$ 不考虑的场景</p><p>$\quad$ $\quad$ 数据在通信中可能遭到有意的篡改，且无法通过校验检测</p><p>$\quad$ $\quad$ 收到的数据可能不是来自发送方，而是某第三方编造</p><h5 id="形式化描述"><a href="#形式化描述" class="headerlink" title="形式化描述"></a>形式化描述</h5><p><img src="/../CNP/CN502.png"></p><h5 id="学习可靠传输的方法"><a href="#学习可靠传输的方法" class="headerlink" title="学习可靠传输的方法"></a>学习可靠传输的方法</h5><p>$\quad$ 从最简单的场景开始，考虑如何设计可靠性协议</p><p>$\quad$ 先达成可靠性，然后优化性能</p><p><img src="/../CNP/CN503.png"></p><p>$\quad$ 可靠性机制是分布式算法：发送方、接收方各自都应执行相应操作，协同保证可靠性</p><p>$\quad$ 发送方或者接收方的功能，可以用有限状态机（FSM）进行表示</p><p><img src="/../CNP/CN504.png"></p><p>$\quad$ 本章节统一使用packet指代传输的数据单元</p><h4 id="一般的可靠性方案"><a href="#一般的可靠性方案" class="headerlink" title="一般的可靠性方案"></a>一般的可靠性方案</h4><h5 id="完美信道-乌托邦协议（rdt-1-0）"><a href="#完美信道-乌托邦协议（rdt-1-0）" class="headerlink" title="完美信道-乌托邦协议（rdt 1.0）"></a>完美信道-乌托邦协议（rdt 1.0）</h5><p>$\quad$ 假设：</p><p>$\quad$ $\quad$ 完美信道：帧不会丢失或受损</p><p>$\quad$ $\quad$ 始终就绪：发送方&#x2F;接收方的网络层始终处于就绪状态</p><p>$\quad$ $\quad$ 瞬间完成：发送方&#x2F;接收方能够生成&#x2F;处理无穷多的数据</p><p>$\quad$ 乌托邦：完美但不现实的协议(rdt 1.0)</p><p>$\quad$ $\quad$ 不处理任何流量控制或纠错工作</p><p>$\quad$ $\quad$ 接近于无确认的无连接服务</p><p><img src="/../CNP/CN505.png"></p><h6 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h6><p><img src="/../CNP/CN506.png"></p><h5 id="有错但不丢包信道——rdt2-0协议"><a href="#有错但不丢包信道——rdt2-0协议" class="headerlink" title="有错但不丢包信道——rdt2.0协议"></a>有错但不丢包信道——rdt2.0协议</h5><p>$\quad$ 假设</p><p>$\quad$ $\quad$ 信道传输时，数据包中某些比特会发生0-1翻转，但可以被校验检测</p><p>$\quad$ 自动重传请求（ARQ, Automatic Repeat reQuest）:  基于反馈的重传</p><p>$\quad$ $\quad$ 三要素：（接收方）差错检测、（接收方）反馈、（发送方）重传</p><p>$\quad$ 反馈内容</p><p>$\quad$ $\quad$ acknowledgements (ACKs): 接收方告诉发送方，收到正确数据包</p><p>$\quad$ $\quad$ negative acknowledgements (NAKs): 接收方告诉发送方，收到数据有错误</p><p>$\quad$ rdt 2.0协议</p><p>$\quad$ $\quad$ rdt2.0是最简单的ARQ协议</p><p>$\quad$ $\quad$ $\quad$ 发送方发送一个数据包后暂停，等待ACK或NAK到达后发送下一个包</p><p>$\quad$ $\quad$ $\quad$ 接收方</p><p>$\quad$ $\quad$ $\quad$ $\quad$ 若检测数据包有错，返回NAK</p><p>$\quad$ $\quad$ $\quad$ $\quad$ 否则，完成接收后，回复ACK接收</p><p>$\quad$ $\quad$ $\quad$ ACK与NAK的内容是不重要的：哑帧（dummy frame）</p><p>$\quad$ $\quad$ $\quad$ 此类协议又称停-等式协议（stop-and-wait）</p><p>$\quad$ $\quad$ $\quad$ $\quad$ 发送1个报文后就停下，等待后再发</p><p><img src="/../CNP/CN507.png"></p><h6 id="状态机-1"><a href="#状态机-1" class="headerlink" title="状态机"></a>状态机</h6><p><img src="/../CNP/CN508.png"></p><h6 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h6><p>$\quad$ 问题：如果ACK或NAK出错</p><p>$\quad$ $\quad$ 检测出ACK或NAK有错后，发送方不知道接收方的状况</p><p>$\quad$ 选择1：发送方通知接收方重传ACK或NAK</p><p>$\quad$ $\quad$ 缺陷：通知本身也可能出错，陷入死循环</p><p>$\quad$ 选择2：采用更复杂的校验技术，不仅可以检测差错，还能纠正差错</p><p>$\quad$ $\quad$ 缺陷：额外的计算与传输开销</p><p>$\quad$ 选择3：发送方直接重传</p><p>$\quad$ $\quad$ 缺陷：接收方收到多份数据</p><h6 id="rdt2-1"><a href="#rdt2-1" class="headerlink" title="rdt2.1"></a>rdt2.1</h6><p>$\quad$ 选择3并额外操作：</p><p>$\quad$ $\quad$ 发送方</p><p>$\quad$ $\quad$ $\quad$ 在数据包中加上序号Seq，区分不同数据包</p><p>$\quad$ $\quad$ 接收方</p><p>$\quad$ $\quad$ $\quad$ 忽略序号重复的数据包</p><p>$\quad$ 问题1：重传（方案3）与复杂编码（方案2）的优势？</p><p>$\quad$ $\quad$ 方案2：每个ACK&#x2F;NAK都需要解码，开销大</p><p>$\quad$ $\quad$ 方案3：只在出错时重传</p><p>$\quad$ 问题2：序号值范围多大？</p><p>$\quad$ $\quad$ 在停等协议下，序号seq只需要区分当前数据包是否是前一次发送的重传，1 bit足够</p><p>$\quad$ $\quad$ 前一次发送的seq&#x3D;0，重传继续seq&#x3D;0，下一个数据包seq&#x3D;1</p><p>$\quad$ $\quad$ 前一次发送的seq&#x3D;1，重传继续seq&#x3D;1，下一个数据包seq&#x3D;0</p><p><img src="/../CNP/CN509.png"></p><p><strong>发送方状态机</strong></p><p><img src="/../CNP/CN510.png"></p><p><strong>接收方状态机</strong></p><p><img src="/../CNP/CN511.png"></p><h6 id="rdt-2-2——不需要NAK"><a href="#rdt-2-2——不需要NAK" class="headerlink" title="rdt 2.2——不需要NAK"></a>rdt 2.2——不需要NAK</h6><p>$\quad$ rdt 2.1中，ACK与NAK不携带任何信息</p><p>$\quad$ rdt 2.2: 在ACK中加上最近成功接收的seq</p><p>$\quad$ $\quad$ 发送方就可以判断最近发送是否成功（通过比较ACK的seq与自己的seq）</p><p>$\quad$ $\quad$ NAK就不再需要</p><p>$\quad$ $\quad$ 当ACK出错或ACK.seq !&#x3D; seq，发送方进行重传</p><p><strong>发送方状态机</strong></p><p><img src="/../CNP/CN512.png"></p><p><strong>接收方状态机</strong></p><p><img src="/../CNP/CN513.png"></p><h5 id="有错且丢包信道-rdt-3-0协议"><a href="#有错且丢包信道-rdt-3-0协议" class="headerlink" title="有错且丢包信道:rdt 3.0协议"></a>有错且丢包信道:rdt 3.0协议</h5><p>$\quad$ 假设</p><p>$\quad$ $\quad$ 信道不仅会出错，还会丢失数据包，导致：</p><p>$\quad$ $\quad$ $\quad$ 数据包在传输过程中可能会丢失 ，永远不可能到达接收方</p><p>$\quad$ $\quad$ 不考虑乱序</p><p>$\quad$ 解决方案：rdt 3.0</p><p>$\quad$ $\quad$ 发送方增加一个计时器(timer)，如果经过一段时间没有收到确认，发送方将超时，于是再次发送该数据包</p><p>$\quad$ $\quad$ 如果数据包只是发生了延迟（而不是丢失），会导致接收方收到多个数据包</p><p>$\quad$ $\quad$ 可以通过seq判断重复数据</p><p><img src="/../CNP/CN514.png"></p><h6 id="状态机-2"><a href="#状态机-2" class="headerlink" title="状态机"></a>状态机</h6><p><strong>发送方：</strong></p><p><img src="/../CNP/CN515.png"></p><p><strong>接收方</strong></p><p>$\quad$ 与rdt 2.2完全一样</p><h6 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h6><p><img src="/../CNP/CN517.png"></p><p><img src="/../CNP/CN518.png"></p><h5 id="停等式协议的效率"><a href="#停等式协议的效率" class="headerlink" title="停等式协议的效率"></a>停等式协议的效率</h5><p>$\quad$ rdt 2.0, rdt 2.1, rdt 2.2, rdt 3.0都是停等式协议</p><p>$\quad$ 效率的评估</p><p>$\quad$ $\quad$ F &#x3D; 数据大小 (bits)  </p><p>$\quad$ $\quad$ R &#x3D; 信道发送速率 (bits&#x2F;second)</p><p>$\quad$ $\quad$ I &#x3D; 信道传播延迟（不考虑接发送端与收端处理延迟、接收端发送ACK延迟） </p><p>$\quad$ $\quad$ 数据发送时间 (Time to transmit a single frame) &#x3D; F&#x2F;R</p><p>$\quad$ $\quad$ 往返延迟 RTT &#x3D;2I</p><p>$\quad$ $\quad$ 停止等待协议的发送工作时间是F&#x2F;R，空闲时间是RTT</p><p>$\quad$ $\quad$ 信道利用率 (line utilization)&#x3D;F&#x2F;(F+R∙RTT)</p><p>$\quad$ $\quad$ 当 F&lt;RTT 时：信道利用率 &lt; 50%</p><p><img src="/../CNP/CN516.png"></p><h6 id="效率问题"><a href="#效率问题" class="headerlink" title="效率问题"></a>效率问题</h6><p>$\quad$ 信道利用率很低：</p><p>$\quad$ $\quad$ 每一帧的发送时间是1毫秒(1000 bits&#x2F;(1,000,000 bits&#x2F;sec)). 由于传播延迟较长，发送者在541毫秒之后才能收到确认，信道利用率1&#x2F;541</p><p>$\quad$ 停止等待协议的问题是只能有一个没有被确认的帧在发送中</p><p>$\quad$ $\quad$ 假如将链路看成是一根管道，数据是管道中流动的水，那么在传输延迟较长的信道上，停-等协议无法使数据充满管道，因而信道利用率很低</p><p>$\quad$ 一种提高效率的方法：使用更大的帧</p><p>$\quad$ $\quad$ 可以使用更大的帧，但是帧的最大长度受到信道比特错误率（BER，Bit Error Ratio）的限制，帧越大，在传输中出错的概率越高，将导致更多的重传</p><h4 id="一般可靠性方案性能优化"><a href="#一般可靠性方案性能优化" class="headerlink" title="一般可靠性方案性能优化"></a>一般可靠性方案性能优化</h4><h5 id="流水线传输"><a href="#流水线传输" class="headerlink" title="流水线传输"></a>流水线传输</h5><p>$\quad$ 允许发送方在没收到确认前连续发送多个数据包</p><p>$\quad$ 信道内有多个正在传输且未被确认的数据包</p><p><img src="/../CNP/CN519.png"></p><h6 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h6><p>$\quad$ 事项1：增大序号seq的范围</p><p>$\quad$ $\quad$ 每一个等待确认的数据包都需要一个唯一的seq</p><p>$\quad$ $\quad$ 停等协议中的{0，1}不足够使用</p><p>$\quad$ $\quad$ seq被确认后可以复用</p><p>$\quad$ 事项2：发送方需保存所有未被确认的数据包</p><p>$\quad$ 事项3：处理多个数据包的丢失、损坏、超长延迟</p><p>$\quad$ $\quad$ 三要素：差错检测、反馈、重传</p><p>$\quad$ $\quad$ 根据“反馈+重传”的不同，有2种方法：回退N步（Go-back-N，GBN）、选择重传（Selective Repeat，SR）</p><h6 id="滑动窗口机制：限制最多有N个未确认数据包"><a href="#滑动窗口机制：限制最多有N个未确认数据包" class="headerlink" title="滑动窗口机制：限制最多有N个未确认数据包"></a>滑动窗口机制：限制最多有N个未确认数据包</h6><p>$\quad$ 降低开销</p><p>$\quad$ $\quad$ 发送方：降低缓存未确认包的内存开销</p><p>$\quad$ $\quad$ 接收方：避免处理速度跟不上发送速度</p><p>$\quad$ $\quad$ 网络：减少带宽开销</p><p>$\quad$ $\quad$ Seq：有限bit位即可表示</p><p>$\quad$ 目的</p><p>$\quad$ $\quad$ 对可以连续发出的最多帧数（已发出但未确认的帧）作限制</p><p>$\quad$ 序号使用</p><p>$\quad$ $\quad$ 循环重复使用有限的帧序号</p><p>$\quad$ 接收窗口驱动发送窗口的转动</p><p>$\quad$ $\quad$ 发送窗口：其大小记作WT，表示在收到对方确认的信息之前，可以连续发出的最多数据帧数</p><p>$\quad$ $\quad$ 接收窗口：其大小记作WR ，为可以连续接收的最多数据帧数</p><p><img src="/../CNP/CN520.png"></p><p><img src="/../CNP/CN521.png"></p><h5 id="回退N算法（GBN）"><a href="#回退N算法（GBN）" class="headerlink" title="回退N算法（GBN）"></a>回退N算法（GBN）</h5><h6 id="确认-重传：回退N-VS-选择重传"><a href="#确认-重传：回退N-VS-选择重传" class="headerlink" title="确认+重传：回退N VS 选择重传"></a>确认+重传：回退N VS 选择重传</h6><p><img src="/CNP/CN522.png"></p><h6 id="回退N"><a href="#回退N" class="headerlink" title="回退N"></a>回退N</h6><p>$\quad$ 思想</p><p>$\quad$ $\quad$ 当接收端收到一个出错帧或乱序帧时，丢弃所有的后继帧，并且不为这些帧发送确认</p><p>$\quad$ $\quad$ 发送端超时后，重传所有未被确认的帧</p><p>$\quad$ 要点</p><p>$\quad$ $\quad$ 发送方保存所有未确认数据包</p><p>$\quad$ $\quad$ $\quad$ 构成一个先进先出队列</p><p>$\quad$ $\quad$ $\quad$ seq值连续，只需维护seq的上下界</p><p>$\quad$ $\quad$ 接收端无需保存数据包</p><p>$\quad$ $\quad$ $\quad$ 只要记住下一个期望收到的seq</p><p>$\quad$ 优劣</p><p>$\quad$ $\quad$ 优点：减轻接收端负担</p><p>$\quad$ $\quad$ 缺点：重传包数量大，增加发送端与信道负担</p><h6 id="发送方"><a href="#发送方" class="headerlink" title="发送方"></a>发送方</h6><p><img src="/../CNP/CN523.png"></p><p><strong>状态机</strong></p><p><img src="/../CNP/CN524.png"></p><h6 id="接收方"><a href="#接收方" class="headerlink" title="接收方"></a>接收方</h6><p><img src="/../CNP/CN525.png"></p><h6 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h6><p><img src="/../CNP/CN526.png"></p><h5 id="选择重传-SR"><a href="#选择重传-SR" class="headerlink" title="选择重传(SR)"></a>选择重传(SR)</h5><p>$\quad$ 设计思想</p><p>$\quad$ $\quad$ 接收方对每个数据包独立确认</p><p>$\quad$ $\quad$ 若发送方发出连续的若干包后，收到对其中某一包的ACK错误，或某一包的定时器超时， 则只重传该出错包或计时器超时的数据包</p><p>$\quad$ $\quad$ 发送端和接收端都保存数据包</p><p>$\quad$ 要点</p><p>$\quad$ $\quad$ 发送端需要对每个包维护计时器</p><p>$\quad$ $\quad$ 接收端需要缓存已经接收的数据包，以便按顺序交付给上一层</p><p>$\quad$ 优劣</p><p>$\quad$ $\quad$ 优点：减少重传数量</p><p>$\quad$ $\quad$ 缺点：接收端缓存、发送端逐包计时器</p><p><img src="/../CNP/CN527.png"></p><h6 id="处理事件"><a href="#处理事件" class="headerlink" title="处理事件"></a>处理事件</h6><p><img src="/../CNP/CN528.png"></p><h6 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h6><p><img src="/../CNP/CN529.png"></p><p><img src="/../CNP/CN530.png"></p><h6 id="与GBN对比"><a href="#与GBN对比" class="headerlink" title="与GBN对比"></a>与GBN对比</h6><p><img src="/../CNP/CN531.png"></p><h4 id="TCP可靠性方案"><a href="#TCP可靠性方案" class="headerlink" title="TCP可靠性方案"></a>TCP可靠性方案</h4><p>$\quad$ 高度简化的TCP协议：仅考虑可靠传输机制</p><p>$\quad$ 发送方：</p><p>$\quad$ $\quad$ 定时器的使用：仅对最早未确认的报文段使用一个重传定时器（与GBN类似）</p><p>$\quad$ $\quad$ 重发策略：仅在超时后重发最早未确认的报文段（与SR类似，因为接收端缓存了失序的报文段）</p><p>$\quad$ 接收方：</p><p>$\quad$ $\quad$ 确认方式：采用累积确认，仅在正确、按序收到报文段后，更新确认序号；其余情况，重复前一次的确认序号（与GBN类似）</p><p>$\quad$ $\quad$ 失序报文段处理：缓存失序的报文段（与SR类似）</p><h5 id="TCP可靠数据传输"><a href="#TCP可靠数据传输" class="headerlink" title="TCP可靠数据传输"></a>TCP可靠数据传输</h5><p>$\quad$ TCP 在不可靠的IP服务上建立可靠的数据传输</p><p>$\quad$ $\quad$ 可能报文出错（但可以校验）、丢包、乱序</p><p>$\quad$ 基本机制：流水线传输</p><p>$\quad$ $\quad$ 发送端：流水线式发送数据、等待确认、超时重传</p><p>$\quad$ $\quad$ 接收端：进行差错检测、确认接收</p><p>$\quad$ 对字节建立序号，而非报文</p><p>$\quad$ $\quad$ ACK值为下一个期望的字节序号，而非当前已经收到的最后一个字节</p><p>$\quad$ $\quad$ ACK值放在正常数据包里（捎带，piggyback）</p><p>$\quad$ 乱序处理：协议没有明确规定实现方式</p><p>$\quad$ $\quad$ 接收端不缓存：可以正常工作，处理简单，但效率低</p><p>$\quad$ $\quad$ 接收端缓存：效率高，但处理复杂</p><h5 id="TCP发送端"><a href="#TCP发送端" class="headerlink" title="TCP发送端"></a>TCP发送端</h5><h6 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h6><p>$\quad$ 事件1：收到应用数据：</p><p>$\quad$ $\quad$ 创建并发送TCP报文段</p><p>$\quad$ $\quad$ 若当前没有定时器在运行（没有已发送、未确认的报文段），启动定时器</p><p>$\quad$ 事件2：超时:</p><p>$\quad$ $\quad$ 重传包含最小序号的、未确认的报文段</p><p>$\quad$ $\quad$ 重启定时器</p><p>$\quad$ 事件3：收到ACK：</p><p>$\quad$ $\quad$ 如果确认序号大于基序号（已发送未确认的最小序号）：</p><p>$\quad$ $\quad$ $\quad$ 推进发送窗口（更新基序号）</p><p>$\quad$ $\quad$ $\quad$ 如果发送窗口中还有未确认的报文段，重启定时器，否则终止定时器</p><h6 id="状态机-3"><a href="#状态机-3" class="headerlink" title="状态机"></a>状态机</h6><p><img src="/../CNP/CN532.png"></p><h6 id="重传场景"><a href="#重传场景" class="headerlink" title="重传场景"></a>重传场景</h6><p><img src="/../CNP/CN533.png"></p><p>$\quad$ TCP通过采用以下机制减少了不必要的重传：</p><p>$\quad$ $\quad$ 只使用一个定时器且只重发第一个未确认报文，避免了超时设置过小时重发大量报文段</p><p>$\quad$ $\quad$ 利用流水式发送和累积确认，可以避免重发某些丢失了ACK的报文段</p><h6 id="优化1：设置超时值"><a href="#优化1：设置超时值" class="headerlink" title="优化1：设置超时值"></a>优化1：设置超时值</h6><p>$\quad$ 若超时值太小，容易产生不必要的重传</p><p>$\quad$ 若超时值太大，则丢包恢复的时间太长</p><p>$\quad$ 直观上，超时值应大于RTT，但RTT是变化的</p><p>$\quad$RTT是变化的，需要实时测量从发出某个报文段到收到其确认报文段之间经过的时间（称SampleRTT）</p><p>$\quad$ $\quad$ 由于SampleRTT波动很大，更有意义的是计算其平均值（称EstimatedRTT）</p><p>$\quad$ $\quad$ 平均RTT的估算方法（指数加权移动平均）：EstimatedRTT &#x3D; (1- a)<em>EstimatedRTT + a</em>SampleRTT（典型地，a &#x3D; 0.125）</p><p>$\quad$ 瞬时RTT和平均RTT有很大的偏差：</p><p>$\quad$ $\quad$ 需要在EstimtedRTT 上加一个“安全距离”，作为超时值</p><p>$\quad$ $\quad$ 安全距离的大小与RTT的波动幅度有关</p><p>$\quad$ 估算SampleRTT 与 EstimatedRTT的偏差（称DevRTT）：DevRTT &#x3D; (1-b)<em>DevRTT + b</em>|SampleRTT-EstimatedRTT|（典型地， b &#x3D; 0.25）</p><p>$\quad$ 设置重传定时器的超时值：</p><p>$\quad$ $\quad$ TimeoutInterval &#x3D; EstimatedRTT + 4xDevRTT</p><p><strong>TCP确认的二义性</strong></p><p>$\quad$ 重传的TCP报文段使用与原报文段相同的序号</p><p>$\quad$ 发送端收到确认后 ，无法得知是对哪个报文段进行的确认</p><p>$\quad$ 解决方法：</p><p>$\quad$ $\quad$ 忽略有二义性的确认，只对一次发送成功的报文段测量SampleRTT ，并更新EstimtedRTT</p><p>$\quad$ $\quad$ 当TCP重传一个段时，停止测量SampleRTT</p><p><strong>定时器补偿</strong></p><p>$\quad$ 简单忽略重传报文段的问题：</p><p>$\quad$ $\quad$ 重传意味着超时值可能偏小了，需要增大</p><p>$\quad$ $\quad$ 若简单忽略重传报文段（不更新EstimtedRTT），则超时值也不会更新，超时设置过小的问题没有解决</p><p>$\quad$ 解决方法：</p><p>$\quad$ $\quad$ 采用定时器补偿策略，发送方每重传一个报文段，就直接将超时值增大一倍（不依赖于RTT的更新）</p><p>$\quad$ $\quad$ 若连续发生超时事件，超时值呈指数增长（至一个设定的上限值）</p><p><strong>Karn算法</strong></p><p>$\quad$ Karn算法结合使用RTT估计值和定时器补偿策略确定超时值：</p><p>$\quad$ $\quad$ 使用EstimatedRTT估计初始的超时值</p><p>$\quad$ $\quad$ 若发生超时，每次重传时对定时器进行补偿（超时值加倍），直到成功传输一个报文段为止</p><p>$\quad$ $\quad$ 若收到上层应用数据、或某个报文段没有重传就被确认了，用最近的EstimatedRTT估计超时值</p><h6 id="优化2-：快速重传"><a href="#优化2-：快速重传" class="headerlink" title="优化2 ：快速重传"></a>优化2 ：快速重传</h6><p><img src="/../CNP/CN534.png"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><br> event: ACK received, with ACK field value of y<br><br><span class="hljs-title function_">if</span> <span class="hljs-params">(y &gt; SendBase)</span><br><br>&#123; <span class="hljs-comment">//收到更新的确认号</span><br><br>SendBase = y<br><br><span class="hljs-keyword">if</span> (there are currently not-yet-acknowledged segments)<br><br>start timer<br><br>&#125;<br><br><span class="hljs-keyword">else</span><br><br>&#123; <span class="hljs-comment">//收到重复序号的ACK</span><br><br>increment count of dup ACKs received <span class="hljs-keyword">for</span> y<br><br><span class="hljs-keyword">if</span> (count of dup ACKs received <span class="hljs-keyword">for</span> y = <span class="hljs-number">3</span>) &#123;<br><br>resend segment with sequence number y　<span class="hljs-comment">//快速重传　</span><br><br>&#125;<br><br></code></pre></td></tr></table></figure><h5 id="TCP接收端"><a href="#TCP接收端" class="headerlink" title="TCP接收端"></a>TCP接收端</h5><p>$\quad$ 理论上，接收端只需区分两种情况：</p><p>$\quad$ $\quad$ 收到期待的报文段：发送更新的确认序号</p><p>$\quad$ $\quad$ 其它情况：重复当前的确认序号</p><p>$\quad$ 为减小通信量，TCP允许接收端推迟确认：</p><p>$\quad$ $\quad$ 接收端可以在收到若干个报文段后，发送一个累积确认的报文段（类似GBN）</p><p>$\quad$ 理论上，接收端只需区分两种情况：</p><p>$\quad$ $\quad$ 收到期待的报文段：发送更新的确认序号</p><p>$\quad$ $\quad$ 其它情况：重复当前的确认序号</p><p>$\quad$ 为减小通信量，TCP允许接收端推迟确认：</p><p>$\quad$ $\quad$ 接收端可以在收到若干个报文段后，发送一个累积确认的报文段（类似GBN）</p><h6 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h6><p><img src="/../CNP/CN535.png"></p><h6 id="TCP结合了GBN和SR的优点"><a href="#TCP结合了GBN和SR的优点" class="headerlink" title="TCP结合了GBN和SR的优点"></a>TCP结合了GBN和SR的优点</h6><p>$\quad$ 定时器的使用：与GBN类似，只对最早未确认的报文段使用一个定时器</p><p>$\quad$ 超时重传：与SR类似，只重传部分数据</p><p>$\quad$ TCP在重传开销方面要优于GBN 和 SR！</p><p><img src="/../CNP/CN536.png"></p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/../CNP/CN537.png"></h2>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>CN</category>
      
      <category>传输层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CN</tag>
      
      <tag>传输层</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git与CMake</title>
    <link href="/2023/10/19/Git%E4%B8%8ECMake/"/>
    <url>/2023/10/19/Git%E4%B8%8ECMake/</url>
    
    <content type="html"><![CDATA[<p>git和cmake相关内容</p><span id="more"></span><h1 id="Git与CMake"><a href="#Git与CMake" class="headerlink" title="Git与CMake"></a>Git与CMake</h1><h2 id="CMake-基本使用方法"><a href="#CMake-基本使用方法" class="headerlink" title="CMake 基本使用方法"></a>CMake 基本使用方法</h2><p>$\quad$ CMake是一个简单的工具，帮助我们从更抽象的角度来维护项目，而不需要去手动调整和键入编译指令等细碎的内容</p><h3 id="一个简单的Example"><a href="#一个简单的Example" class="headerlink" title="一个简单的Example"></a>一个简单的Example</h3><p>$\quad$ 新建一个目录并进入该目录<code>mkdir Test &amp;&amp; cd Test</code>，在该目录下创建文件<code>CMakeLists.txt</code>，并在该文件内输入如下的内容</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><br><span class="hljs-keyword">project</span> (<span class="hljs-keyword">Test</span>)<br><br><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.10</span>)<br><br></code></pre></td></tr></table></figure><p>$\quad$ 这样一个最简单的CMake项目就建立完成了</p><p>为了测试CMake的功能，我们在这个目录下新建一个<code>main.cpp</code>的文件，内容如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> </span>&#123;<br><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Hello World&quot;</span> &lt;&lt; std::endl;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>$\quad$ 修改<code>CMakeLists.txt</code>在末尾加入一行<code>add_executable(hello main.cpp)</code>这一行代码的意义在于：</p><ol><li><p>新建了一个hello的可执行程序</p></li><li><p>这个hello的可执行程序代码由main.cpp这个<strong>源文件</strong>构成</p></li></ol><p>$\quad$ 在该目录下新建一个<code>build</code>文件夹，进入这个文件夹并执行<code>cmake .. -G &quot;Unix Makefiles&quot;</code></p><p>$\quad$ 这样，我们就在<code>build</code>目录下生成了Makefile的文件，只需要输入<code>make</code>即可进行编译，编译的结果也在<code>build</code>目录中</p><p>$\quad$ 此时我们应该能在<code>build</code>目录中找到一个叫做<code>hello</code>的可执行文件，和Make本身的作用相同，当我们修改了文件之后，只需要在<code>build</code>目录中重新执行<code>make</code>即可根据修改的文件重新编译</p><p>$\quad$ 当我们修改了<code>CMakeLists.txt</code>文件，但是我们不希望更改任何设置的时候，我们只需要在<code>build</code>目录中重新执行<code>cmake ..</code>即可(不用加任何参数)</p><h3 id="添加头文件"><a href="#添加头文件" class="headerlink" title="添加头文件"></a>添加头文件</h3><p>$\quad$ 某些情况下（比如为了让文件夹更美观），我们可能会将源文件和头文件放到不同的文件夹中比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br>- include<br><br>--- hello.hpp<br><br>- src<br><br>--- main.cpp<br><br>- CMakeLists.txt<br><br></code></pre></td></tr></table></figure><p>$\quad$ 但是这样，我们就需要在<code>hello.cpp</code>中引用<code>hello.hpp</code>时使用<code>#include &quot;../include/hello.hpp</code></p><p>$\quad$ 为了解决这个问题，我们可以在编译选项中加入<code>-Iinclude</code>这个参数解决</p><p>在CMake中表现为，我们可以为某一个可执行文件添加一个include目录使用方法<code>target_include_directories</code>即可解决</p><p>以上面的文件夹结构为例我们可以在<code>CMakeLists.txt</code>中添加</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><br><span class="hljs-keyword">add_executable</span>(hello src/main.cpp)<br><br><span class="hljs-keyword">target_include_directories</span>(hello PUBLIC <span class="hljs-keyword">include</span>)<br><br></code></pre></td></tr></table></figure><p>$\quad$ 这样我们就可以在<code>main.cpp</code>中使用<code>#include &lt;hello.hpp&gt;</code>了</p><h3 id="库"><a href="#库" class="headerlink" title="库"></a>库</h3><h4 id="链接库"><a href="#链接库" class="headerlink" title="链接库"></a>链接库</h4><p>$\quad$ 我们可能经常使用别人的库，当需要进行链接的时候，我们会使用指令<code>-lXXX</code>这会让编译器从某些特定的路径中查找<code>libXXX.a</code>文件并进行链接</p><p>$\quad$ 对应在CMake中的命令为<code>target_link_libraries</code></p><p>$\quad$ 同样以上面的内容为例子，假设一个我们要链接<code>libaaa.a</code>和<code>libbbb.a</code>，我们只需要使用<code>target_link_libraries(hello PUBLIC aaa bbb)</code></p><h4 id="创建库"><a href="#创建库" class="headerlink" title="创建库"></a>创建库</h4><p>$\quad$ 另一种情况是我们希望使用自己创建的库我们可以使用指令<code>add_library</code>创建一个库</p><p>$\quad$ 文件目录为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain"><br>- main.cpp<br><br>- mylib.cpp<br><br>- CMakeLists.txt<br><br></code></pre></td></tr></table></figure><p>$\quad$ <code>main.cpp</code>为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintHelloWorld</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-built_in">PrintHelloWorld</span>(); &#125;<br><br></code></pre></td></tr></table></figure><p>$\quad$ <code>mylib.cpp</code>为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintHelloWorld</span><span class="hljs-params">()</span> </span>&#123;<br><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Hello World&quot;</span> &lt;&lt; std::endl;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>$\quad$ 此时我们只需要像<code>add_executable</code>一样使用<code>add_library</code>即可创建一个库</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><br><span class="hljs-keyword">add_library</span>(mlib mylib.cpp)<br><br></code></pre></td></tr></table></figure><p>$\quad$ 使用指令<code>target_link_libraries(hello PUBLIC mlib)</code>即可</p><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>$\quad$ Git 是一个开源的分布式版本控制系统，常用于便捷高效地处理任何或大或小的项目。</p><h3 id="Git-基本操作"><a href="#Git-基本操作" class="headerlink" title="Git 基本操作"></a>Git 基本操作</h3><h4 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h4><p>$\quad$ <code>git init</code> 用于创建并初始化一个新的仓库，你可以在该仓库开始构建项目。</p><p>$\quad$ 在任意位置新建文件夹 <code>mkdir lab0</code> ，在该目录下执行 <code>git init</code> 会在该位置创建本地 git 仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br><span class="hljs-built_in">mkdir</span> lab0<br><br><span class="hljs-built_in">cd</span> lab0<br><br>git init<br><br></code></pre></td></tr></table></figure><p>$\quad$ 除了新建一个仓库，你也可以使用 <code>git clone</code> 命令拷贝一个现有仓库，我们以 Lab0 的模板仓库为例，在任意位置执行以下指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>git <span class="hljs-built_in">clone</span> https://github.com/N2Sys-EDU/Lab0-Introduction-To-Classroom.git<br><br></code></pre></td></tr></table></figure><p>$\quad$ 这条指令将位于 <code>https://github.com/N2Sys-EDU/Lab0-Introduction-To-Classroom.git</code> 的远程仓库克隆到本地，你将会在当前目录下发现目录 <code>Lab0-Introduction-To-Classroom/</code></p><h4 id="提交修改"><a href="#提交修改" class="headerlink" title="提交修改"></a>提交修改</h4><p>$\quad$ 当你在项目中做了一些修改后，比如创建一个新文件 <code>touch README.md</code> ，你可以使用 <code>git add</code> 命令来将你的修改添加到暂存区，例如 <code>git add README.md</code> ，你也可以使用 <code>git add .</code> 来将所有修改添加到暂存区。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br><span class="hljs-built_in">touch</span> README.md<br><br>git add README.md<br><br></code></pre></td></tr></table></figure><p>$\quad$ 在确认了你的改动之后，你可以将文件提交到仓库中，但在此之前，你需要先设置你的用户信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>git config --global user.name <span class="hljs-string">&quot;labman008&quot;</span><br><br>git config --global user.email <span class="hljs-string">&quot;labman008@pku.edu.cn&quot;</span><br><br></code></pre></td></tr></table></figure><p>$\quad$ <code>--global</code> 用于指明作用域为全局，相应的你也可以使用 <code>--local</code> 来使得配置仅在当前仓库生效。</p><p>$\quad$ 之后，你可以使用 <code>git commit</code> 指令将暂存区的文件提交到本地仓库中，这将会在仓库中创建一个快照，或者说项目的一个版本，你可以利用 git 在不同版本之间快捷的切换，换言之你不用再担心因为反复修改而失去了第一份能运行的代码了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>git commit -m <span class="hljs-string">&quot;first commit&quot;</span><br><br></code></pre></td></tr></table></figure><p>$\quad$ <code>git commit -m [message]</code> 用于为你的提交添加一些说明。另外，你也可以使用 <code>git commit -a</code> 来跳过 <code>git add</code></p><h3 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h3><p>$\quad$ Github 是一个在线软件软代码托管服务平台，使用 git 作为版本控制软件。截至 2022 年 6 月， github 已有超过 5700 万注册用户和 1.9 亿代码库（包括至少 2800 万开源代码库），是世界上最大的代码托管网站和开源社区。</p><h4 id="创建账号"><a href="#创建账号" class="headerlink" title="创建账号"></a>创建账号</h4><p>$\quad$ 打开 <a href="https://github.com/">github官网</a> ，点击右上角 <code>sign up</code> ，跟随指引创建你的 github 账号。</p><h4 id="创建仓库-1"><a href="#创建仓库-1" class="headerlink" title="创建仓库"></a>创建仓库</h4><p>$\quad$ 登入后点击左侧 New 或右上角加号 - <code>New repository</code> 新建一个仓库，键入仓库名和其他你觉得需要的信息后点击 <code>Create repository</code> 即可完成创建。</p><h4 id="配置-ssh-key"><a href="#配置-ssh-key" class="headerlink" title="配置 ssh key"></a>配置 ssh key</h4><p>$\quad$ 为了在本地仓库和远程仓库间进行传输的安全性，需要进行验证。我们推荐你使用 ssh 进行加密传输，为此你需要在 github 上添加你的 ssh 公钥。</p><h5 id="生成-SSH-Key"><a href="#生成-SSH-Key" class="headerlink" title="生成 SSH Key"></a>生成 SSH Key</h5><p>$\quad$ 在本地使用 <code>ssh-keygen</code> 命令生成密钥。简单起见，这里我们使用 <code>ssh-keygen</code> 的默认生成方式，你可以查询该指令的参数来修改生成方式。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>ssh-keygen<br><br></code></pre></td></tr></table></figure><p>$\quad$ 你可以简单的键入三次回车来生成密钥，生成的密钥在 <code>~/.ssh/</code> 目录下。</p><h5 id="添加-SSH-Key"><a href="#添加-SSH-Key" class="headerlink" title="添加 SSH Key"></a>添加 SSH Key</h5><p>$\quad$ 回到 github ，点击右上角头像 - <code>Settings</code> ，然后点击左侧 <code>SSH and GPG keys</code> 进入 ssh key 配置界面。点击 <code>New SSH key</code> 添加新的密钥。</p><p>$\quad$ 复制本地 <code>~/.ssh/id_rsa.pub</code> 中的 key 粘贴进 <code>Key</code> 中，在 <code>Title</code> 一栏你可以为该密钥命名。</p><p>$\quad$ 在 linux 上你可以使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br><span class="hljs-built_in">cat</span> ~/.ssh/id_rsa.pub<br><br></code></pre></td></tr></table></figure><p>$\quad$ 获取生成的公钥。</p><p>$\quad$ 输入完后，点击 <code>Add SSH key</code> 完成添加。</p><p>$\quad$ 你可以在本地执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>ssh -T git@github.com<br><br></code></pre></td></tr></table></figure><p>$\quad$ 来测试是否添加成功。</p><h4 id="克隆仓库到本地"><a href="#克隆仓库到本地" class="headerlink" title="克隆仓库到本地"></a>克隆仓库到本地</h4><p>$\quad$ 打开你想要 clone 的远程仓库，比如 classroom 自动新建的你的 lab0 仓库，点击绿色的 <code>Code</code> 按钮，选择 <code>SSH</code> ，复制下方的链接。</p><p>在本地执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>git <span class="hljs-built_in">clone</span> git@github.com:N2Sys-EDU/lab0-introduction-xxx.git<br><br></code></pre></td></tr></table></figure><p>$\quad$ 将 clone 后的链接换成刚刚复制的链接，如果之前的配置正确，你将在本地看到 clone 下来的本地仓库。最后，我们需要在本地仓库和远程仓库间进行同步。</p><h5 id="push"><a href="#push" class="headerlink" title="push"></a>push</h5><p>$\quad$ 你可以通过 <code>git push</code> 命令将本地仓库推送到远端。注意，只有已提交的更改才会被推送。即，假设你修改了 lab0 仓库中的 hellonetwowrk.cpp 文件，那么你可以通过以下指令更新远程仓库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>git add hellonetwork.cpp<br><br>git commit -m <span class="hljs-string">&quot;hellonetwork&quot;</span><br><br>git push<br><br></code></pre></td></tr></table></figure><p>$\quad$ 或者简单的使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>git commit -am <span class="hljs-string">&quot;hellonetwork&quot;</span><br><br>git push<br><br></code></pre></td></tr></table></figure><h5 id="pull"><a href="#pull" class="headerlink" title="pull"></a>pull</h5><p>$\quad$ 你可以通过 <code>git pull</code> 命令将远端仓库的更新拉取到本地。这主要用于合作开发或者使用多台设备进行开发。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>git pull<br><br></code></pre></td></tr></table></figure><h5 id="branch"><a href="#branch" class="headerlink" title="branch"></a>branch</h5><p>$\quad$ 你可以通过 <code>git branch</code> 命令来基于当前版本创建一个新的分支，不同的分支创建后互相独立。之后，你可以通过 <code>git checkout</code> 命令来切换分支。举例来说，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>git branch new-branch<br><br>git checkout new-branch<br><br></code></pre></td></tr></table></figure><p>$\quad$ 对分支 new-branch 的修改不会影响到原分支，同样的，对原分支的修改将不再影响 new-branch 你可以再次执行 <code>git checkout main</code> 回到原分支， <code>main</code> 是 github 的默认分支。</p><p>$\quad$ 另外，你可以通过 <code>git merge</code> 命令合并两个分支。</p><h5 id="reset"><a href="#reset" class="headerlink" title="reset"></a>reset</h5><p>$\quad$ <code>reset</code> 命令用于版本回滚，即回退到提交过的某一版本</p><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>CMake</tag>
      
      <tag>Github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Socket编程</title>
    <link href="/2023/10/18/socket%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/10/18/socket%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p> socket 编程相关内容 对应计网lab1</p><span id="more"></span><h1 id="Socket编程"><a href="#Socket编程" class="headerlink" title="Socket编程"></a>Socket编程</h1><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p>$\quad$ 这里给出了一个最简单的连接的例子:</p><p><strong>Server</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>sock = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>); <span class="hljs-comment">// 申请一个TCP的socket</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> addr; <span class="hljs-comment">// 描述监听的地址</span><br><br>addr.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">23233</span>); <span class="hljs-comment">// 在23233端口监听 htons是host to network (short)的简称，表示进行大小端表示法转换，网络中一般使用大端法</span><br><br>addr.sin_family = AF_INET; <span class="hljs-comment">// 表示使用AF_INET地址族</span><br><br><span class="hljs-built_in">inet_pton</span>(AF_INET, <span class="hljs-string">&quot;127.0.0.1&quot;</span>, &amp;addr.sin_addr); <span class="hljs-comment">// 监听127.0.0.1地址，将字符串表示转化为二进制表示</span><br><br><span class="hljs-built_in">bind</span>(sock, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;addr, <span class="hljs-built_in">sizeof</span>(addr));<br><br><span class="hljs-built_in">listen</span>(sock, <span class="hljs-number">128</span>);<br><br><span class="hljs-type">int</span> client = <span class="hljs-built_in">accept</span>(sock, <span class="hljs-literal">nullptr</span>, <span class="hljs-literal">nullptr</span>);<br><br></code></pre></td></tr></table></figure><p><strong>Client</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br>sock = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> addr;<br><br>addr.sin_port = <span class="hljs-built_in">htons</span>(<span class="hljs-number">23233</span>);<br><br>addr.sin_family = AF_INET;<br><br><span class="hljs-built_in">inet_pton</span>(AF_INET, <span class="hljs-string">&quot;127.0.0.1&quot;</span>, &amp;addr.sin_addr); <span class="hljs-comment">// 表示我们要连接到服务器的127.0.0.1:23233</span><br><br><span class="hljs-built_in">connect</span>(sock, (<span class="hljs-keyword">struct</span> sockaddr*)&amp;addr, <span class="hljs-built_in">sizeof</span>(addr));<br><br></code></pre></td></tr></table></figure><p>而传输数据我们只需要使用<code>recv</code>和<code>send</code>进行即可</p><p><strong>Server</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-type">char</span> buffer[<span class="hljs-number">128</span>];<br><br><span class="hljs-type">size_t</span> l = <span class="hljs-built_in">recv</span>(client, buffer, <span class="hljs-number">128</span>, <span class="hljs-number">0</span>);<br><br><span class="hljs-built_in">send</span>(client, buffer, l, <span class="hljs-number">0</span>);<br><br></code></pre></td></tr></table></figure><p><strong>Client</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-type">char</span> buffer[<span class="hljs-number">128</span>];<br><br><span class="hljs-built_in">sprintf</span>(buffer, <span class="hljs-string">&quot;Hello Server&quot;</span>);<br><br><span class="hljs-built_in">send</span>(sock, buffer, <span class="hljs-built_in">strlen</span>(buffer)+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br><br><span class="hljs-built_in">recv</span>(sock, buffer, <span class="hljs-number">128</span>, <span class="hljs-number">0</span>);<br><br></code></pre></td></tr></table></figure><p>$\quad$ 这个例子描述了Client向Server发送字符串”Hello Server”，Server将数据发回Client的过程。</p><p>$\quad$ 但是事实上这样做并不总是正确的，我们可以将send看成是一个缓冲区，这个缓冲区按照固定的速度将内容放到对侧连接的缓冲区中，此时因为已经送达，我们才能将这个缓冲区中已经确认到达的数据清除。调用send的过程等价于我们将要发送的数据拷贝一份放入缓冲区，然后缓冲区会自动发送。但是缓冲区的大小是有限制的，因此调用send并不一定将所有数据都成功放入缓冲区了。</p><p>$\quad$ 下面给出了一个保证将所有数据放入缓冲区的例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-type">size_t</span> ret = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span> (ret &lt; len) &#123;<br><br><span class="hljs-type">ssize_t</span> b = <span class="hljs-built_in">send</span>(sock, buffer + ret, len - ret, <span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;socket Closed&quot;</span>); <span class="hljs-comment">// 当连接断开</span><br><br><span class="hljs-keyword">if</span> (b &lt; <span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error ?&quot;</span>); <span class="hljs-comment">// 这里可能发生了一些意料之外的情况</span><br><br>ret += b; <span class="hljs-comment">// 成功将b个byte塞进了缓冲区</span><br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>接收端同理:</p><ol><li><p>接收缓冲区是有大小限制的</p></li><li><p>当我们想接收一定长度的数据的时候，这些数据可能只有部分到达了当前机器</p></li></ol><p>因此我们也需要像这样接收数据才能获取到我们想要的所有信息</p><h2 id="Pthread"><a href="#Pthread" class="headerlink" title="Pthread"></a>Pthread</h2><p>$\quad$ <code>pthread_create</code> 函数用于创建一个新的线程，它需要四个参数，包括一个 <code>pthread_t</code> 变量用于存储线程，一个 <code>pthread_attr_t</code> 变量用于指明线程属性，一个线程初始化函数及该函数的参数。线程初始化函数会在线程执行时被调用。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">pthread_t</span> thread;<br><br><span class="hljs-type">pthread_addr_t</span> thread_attribute;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">thread_function</span><span class="hljs-params">(<span class="hljs-type">void</span> *argument)</span>;<br><br><span class="hljs-type">char</span>* argument;<br><br>  <br><br>pthread_create(&amp;thread, thread_attribute, (<span class="hljs-type">void</span>*)&amp;thread_function, (<span class="hljs-type">void</span>*)&amp;argument);<br><br></code></pre></td></tr></table></figure><p>$\quad$ 大多数情况下，线程属性参数用来指明最小栈空间，可以使用 <code>pthread_attr_default</code> 来使用默认参数, 在未来可能会有更多的用法。与 UNIX 进程的 <code>fork</code> 从当前程序的相同位置开始执行不同，线程会从 <code>pthread_create</code> 中指明的初始化函数处开始执行。这样做的原因很简单，如果线程也从当前程序位置开始执行，那么可能有多个线程使用相同的 resources 执行同样的指令。</p><p>$\quad$ 现在我们知道了如何创建线程。让我们来设计一个多线程应用在 <code>stdout</code> 上输出被深爱的 <code>Hello World</code> 吧。首先，我们需要两个 <code>pthread_t</code> 变量，以及一个初始化函数。我们还需要一个方法来让每个线程打印不同的信息。一个方法是将输出分解成若干字符串，并给每个线程一个不同的字符串作为初始化函数的参数。可以参考以下代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">void</span> <span class="hljs-title function_">print_message_function</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span>;<br><br>main() &#123;<br><br><span class="hljs-type">pthread_t</span> thread1, thread2;<br><br><span class="hljs-type">char</span>* message1 = <span class="hljs-string">&quot;Hello&quot;</span>;<br><br><span class="hljs-type">char</span>* message2 = <span class="hljs-string">&quot;World&quot;</span>;<br><br>pthread_create(&amp;thread1, pthread_attr_default, (<span class="hljs-type">void</span>*)&amp;print_message_fuction, (<span class="hljs-type">void</span>*)message1);<br><br>pthread_create(&amp;thread2, pthread_attr_default, (<span class="hljs-type">void</span>*)&amp;print_message_fuction, (<span class="hljs-type">void</span>*)message2);<br><br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">print_message_function</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span> &#123;<br><br><span class="hljs-type">char</span>* message;<br><br>message = (<span class="hljs-type">char</span>*)ptr;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s &quot;</span>, message);<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>$\quad$ 注意 <code>print_message_function</code> 的原型以及在调用时的强制类型转换。这段程序首先通过 <code>pthread_create</code> 创建第一个线程，并将 <code>Hello</code> 作为初始化参数传入。第二个线程的初始化参数是 <code>World</code> 。第一个线程将从 <code>print_message_function</code> 的第一行开始执行，它将输出 <code>Hello</code> 并退出。一个线程会在离开初始化函数时被关闭，因此第一个线程将会在输出 <code>Hello</code> 后关闭。同样的，第二个线程会在输出 <code>World</code> 后关闭。尽管这段代码看起来很合理，它实际上存在两个重要的缺陷。</p><p>$\quad$ 第一个也是最重要的问题是，线程是并发执行的。因此并不能保证第一个线程先于第二个线程到达 <code>printf</code> 函数。因此我们可能会看到 <code>World Hello</code> 而不是 <code>Hello World</code> 。</p><p>$\quad$ 另一个更微妙的问题是，注意到在父线程（最初的线程，尽管每个线程都是一样的，我们仍习惯于这样称呼）中调用了 <code>exit</code> 函数。如果父线程在两个子线程执行 <code>printf</code> 之前就调用了 <code>exit</code> ，那么将不会有任何输出。这是因为 <code>exit</code> 函数将退出进程（释放任务），因而将结束所有线程。因此，任一线程，不论是父线程或是子线程，只要调用 <code>exit</code> 就将结束所有其他线程和该进程。如果线程希望明确的终止，它必须使用 <code>pthread_exit</code> 函数来避免这个问题。</p><p>$\quad$ 因此可以看到，我们的 <code>Hello World</code> 程序有两个竞争情况。一个是由 <code>exit</code> 调用产生的竞争，另一个是由谁先到达 <code>printf</code> 产生的竞争。让我们使用一点疯狂的胶水和胶带来解决这些竞争。既然我们希望每个子线程在父线程退出之前完成，让我们在父线程中插入一些延迟来给子线程更多时间。为了保证第一个子线程先执行 <code>printf</code> ，让我们在第二次 <code>pthread_create</code> 调用前插入一些延迟。这样我们的代码修改为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-type">void</span> <span class="hljs-title function_">print_message_function</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span>;<br><br>main() &#123;<br><br><span class="hljs-type">pthread_t</span> thread1, thread2;<br><br><span class="hljs-type">char</span>* message1 = <span class="hljs-string">&quot;Hello&quot;</span>;<br><br><span class="hljs-type">char</span>* message2 = <span class="hljs-string">&quot;World&quot;</span>;<br><br>pthread_create(&amp;thread1, pthread_attr_default, (<span class="hljs-type">void</span>*)&amp;print_message_fuction, (<span class="hljs-type">void</span>*)message1);<br><br>sleep(<span class="hljs-number">10</span>);<br><br>pthread_create(&amp;thread2, pthread_attr_default, (<span class="hljs-type">void</span>*)&amp;print_message_fuction, (<span class="hljs-type">void</span>*)message2);<br><br>sleep(<span class="hljs-number">10</span>);<br><br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">print_message_function</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span> &#123;<br><br><span class="hljs-type">char</span>* message;<br><br>message = (<span class="hljs-type">char</span>*)ptr;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s &quot;</span>, message);<br><br>pthread_exit(<span class="hljs-number">0</span>);<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>$\quad$ 这段代码能达到我们的目标吗？并不一定。依靠时间上的延迟来执行同步是不安全的。 这里的竞争情况实际上和我们在分布式应用和共享资源中遇到的情况一样。共享资源就是这里的 <code>stdout</code> ，分布式计算单元就是这里的三个线程。线程一必须在线程二之前输出到 <code>stdout</code> 并且两者都需要在父线程调用 <code>exit</code> 前完成工作。</p><p>$\quad$ 除了我们试图使用延迟来进行同步之外，我们还犯了另一个错误。 <code>sleep</code> 函数和 <code>exit</code> 函数一样都作用于进程。当一个线程调用 <code>sleep</code> 时，整个进程都将挂起，也就是说所有的线程都将被挂起。因此我们现在的情况实际上和不添加 <code>sleep</code> 时完全一样，除了程序会多运行 20 秒。想要使一个线程延时，正确的函数应该是 <code>pthread_delay_np</code> （ np 意为 not process ），例如，将一个线程延迟 2 秒可以使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec</span> <span class="hljs-title">delay</span>;</span><br><br>delay.tv_sec = <span class="hljs-number">2</span>;<br><br>delay.tv_nsec = <span class="hljs-number">0</span>;<br><br>pthread_delay_np(&amp;delay);<br><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>CN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CN</tag>
      
      <tag>socket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>应用层-其他应用层协议</title>
    <link href="/2023/10/15/%E5%BA%94%E7%94%A8%E5%B1%82-%E5%85%B6%E4%BB%96%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE/"/>
    <url>/2023/10/15/%E5%BA%94%E7%94%A8%E5%B1%82-%E5%85%B6%E4%BB%96%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<p> 对应 北京大学计算机网络课程第二讲第三部分</p><p> 参考教材计算机网络-自顶向下方法</p><span id="more"></span><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="应用层-其他应用层协议"><a href="#应用层-其他应用层协议" class="headerlink" title="应用层-其他应用层协议"></a>应用层-其他应用层协议</h2><h3 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h3><p>$\quad$ 每个实体都是一个对等结点（peer）<br>$\quad$ 服务：去中心化的连接与传输<br>$\quad$ $\quad$ 不需要长期在线服务器<br>$\quad$ $\quad$ 任意的对等结点可以直接建立连接<br>$\quad$ $\quad$ 对等结点可以随时加入或退出<br>$\quad$ $\quad$ 对等结点可以变换IP地址<br>$\quad$ 典型例子：<br>$\quad$ $\quad$ P2P文件分享（BitTorrent)<br>$\quad$ $\quad$ 视频流（PPLive）<br>$\quad$ $\quad$ VoIP（Skype）</p><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>$\quad$ 避免单一中心化结点造成的性能瓶颈<br>例:<br><img src="/../CNP/CN301.png"><br><img src="/../CNP/CN302.png"></p><h4 id="核心问题：Peer索引"><a href="#核心问题：Peer索引" class="headerlink" title="核心问题：Peer索引"></a>核心问题：Peer索引</h4><p>$\quad$ P2P协议中，资源索引都是最关键的问题<br>$\quad$ $\quad$ 目标：给定资源，查询拥有资源的peer<br>$\quad$ $\quad$ Peer可以随时加入或者退出，也可以动态更改IP地址<br>$\quad$ 例：P2P文件传输<br>$\quad$ $\quad$ 索引系统：记录文件到网络位置（IP地址 + 端口号）的映射<br>$\quad$ $\quad$ 通过索引系统，定位文件的下载地址<br>$\quad$ $\quad$ 需要动态追踪每个peer拥有的文件<br>$\quad$ 例：P2P即时通讯<br>$\quad$ $\quad$ 索引系统：记录用户ID到网络位置（IP地址 + 端口号）的映射<br>$\quad$ $\quad$ 用户启动即时通讯软件时，告诉索引系统当前IP地址与端口号<br>$\quad$ $\quad$ Peers通过索引系统，查找发送目标的网络位置</p><h5 id="中心化索引"><a href="#中心化索引" class="headerlink" title="中心化索引"></a>中心化索引</h5><p>$\quad$ 由一个中心化服务器帮助检索<br>$\quad$ $\quad$ P2P模式传输资源（文件，即时消息）<br>$\quad$ $\quad$ 中心化模式定位资源位置</p><h6 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h6><p>$\quad$ 每个peer需要连接中心化服务器, 告知:<br>$\quad$ $\quad$ 自身IP地址<br>$\quad$ $\quad$ 拥有内容<br>$\quad$ Alice下载文件时，先向中心化服务器查询某个内容的拥有者Bob<br>$\quad$  Alice向Bob提出请求</p><h6 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h6><p>$\quad$ 单点故障与性能瓶颈<br>$\quad$ 解决：洪泛请求<br>$\quad$ $\quad$ 每个peer独立建立索引，记录自身拥有的资源<br>$\quad$ $\quad$ Peer之间形成一个图（graph）<br>$\quad$ $\quad$ $\quad$ 图中的边为TCP连接<br>$\quad$ $\quad$ $\quad$ 通常每个peer建立小于10个连接<br>$\quad$ $\quad$ $\quad$ 注意：peers与TCP连接形成的网络，又被成为Overlay网络，有别于IP网络<br>$\quad$ $\quad$ 查找资源：<br>$\quad$ $\quad$ $\quad$ 每个peer向邻居peer查询，如果邻居peer没有该资源，则邻居peer向自身邻居递归查询<br>$\quad$ $\quad$ $\quad$ 一旦查询到结果，沿查询路径返回最初的查询发起者<br><img src="/../CNP/CN303.png"><br>$\quad$ 解决：混合索引<br>$\quad$ $\quad$ 混合方法: 介于中心化索引与洪泛索引之间<br>$\quad$ $\quad$ 将Overlay网络组织为层次化结构<br>$\quad$ $\quad$ $\quad$ 存在超级结点<br>$\quad$ $\quad$ $\quad$ 每个普通结点连向至少1个超级结点<br>$\quad$ $\quad$ $\quad$ 超级结点之间可以任意建立连接<br>$\quad$ $\quad$ 普通结点与超级结点间，使用中心化索引<br>$\quad$ $\quad$ $\quad$ 超级结点扮演中心化服务器<br>$\quad$ $\quad$ $\quad$ 超级结点记录“资源-&gt;网络位置”映射<br>$\quad$ $\quad$ 超级结点间采用去中心化的洪泛方式查询索引</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><h5 id="Gnutella"><a href="#Gnutella" class="headerlink" title="Gnutella"></a>Gnutella</h5><p>$\quad$ 纯P2P的文件分发协议<br>$\quad$ 建立TCP connections：洪泛过程<br>$\quad$ $\quad$ 1.新加入结点Alice通过candidate peers列表，找到其他peers<br>$\quad$ $\quad$ 2.Alice遍历列表里每个peer，直到与某个peer Bob建立TCP连接<br>$\quad$ $\quad$ 3.洪泛: Alice发送Ping消息给Bob，Bob将这个Ping消息转发给所有邻居，邻居们也不断重复<br>$\quad$ $\quad$ $\quad$ Peers收到Ping消息后，向Alice回复Pong消息<br>$\quad$ $\quad$ 4.Alice收到Pong消息后，可以建立新的TCP连接</p><h5 id="BitTorret"><a href="#BitTorret" class="headerlink" title="BitTorret"></a>BitTorret</h5><p>$\quad$ BitTorrent是基于P2P思想的文件分发的一个协议<br>$\quad$ BitTorrent不是纯P2P架构<br>$\quad$ 所有正在交换某个文件的peer，组成一个torrent（种子）<br>$\quad$ 中心化的跟踪器(Tracker)：<br>$\quad$ $\quad$ 一个独立服务器<br>$\quad$ $\quad$ 维护着一个正在主动上传和下载该内容的所有其他对等用户列表<br>$\quad$ $\quad$ 对等方可以通过Tracker（跟踪器）找到其他对等方<br><img src="/../CNP/CN304.png"></p><h6 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h6><p>$\quad$ 文件被划分为256Kb大小的块(chunk)<br>$\quad$ torrent中的节点发送或接收文件<br>$\quad$ 当一个peer加入torrent时<br>$\quad$ $\quad$ 向追踪器注册，加入torrent中<br>$\quad$ $\quad$ 没有任何块，但随后会从其他peers逐渐获取文件块<br>$\quad$ 下载过程：<br>$\quad$ $\quad$ peers彼此之间交换各自拥有的块清单<br>$\quad$ $\quad$ 下载与上传文件块可同时进行<br>$\quad$ $\quad$ 也与其他peers互相交换各自知道的peers<br>$\quad$ 节点动态加入和退出<br>$\quad$ 获取整个文件后，存在自私离开可能</p><h6 id="结点优化策略"><a href="#结点优化策略" class="headerlink" title="结点优化策略"></a>结点优化策略</h6><p>$\quad$ 一些优化策略<br>$\quad$ $\quad$ 选择罕见的很难找到的块下载<br>$\quad$ $\quad$ 趋向于匹配那些相互之间具有可比性上传和下载速率的对等节点（同级别结点）<br>$\quad$ $\quad$ 一个对等节点为其他对等节点作出的贡献越多，它预期的回报就越大</p><h5 id="Skype"><a href="#Skype" class="headerlink" title="Skype"></a>Skype</h5><p>$\quad$ 基于P2P的即使通讯<br>$\quad$ 私有的应用层协议<br>$\quad$ $\quad$ 通过逆向工程推断工作原理<br>$\quad$ 基于层次化结构的混合方法<br>$\quad$ $\quad$ 存在超级结点<br>$\quad$ 超级结点上的索引系统记录：<br>$\quad$ $\quad$ 用户名 -&gt; IP地址</p><h6 id="层级化结构"><a href="#层级化结构" class="headerlink" title="层级化结构"></a>层级化结构</h6><p>$\quad$ 避免网络管理导致普通结点之间无法直接建立连接<br>$\quad$ 网络地址转换（Network address translation，NAT）<br>$\quad$ 防火墙<br>$\quad$ 可以利用超级结点作为中继代理<br>$\quad$ 超级结点之间也并非完全联通，有时候还需要第三方超级结点作为中继<br><img src="/../CNP/CN305.png"></p><h5 id="分布式哈希表"><a href="#分布式哈希表" class="headerlink" title="分布式哈希表"></a>分布式哈希表</h5><p>$\quad$ 没有中心化追踪器，实现P2P<br>$\quad$ P2P系统本质是将关键字(key)集合分散到多个peers上<br>$\quad$ 核心挑战：如何管理key-&gt;peer映射<br>$\quad$ $\quad$ peers可能随时加入或退出<br>$\quad$ $\quad$ 需要追踪关键字存储位置的变化<br>$\quad$ $\quad$ 追踪器以中心化的方式，记录各个peers的活跃情况与保存关键字<br>$\quad$ 分布式哈希表（distributed hash tables, DHTs)<br>$\quad$ $\quad$ 不需要中心化追踪器，就能查询每个key在哪个peers上<br>$\quad$ DHT是一个概念，具体有多种实现方式:</p><h6 id="Chord"><a href="#Chord" class="headerlink" title="Chord"></a>Chord</h6><p><img src="/../CNP/CN306.png"><br>$\quad$ 基本思想：<br>$\quad$ 对所有peers地址，以及key计算哈希值<br>$\quad$ 哈希值取模后，排列在一个圆环上<br>$\quad$ 每个key由圆环上顺时针方向的下一个peer负责存储<br>$\quad$ 若查询失败，则继续沿着顺时针方向查询<br>$\quad$ Peers加入或退出时，需要更新操作<br>$\quad$ $\quad$ 可以延迟更新，但增加查询开销<br>$\quad$ $\quad$ 当新Peer加入：<br>$\quad$ $\quad$ $\quad$ 通知前驱结点、后续Peer更改邻居关系<br>$\quad$ $\quad$ $\quad$ 从后续Peer迁移数据<br>$\quad$ $\quad$ 如果多个Peers几乎同时加入<br>$\quad$ $\quad$ $\quad$ 周期性咨询后续Peer：谁是你的前驱Peer<br>$\quad$ $\quad$ $\quad$ 进行邻居关系更新、数据迁移<br>$\quad$ $\quad$ 当Peer正常退出：<br>$\quad$ $\quad$ $\quad$ 通知前驱结点、后续Peer更改邻居关系<br>$\quad$ $\quad$ $\quad$ 将数据迁移至后续Peer<br>$\quad$ $\quad$ 当Peer异常退出<br>$\quad$ $\quad$ $\quad$ 发送数据丢失<br>$\quad$ $\quad$ $\quad$ 解决方案：每份数据在多个peer上进行备份,一旦发现异常退出，从备份数据中进行恢复</p><h3 id="流媒体"><a href="#流媒体" class="headerlink" title="流媒体"></a>流媒体</h3><p>$\quad$ 常见的流媒体服务</p><p>$\quad$ $\quad$ 媒体点播：提前录制好，边下载边播放（起始时延&lt;10s；类VCR操作（例如拖动进度条）&lt;1~2s）</p><p>$\quad$ $\quad$ 媒体直播：边录制边上传，边下载边播放（大规模直播往往有数秒的时延）</p><p>$\quad$ $\quad$ 实时交互 ：双方或多方实时交互式通信（时延&lt;400ms可接受，VR则需要&lt;25ms）</p><p>$\quad$ 流媒体概念</p><p>$\quad$ $\quad$ 连续媒体（音视频）经压缩编码、数据打包后，经过网络发送给接收方</p><p>$\quad$ $\quad$ 接收方对数据进行重组、解码和播放</p><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p>$\quad$ 端到端时延约束</p><p>$\quad$ 时序性约束：流媒体数据必须按照一定的顺序连续播放</p><p>$\quad$ 具有一定程度的容错性：丢失部分数据包也可完成基本功能</p><h4 id="编码与格式"><a href="#编码与格式" class="headerlink" title="编码与格式"></a>编码与格式</h4><p>$\quad$ 视频编码标准：H.264，H.265，VP9，AV1等</p><p>$\quad$ $\quad$ H.264：最主流的编码；支持不同分辨率、比特率；兼容性好</p><p>$\quad$ $\quad$ H.265：H.264的升级，视频内容压缩50%；硬件成本高，专利许可费高</p><p>$\quad$ $\quad$ VP9：Google开源视频编码标准，与H.265相当性能，无许可费</p><p>$\quad$ $\quad$ AV1：开源标准，比H.265与VP9性能更好，开源免费</p><p>$\quad$ 音频编码标准：AAC，MP3，Opus等</p><p>$\quad$ 媒体容器格式：封装视频与音频</p><p>$\quad$ $\quad$ MP4：支持多种视频编码与音频编码，兼容性最好</p><p>$\quad$ $\quad$ MKV：多音轨、多字幕，适合电影电视剧；兼容性不如MP4</p><p>$\quad$ $\quad$ FLV：支持编码最少；早期因为跨平台、交互性好，用于网络流媒体，现逐渐淘汰</p><h4 id="挑战"><a href="#挑战" class="headerlink" title="挑战"></a>挑战</h4><p>$\quad$ 目标：流媒体服务质量</p><p>$\quad$ $\quad$ 画质、启动延迟、平滑、交互性</p><p>$\quad$ 现实约束：网络条件有限</p><p>$\quad$ $\quad$ 带宽有限、动态变化、延迟抖动、丢失、异构性</p><p>$\quad$ 如何在“尽力服务”的网络传输条件下获得良好的视频质量？</p><p>$\quad$ $\quad$ UDP不保障可靠传输（丢包、乱序）</p><p>$\quad$ $\quad$ 即使是TCP，也只保证不丢包与顺序（而且引入额外处理开销），但无法提供带宽与延迟保障</p><h4 id="媒体点播"><a href="#媒体点播" class="headerlink" title="媒体点播"></a>媒体点播</h4><p>$\quad$ 浏览器从服务器下载并播放流媒体文件</p><p>$\quad$ $\quad$ 浏览器用户使用 HTTP 的 GET 报文接入到Web服务器；这个超链指向一个元文件（有音&#x2F;视频文件的统一资源定位符 URL）</p><p>$\quad$ $\quad$ Web服务器把该元文件装入 HTTP 响应报文的主体，发回给浏览器</p><p>$\quad$ $\quad$ 浏览器调用媒体播放器，把提取出的元文件传输给媒体播放器</p><p>$\quad$ $\quad$ 媒体播放器使用元文件中的 URL，向媒体服务器发送 HTTP 请求报文，要求下载音&#x2F;视频文件</p><p>$\quad$ $\quad$ 媒体服务器发送 HTTP 响应报文，把音&#x2F;视频文件发送给媒体播放器；媒体播放器边下载边解压缩边播放（通过时间戳同步音频流和视频流）</p><p><img src="/../CNP/CN307.png"></p><p>$\quad$ 发送端以恒定速率产生数据分组</p><p>$\quad$ 网络传输后的结果</p><p>$\quad$ $\quad$ 由于网络传输的抖动特性，分组到达接收端时变成了非恒定速率</p><p>$\quad$ $\quad$ 此时如果到达时就随即播放，则会出现卡顿</p><p>$\quad$ $\quad$ （分组1、3到达接收端可播放，分组2、4、5、6未到达，出现卡顿）</p><p>$\quad$ 如何应对网络传输的抖动特性</p><p>$\quad$ $\quad$ 在接收端经过缓存后，再以恒定速率播放（推迟播放时间）</p><p>$\quad$ $\quad$ 能够在一定程度上消除了时延的抖动</p><p>$\quad$ $\quad$ 但付出的代价是增加了时延</p><p><img src="/../CNP/CN308.png"></p><p>$\quad$ 客户端缓冲区</p><p>$\quad$ $\quad$ 客户端播放的是本地缓冲区的内容，而不是立即播放来自网络的实时内容</p><p>$\quad$ $\quad$ 基于2个阈值控制</p><p>$\quad$ $\quad$ $\quad$ 缓冲区内容小于低阈值标记：数据即将播完，容易出现卡顿；需要加速传输</p><p>$\quad$ $\quad$ $\quad$ 缓冲区内容大于高阈值标记：占用过多存储空间；可以减慢传输</p><p>$\quad$ $\quad$ $\quad$ 需要的决策：需要多大缓存，服务器以多快速率发送，才能在不稳定的网络中，尽量满足用户期望：高清、低延迟、不卡顿</p><p>$\quad$ $\quad$ $\quad$ 上述决策需要特定网络协议支持</p><p><img src="/../CNP/CN309.png"></p><h4 id="直播与实时音视频"><a href="#直播与实时音视频" class="headerlink" title="直播与实时音视频"></a>直播与实时音视频</h4><p>$\quad$ 实时音频&#x2F;视频所需要的几种应用协议</p><p>$\quad$ $\quad$ 信令协议，对建立的连接起控制作用，如RTSP</p><p>$\quad$ $\quad$ 数据传送协议，使音&#x2F;视频能够以时延敏感属性传送，如RTP&#x2F;RTCP</p><p>$\quad$ $\quad$ $\quad$ 又包括：负责实际数据传输的（如RTP）与负责服务质量保障的（如RTCP）</p><p>$\quad$ 使用TCP，还是UDP？</p><p>$\quad$ $\quad$ UDP不可靠但效率高，更适合实时类应用</p><p>$\quad$ $\quad$ UDP需要自行实现流控算法，增加了开发成本和复杂性</p><p>$\quad$ $\quad$ UDP传输音视频可能会被路由器丢弃或防火墙阻拦，而TCP可以畅通无阻</p><p>$\quad$ 实际：衍生出协议众多，技术路线各异</p><p>$\quad$ 各类协议广泛用于点播、直播、实时音频场景</p><h4 id="流媒体协议"><a href="#流媒体协议" class="headerlink" title="流媒体协议"></a>流媒体协议</h4><p><img src="/../CNP/CN310.png"></p><h5 id="实时传输协议-RTP-Real-time-Transport-Protocol"><a href="#实时传输协议-RTP-Real-time-Transport-Protocol" class="headerlink" title="实时传输协议 RTP (Real-time Transport Protocol)"></a>实时传输协议 RTP (Real-time Transport Protocol)</h5><p>$\quad$ 使用UDP</p><p>$\quad$ RTP 为实时应用提供端到端的数据传输，但不提供任何服务质量的保证</p><p>$\quad$ RTP 不对多媒体数据块做任何处理</p><p>$\quad$ $\quad$ 这里处理指编码、解码、缓存等，这些都是媒体播放器负责</p><h5 id="实时传输控制协议-RTCP-RTP-Control-Protocol"><a href="#实时传输控制协议-RTCP-RTP-Control-Protocol" class="headerlink" title="实时传输控制协议 RTCP (RTP Control Protocol)"></a>实时传输控制协议 RTCP (RTP Control Protocol)</h5><p>$\quad$ RTCP 是与 RTP 配合使用的控制协议</p><p>$\quad$ RTCP 的主要功能：服务质量的监视与反馈、媒体间的同步、播组中成员的标识</p><p>$\quad$ RTCP 分组也使用 UDP 传送</p><p>$\quad$ 可将多个 RTCP 分组封装在一个 UDP 用户数据报中</p><p>$\quad$ RTCP 分组周期性地在网上传送，它带有发送端和接收端对服务质量的统计信息报告</p><p>$\quad$ RTP与RTCP很少直接使用，大多作为其他流媒体协议的基础</p><h5 id="实时流式协议RTSP-Real-Time-Streaming-Protocol"><a href="#实时流式协议RTSP-Real-Time-Streaming-Protocol" class="headerlink" title="实时流式协议RTSP (Real-Time Streaming Protocol)"></a>实时流式协议RTSP (Real-Time Streaming Protocol)</h5><p>$\quad$ RTSP本身并不传送数据，是一个多媒体播放控制协议，通用性好</p><p>$\quad$ $\quad$ 没有定义音频&#x2F;视频的编码方案</p><p>$\quad$ $\quad$ 没有规定音频&#x2F;视频在网络中传送时应如何封装在分组中</p><p>$\quad$ $\quad$ 没有规定音频&#x2F;视频流在媒体播放器中应如何缓存</p><p>$\quad$ RTSP对播放情况进行控制，如：暂停&#x2F;继续、后退、前进等， 又称为“互联网录像机遥控协议”</p><p>$\quad$ RTSP是有状态的协议，它记录用户所处于的状态（初始化状态、播放状态或暂停状态）</p><p>$\quad$ RTSP控制分组既可在 TCP 上传送，也可在 UDP 上传送</p><p>$\quad$ $\quad$ 使用UDP时，底层就是使用RTP+RTCP</p><h6 id="使用-RTSP-的媒体服务器的工作过程"><a href="#使用-RTSP-的媒体服务器的工作过程" class="headerlink" title="使用 RTSP 的媒体服务器的工作过程"></a>使用 RTSP 的媒体服务器的工作过程</h6><p>$\quad$ 浏览器向万维网服务器请求音&#x2F;视频文件</p><p>$\quad$ 万维网服务器从浏览器发送携带有元文件的响应</p><p>$\quad$ 浏览器把收到的元文件传输给媒体播放器</p><p>$\quad$ RTSP 客户与媒体服务器的 RTSP 服务器建立连接</p><p>$\quad$ RTSP 服务器发送响应 RESPONSE 报文</p><p>$\quad$ RTSP 客户发送 PLAY 报文，开始下载音&#x2F;视频文件的特定位置</p><p>$\quad$ RTSP 服务器发送响应 RESPONSE 报文</p><p>$\quad$ 开始传输音视频数据（使用RTP协议传输内容）</p><p>$\quad$ RTSP 客户发送 TEARDOWN 报文断开连接</p><p>$\quad$ RTSP 服务器发送响应 RESPONSE 报文</p><p><img src="/../CNP/CN311.png"></p><h5 id="RTMP"><a href="#RTMP" class="headerlink" title="RTMP"></a>RTMP</h5><p>$\quad$ Adobe开发，最初用于Flash媒体传输，后被广泛使用</p><p><img src="/../CNP/CN312.png"></p><h5 id="其他流媒体协议"><a href="#其他流媒体协议" class="headerlink" title="其他流媒体协议"></a>其他流媒体协议</h5><p>$\quad$ RSVP：让网络层预留资源，通常用于专网</p><p>$\quad$ MMS：Microsoft Media Server Protocol，微软流媒体协议</p><p>$\quad$ $\quad$ 支持UDP、TCP，但是不使用RTP与RTCP，而是微软内部的ASF格式</p><p>$\quad$ $\quad$ 逐渐淘汰</p><p>$\quad$ 随着HTTP5的出现，传输流媒体协议逐渐减少</p><p>$\quad$ 最新流媒体技术：</p><h6 id="网页实时通信-WebRTC（Web-Real-Time-Communication）"><a href="#网页实时通信-WebRTC（Web-Real-Time-Communication）" class="headerlink" title="网页实时通信 WebRTC（Web Real-Time Communication）"></a>网页实时通信 WebRTC（Web Real-Time Communication）</h6><p>$\quad$ 由Google发起的实时音视频通信开源项目</p><p>$\quad$ 建立浏览器之间点对点的连接，实现音&#x2F;视频流的传输</p><p>$\quad$ WebRTC协议栈</p><p>$\quad$ $\quad$ 为了满足实时性需求，其核心协议基于 UDP 基础上搭建</p><p>$\quad$ $\quad$ Secure RTP（SRTP）与 Secure  RTCP（SRTCP） 是对媒体数据的封装与传输控制协议</p><p>$\quad$ $\quad$ 流控制传输协议SCTP，提供类似 TCP 的特性</p><p>$\quad$ $\quad$ RTCPeerConnection 用来建立和维护端到端连接</p><p>$\quad$ $\quad$ RTCDataChannel 用来支持端到端的任意二进制数据传输</p><p>$\quad$ $\quad$ DTLS 对传输内容进行加密，是 UDP 版 TLS</p><p>$\quad$ $\quad$ ICE、STUN、TURN 用于内网穿透，应对NAT 等私有地址转换的问题</p><p><img src="/../CNP/CN313.png"></p><h6 id="基于HTTP的协议"><a href="#基于HTTP的协议" class="headerlink" title="基于HTTP的协议"></a>基于HTTP的协议</h6><p>$\quad$ MPEG-DASH：也叫DASH over HTTP，全称Dynamic Adaptive Streaming over HTT</p><p>$\quad$ $\quad$ 开放的国际标准</p><p>$\quad$ $\quad$ 支持各种视频、音频格式、文件封装格式</p><p>$\quad$ $\quad$ 视频传输优化（无论点播、直播、实时交互）</p><p>$\quad$ $\quad$ $\quad$ 客户端基于当前网络状况，向服务器请求视频块</p><p>$\quad$ $\quad$ $\quad$ 若视频块的码率&gt;可用带宽：视频块难以及时抵达客户端，出现卡顿</p><p>$\quad$ $\quad$ $\quad$ 若视频块的码率&lt;可用带宽：视频质量较低，没有充分利用带宽资源</p><p>$\quad$ $\quad$ 基本思想</p><p>$\quad$ $\quad$ $\quad$ 完整视频被拆分为固定时长 (2s-10s) 的视频片段(segment)， 每段提供不同码率</p><p>$\quad$ $\quad$ $\quad$ 视频片段与其对应的元文件（URL）一同存放于DASH服务器</p><p>$\quad$ $\quad$ $\quad$ 客户端基于网络条件、缓冲大小等，对每个视频片段，自适应选择合适的视频码率来下载</p><p><img src="/../CNP/CN314.png"></p><p><img src="/../CNP/CN315.png"></p><p>$\quad$ $\quad$ 对流媒体进行更好的编码，例如：可扩展视频编码 SVC（Scalable Video Coding）</p><p>$\quad$ $\quad$ $\quad$ SVC 是以H.264为基础，支持多层分级特性：立足基础层，采用锦上添花的增强层</p><p>$\quad$ $\quad$ $\quad$ 基础层与增强层：不同的帧率、空间分辨率</p><p>$\quad$ $\quad$ $\quad$ 当带宽不足时，只对基础层的码流进行传输和解码，这时解码的视频质量不高</p><p>$\quad$ $\quad$ $\quad$ 当带宽充足时，可以传输和解码增强层的码流来提高视频的解码质量</p><p>$\quad$ $\quad$ $\quad$ 优点：确保传输基础层来避免卡顿，使用富裕的带宽传输增强层，充分利用带宽</p><p>$\quad$ $\quad$ $\quad$ 缺点：编解码复杂度增加，有多个增强层时开销过大</p><p><img src="/../CNP/CN316.png"></p><p>$\quad$ HLS（HTTP Live Streaming）：Apple开发</p><p>$\quad$ $\quad$ 面向iOS、Safari浏览器等Apple生态</p><p>$\quad$ $\quad$ 只使用MPEG-2 Transport Stream文件格式</p><p>$\quad$ HDS：Adobe开发</p><p>$\quad$ $\quad$ 原本想取代RTMP作为对Flash的新支持，但由于Flash停止更新，HDS也停止更新</p><p>$\quad$ $\quad$ RTMP由于自身不限于Flash，仍在广泛使用（虽然也在减少）</p><p>$\quad$ Microsoft Smooth Streaming</p><p>$\quad$ $\quad$ 服务于Silverlight的流媒体协议，Silverlight是微软用于对标Flash的交互性网络应用开发工具</p><p>$\quad$ $\quad$ Silverlight被HTML5、CSS3、JavaScript取代， Smooth Streaming使用也逐渐减少</p><h3 id="内容分发网络CDN"><a href="#内容分发网络CDN" class="headerlink" title="内容分发网络CDN"></a>内容分发网络CDN</h3><p>$\quad$ CDN服务提供</p><p>$\quad$ $\quad$ CDN服务提供商：Akamai、蓝讯、世纪互联、网宿等</p><p>$\quad$ $\quad$ 互联网内容提供商（ICP）：腾讯、百度等</p><p>$\quad$ $\quad$ 互联网服务提供商（ISP）：移动、联通、电信等</p><p>$\quad$ 关键问题</p><p>$\quad$ $\quad$ CDN服务器如何布局</p><p>$\quad$ $\quad$ 如何通过CDN获取资源</p><p>$\quad$ $\quad$ 如何进行重定向，将请求调度到较近或负载较轻的CDN服务器</p><h4 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h4><p>$\quad$ $\quad$ 广度：深入部署到很多访问网络的内部</p><p>$\quad$ $\quad$ 深度：少量靠近接入网的关键位置建造大集群，距离用户要近</p><h4 id="获取资源"><a href="#获取资源" class="headerlink" title="获取资源"></a>获取资源</h4><p>$\quad$ CDN缓存位置和内容——在CDN节点上存储内容拷贝</p><p>$\quad$ $\quad$ 如MADMEN</p><p>$\quad$ 订阅者（subscriber）请求内容，服务提供者返回清单CDN</p><p>$\quad$ $\quad$ 通过清单,客户端以可支持的最高速率检索到内容</p><p>$\quad$ $\quad$ 如果网络路径拥塞，可能会选择不同的拷贝或网络速率</p><h4 id="HTTP重定向"><a href="#HTTP重定向" class="headerlink" title="HTTP重定向"></a>HTTP重定向</h4><p>$\quad$ 目标：将请求调度到较近或负载较轻的CDN服务器</p><p>$\quad$ 方法1：HTTP重定向请求内容，服务提供者返回清单CDN</p><p>$\quad$ $\quad$ 原始服务器决策CDN服务器</p><p>$\quad$ $\quad$ HTTP响应：状态码30X，Location：指明新的位置</p><p><img src="/../CNP/CN317.png"></p><p>$\quad$ 方法2：DNS辅助实现CDN</p><p>$\quad$ $\quad$ 负载均衡DNS负责决策CDN服务器选择</p><p>$\quad$ $\quad$ 负载均衡DNS需要收集CDN服务器的位置和负载情况</p><p>$\quad$ $\quad$ 如果找不到被请求的对象，需要从原始服务器获取</p><p><img src="/../CNP/CN318.png"></p><p>$\quad$ 方法3：网站所有者可以重写通过CDN与内容链接的页面</p><h3 id="Telnet"><a href="#Telnet" class="headerlink" title="Telnet"></a>Telnet</h3><p>$\quad$ 远程登录是网络最早提供的基本服务之一，通过终端仿真协议实现对远程计算机系统的访问，就像访问本地资源一样，而且这个过程对用户是透明的</p><p>$\quad$ 目标：解决异构计算机系统的差异性问题，主要体现在对终端键盘输入命令的解释上</p><p>$\quad$ $\quad$ Telnet协议最早出现在20世纪60年代后期，1983年由RFC 854确定为Internet标准</p><p>$\quad$ $\quad$ Telnet &#x3D; Teletype over Network</p><p>$\quad$ 架构</p><p>$\quad$ $\quad$ Telnet协议使用C&#x2F;S方式实现。在本地系统运行Telnet客户进程，在远程主机运行Telnet服务器进程</p><p>$\quad$ $\quad$ Telnet协议使用TCP连接通信，服务器进程默认监听TCP23端口，服务器使用主进程等待新的请求，并产生从属进程来处理每一个连接</p><h4 id="NVT"><a href="#NVT" class="headerlink" title="NVT"></a>NVT</h4><p>$\quad$ Telnet协议引入网络虚拟终端NVT（Network Virtual Terminal），使用一种专门的键盘定义来屏蔽不同计算机系统对键盘输入的差异性，同时定义客户进程与远程服务器进程之间的交互过程</p><p>$\quad$ NVT是Telnet协议定义的一组通用字符集，通过这种统一的数据表示方式，来保证不同硬件、软件与数据格式的终端与主机之间通信的兼容性</p><p>$\quad$ 本地终端输入的字符首先由本地Telnet客户进程转换为NVT格式，通过网络将NVT格式的字符传输到远程主机，远程Telnet服务器进程再将NVT格式的字符转换为远程主机能够识别和处理的字符格式</p><p>$\quad$ 使用Telnet协议在网络中传输的数据都是NVT格式，不同的用户终端与服务器进程均与本地终端格式无关</p><h4 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h4><p>$\quad$ 本地Telnet客户进程与远程主机上的Telnet服务器进程建立TCP连接</p><p>$\quad$ 将本地终端上输入的用户名和口令及以后输入的任何命令或字符以网络虚拟终端NVT格式传输给远程主机</p><p>$\quad$ 将远程主机输出的NVT格式的数据转化为本地所接受的格式送回本地终端，包括输入命令回显和命令执行结果</p><p>$\quad$ 本地终端对远程主机撤销连接，从而结束 Telnet远程登录过程</p><p><img src="/../CNP/CN319.png"></p><h3 id="FTP"><a href="#FTP" class="headerlink" title="FTP"></a>FTP</h3><p>$\quad$ 网络环境下复制文件的复杂性</p><p>$\quad$ $\quad$ 计算机存储数据的格式不同</p><p>$\quad$ $\quad$ 文件目录结构和文件命名规则不同</p><p>$\quad$ $\quad$ 对于相同的文件存取功能，操作系统使用的命令不同</p><p>$\quad$ $\quad$ 访问控制方法不同</p><p>$\quad$ 文件传输协议FTP(File Transfer Protocol)是Internet上使用最广泛的应用层协议之一</p><p>$\quad$ $\quad$ FTP提供交互式的访问，允许用户指明文件的类型与格式，并允许文件具有存取权限</p><p>$\quad$ $\quad$ FTP屏蔽了各计算机系统的细节，适用于在异构网络中任意计算机之间传送文件</p><p>$\quad$ $\quad$ RFC 959早在1985年就已经成为Internet的正式标准</p><h4 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h4><p>$\quad$ FTP使用C&#x2F;S方式实现</p><p>$\quad$ FTP工作过程</p><p>$\quad$ $\quad$ 服务器主进程打开TCP21端口，等待客户进程发出的连接请求</p><p>$\quad$ $\quad$ 客户可以用分配的任意一个本地端口号与服务器进程的TCP21端口进行连接</p><p>$\quad$ $\quad$ 客户请求到来时，服务器主进程启动控制进程与数据进程来处理客户进程发来的请求</p><p>$\quad$ $\quad$ 服务器控制进程与数据进程对客户进程的请求处理完毕后即终止</p><p>$\quad$ $\quad$ 服务器主进程返回，继续等待接收其他客户进程发来的连接请求，服务器主进程与从属进程（控制进程、数据进程）并行工作</p><p>$\quad$ FTP的两个端口与两个连接</p><p>$\quad$ $\quad$ 控制连接在整个会话期间一直保持，客户进程发出的文件传输请求通过控制连接发送给服务器控制进程（工作在TCP21端口），但控制连接不用来传输文件</p><p>$\quad$ $\quad$ 服务器控制进程在接收到客户进程发送来的文件传输请求后就创建数据传输进程（工作在TCP20端口）和数据连接</p><p>$\quad$ $\quad$ 数据连接用来连接客户进程和服务器数据传输进程，实际完成文件的传输。服务器数据传输进程在文件传输完毕后关闭数据连接并结束运行</p><h4 id="简单文件传输协议TFTP"><a href="#简单文件传输协议TFTP" class="headerlink" title="简单文件传输协议TFTP"></a>简单文件传输协议TFTP</h4><p>$\quad$ TFTP(Trivial File Transfer Protocol) 是一个很小且易于实现的文件传输协议</p><p>$\quad$ 使用C&#x2F;S方式和UDP协议实现</p><p>$\quad$ 只支持文件传输而不支持交互</p><p>$\quad$ 没有庞大的命令集，没有列目录的功能，也不能对用户进行身份鉴别</p><p>$\quad$ 支持ASCII 码或二进制传送</p><p>$\quad$ 支持对文件进行读或写</p><p>$\quad$ 使用很简单的首部</p><p>$\quad$ 与FTP是两个不同协议</p><h5 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h5><p>$\quad$ 以PDU为单位进行传输</p><p>$\quad$ PDU也称为文件块 (block)，按序从1开始编号</p><p>$\quad$ 每次传送的数据PDU中有512字节的数据，但最后一次可不足512字节</p><p>$\quad$ 若文件长度恰好为512字节的整数倍，则在文件传输完毕后，还必须在最后发送一个只含首部而无数据的数据 PDU</p><p>$\quad$ 若文件长度不是512字节的整数倍，则最后传送数据PDU的数据字段一定不满512字节，这正好可作为文件结束的标志</p><h5 id="工作过程-1"><a href="#工作过程-1" class="headerlink" title="工作过程"></a>工作过程</h5><p>$\quad$ 每发送完一个文件块后就等待对方的确认，确认时应指明所确认的块编号</p><p>$\quad$ 发完数据后在规定时间内收不到确认就要重发该数据PDU</p><p>$\quad$ 文件请求方若在规定时间内收不到下一个文件块，也要重发确认PDU。这样就能保证文件的传输不会因某一个数据PDU的丢失而失败</p><p>$\quad$ 开始工作时，TFTP客户进程发送一个读请求PDU或写请求PDU给TFTP服务器进程，其UDP端口号为69</p><p>$\quad$ TFTP服务器进程要选择一个新的端口和TFTP客户进程进行通信</p><h3 id="SNMP"><a href="#SNMP" class="headerlink" title="SNMP"></a>SNMP</h3><h4 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h4><p>$\quad$ 目的</p><p>$\quad$ $\quad$ 有效利用网络资源</p><p>$\quad$ $\quad$ 及时报告和处理网络故障</p><p>$\quad$ $\quad$ 保障网络正常、高效运行</p><p>$\quad$ 网络管理的功能</p><p>$\quad$ $\quad$ 配置管理（Configuration Management）</p><p>$\quad$ $\quad$ 故障管理（Fault Management）</p><p>$\quad$ $\quad$ 性能管理（Performance Management）</p><p>$\quad$ $\quad$ 计费管理（Accounting Management）</p><p>$\quad$ $\quad$ 安全管理（Security Management）</p><h5 id="网络管理系统"><a href="#网络管理系统" class="headerlink" title="网络管理系统"></a>网络管理系统</h5><p>$\quad$ 管理器（Manager）：网络管理进程，提供网络管理用户界面，完成管理任务</p><p>$\quad$ 管理对象（Managed Object）：网络中的软硬件系统</p><p>$\quad$ 代理（Agent）：管理对象中的进程，负责与管理器交互</p><p>$\quad$ 管理信息库（MIB，Management Information Base）：存储网络信息</p><p>$\quad$ 本地MIB：每个代理管理自己的本地MIB，仅包含本地设备相关信息</p><p>$\quad$ 网络MIB：代理与管理器交换网络状态信息，共同构成整个网络的MIB</p><p>$\quad$ 网络管理协议（Network Management Protocol）</p><p>$\quad$ TCP&#x2F;IP的简单网络管理协议SNMP（Simple Network Management Protocol）</p><p>$\quad$ OSI的公共管理信息协议CMIP（Common Management Information Protocol）</p><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>$\quad$ 指导思想</p><p>$\quad$ $\quad$ 尽可能简单：用简单的系统结构和协议来解决复杂的网络管理问题</p><p>$\quad$ $\quad$ $\quad$ 协议交互过程简单，仅有4类操作对网络进行管理</p><p>$\quad$ $\quad$ $\quad$ 使用UDP协议，以简化设计和降低通信开销</p><p>$\quad$ $\quad$ 影响尽量小：网络中任何软硬件的增减对原有管理对象的影响尽量小</p><p>$\quad$ 版本变迁</p><p>$\quad$ $\quad$ SNMPv1：RFC 1067(1988)、RFC 1098(1989)、RFC 1155~1157(1990)</p><p>$\quad$ $\quad$ SNMPsec：RFC 1351~1353(1992)</p><p>$\quad$ $\quad$ SNMPv2：RFC 1441~1445(1993)</p><p>$\quad$ $\quad$ SNMPv3：RFC 3410~3418(2002)，安全性和可管理性大为提高</p><h4 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h4><h5 id="SNMP协议规则——轮询方式"><a href="#SNMP协议规则——轮询方式" class="headerlink" title="SNMP协议规则——轮询方式"></a>SNMP协议规则——轮询方式</h5><p>$\quad$ 管理器采用轮询方式，周期性“读”“写”来实现网络管理功能</p><p>$\quad$ $\quad$ “读”操作：管理器向代理发送get报文来检测管理对象状态</p><p>$\quad$ $\quad$ “写”操作：管理器向代理发送set报文来修改管理对象状态</p><p>$\quad$ 轮询方式的优点</p><p>$\quad$ $\quad$ 协议实现相对简单</p><p>$\quad$ $\quad$ 能限制所产生管理信息的通信量</p><p>$\quad$ 轮询方式的缺点</p><p>$\quad$ $\quad$ 不够灵活，而且所能管理的设备数目不能太多</p><p>$\quad$ $\quad$ 开销比较大</p><h5 id="SNMP协议规则——陷阱方式"><a href="#SNMP协议规则——陷阱方式" class="headerlink" title="SNMP协议规则——陷阱方式"></a>SNMP协议规则——陷阱方式</h5><p>$\quad$ SNMP允许代理不经过管理器询问就能发送某些信息，这种信息称为陷阱（trap）报文，通常代表代理检测到的重要事件</p><p>$\quad$ 当管理对象的代理检测到有事件发生时，就检查其门限值。代理只向管理器报告达到特定门限值的事件，这个过程称为过滤</p><p>$\quad$ 陷阱方式的优点</p><p>$\quad$ $\quad$ 仅在严重事件发生时才发送陷阱报文</p><p>$\quad$ $\quad$ 陷阱信息很简单且所需字节数很少</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>$\quad$ SNMP协议实现</p><p>$\quad$ $\quad$ SNMP使用无连接的UDP协议实现，众所周知UDP协议不保证可靠交付</p><p>$\quad$ $\quad$ SNMP使用C&#x2F;S方式实现</p><p>$\quad$ $\quad$ $\quad$ 代理运行服务器端进程在UPD端口161接收get或set报文以及发送response报文，与161端口通信的客户端进程则使用临时端口</p><p>$\quad$ $\quad$ $\quad$ 管理器运行客户端进程在UPD端口162接收来自代理的trap报文</p><p>$\quad$ SNMP的通常使用</p><p>$\quad$ $\quad$ 使用周期性轮询方式实现对网络资源的实时监控与管理</p><p>$\quad$ $\quad$ 使用陷阱方式报告重要事件的发生</p><h4 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h4><p><img src="/../CNP/CN320.png"></p><p><img src="/../CNP/CN321.png"></p><h4 id="提供信息"><a href="#提供信息" class="headerlink" title="提供信息"></a>提供信息</h4><p>$\quad$ 基本流量统计：报文数、字节数</p><p>$\quad$ 设备CPU利用率</p><p>$\quad$ 设备内存占用</p><p>$\quad$ 缺乏细粒度信息</p><p>$\quad$ $\quad$ 无法识别TCP连接，更不可能记录每个连接传输多少数据</p><h4 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h4><p>$\quad$ SNMP难以应对当前网络管理需求</p><p>$\quad$ $\quad$ 读操作：SNMP提供的数据不足以支撑复杂网络管理</p><p>$\quad$ $\quad$ 写操作：SNMP能修改的设备状态有限</p><p>$\quad$ $\quad$ $\quad$ 修改参数</p><p>$\quad$ $\quad$ $\quad$ 打开&#x2F;关闭某个端口</p><p>$\quad$ 替代方案</p><p>$\quad$ $\quad$ 状态读取：新型网络测量算法</p><p>$\quad$ $\quad$ 设备控制：软件定义网络、网络功能虚拟化、可编程网络</p><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>CN</category>
      
      <category>应用层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CN</tag>
      
      <tag>应用层</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>应用层-DNS,电子邮件</title>
    <link href="/2023/09/26/%E5%BA%94%E7%94%A8%E5%B1%82-DNS%EF%BC%8C%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6/"/>
    <url>/2023/09/26/%E5%BA%94%E7%94%A8%E5%B1%82-DNS%EF%BC%8C%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p> 对应 北京大学计算机网络课程第二讲第二部分<br> 参考教材计算机网络-自顶向下方法</p><span id="more"></span><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="应用层-DNS-电子邮件"><a href="#应用层-DNS-电子邮件" class="headerlink" title="应用层-DNS,电子邮件"></a>应用层-DNS,电子邮件</h2><h3 id="域名系统DNS"><a href="#域名系统DNS" class="headerlink" title="域名系统DNS"></a>域名系统DNS</h3><p>$\quad$ 域名系统（DNS，Domain Name System）是互联网重要的基础设施<br>$\quad$ $\quad$ 向所有需要域名解析的应用提供服务，主要负责将域名映射成IP地址<br>$\quad$ $\quad$ 可以基于域名查询IP地址<br>$\quad$ $\quad$ 也可以基于IP地址，反向查询域名<br>$\quad$ DNS提供的是与网络层有关的功能，但以应用层技术的方式实现<br>$\quad$ 域名与IP地址可以是一对一、一对多或者多对一的关系</p><h4 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h4><p>$\quad$ ARPANET时期<br>$\quad$ $\quad$ Hosts.txt文件列出了所有计算机名称和它们的IP地址<br>$\quad$ $\quad$ 所有主机在晚上从指定站点上获取Hosts.txt文件<br>$\quad$ Hosts.txt文件的使用在当时表现不错<br>$\quad$ 互联网发展<br>$\quad$ $\quad$ Hosts.txt文件变得越来越大<br>$\quad$ $\quad$ 需要集中管理来防止主机名冲突<br>$\quad$ 1987年发布了域名系统的RFC文档（RFC1034、RFC1035）<br>$\quad$ $\quad$ 采用了一种层次的、基于域的命名模式，并使用分布式数据库系统实现<br>$\quad$ $\quad$ 主要用途是将主机名映射成IP地址<br>$\quad$ 中心化的DNS不可行</p><h4 id="Internet的域名系统"><a href="#Internet的域名系统" class="headerlink" title="Internet的域名系统"></a>Internet的域名系统</h4><p>$\quad$ Internet使用分布式的域名系统 DNS<br>$\quad$ $\quad$ 一个联机分布式数据库系统<br>$\quad$ 域名的解析是由若干个域名服务器(Domain Name Server)<br>$\quad$ $\quad$ 也叫名字服务器(Name Server)<br>$\quad$ 分布式的好处<br>$\quad$ $\quad$ 避免单点故障<br>$\quad$ $\quad$ 能够处理海量流量<br><img src="/../CNP/CN203.png"></p><h4 id="域名系统服务"><a href="#域名系统服务" class="headerlink" title="域名系统服务"></a>域名系统服务</h4><h5 id="域名结构"><a href="#域名结构" class="headerlink" title="域名结构"></a>域名结构</h5><p>$\quad$ Internet的域名结构也采用了层次树状结构的命名方法<br>$\quad$ $\quad$ 该树状结构又称域树(domain tree)<br>$\quad$ 域名的结构由若干个分量组成，各分量之间用小数点(.)隔开，总长不超过255个字符<br>$\quad$ 各分量分别代表不同级别的域名。(≤63字符)<br>$\quad$ 合法域名中，点“.”的个数至少为一个<br>$\quad$ 通常，点“.”对应的英文单词为dot，也可以读为point<br>$\quad$ 形式：… .三级域名.二级域名.顶级域名<br><img src="/../CNP/CN204.png"></p><h5 id="典型域名"><a href="#典型域名" class="headerlink" title="典型域名"></a>典型域名</h5><h6 id="顶级域名："><a href="#顶级域名：" class="headerlink" title="顶级域名："></a>顶级域名：</h6><p>顶级域名TLD（Top Level Domain）一般有三类<br>$\quad$ 国家或地区顶级域nTLD，也记为ccTLD (cc: country code)<br>$\quad$ $\quad$ 例如.cn 表示中国，.us 表示美国，.uk 表示英国。目前有300多个<br>$\quad$ 基础设施域.arpa (Address and Routing Parameter Area)<br>$\quad$ $\quad$ 专用于Internet基础设施目的<br>$\quad$ $\quad$ 目前有二级域ip6.arpa；iris.arpa；in-addr.arpa；uri.arpa；urn.arpa；home.arpa；as112.arpa；in-addr-servers.arpa；ipv4only.arpa等<br>$\quad$ 通用顶级域gTLD<br>$\quad$ $\quad$ 早期规定了20个通用顶级域名，2011年批准新通用顶级域名(New Generic Top-level Domain，New gTLD)<br>$\quad$ $\quad$ 截至2020年，已注册有1200多个通用顶级域名</p><h6 id="二级域名"><a href="#二级域名" class="headerlink" title="二级域名"></a>二级域名</h6><p>国家顶级域名 .cn下的二级域名分为三类<br>$\quad$ 类别域名7个<br>$\quad$ $\quad$ edu.cn 教育<br>$\quad$ $\quad$ gov.cn 政府<br>$\quad$ $\quad$ org.cn 非营利组织<br>$\quad$ $\quad$ net.cn 网络服务<br>$\quad$ $\quad$ com.cn 工商金融等企业<br>$\quad$ $\quad$ ac.cn 科研<br>$\quad$ $\quad$ mil.cn 国防机构<br>$\quad$ 行政区域名34个：省、直辖市、自治区、特区等行政区域名，每个行政区域名为两个字母，例如北京bj、河北he等<br>$\quad$ 无类别域名：例如 <a href="http://www.baidu.cn、www.tianya.cn等/">www.baidu.cn、www.tianya.cn等</a></p><h5 id="域名的管理："><a href="#域名的管理：" class="headerlink" title="域名的管理："></a>域名的管理：</h5><p>$\quad$ 域名管理机构分级负责域名注册<br>$\quad$ $\quad$ Internet的域名管理机构: ICANN <a href="http://www.icann.org/">www.icann.org</a><br>$\quad$ $\quad$ 全称: Internet Corporation for Assigned Names and Numbers<br>$\quad$ $\quad$ ccTLD下的二级域名该国自行确定<br>$\quad$ 三级域名注册由其所属二级域名机构负责，以此类推<br>$\quad$ edu.cn下三级域名注册由CERNET负责<br>$\quad$ 我国的其它二级域名注册由中国互联网络信息中心(CNNIC)负责</p><h4 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h4><p>$\quad$ 名字服务器(name server)或域名服务器<br>$\quad$ $\quad$ 保存关于域树(domain tree)的结构和设置信息<br>$\quad$ $\quad$ 负责域名解析工作<br>$\quad$ 每个名字服务器保存相邻域名服务器信息<br>$\quad$ $\quad$ 当自身信息缺失时，知道向哪些服务器询问<br>$\quad$ 域名解析过程对用户透明</p><h5 id="类别"><a href="#类别" class="headerlink" title="类别"></a>类别</h5><p>$\quad$ 根据对应域的层次，名字服务器又进一步分为以下类别<br>$\quad$ $\quad$ 根名字服务器(root name server) &#x2F;根服务器(root server)<br>$\quad$ $\quad$ 顶级域名字服务器(TLD name server)<br>$\quad$ $\quad$ 二级域名字服务器(second level domain name server)<br>$\quad$ $\quad$ 三级域名字服务器(third level domain name server)<br>$\quad$ $\quad$ ……<br>$\quad$ 三级域及以下的名字服务器通常在用户本地区域，因此<br>$\quad$ $\quad$ 三级域及以下的名字服务器也统称为本地域名服务器（Local DNS Server）或 迭代域名服务器<br>$\quad$ $\quad$ 二级域的名字服务器也称为权威名字服务器</p><h5 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h5><p><img src="/../CNP/CN205.png"></p><h6 id="根服务器（Root-DNS-Server）："><a href="#根服务器（Root-DNS-Server）：" class="headerlink" title="根服务器（Root DNS Server）："></a>根服务器（Root DNS Server）：</h6><p>$\quad$ 根服务器是最高层次的名字服务器<br>$\quad$ 每个根服务器都知道所有的顶级域名服务器(TLD name servers)的域名及其IP地址<br>$\quad$ 根服务器并不直接把主机用户所查的域名转换成IP地址<br>$\quad$ IPv4根服务器共有13套(不是13台机器)，这些根服务器相应的域名分别是<br>$\quad$ $\quad$ a.rootservers.net 到 m.rootservers.net<br>$\quad$ 更改根服务器数据只在a.rootservers.net上进行，然后同步到另外12套中<br>$\quad$ $\quad$ 既能保证数据一致性，也提高了域名服务可靠性<br>$\quad$ 每套都可以有多个镜像(mirrored)根服务器，其内容定期与上述对应的根服务器同步<br>$\quad$ $\quad$ 注意，同步需要一定的时间才能完成<br>$\quad$ $\quad$ 已设置了1000多台镜像根服务器<br>$\quad$ $\quad$ 世界上大部分DNS域名服务器都能就近找到一个根服务器<br>$\quad$ 2016年，全球新部署25套IPv6根服务器<br>$\quad$ $\quad$ 中国4套</p><h6 id="顶级域名字服务器（TLD-name-server"><a href="#顶级域名字服务器（TLD-name-server" class="headerlink" title="顶级域名字服务器（TLD name server)"></a>顶级域名字服务器（TLD name server)</h6><p>$\quad$ 顶级域(TLD)名字服务器负责管理在该顶级域名服务器注册的所有二级域名<br>$\quad$ 当收到DNS查询请求时就给出相应的回答<br>$\quad$ $\quad$ 可能是最后的结果，也可能是下一步应当找的二级域名字服务器的 IP 地址</p><h6 id="二级域名字服务器"><a href="#二级域名字服务器" class="headerlink" title="二级域名字服务器"></a>二级域名字服务器</h6><p>$\quad$ 每一个主机都必须在某个二级域名字服务器处注册登记。因此二级域名字服务器知道其管辖的主机名应当转换成什么IP地址<br>$\quad$ $\quad$ 各个二级域名单位根据自己的具体情况把所属域名划为若干个管辖区(zone)，也可简称为区<br>$\quad$ 每个区设置相应的权威名字服务器，用来保存该区中的所有主机的域名到IP地址的映射<br>$\quad$ 一般来说，每个名字服务器只负责解析本辖域（区）的域名<br>$\quad$ $\quad$ 名字服务器的管辖范围以“区”为单位，而不是以“域”为单位<br>$\quad$ $\quad$ 区可以小于或等于域，但不可能大于域<br><img src="/../CNP/CN206.png"></p><h6 id="本地DNS服务器"><a href="#本地DNS服务器" class="headerlink" title="本地DNS服务器"></a>本地DNS服务器</h6><p>$\quad$ 每一个Internet服务提供者ISP(Internet Service Provider), 都至少有一个本地DNS服务器（又称递归服务器），距离用户主机较近<br>$\quad$ 不同网络中的递归服务器、本地域名服务器的部署层次可能不同<br>$\quad$ 最简单的部署层次是只有一层本地域名字服务器，即三级域名字服务器<br>$\quad$ 实际部署中，解析请求路径上的递归服务器&#x2F;本地域名服务器可能有多层</p><h4 id="域名解析与DNS协议"><a href="#域名解析与DNS协议" class="headerlink" title="域名解析与DNS协议"></a>域名解析与DNS协议</h4><h5 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h5><p>$\quad$ 当某一应用进程需要进行域名解析时，该应用进程将域名放在DNS请求报文（UDP数据报, 目标端口号为53）发给本地DNS服务器<br>$\quad$ $\quad$ 使用UDP是为了减少开销<br>$\quad$ 本地DNS服务器得到查询结果后, 将对应IP地址放在应答报文中返回给应用进程<br>$\quad$ 域名查询有递归查询(recursive query)和迭代查询(或循环查询，iterative query) 两种方式<br>$\quad$ $\quad$ 主机向本地DNS服务器的查询一般采用递归查询<br>$\quad$ $\quad$ 本地DNS服务器向更上层域名服务器可以采用递归查询，但一般优先采用迭代查询<br>$\quad$ $\quad$ 实际中，请求方与服务器有一定自主权选择哪种方式<br>$\quad$ 本地DNS解析先尝试递归查询（查询对象：本地DNS服务器）<br>$\quad$ $\quad$ 当用户主机发出DNS查询报文时，这个查询报文首先被送往该主机所在区域的递归服务器<br>$\quad$ $\quad$ 如果所要查询的主机也处在本地ISP的管辖范围，则本地域名服务器就能进行域名解析，否则就需要再询问其他的域名服务器<br>$\quad$ $\quad$ 在递归服务器&#x2F;本地域名服务器有多层的结构中，当本层服务器没有解析结果时，通常是逐级向上递归进行查询<br>$\quad$ 随后尝试迭代查询（查询对象：根服务器、顶级域名字服务器、二级域名字服务器）<br>$\quad$ $\quad$ 当查询请求到达本地域最上一层名字服务器时，该层服务器对自己无法解析的任何一个域名<br>$\quad$ $\quad$ 此时，先求助于根服务器（而不是二级域名字服务器），开始逐步迭代查询<br>$\quad$ 在谷歌公司提供的公共DNS服务系统中，把根信息也同步到它的递归服务器上，这时就不再需要传统的查询根服务器的过程，从而提高查询效率</p><h6 id="递归查询"><a href="#递归查询" class="headerlink" title="递归查询"></a>递归查询</h6><p>$\quad$ 当收到查询请求报文的域名服务器不知被查询域名的IP地址时，该域名服务器就以DNS客户的身份向下一步应查询的域名服务器发出查询请求，即替递归服务器继续查询<br>$\quad$ 一般在本地服务器内部采用<br><img src="/../CNP/CN207.png"></p><h6 id="迭代查询"><a href="#迭代查询" class="headerlink" title="迭代查询"></a>迭代查询</h6><p>$\quad$ 当收到查询请求报文的域名服务器不知道被查询域名的IP地址时，就把自己知道的下一步应查询的域名服务器IP地址告诉查询者，由查询者继续向该域名服务器查询<br>$\quad$ 通常本地DNS之上使用<br><img src="/../CNP/CN208.png"></p><h5 id="DNS报文"><a href="#DNS报文" class="headerlink" title="DNS报文"></a>DNS报文</h5><p>$\quad$ 分为三部分：基础结构(报文首部)、问题、资源记录(RR, Resource Record)<br>$\quad$ 报文类型分为查询请求(query)和查询响应(reply)两类，请求和响应的报文结构基本相同<br><img src="/../CNP/CN209.png"></p><h6 id="基础结构部分"><a href="#基础结构部分" class="headerlink" title="基础结构部分"></a>基础结构部分</h6><p><img src="/../CNP/CN211.png"><br>$\quad$ 事务ID：DNS报文的ID标识。对于请求报文和其对应的响应报文，该字段的值是相同的。通过它可以区分 DNS 应答报文是对哪个请求进行响应的<br>$\quad$ 标志：DNS报文中的标志字段<br>$\quad$ $\quad$ QR（Query&#x2F;Response）：查询请求&#x2F;响应的标志信息。查询请求时值为0；响应时值为1<br>$\quad$ $\quad$ Opcode：操作码。其中，0表示标准查询；1表示反向查询；2表示服务器状态请求<br>$\quad$ $\quad$ AA（Authoritative）：授权应答，该字段在响应报文中有效。值为1时表示名称服务器是权威服务器；值为0时表示不是权威服务器<br>$\quad$ $\quad$ TC（Truncated）：表示是否被截断。值为1时，表示响应已超过512字节并已被截断，只返回前512个字节<br>$\quad$ $\quad$ RD（Recursion Desired）：期望递归。该字段能在一个查询中设置，并在响应中返回。该标志告诉域名服务器必须处理这个查询，这种方式被称为一个递归查询。如果该位为0，且被请求的域名服务器没有一个授权回答，它将返回一个能解答该查询的其他域名服务器列表。这种方式被称为迭代查询<br>$\quad$ $\quad$ RA（Recursion Available）：可用递归。该字段只出现在响应报文中。当值为1时，表示服务器支持递归查询<br>$\quad$ $\quad$ Z：保留字段，在所有的请求和响应报文中，它的值必须为0<br>$\quad$ $\quad$ Rcode（Reply code）：返回码字段，表示响应的差错状态。常用Rcode有<br>$\quad$ $\quad$ $\quad$ 当值为0(NoError)时，表示没有错误<br>$\quad$ $\quad$ $\quad$ 当值为1(FormErr)时，表示报文格式错误，服务器不能理解请求的报文<br>$\quad$ $\quad$ $\quad$ 当值为2(ServFail)时，表示域名服务器失败，因为服务器的原因导致没办法处理这个请求<br>$\quad$ $\quad$ $\quad$ 当值为3(NXDomain)时，表示域名不存在，只有对授权域名解析服务器有意义，指出解析的域名不存在<br>$\quad$ $\quad$ $\quad$ 当值为4(NotImp)时，表示查询类型不支持，即域名服务器不支持查询类型<br>$\quad$ $\quad$ $\quad$ 当值为5(Refused)时，表示拒绝应答，一般是服务器由于设置的策略拒绝给出应答，如服务器不希望对某些请求者给出应答<br><img src="/../CNP/CN210.png"><br>$\quad$ 问题计数：DNS查询请求的数目<br>$\quad$ 回答资源记录数：DNS响应的数目<br>$\quad$ 权威资源记录数：权威资源记录的数目<br>$\quad$ 附加资源记录数：额外的记录数目（如：权威名字服务器对应IP地址的数目）</p><h6 id="问题部分"><a href="#问题部分" class="headerlink" title="问题部分"></a>问题部分</h6><p><img src="/../CNP/CN212.png"><br>$\quad$ 用来显示DNS查询请求的问题，通常只有一个问题<br>$\quad$ 包含正在进行的查询信息，包含查询名（被查询主机名字）、查询类型、查询类<br>$\quad$ $\quad$ 查询名(name)：一般为要查询的域名，有时是IP地址，用于反向查询<br>$\quad$ $\quad$ 查询类型(type)：DNS查询请求的资源类型。通常查询类型为A类型，表示由域名获取对应的IP地址<br>$\quad$ $\quad$ 查询类(class)：地址类型，通常为互联网地址，值为1(IN)<br>$\quad$ $\quad$ 其他值包括CS、CH等，表示各种早期非Internet互联网的地址</p><h6 id="资源部分"><a href="#资源部分" class="headerlink" title="资源部分"></a>资源部分</h6><p>$\quad$ 资源记录部分只有在DNS响应报文中才出现<br>$\quad$ 由3个字段构成，包括<br>$\quad$ $\quad$ 回答问题区域字段<br>$\quad$ $\quad$ 权威名字服务器区域字段<br>$\quad$ $\quad$ 附加信息区域字段<br>$\quad$ 这3个字段都采用资源记录的格式<br>$\quad$ $\quad$ 域名：DNS请求的域名<br>$\quad$ $\quad$ 类型：资源记录的类型，与问题部分中的查询类型值相同<br><img src="/../CNP/CN214.png"><br><img src="/../CNP/CN215.png"></p><p>$\quad$ $\quad$ 类：地址类型，与问题部分中的查询类值相同<br>$\quad$ $\quad$ 生存时间：以秒为单位，表示资源记录的生命周期<br>$\quad$ $\quad$ $\quad$ 取出资源记录后决定保存及使用缓存数据的时间<br>$\quad$ $\quad$ $\quad$ 也表明该资源记录的稳定程度，稳定的信息会被分配一个很大的值<br>$\quad$ $\quad$ 资源数据长度：资源数据的长度<br>$\quad$ $\quad$ 资源数据：表示按查询段要求返回的相关资源记录的数据<br><img src="/../CNP/CN213.png"></p><h5 id="域名系统高速缓存"><a href="#域名系统高速缓存" class="headerlink" title="域名系统高速缓存"></a>域名系统高速缓存</h5><p>$\quad$ 为提高DNS查询效率，并减轻根域名服务器的负荷和减少Internet上的DNS查询报文数量，<br>$\quad$ $\quad$ 域名服务器广泛使用高速缓存，用来存放最近查询过的域名以及从何处获得域名映射信息的记录</p><h6 id="域名缓存的好处"><a href="#域名缓存的好处" class="headerlink" title="域名缓存的好处"></a>域名缓存的好处</h6><p>$\quad$ 缓存数据1：缓存“域名-&gt;IP”映射<br>$\quad$ $\quad$ 例如不久前已有用户查询过域名为y.abc.com的IP地址，则本地域名服务器&#x2F;递归解析器就不必再向根域名服务器重新查询y.abc.com的IP地址了，而是直接把高速缓存中存放的上次查询结果（即y.abc.com的IP地址）告诉用户<br>$\quad$ $\quad$ 减少Internet上查询数量<br>$\quad$ 缓存数据2：缓存顶级域名字服务器信息<br>$\quad$ $\quad$ 假定本地域名服务器的缓存中并没有 y.abc.com 的IP地址，但存放着顶级域名服务器 dns.com 的IP地址，则本地域名服务器就不必向根域名服务器进行查询，而可以直接向 .com 顶级域名服务器发送查询请求报文<br>$\quad$ $\quad$ 减少对根服务器的缓存<br>$\quad$ 主机一般也缓存域名有关信息</p><h6 id="缓存项目的时限"><a href="#缓存项目的时限" class="headerlink" title="缓存项目的时限"></a>缓存项目的时限</h6><p>$\quad$ 域名到IP地址的绑定可能发生变化（但并不会经常改变）。为保持高速缓存中的内容正确，域名服务器应为每项内容设置计时器并处理超时项目（例如，典型的数值是每个项目只存放48小时)<br>$\quad$ 当域名服务器已从缓存中删去某项信息后又被请求查询该项信息，就必须重新查询<br>$\quad$ 当权限域名服务器回答一个查询请求时，在响应中都指明绑定有效存在的时间值。增加此时间值可减少网络开销，而减少此时间值可提高域名解析的准确性</p><h5 id="DNSSEC安全机制"><a href="#DNSSEC安全机制" class="headerlink" title="DNSSEC安全机制"></a>DNSSEC安全机制</h5><p>$\quad$ DNS协议设计之初没有过多考虑安全问题，导致DNS存在以下缺陷<br>$\quad$ $\quad$ 几乎所有DNS流量都是基于UDP明文传输的<br>$\quad$ $\quad$ DNS的资源记录未加上任何的认证和加密措施<br>$\quad$&#x3D;&gt;DNS的用户隐私容易被泄露<br>$\quad$ DNSSEC依靠数字签名保证DNS应答报文的真实性和完整性<br>$\quad$ $\quad$ 包括通过身份验证拒绝DNS数据存在的机制<br>$\quad$ 在DNSSEC的使用中<br>$\quad$ $\quad$ 域名服务器用自己的私有密钥对资源记录(Resource Record, RR)进行签名<br>$\quad$ $\quad$ 解析服务器用域名服务器的公开密钥对收到的应答信息进行验证<br>$\quad$ $\quad$ 如果验证失败，表明这一报文可能是假冒的，或者在传输过程、缓存过程中被篡改了</p><h6 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h6><p>$\quad$ 一个支持DNSSEC的解析器向支持DNSSEC并管理test.net域名的权威域名服务器请求域名<a href="http://www.test.net/">www.test.net</a><br>$\quad$ 解析器收到<br>$\quad$ $\quad$ 一个标准的A记录 (IP地址)<br>$\quad$ $\quad$ 一个同名的RRSIG记录，其中包含test.net这个授权域的数字签名<br>$\quad$ $\quad$ $\quad$ 用test.net.的私有密钥来签名的<br>$\quad$ 解析服务器验证过程<br>$\quad$ $\quad$ 再次向test.net.的域名服务器查询响应的公开密钥，即DNSKEY资源记录<br>$\quad$ $\quad$ 用其中的公钥验证上述记录(关于<a href="http://www.test.net.的rrsig记录)的真实性与完整性/">www.test.net.的RRSIG记录)的真实性与完整性</a><br><img src="/CNP/CN216.png"></p><h3 id="电子邮件服务"><a href="#电子邮件服务" class="headerlink" title="电子邮件服务"></a>电子邮件服务</h3><p>$\quad$ 电子邮件（E-mail）是自早期Internet出现以来最广泛的应用，是一种异步通讯媒介<br>$\quad$ 优越性<br>$\quad$ $\quad$ 比纸质信件更快更便宜<br>$\quad$ $\quad$ 使用门槛低<br>$\quad$ $\quad$ 收件人可随时上网到自己邮箱读取邮件<br>$\quad$ $\quad$ 电子邮件不仅可传送文字信息，而且还可附上声音和图像等</p><h4 id="电子邮件体系结构"><a href="#电子邮件体系结构" class="headerlink" title="电子邮件体系结构"></a>电子邮件体系结构</h4><p>$\quad$ 采用客户&#x2F;服务器工作模式<br>$\quad$ $\quad$ 用户代理（user agent）——邮件客户端：编辑和发送邮件，接收、读取和管理邮件，管理地址簿；无统一标准<br>$\quad$ $\quad$ 传送代理（message transfer agent）——邮件服务器：邮箱：保存用户收到的邮件，邮件输出队列：存储等待发送的邮件；运行电子邮件协议<br>$\quad$ $\quad$ $\quad$ 邮箱是邮件服务器中的一块内存区域，其标识即为电子邮件地址（邮箱名）<br>$\quad$ $\quad$ $\quad$ 电子邮件地址是一个字符串，用于指定邮件接收者<br>$\quad$ $\quad$ 简单邮件传输协议SMTP（Simple Mail Transfer  Protocol）——邮件服务器之间传递邮件使用的协议：smtp客户: 发送邮件端；smtp服务器: 接收邮件端<br>$\quad$ $\quad$ $\quad$ SMTP利用TCP可靠地从客户向服务器传递邮件，使用端口25<br>$\quad$ $\quad$ $\quad$ 直接投递: 发送端直接到接收端<br>$\quad$ $\quad$ $\quad$ SMTP的3个阶段：连接建立、邮件传送、连接关闭<br>$\quad$ $\quad$ $\quad$ SMTP是一个简单的ASCII协议，邮件必须为7位ASCII<br><img src="/../CNP/CN201.png"><br>$\quad$ $\quad$ 命令&#x2F;响应<br>$\quad$ $\quad$ $\quad$ 命令: ASCII字符串<br>$\quad$ $\quad$ $\quad$ 响应: 状态码+短语</p><h4 id="相关协议"><a href="#相关协议" class="headerlink" title="相关协议"></a>相关协议</h4><h5 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h5><p>$\quad$ 客户端发送的行用”C:”标识，服务发送的行用”S:”标识<br>$\quad$ 来自客户的第一条命令HELO<br>$\quad$ RCPT命令可以将一个邮件发送给多个收件人，此处只有一个收件人，只使用一个RCPT命令</p><h6 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h6><p>$\quad$ Alice使用用户代理撰写发送给 Bob的邮件<br>$\quad$ Alice的用户代理发送邮件到她的邮件服务器；邮件存放在邮件队列<br>$\quad$ SMTP客户端建立与SMTP邮件服务器的TCP连接<br>$\quad$ SMTP客户端通过TCP连接发送Alice的邮件<br>$\quad$ Bob的邮件服务器把邮件存放在Bob的邮箱<br>$\quad$ Bob调用他的用户代理来读取邮件</p><h6 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h6><p>$\quad$ 不包括认证<br>$\quad$ 传输ASCII而不是二进制数据<br>$\quad$ 邮件以明文形式出现</p><h5 id="邮件格式"><a href="#邮件格式" class="headerlink" title="邮件格式"></a>邮件格式</h5><p>$\quad$ SMTP定义了如何传输邮件，但邮件本身也需遵循特定格式<br>$\quad$ $\quad$ SMTP类似HTTP，定义如何传输邮件<br>$\quad$ $\quad$ 邮件格式类似HTML，定义如何描述邮件<br>$\quad$ 首部（header）必须含有一个From:首部行和一个To:首部行，还可以包含 Subject: 等其他可选的首部行<br>$\quad$ 消息体（body）指邮件正文<br>$\quad$ MIME(Multipurpose Internet Mail Extensions)—多用途Internet邮件扩展<br>$\quad$ $\quad$ 基本格式的多媒体扩展<br>$\quad$ $\quad$ 可传输多媒体消息和二进制文件</p><h5 id="最后传递协议"><a href="#最后传递协议" class="headerlink" title="最后传递协议"></a>最后传递协议</h5><p>$\quad$ 邮件已经到达Bob的邮箱，接下来的工作就是将邮件的一个副本传送到Bob的用户代理以便显示<br>$\quad$ 最终交付（邮件访问）协议: 从邮件服务器的邮箱中获取邮件<br>$\quad$ $\quad$ POP3：Post Office Protocol-Version 3，第三版邮局协议<br>$\quad$ $\quad$ IMAP：Internet Message Access Protocol，Internet邮件访问协议<br>$\quad$ $\quad$ Webmail（HTTP）：基于Web的电子邮件<br>$\quad$ $\quad$ 为什么不能使用SMTP获取邮件？<br>$\quad$ $\quad$ $\quad$ 接收方的用户代理不能使用 SMTP 从传输代理获取邮件，因为取邮件是一个拉操作<br>$\quad$ $\quad$ $\quad$ 而 SMTP 是一个推协议，需要推送目标在线<br>$\quad$ $\quad$ $\quad$ 通过引入最终交付（邮件访问）协议来解决这个问题。</p><h6 id="POP3协议"><a href="#POP3协议" class="headerlink" title="POP3协议"></a>POP3协议</h6><p>$\quad$ POP3由RFC1939定义，是一个非常简单的最终交付协议<br>$\quad$ 当用户代理打开一个到端口110上的TCP连接后，客户&#x2F;服务器开始工作<br>$\quad$ POP3的三个阶段：<br>$\quad$ $\quad$ 认证(Authorization)：处理用户登录的过程<br>$\quad$ $\quad$ 事务处理(Trnsactions)：用户收取电子邮件，并将邮件标记为删除<br>$\quad$ $\quad$ 更新(Update)：将标为删除的电子邮件删除<br>$\quad$ POP3使用客户&#x2F;服务器工作方式，在接收邮件的用户PC机中必须运行POP客户程序，而在用户所连接的ISP的邮件服务器中则运行POP服务器程序</p><h6 id="IMAP"><a href="#IMAP" class="headerlink" title="IMAP"></a>IMAP</h6><p>$\quad$ IMAP—Internet邮件访问协议[RFC 2060]<br>$\quad$ 用于最终交付的主要协议<br>$\quad$ IMAP是较早使用的最终交付协议—POP3(邮局协议，版本3)的改进版<br>$\quad$ 邮件服务器运行侦听端口143的IMAP服务器<br>$\quad$ 用户代理运行一个IMAP客户端<br>$\quad$ 客户端连接到服务器并开始发出命令<br>Ø$\quad$ MAP允许用户在不同的地方使用不同的计算机随时上网阅读和处理自己的邮件<br>$\quad$ IMAP服务器把每个邮件与一个文件夹联系起来，<br>$\quad$ $\quad$ 当邮件第一次到达服务器时，它与收件人的INBOX文件夹相关联<br>$\quad$ $\quad$ 收件人能够把邮件移到一个新的、用户创建的文件夹中，阅读邮件，删除邮件等<br>$\quad$ IMAP还为用户提供了在远程文件夹中查询邮件的命令，按指定条件去查询匹配的邮件<br>$\quad$ 与POP3不同，IMAP服务器维护了用户状态信息<br>$\quad$ $\quad$ 例如，文件夹的名字以及哪些邮件与哪些文件夹相关联<br>$\quad$ IMAP具有允许用户代理获取邮件某些部分的命令<br>$\quad$ $\quad$ 例如，一个用户代理可以只读取一个邮件的首部，或只是一个多部分MIME邮件的一部分<br>$\quad$ 用户代理和其邮件服务器之间使用低带宽连接（如一个低速调制解调器链路）的时候，用户可能并不想取回邮箱中的所有邮件，其要避免可能包含如音频或视频片断的大邮件<br>$\quad$ IMAP的缺点是如果用户没有将邮件复制到自己的PC上，则邮件一直是存放在IMAP服务器上。因此用户需要经常与IMAP服务器建立连接</p><h6 id="Webmail"><a href="#Webmail" class="headerlink" title="Webmail"></a>Webmail</h6><p>$\quad$ Webmail——基于Web的电子邮件<br>$\quad$ $\quad$ 提供电子邮件服务的IMAP和SMTP替代方案<br>$\quad$ $\quad$ 使用Web作为界面，用户代理就是普通的浏览器<br>$\quad$ $\quad$ 用户及其远程邮箱之间的通信通过HTTP进行<br><img src="/../CNP/CN202.png"></p><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>CN</category>
      
      <category>应用层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CN</tag>
      
      <tag>应用层</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器人学部分</title>
    <link href="/2023/09/24/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E9%83%A8%E5%88%86/"/>
    <url>/2023/09/24/%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%AD%A6%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p>利用正运动学以及空间变换控制舵机</p><span id="more"></span><h1 id="机器人学基础"><a href="#机器人学基础" class="headerlink" title="机器人学基础"></a>机器人学基础</h1><h2 id="空间描述和变换"><a href="#空间描述和变换" class="headerlink" title="空间描述和变换"></a>空间描述和变换</h2><p>$\quad$·存在一个世界坐标系,讨论任何问题都是基于这个坐标系<br>$\quad$·一旦建立了坐标系,我们就能用一个3x1的位置矢量给世界坐标系中的任何点定位<br>旋转矩阵：</p><p><img src="/../FMCWmg/UCS1.png"></p><p>舵机的旋转即为Z-X-Y欧拉角</p><p>$\quad$ 首先将坐标系{B}和一个已知参考坐标系{A}重合。先将{B}绕$Z_B$转$\alpha$角度，再<br>绕$Y_B$旋转$\beta$ 角，最后绕着$X_B$ 旋转y角<br><img src="/../FMCWmg/UCS2.png"><br>matlab中可以通过rotx()，roty()，rotz()函数计算旋转矩阵</p><h2 id="实物坐标系建立"><a href="#实物坐标系建立" class="headerlink" title="实物坐标系建立"></a>实物坐标系建立</h2><p><img src="/../FMCWmg/UCS3.png"><br><img src="/../FMCWmg/UCS4.png"><br>代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><br>%坐标系变换<br><br>%R为雷达测出的距离，angle_PSI,angle_THETA为雷达测出的角度<br><br>%angle_1，angle_2为舵机目前的角度<br><br>%L为舵机<span class="hljs-number">1</span>转轴的长度<br><br>%P_A=Rotate*（P_B+P） 先平移再旋转<br><br>%%<br><br>L = <span class="hljs-number">50</span>;<br><br>Rotate = rotz(angle_2)*roty(<span class="hljs-number">0</span>)*rotx(angle_1);%Z-Y-X欧拉角<br><br>P_MOVE1= [<span class="hljs-number">0</span>;<span class="hljs-number">0</span>;L];<br><br>P_B_x = R * <span class="hljs-built_in">cos</span>(angle_PSI) * <span class="hljs-built_in">sin</span>(angle_THETA);<br><br>P_B_y = R * <span class="hljs-built_in">cos</span>(angle_PSI) * <span class="hljs-built_in">cos</span>(angle_THETA);<br><br>P_B_z = R * <span class="hljs-built_in">sin</span>(angle_PSI);<br><br>P_B = [P_B_x;P_B_y;P_B_z];%<span class="hljs-number">3</span>号（雷达）坐标系下的坐标<br><br>%%<br><br>P_A = Rotate * (P_B - P_MOVE1);%得到<span class="hljs-number">2</span>号坐标系下的坐标<br><br>%%<br><br>P_MOVE2=[<span class="hljs-number">-45</span>;<span class="hljs-number">-75</span>;<span class="hljs-number">-100</span>];<br><br>P_0 = P_A + P_MOVE2;% <span class="hljs-number">1</span>号坐标系下的坐标<br><br>%%<br><br>% P_A = ;<br><br>angle_2_new = <span class="hljs-built_in">atan</span>(P_A(<span class="hljs-number">1</span>)/P_A(<span class="hljs-number">2</span>));%舵机<span class="hljs-number">2</span>要调整到的角度<br><br>temp = <span class="hljs-built_in">sqrt</span>(P_A(<span class="hljs-number">1</span>)*P_A(<span class="hljs-number">1</span>)+P_A(<span class="hljs-number">2</span>)+P_A(<span class="hljs-number">2</span>));<br><br>angle_1_new = <span class="hljs-built_in">atan</span>(P_A(<span class="hljs-number">3</span>)/temp);%舵机<span class="hljs-number">1</span>要调整到的角度<br><br>disp(angle_1_new);<br><br>disp(angle_2_new);<br><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>CS科研</category>
      
      <category>树莓派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树莓派</tag>
      
      <tag>机器人学</tag>
      
      <tag>舵机</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>应用层-Web与HTTP</title>
    <link href="/2023/09/22/%E5%BA%94%E7%94%A8%E5%B1%82-Web%E4%B8%8EHTTP/"/>
    <url>/2023/09/22/%E5%BA%94%E7%94%A8%E5%B1%82-Web%E4%B8%8EHTTP/</url>
    
    <content type="html"><![CDATA[<p> 对应 北京大学计算机网络课程第二讲第一部分<br> 参考教材计算机网络-自顶向下方法</p><span id="more"></span><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="应用层-Web与HTTP"><a href="#应用层-Web与HTTP" class="headerlink" title="应用层-Web与HTTP"></a>应用层-Web与HTTP</h2><p>$\quad$ 不同主机上的程序之间通过网络应用层完成交互<br>$\quad$ 典型的应用层服务：语音通话，在线会议，社交网络，搜索引擎，信息推送Web访问，文件传输，电子邮件，即时通讯，远程登陆，P2P文件共享，在线游戏，流媒体。。。。。。。</p><h5 id="应用层与下层网络（传输层）接口"><a href="#应用层与下层网络（传输层）接口" class="headerlink" title="应用层与下层网络（传输层）接口"></a>应用层与下层网络（传输层）接口</h5><p>$\quad$ 应用程序在端系统上以进程的形式呈现<br>$\quad$ 进程利用socket（套接字）发送&#x2F;接收消息（通过传输层）<br>$\quad$ socket类似一扇门：从门中向外发送消息，从其他进程收到的消息堆积在门口等待接收<br>$\quad$ 希望传输层提供的服务：可靠传输，高吞吐，低时延，安全</p><h6 id="实际传输层提供的服务"><a href="#实际传输层提供的服务" class="headerlink" title="实际传输层提供的服务"></a>实际传输层提供的服务</h6><p>$\quad$ TCP服务<br>$\quad$ $\quad$ 面向连接：传输前建立连接<br>$\quad$ $\quad$ 可靠传输：丢包重传<br>$\quad$ $\quad$ 有序传输<br>$\quad$ $\quad$ 流量控制：防止接收端过载<br>$\quad$ $\quad$  拥塞控制：防止网络核心过载<br>$\quad$ $\quad$ 无法保证：延迟，吞吐，安全<br>$\quad$ UDP服务<br>$\quad$ $\quad$ 无连接<br>$\quad$ $\quad$  不可靠传输：可能丢包，丢包也无法回复<br>$\quad$ $\quad$  无法保证：可靠性，顺序，流量控制，拥塞控制，延迟，吞吐量，安全<br>$\quad$ $\quad$  问：为什么还有UDP：简单，性能好</p><h4 id="网络应用层的好处："><a href="#网络应用层的好处：" class="headerlink" title="网络应用层的好处："></a>网络应用层的好处：</h4><p>$\quad$ 屏蔽底层细节<br>$\quad$ $\quad$ 设计应用层程序时，需要考虑到TCP与UDP的性质<br>$\quad$ $\quad$ 应用程序无需为下层网络设备编写代码<br>$\quad$ 抽象：许多网络应用有相同的通信模式，网络应用层封装这些共同模式<br>$\quad$ 提供额外的功能：如安全性<br> 总之网络应用层极大简化了网络应用开发，使得互联网可以快速发展</p><h4 id="应用层的通信实体"><a href="#应用层的通信实体" class="headerlink" title="应用层的通信实体"></a>应用层的通信实体</h4><p>$\quad$ 应用层的实体就是应用程序<br>$\quad$ 我们可以给网络中的每台主机命名<br>$\quad$ $\quad$ 网卡MAC地址<br>$\quad$ $\quad$ IP地址<br>$\quad$ $\quad$ 主机名<br>$\quad$ 每个主机的命名仍然不够<br>$\quad$ 对于接收到的消息，需要区分是发给哪个应用程序<br>$\quad$ $\quad$ 单个主机上可能运行多个应用程序<br>$\quad$ $\quad$ 单个应用程序也可能创建多个连接（socket）<br>$\quad$ 解决方案：为每个应用以IP地址+端口号命名<br>$\quad$ $\quad$ HTTP服务器：80<br>$\quad$ $\quad$ 邮件服务器：25</p><h4 id="应用层的组织架构"><a href="#应用层的组织架构" class="headerlink" title="应用层的组织架构"></a>应用层的组织架构</h4><p>$\quad$ 应用程序以两种方法组织:</p><h5 id="客户-x2F-服务器方式（C-x2F-S）"><a href="#客户-x2F-服务器方式（C-x2F-S）" class="headerlink" title="客户&#x2F;服务器方式（C&#x2F;S）"></a>客户&#x2F;服务器方式（C&#x2F;S）</h5><p>$\quad$ 应用层的许多协议是基于C&#x2F;S方式<br>$\quad$ 客户端与服务器是指通信中所涉及的两个应用进程<br>$\quad$ 客户、服务器方式描述的是应用进程之间服务与被服务之间的关系<br>$\quad$ 客户是服务请求方，服务器是服务提供方<br><img src="/../CNP/CN101.png"><br>$\quad$ 分层视角：<br><img src="/CNP/CN102.png"></p><h6 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h6><p>$\quad$ 根据是否建立连接：<br>$\quad$ $\quad$ 可以是面向连接的，也可以是无连接的<br>$\quad$ $\quad$ 面向连接时，C&#x2F;S通信关系一旦建立，通信就是双向的，都可发送和接收数据<br>$\quad$ 根据服务器进程的实现方式<br>$\quad$ $\quad$ 服务器采用<strong>循环方式(iterative mode)</strong><br>$\quad$ $\quad$ $\quad$ 一次只运行一个服务进程<br>$\quad$ $\quad$ $\quad$ 一个服务进程在同一时间只能向一个客户端提供服务<br>$\quad$ $\quad$ $\quad$ 服务进程收到客户进程的请求后，对其他客户进程发来的请求则暂时不予理睬，这些请求都在服务端的队列中排队等候服务进程的处理当服务进程处理完毕一个请求时，就从队列中读取来自下一个客户进程的请求，然后继续处理<br>$\quad$ $\quad$ $\quad$ 当有多个客户进程请求服务时，服务进程就按请求的先后顺序依次做出响应 (阻塞方式)<br>$\quad$ $\quad$ $\quad$ 面向连接的TCP与无连接的UDP都可以用<br><img src="/../CNP/CN103.png"></p><p><img src="/../CNP/CN104.png"></p><p>$\quad$ $\quad$ 服务器采用<strong>并发方式(concurrent mode)</strong><br>$\quad$ $\quad$ $\quad$ 可以同时运行多个服务进程<br>$\quad$ $\quad$ $\quad$ 每一个服务进程都对某个特定的客户进程做出响应 (非阻塞方式)<br>$\quad$ $\quad$ $\quad$ 通常只有面向连接的TCP使用<br>$\quad$ $\quad$ $\quad$ 面向连接的TCP服务进程通常都工作在并发服务方式（尽管也可以使用循环方式）<br>$\quad$ $\quad$ $\quad$ 服务进程在同一时间可同时向多个客户进程提供服务(并发服务)<br>$\quad$ $\quad$ $\quad$ 在TCP服务进程与多个客户进程之间建立多条TCP连接，每条TCP连接在其数据传送完毕后释放<br>$\quad$ $\quad$ $\quad$ 具体流程<br>$\quad$ $\quad$ $\quad$ $\quad$ 服务器监听一个（熟知）服务端口，如HTTP的80端口<br>$\quad$ $\quad$ $\quad$ $\quad$ 主服务进程在熟知端口等待客户进程发出的请求<br>$\quad$ $\quad$ $\quad$ $\quad$ 一旦收到客户的请求，就创建一个从属服务进程，并指明从属服务进程使用临时套接字（又称连接套接字）与该客户建立TCP连接<br>$\quad$ $\quad$ $\quad$ $\quad$ 然后主服务进程继续在原来的熟知端口等待向其他客户提供服务<br><img src="/../CNP/CN105.png"></p><p>$\quad$ 为什么无连接的UDP只能采用循环方式，无法采用并发方式<br>$\quad$ 原因：无连接UDP只有一个套接字，无法被多个从属进程同时访问</p><p>$\quad$ 对比：<br><img src="/../CNP/CN106.png"></p><h6 id="特例：浏览器-x2F-服务模式："><a href="#特例：浏览器-x2F-服务模式：" class="headerlink" title="特例：浏览器&#x2F;服务模式："></a>特例：浏览器&#x2F;服务模式：</h6><p>$\quad$ 浏览器&#x2F;服务器(B&#x2F;S，Browser&#x2F;Server) 方式可以看做C&#x2F;S方式的特例，即客户软件改为浏览器了<br>$\quad$ B&#x2F;S方式采取浏览器请求、服务器响应的工作模式<br>$\quad$ 在B&#x2F;S方式下，用户界面完全通过Web浏览器实现，一部分事务逻辑在服务器前端实现，但主要的事务逻辑在服务器后端实现<br><img src="/../CNP/CN107.png"><br>$\quad$ B&#x2F;S方式通常采取3层架构实现<br>$\quad$ $\quad$ 数据层：由数据库服务器承担数据处理逻辑，其任务是接受Web服务器对数据库服务器提出的数据操作请求，然后由数据库服务器进行数据处理并把处理结果返回给web服务器<br>$\quad$ $\quad$ 处理层：由Web服务器承担业务处理逻辑和页面存储管理，接受客户浏览器的任务请求，执行相应的事务处理<br>$\quad$ $\quad$ 表现层：浏览器仅承担网页信息的浏览功能, 以超文本格式实现信息的输入和浏览<br><img src="/../CNP/CN108.png"></p><h5 id="对等方式（P2P）"><a href="#对等方式（P2P）" class="headerlink" title="对等方式（P2P）"></a>对等方式（P2P）</h5><p>$\quad$ 对等方式是指两个进程在通信时并不区分服务的请求方和服务的提供方<br>$\quad$ $\quad$ 只要两个主机都运行P2P软件，它们就可以进行平等、对等的通信<br>$\quad$ $\quad$ 双方都可以下载对方存储在硬盘中的共享文档，如果权限允许的话<br>$\quad$ 应用<br>$\quad$ $\quad$ 音频&#x2F;视频应用推动了P2P对等通信方式的发展<br>$\quad$ $\quad$ 音频&#x2F;视频流量已占主要比例<br>$\quad$ P2P方式从本质上看仍然是使用了C&#x2F;S方式，但强调的是通信过程中的对等，这时每一个P2P进程既是客户同时也是服务器<br><img src="/../CNP/CN109.png"></p><h6 id="P2P实体的特征"><a href="#P2P实体的特征" class="headerlink" title="P2P实体的特征"></a>P2P实体的特征</h6><p>$\quad$ 不需要总是在线<br>$\quad$ $\quad$ 虽然每个程序也扮演服务器角色，但与“客户端-服务器”中不同，不需要始终在线<br>$\quad$ 实体可以随时进入与退出<br>$\quad$ $\quad$ 可以动态改变IP地址<br>$\quad$ $\quad$ 需要额外的管理开销<br>$\quad$ 任意两个实体之间可以直接通信<br>$\quad$ 易于扩展<br>$\quad$ $\quad$ 每个结点都贡献自己的计算资源，也消耗一部分资源</p><h4 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h4><p>$\quad$ 应用层的实体就是应用协议<br>$\quad$ $\quad$ 通信内容：某个约定好的应用层协议<br>$\quad$ 每个应用层协议都是为了解决某一应用问题，通过位于不同主机中的多个应用程序之间的通信和协同工作来完成<br><img src="/../CNP/CN110.png"></p><h5 id="Web基本协议"><a href="#Web基本协议" class="headerlink" title="Web基本协议"></a>Web基本协议</h5><p>$\quad$ WWW&#x3D;World Wide Web<br>$\quad$ 构成：Web对象（网页，多媒体资源，动态对象与服务），通过URLs定位；HTTP服务器和客户端；服务器与客户端之间执行的HTTP协议<br><img src="/../CNP/CN111.png"></p><h6 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h6><p>$\quad$ Web页面（HTML文档）：包含到多种对象或链接<br>$\quad$ Web对象（包括静态对象和动态对象）：可以是HTML文档，图像文件，视频文件，声音文件，脚本文件等<br>$\quad$ 对象用URL（统一资源定位符）编址：协议类型:&#x2F;&#x2F;主机名：端口&#x2F;&#x2F;路径和文件名<br><img src="/../CNP/CN113.png"></p><h6 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h6><p>$\quad$ 发出请求，接收响应，解释HTML文档并显示<br>$\quad$ 有些对象需要浏览器安装插件<br><img src="/../CNP/CN112.png"></p><h6 id="Web对象"><a href="#Web对象" class="headerlink" title="Web对象"></a>Web对象</h6><p>$\quad$ 静态对象与静态网页<br>$\quad$ $\quad$ 文本，表格，图片，图像和视频等多媒体类型的信息（实现语言：标记语言，如：HTML，XML，PHP等）<br>$\quad$ $\quad$ 字体、颜色和布局等风格类型的信息（实现语言：层叠样式表CSS）<br>$\quad$ 动态对象与动态网页<br>$\quad$ $\quad$ 交互信息，比如，用户注册信息、登录信息等（实现：PHP&#x2F;JSP等语言+MySQL等数据库）<br>$\quad$ 链接：<br>$\quad$ $\quad$ 超链接（HyperLinks）：指向其他对象的URLs<br><img src="/../CNP/CN114.png"><br>$\quad$ 动态Web<br>$\quad$ $\quad$ 通用网关接口CGI<br>$\quad$ $\quad$ $\quad$ CGI (Common Gateway Interface) 是一种标准<br>$\quad$ $\quad$ $\quad$ $\quad$ 在服务器创建动态文档<br>$\quad$ $\quad$ $\quad$ $\quad$ 定义了动态文档应如何创建<br>$\quad$ $\quad$ $\quad$ $\quad$ 输入数据应如何提供给应用程序<br>$\quad$ $\quad$ $\quad$ $\quad$ 输出结果应如何使用<br><img src="/../CNP/CN115.png"><br>$\quad$ $\quad$ 脚本语言+数据库技术<br>$\quad$ $\quad$ $\quad$ 更好的服务器逻辑表示“脚本”指的是一个程序，它被另一个程序（即解释程序，如Web浏览器）解释执行，而不是由计算机的处理器来解释或执行<br>$\quad$ $\quad$ $\quad$ 数据库：更好的数据交换方式<br>$\quad$ $\quad$ 动态页面的创建，可以在浏览器or &#x2F;and 服务器进行</p><p><img src="/../CNP/CN116.png"><br>$\quad$ $\quad$ 动态Web的执行:Web内容展示（前端）和服务逻辑（后端）相分离；脚本程序可以在服务器或客户端创建Web文档<br>$\quad$ $\quad$ AJAX技术（Asynchronous JavaScript and XML）：超文本标记语言HTML+CSS：用于Web网页内容的显示<br>$\quad$ $\quad$ $\quad$ 文档对象模型DOM:是HTML和XML文档的编程接口，本质上是页面的API，采用树形结构组织。<br>$\quad$ $\quad$ $\quad$ 扩展标记语言XML：用于程序和服务器交换应用数据<br>$\quad$ $\quad$ $\quad$ 异步式工作方式：用于发送和检索XML数据<br>$\quad$ $\quad$ $\quad$ JavaScript：用于将以上功能进行组合并协同工作<br>$\quad$ $\quad$ AJAX不是新的编程语言，而是一种使用现有标准的新方法<br>$\quad$ $\quad$ LAMP&#x3D;Linux+Apache+MySQL+PHP<br>$\quad$ $\quad$ LAMP不是新的工具，而是一套Web服务器软件集合</p><h5 id="HTTP协议："><a href="#HTTP协议：" class="headerlink" title="HTTP协议："></a>HTTP协议：</h5><p>$\quad$ 超文本传输协议HTTP（HyperText Transfer Protocol）在传输层通常使用TCP协议，缺省使用TCP的80端口<br>$\quad$ HTTP为无状态协议，服务器端不保留之前请求的状态信息<br>$\quad$ $\quad$ 无状态协议：效率低，但简单<br>$\quad$ $\quad$ 有状态协议：维护状态相对复杂，需要维护历史信息，在客户端或服务器出现故障时，需要保持状态的一致性等。</p><h6 id="HTTP发展现状"><a href="#HTTP发展现状" class="headerlink" title="HTTP发展现状"></a>HTTP发展现状</h6><p><img src="/../CNP/(1)CN111.png"></p><h6 id="HTTP1-0"><a href="#HTTP1-0" class="headerlink" title="HTTP1.0"></a>HTTP1.0</h6><p><img src="/../CNP/(1)CN112.png"></p><h6 id="非持久连接和持久连接"><a href="#非持久连接和持久连接" class="headerlink" title="非持久连接和持久连接"></a>非持久连接和持久连接</h6><p>$\quad$ 非持久连接<br>$\quad$ $\quad$ HTTP&#x2F;1.0缺省为非持久连接<br>$\quad$ $\quad$ $\quad$ 服务器接收请求、响应、关闭TCP连接<br>$\quad$ $\quad$ 获取每个对象需要三个阶段<br>$\quad$ $\quad$ $\quad$ 建立TCP连接<br>$\quad$ $\quad$ $\quad$ 对象请求和传输<br>$\quad$ $\quad$ $\quad$ 关闭TCP连接<br>$\quad$ $\quad$ 每次连接需要经历TCP慢启动阶段<br>$\quad$ 持久连接<br>$\quad$ $\quad$ HTTP&#x2F;1.1缺省为持久连接<br>$\quad$ $\quad$ $\quad$ 在相同的TCP连接上，服务器接收请求、响应；再接收请求、响应；响应后保持连接<br>$\quad$ $\quad$ HTTP&#x2F;1.1-pipeline 支持流水线机制<br>$\quad$ $\quad$ $\quad$ 需要按序响应<br>$\quad$ $\quad$ 经历较少的慢启动过程，减少往返时间<br>$\quad$ $\quad$ $\quad$ 降低响应时间</p><h6 id="HTTP1-x"><a href="#HTTP1-x" class="headerlink" title="HTTP1.x"></a>HTTP1.x</h6><p><img src="/../CNP/(1)CN113.png"></p><h6 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h6><p>$\quad$ 2015年5月，以RFC 7540正式发布<br>$\quad$ 多路复用<br>$\quad$ $\quad$ HTTP 1.1：一个请求的响应收到后，才能发送下一个请求<br>$\quad$ $\quad$ HTTP 1.1-pipeline：可以同时发送多个请求，但要按顺序响应<br>$\quad$ $\quad$ HTTP 2：请求&#x2F;响应允许交错，还可以自定义优先级<br>$\quad$ 压缩<br>$\quad$ HTTP 2：服务器可以主动推送消息<br>$\quad$ $\quad$ 确认客户端存活<br>$\quad$ $\quad$ 预测资源请求<br>$\quad$ 流量控制<br>$\quad$ $\quad$ HTTP 1.1：完全依赖TCP<br>$\quad$ $\quad$ HTTP 2：允许应用层进行控制</p><h6 id="HTTP3"><a href="#HTTP3" class="headerlink" title="HTTP3"></a>HTTP3</h6><p>$\quad$ 2022年6月以RFC 9114发布<br>$\quad$ $\quad$ 同时，HTTP 2更新至RFC 9113<br>$\quad$ 主要是传输层变化，与应用层关系不大<br>$\quad$ $\quad$ 将TCP替换为UDP + QUIC<br>$\quad$ $\quad$ （将在传输层章节介绍）</p><h6 id="HTTP请求报文结构"><a href="#HTTP请求报文结构" class="headerlink" title="HTTP请求报文结构"></a>HTTP请求报文结构</h6><p>$\quad$ 请求报文由三个部分组成，即开始行、首部行和实体主体<br>$\quad$ 在请求报文中，开始行又称请求行<br>$\quad$ 方法是对所请求的对象进行的操作，实际上也就是一些命令<br>$\quad$ 请求报文的类型是由它所采用的方法决定的<br>$\quad$ URL是所请求资源的URL（有时URL会带一些参数，参数以“?”开始，每个参数的形式为“name&#x3D;value”，参数之间以“&amp;”隔开）<br><img src="/../CNP/(1)CN114.png"><br><img src="/../CNP/(1)CN115.png"><br><img src="/../CNP/(1)CN116.png"></p><h6 id="HTTP响应报文结构"><a href="#HTTP响应报文结构" class="headerlink" title="HTTP响应报文结构"></a>HTTP响应报文结构</h6><p>$\quad$ 与请求报文类似，由三个部分组成，即开始行、首部行和实体主体<br>$\quad$ 在响应报文中，开始行又称状态行<br>$\quad$ 状态码都是三位数字<br>$\quad$ $\quad$ 1xx 表示通知信息的，如请求收到了或正在进行处理。<br>$\quad$ $\quad$ 2xx 表示成功，如接受或知道了。<br>$\quad$ $\quad$ 3xx 表示重定向，表示要完成请求还必须采取进一步的行动。<br>$\quad$ $\quad$ 4xx 表示客户的差错，如请求中有错误的语法或不能完成。<br>$\quad$ $\quad$ 5xx 表示服务器的差错，如服务器失效无法完成请求。<br>$\quad$ $\quad$ 典型的状态码<br>$\quad$ $\quad$ $\quad$ 200 OK<br>$\quad$ $\quad$ $\quad$ $\quad$ 请求成功，被请求的对象包含在该响应的数据部分<br>$\quad$ $\quad$ $\quad$ 301 Moved Permanently<br>$\quad$ $\quad$ $\quad$ $\quad$ 请求的对象被移走，新的位置在响应中通过Location: 给出<br>$\quad$ $\quad$ $\quad$ 400 Bad Request<br>$\quad$ $\quad$ $\quad$ $\quad$ 服务器不能解释请求报文<br>$\quad$ $\quad$ $\quad$ 404 Not Found<br>$\quad$ $\quad$ $\quad$ $\quad$ 服务器中找不到请求的文档<br>$\quad$ $\quad$ $\quad$ 505 HTTP Version Not Supported<br>$\quad$ $\quad$ $\quad$ $\quad$ 服务器不支持相应的HTTP版本<br><img src="/../CNP/CN117.png"></p><h6 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h6><p>$\quad$ 浏览器缓存<br>$\quad$ $\quad$ 在浏览器主机保存用户访问过的服务器Web页副本<br>$\quad$ $\quad$ 再次访问该页，不必从服务器再次传输，提高访问效率<br><img src="/../CNP/CN118.png"><br>$\quad$ 代理服务器缓存<br>$\quad$ $\quad$ 目标：代理服务器缓存已访问过的Web页副本，满足用户浏览器从代理服务器提取Web页，尽量减少原始服务器参与<br>$\quad$ $\quad$ 设置用户浏览器，通过代理服务器进行Web访问<br>$\quad$ $\quad$ 浏览器将所有的HTTP请求发送到代理服务器<br>$\quad$ $\quad$ $\quad$ 如果缓存中有被请求的对象，则直接返回对象<br>$\quad$ $\quad$ $\quad$ 否则，代理服务器向原始服务器请求对象，再将对象返回给客户端<br>$\quad$ $\quad$ 性能分析：<br><img src="/../CNP/CN119.png"><br><img src="/../CNP/CN120.png"><br>$\quad$ $\quad$ Web缓存存在的困难，即Web缓存与原始服务器Web页一致性问题<br>$\quad$ $\quad$ $\quad$ 启发式策略（较少使用）：服务器响应Web页的Last-Modified头和Expires头<br>$\quad$ $\quad$ $\quad$ 询问式策略（常用）：通过特殊的关键字头询问原始服务器，Web副本是否已更新<br><img src="/../CNP/CN121.png"></p><h6 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h6><p><img src="/../CNP/CN122.png"><br><img src="/../CNP/CN123.png"><br>$\quad$ Cookies一般包含5个字段<br>$\quad$ $\quad$ 域指明Cookie来自何方，每个域为每个客户分配Cookie有数量限制<br>$\quad$ $\quad$ 路径标明服务器的文件树中哪些部分可以使用该Cookie<br>$\quad$ $\quad$ 内容采用“名字&#x3D;值”的形式，是Cookie存放内容的地方，可以达到4K容量，内容只是字符串，不是可执行程序<br>$\quad$ $\quad$ 安全指示浏览器只向使用安全传输连接的服务器返回Cookie<br><img src="/../CNP/CN124.png"><br>$\quad$ $\quad$ Cookie文件保存的只是文本串，没有可执行程序</p><h6 id="访问安全"><a href="#访问安全" class="headerlink" title="访问安全"></a>访问安全</h6><p>$\quad$ Web访问安全<br>$\quad$ $\quad$ 并非所有Web页都会向公众开放<br>$\quad$ $\quad$ Web服务器可以限定客户端访问的IP地址空间，比如限制只向公司内部员工开放<br>$\quad$ $\quad$ Apache服务器将设置限制访问规则的文件.htaccess放置在被限制访问的页面所在的目录，客户端访问时进行规则匹配<br>$\quad$ $\quad$ 无状态：客户端需要在每个请求中携带认证信息<br>$\quad$ $\quad$ 认证方法：通常在HTTP请求中使用“用户名-密码”<br>$\quad$ $\quad$ 每个请求头中包含关键字authorization:<br>$\quad$ $\quad$ 如果请求头中无authorization: ，则服务器拒绝访问，并在响应头中包含WWW authenticate：<br><img src="/../CNP/CN125.png"></p><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>CN</category>
      
      <category>应用层</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CN</tag>
      
      <tag>应用层</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派PVM的使用</title>
    <link href="/2023/09/19/%E6%A0%91%E8%8E%93%E6%B4%BEPVM%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/09/19/%E6%A0%91%E8%8E%93%E6%B4%BEPVM%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>利用树莓派中python GPIO库实现</p><span id="more"></span><p>上方舵机角度范围为0～180<br>下方为0～270（角度高了点线会缠绕）<br>(可以为负数，但是超过了某范围会自动复位)<br>以下为代码</p><h4 id="RPI-GPIO"><a href="#RPI-GPIO" class="headerlink" title="RPI.GPIO"></a>RPI.GPIO</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs python">  <br><br><span class="hljs-keyword">import</span> RPi.GPIO <span class="hljs-keyword">as</span> GPIO<br><br><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> sleep<br><br>  <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">tonum1</span>(<span class="hljs-params">degree</span>): <span class="hljs-comment"># 用于处理角度转换的函数</span><br><br>dc = <span class="hljs-built_in">float</span>(degree)/<span class="hljs-number">18</span>+<span class="hljs-number">2.5</span><br><br><span class="hljs-keyword">return</span> dc<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">tonum</span>(<span class="hljs-params">degree</span>): <span class="hljs-comment"># 用于处理角度转换的函数</span><br><br>dc = <span class="hljs-built_in">float</span>(degree)/<span class="hljs-number">27</span>+<span class="hljs-number">2.5</span><br><br><span class="hljs-keyword">return</span> dc<br><br><span class="hljs-comment"># dc = 1/27*角度 + 2.5</span><br><br>  <br><br>servopin1 = <span class="hljs-number">17</span> <span class="hljs-comment">#舵机1,方向为左右转</span><br><br>servopin2 = <span class="hljs-number">18</span> <span class="hljs-comment">#舵机2,方向为上下转</span><br><br>  <br><br>GPIO.setmode(GPIO.BCM)<br><br>GPIO.setup(servopin1, GPIO.OUT, initial=<span class="hljs-literal">False</span>)<br><br>GPIO.setup(servopin2, GPIO.OUT, initial=<span class="hljs-literal">False</span>)<br><br>p1 = GPIO.PWM(servopin1,<span class="hljs-number">50</span>) <span class="hljs-comment">#50HZ</span><br><br>p2 = GPIO.PWM(servopin2,<span class="hljs-number">50</span>) <span class="hljs-comment">#50HZ</span><br><br>  <br><br>p1.start(tonum1(<span class="hljs-number">90</span>)) <span class="hljs-comment">#初始化角度</span><br><br>p2.start(tonum(<span class="hljs-number">40</span>)) <span class="hljs-comment">#初始化角度</span><br><br>sleep(<span class="hljs-number">0.5</span>)<br><br>p1.ChangeDutyCycle(<span class="hljs-number">0</span>) <span class="hljs-comment">#清除当前占空比，使舵机停止抖动</span><br><br>p2.ChangeDutyCycle(<span class="hljs-number">0</span>) <span class="hljs-comment">#清除当前占空比，使舵机停止抖动</span><br><br>sleep(<span class="hljs-number">0.1</span>)<br><br>  <br>  <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">left</span>(<span class="hljs-params">r</span>):<br><br><span class="hljs-comment"># if r &gt;= 0:</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前角度为&#x27;</span>,r)<br><br>p1.ChangeDutyCycle(tonum1(r)) <span class="hljs-comment">#执行角度变化</span><br><br>sleep(<span class="hljs-number">0.1</span>)<br><br>p1.ChangeDutyCycle(<span class="hljs-number">0</span>) <span class="hljs-comment">#清除当前占空比，使舵机停止抖动</span><br><br>sleep(<span class="hljs-number">0.01</span>)<br><br><span class="hljs-comment">#else:</span><br><br><span class="hljs-comment"># print(&#x27;\n**超出范围**\n&#x27;)</span><br><br><span class="hljs-comment"># r = 90</span><br><br><span class="hljs-comment"># p1.ChangeDutyCycle(tonum(r)) #执行角度变化</span><br><br><span class="hljs-comment"># sleep(0.1)</span><br><br><span class="hljs-comment"># p1.ChangeDutyCycle(0) #清除当前占空比，使舵机停止抖动</span><br><br><span class="hljs-comment"># sleep(0.01)</span><br><br>  <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">up</span>(<span class="hljs-params">l</span>):<br><br><span class="hljs-comment">#if l &gt; 0:</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前角度为&#x27;</span>,l)<br><br>p2.ChangeDutyCycle(tonum(l)) <span class="hljs-comment">#执行角度变化，</span><br><br>sleep(<span class="hljs-number">0.1</span>)<br><br>p2.ChangeDutyCycle(<span class="hljs-number">0</span>) <span class="hljs-comment">#清除当前占空比，使舵机停止抖动</span><br><br>sleep(<span class="hljs-number">0.01</span>)<br><br><span class="hljs-comment"># else:</span><br><br><span class="hljs-comment">#print(&#x27;\n**超出范围**\n&#x27;)</span><br><br><span class="hljs-comment">#l=45</span><br><br><span class="hljs-comment">#p2.ChangeDutyCycle(tonum(l)) #执行角度变化</span><br><br><span class="hljs-comment">#sleep(0.1)</span><br><br><span class="hljs-comment">#p2.ChangeDutyCycle(0) #清除当前占空比，使舵机停止抖动</span><br><br><span class="hljs-comment"># sleep(0.01)</span><br><br>  <br>  <br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br><br>r = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;input 1 angle:&#x27;</span>))<br><br>l = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;input 2 angle:&#x27;</span>))<br><br>left(r)<br><br>up(l)<br><br><span class="hljs-comment">#1 is 180,2 is 270</span><br><br></code></pre></td></tr></table></figure><h4 id="pigpio"><a href="#pigpio" class="headerlink" title="pigpio"></a>pigpio</h4><p>$\quad$ 因为RPI.GPIO库无法实现remote GPIO，修改为pigpio<br>$\quad$ 使用前在树莓派的&#x2F;首选项&#x2F;Raspberry Pi Configuration中启用remote GPIO</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#coding=UTF-8</span><br><br><span class="hljs-keyword">import</span> pigpio<br><br><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> sleep<br><br>  <br><br>pi = pigpio.pi(<span class="hljs-string">&#x27;10.6.28.31&#x27;</span>)<br><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> pi.connected:<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;connect fail&#x27;</span>)<br><br>  <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">tonum1</span>(<span class="hljs-params">degree</span>): <span class="hljs-comment"># 用于上方舵机处理角度转换的函数0~180</span><br><br>dc = <span class="hljs-built_in">float</span>(degree)*<span class="hljs-number">1000</span>/<span class="hljs-number">90</span>+<span class="hljs-number">500</span><br><br><span class="hljs-keyword">return</span> dc<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">tonum2</span>(<span class="hljs-params">degree</span>): <span class="hljs-comment"># 用于下方舵机处理角度转换的函数0~270</span><br><br>dc = <span class="hljs-built_in">float</span>(degree)*<span class="hljs-number">1000</span>/(<span class="hljs-number">45</span>*<span class="hljs-number">3</span>)+<span class="hljs-number">500</span><br><br><span class="hljs-keyword">return</span> dc<br><br>  <br>  <br><br>servopin1 = <span class="hljs-number">17</span> <span class="hljs-comment">#舵机1,方向为左右转</span><br><br>servopin2 = <span class="hljs-number">18</span> <span class="hljs-comment">#舵机2,方向为上下转</span><br><br>  <br><br>pi.set_PWM_frequency(servopin1,<span class="hljs-number">50</span>)<br><br>pi.set_PWM_frequency(servopin2,<span class="hljs-number">50</span>)<span class="hljs-comment"># frequency = 50Hz</span><br><br>  <br><br>sleep(<span class="hljs-number">0.5</span>)<br><br>  <br>  <br><br>pi.set_servo_pulsewidth(servopin1, tonum1(<span class="hljs-number">0</span>))<br><br>pi.set_servo_pulsewidth(servopin2, tonum2(<span class="hljs-number">0</span>))<span class="hljs-comment">#初始角度两个0</span><br><br>sleep(<span class="hljs-number">0.5</span>)<br><br>  <br>  <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">left</span>(<span class="hljs-params">r</span>):<br><br><span class="hljs-keyword">if</span> r &lt;= <span class="hljs-number">180</span>:<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前角度为&#x27;</span>,r)<br><br>pi.set_servo_pulsewidth(servopin1,tonum1(r)) <span class="hljs-comment">#执行角度变化</span><br><br>sleep(<span class="hljs-number">0.1</span>)<br><br><span class="hljs-keyword">else</span>:<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\n**超出范围**\n&#x27;</span>)<br><br>pi.set_servo_pulsewidth(servopin1,tonum1(<span class="hljs-number">0</span>))<br><br>sleep(<span class="hljs-number">0.01</span>)<br><br>  <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">up</span>(<span class="hljs-params">l</span>):<br><br><span class="hljs-keyword">if</span> l &lt;= <span class="hljs-number">270</span>:<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前角度为&#x27;</span>,l)<br><br>pi.set_servo_pulsewidth(servopin2,tonum2(l))<span class="hljs-comment">#执行角度变化，</span><br><br>sleep(<span class="hljs-number">0.1</span>)<br><br><span class="hljs-keyword">else</span>:<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\n**超出范围**\n&#x27;</span>)<br><br>pi.set_servo_pulsewidth(servopin2,tonum2(<span class="hljs-number">0</span>))<br><br>sleep(<span class="hljs-number">0.01</span>)<br><br>  <br>  <br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br><br>r = <span class="hljs-built_in">float</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;input 1 angle:&#x27;</span>))<br><br>l = <span class="hljs-built_in">float</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;input 2 angle:&#x27;</span>))<br><br>up(l)<br><br>left(r)<br><br><span class="hljs-comment">#1 is 180,2 is 270</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>CS科研</category>
      
      <category>树莓派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树莓派</tag>
      
      <tag>舵机</tag>
      
      <tag>PVM</tag>
      
      <tag>云台</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络基础知识</title>
    <link href="/2023/09/18/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/09/18/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p> 对应 北京大学计算机网络课程第一讲<br> 参考教材计算机网络-自顶向下方法</p><span id="more"></span><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="网络基础知识"><a href="#网络基础知识" class="headerlink" title="网络基础知识"></a>网络基础知识</h2><p>$\quad$ <strong>学习内容：</strong></p><hr><p>网络实体如何通过协议，实现各类网络功能&#x2F;服务</p><hr><p>$\quad$ <strong>主要内容：</strong><br><img src="/../CNP/CN012.png"></p><h3 id="计算机网络中的主要问题："><a href="#计算机网络中的主要问题：" class="headerlink" title="计算机网络中的主要问题："></a>计算机网络中的主要问题：</h3><h5 id="对等实体"><a href="#对等实体" class="headerlink" title="对等实体"></a>对等实体</h5><p>$\quad$ 实体的识别和命名<br>$\quad$ 实体的组织形式</p><h5 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h5><p>$\quad$  传输接口<br>$\quad$  服务性能<br>$\quad$  是否具有可靠性，安全性等保障</p><h5 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h5><p>$\quad$  传输内容的格式，语义，顺序</p><h5 id="实现与管理"><a href="#实现与管理" class="headerlink" title="实现与管理"></a>实现与管理</h5><p>$\quad$  功能、协议-&gt;实体的映射<br>$\quad$  资源分配与调度</p><h3 id="实体：计算机网络的组成"><a href="#实体：计算机网络的组成" class="headerlink" title="实体：计算机网络的组成"></a>实体：计算机网络的组成</h3><h4 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h4><h5 id="个域网PAN"><a href="#个域网PAN" class="headerlink" title="个域网PAN"></a>个域网PAN</h5><p>$\quad$  能在便携式消费电器与通信设备之间进行短距离通信的网络<br>$\quad$  覆盖范围一般在10米半径以内，如蓝牙耳机等</p><h5 id="局域网LAN"><a href="#局域网LAN" class="headerlink" title="局域网LAN"></a>局域网LAN</h5><p>$\quad$  局部地区形成的区域网络，如企业网络<br>$\quad$  分布地区范围有限，可大可小<br>$\quad$  电脑WLAN接入，打印机共享等</p><h5 id="城域网MAN"><a href="#城域网MAN" class="headerlink" title="城域网MAN"></a>城域网MAN</h5><p>$\quad$  覆盖一整个城市的网络</p><h5 id="广域网WAN"><a href="#广域网WAN" class="headerlink" title="广域网WAN"></a>广域网WAN</h5><p>$\quad$  覆盖很大地理区域，乃至覆盖国家和地区</p><h4 id="今天的互联网：网络的网络"><a href="#今天的互联网：网络的网络" class="headerlink" title="今天的互联网：网络的网络"></a>今天的互联网：网络的网络</h4><p>$\quad$  由多个子网络构成<br>$\quad$  每个子网络又可进一步划分<br>$\quad$  直到每个公司、家庭甚至房间内的小网络</p><h5 id="ISP（Internet-service-provider）"><a href="#ISP（Internet-service-provider）" class="headerlink" title="ISP（Internet service provider）"></a>ISP（Internet service provider）</h5><p>提供网络接入与互联服务<br><img src="/CNP/CN01.png"></p><h5 id="网络边缘："><a href="#网络边缘：" class="headerlink" title="网络边缘："></a>网络边缘：</h5><p>$\quad$  端系统：位于互联网边缘与互联网相连的计算机和其他设备<br>$\quad$  端系统由各类主机（host）构成:桌面计算机，移动计算机，服务器，其他智能终端设备</p><h6 id="主机Host"><a href="#主机Host" class="headerlink" title="主机Host"></a>主机Host</h6><p>$\quad$  客户端：各类智能终端<br>$\quad$  服务器<br>$\quad$  功能：容纳（运行）应用程序，将用户程序产生的数据向接入网发送，从网络接收数据并提供给应用程序。<br>$\quad$  内部结构：<br>$\quad$ $\quad$  网络设备硬件（网卡）：对外通信<br>$\quad$ $\quad$  内核软件：内核驱动：网卡管理与访问（为特定网卡开发）；网络协议栈：网络数据处理（与网卡无关）<br>$\quad$ $\quad$  用户软件：调用内存提供接口(socket)进行数据发送&#x2F;接收<br>$\quad$  命名：<br>$\quad$ $\quad$  唯一设备ID（48位mac地址）：全球唯一，不可修改（IEEE将命名空间分给各个厂商，厂商自行保证出厂设备不重名）<br>$\quad$ $\quad$  IP地址：一组数字构成（IPv4 32位，IPv6 128位）<br>$\quad$ $\quad$  主机名：字符串（方便记忆）<br><img src="/../CNP/CN02.png"></p><h5 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h5><p>$\quad$  连接边缘端系统与网络核心<br>$\quad$  通信链路（光纤、铜缆、无线电、激光链路）</p><h6 id="接入网目标"><a href="#接入网目标" class="headerlink" title="接入网目标"></a>接入网目标</h6><p>$\quad$  将主机连接到边缘路由器上<br>$\quad$  边缘路由器是将端系统Host去往任何远程端系统的路程上的第一台路由器<br>$\quad$  各种异构网络是通过边缘路由器接入</p><h6 id="如何将终端系统连接到边缘路由器"><a href="#如何将终端系统连接到边缘路由器" class="headerlink" title="如何将终端系统连接到边缘路由器"></a>如何将终端系统连接到边缘路由器</h6><p>$\quad$  通过各种物理介质（引导性介质：双绞线，同轴电缆(两根同心铜导线)，光纤；非引导性介质：无线电，无线链路）<br>$\quad$  有线网络接入技术：拨号上网（数字用户线DSL），同轴电路，光纤到户，以太网<br>$\quad$  无线网络接入技术：WiFi，4G、5G，卫星广域覆盖</p><p>$\quad$  传输单位：位（bit）1B&#x3D;8b K&#x2F;M&#x2F;G层级为10^3进制</p><h5 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h5><p>$\quad$  由互联网端系统的分组交换设备和通信链路构成的网状网<br>$\quad$  目标：将海量的端系统互联起来<br>$\quad$  关键技术：分组交换<br>$\quad$ $\quad$  主机将数据分成分组（Packet），发送到网络<br>$\quad$ $\quad$  网络将数据分组从一个路由器转发到下一个路由器，通过从源到目标的路径上的链路，逐跳传输抵达目的地</p><h6 id="两大功能"><a href="#两大功能" class="headerlink" title="两大功能"></a>两大功能</h6><p>$\quad$   功能1：路由<br>$\quad$ $\quad$  全局操作：确定数据分组从源到目标所使用的路径<br>$\quad$ $\quad$  需要路由协议与路由算法，产生路由表<br>$\quad$  功能2：转发<br>$\quad$ $\quad$  本地操作：路由器或交换机将收到的数据分组转发出去（即移动到该设备的某个输出接口）<br>$\quad$ $\quad$  确定转发出去的接口&#x2F;链路，根据从“入接口”收到分组头中的目的地址，查找本地路由表，确定”出接口”<br><img src="/../CNP/CN03.png"></p><h6 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h6><p>$\quad$  将大消息（message）拆分成多个小分组（packet)<br>$\quad$  以分组作为数据传输单元<br>$\quad$  每个分组的首部都含有地址（目的地址和源地址）等控制信息<br>$\quad$  支持灵活的统计多路复用<br>$\quad$  使用存储-转发机制，实现数据交互的通信方式<br>$\quad$ $\quad$  路由器需要接收到完整的整个数据包后，才能开始向下一跳发送<br>$\quad$ $\quad$  存储转发带来额外的报文的传输延迟<br>$\quad$ $\quad$ $\quad$  正常的链路传播延迟：将L位数据包，以R bps的速率发送到链路中，需要L&#x2F;R秒<br>$\quad$  每个分组在互联网中独立地选择传输路径<br>$\quad$ $\quad$  不同分组可以共享使用同一节点或链路<br>$\quad$ $\quad$  如果某段链路上，分组到达速率超过链路传输速率<br>$\quad$ $\quad$ $\quad$  分组在一个缓冲区中排队，等到链路可用<br>$\quad$ $\quad$ $\quad$  若队列被填满，后续分组就被抛弃（丢包）</p><h6 id="另一种选择：电路交换"><a href="#另一种选择：电路交换" class="headerlink" title="另一种选择：电路交换"></a>另一种选择：电路交换</h6><p>$\quad$  先呼叫建立连接，实现端到端的资源预留（链路带宽资源，交换机的交换能力）<br>$\quad$  电路交换连接建立后，物理通路被通信双方独占，资源专用，既不空闲也不与其他连接共享<br>$\quad$  由于建立连接并预留资源，因此传输性好，但如果有设备故障则传输中断</p><h6 id="交换方式的比较"><a href="#交换方式的比较" class="headerlink" title="交换方式的比较"></a>交换方式的比较</h6><p>$\quad$  分组交换随时发送无需连接；电路交换需要建立连接<br>$\quad$  分组交换没有预留资源，但较灵活；电路交换为每个连接预留资源<br>$\quad$  分组交换适合有大量突发资源，简单，不需要建立连接<br>$\quad$ $\quad$  缺点1：分组交换容易拥塞，引起排队延迟甚至丢包<br>$\quad$ $\quad$ $\quad$  需要设计可靠性机制与拥塞控制机制<br>$\quad$ $\quad$  缺点2:分组交换无法提供类似电路交换的服务<br>$\quad$ $\quad$ $\quad$  折中方法：虚电路（目前仍然没有公认解决方案）</p><h5 id="Internet架构"><a href="#Internet架构" class="headerlink" title="Internet架构"></a>Internet架构</h5><p>$\quad$  端系统通过本地网络提供商（access ISP）接入Internet<br>$\quad$  本地网络提供商之间也需要相互连接,产生了以恶搞结构极度复杂的当今Internet</p><h6 id="Access-ISP如何建立连接？"><a href="#Access-ISP如何建立连接？" class="headerlink" title="Access ISP如何建立连接？"></a>Access ISP如何建立连接？</h6><p>$\quad$  选择1：两两建立链路：可拓展性问题（O（N^2）链路）<br>$\quad$  选择2：每个Access ISP接入一个全局ISP （ISP之间签署服务协议）<br>$\quad$ $\quad$  单个ISP可能无法满足传输要求，其他全局ISP出现<br>$\quad$ $\quad$  全局ISP之间也需要互连<br>$\quad$ $\quad$  互联网公司也组建自己网络，使得数据中心与用户距离更近，这种网络通常称为CDN</p><p><img src="/../CNP/CN04.png"></p><h3 id="服务：网络的功能，接口，质量"><a href="#服务：网络的功能，接口，质量" class="headerlink" title="服务：网络的功能，接口，质量"></a>服务：网络的功能，接口，质量</h3><p>$\quad$  从应用程序角度：与网络上的其他应用程序交互（发送&#x2F;接收消息）<br>$\quad$  按调用方式：分为“面向连接”和”无连接“两大类<br>$\quad$  按服务质量：可靠性，性能，安全<br>$\quad$  服务由一组可用于用户进程以访问服务的原语（操作）形式指定<br>$\quad$  原语告诉服务执行某些操作或报告对等实体所采取的操作<br>$\quad$  六个核心服务原语：<br><img src="/../CNP/CN05.png"></p><h6 id="面向连接的网络服务"><a href="#面向连接的网络服务" class="headerlink" title="面向连接的网络服务"></a>面向连接的网络服务</h6><p>$\quad$  传输数据之前，先建立对话链接</p><h6 id="无连接的网络服务"><a href="#无连接的网络服务" class="headerlink" title="无连接的网络服务"></a>无连接的网络服务</h6><p>$\quad$  数据传输前不需要事先建立连接<br>$\quad$  传输过程不需要应答</p><h4 id="网络服务的性能指标"><a href="#网络服务的性能指标" class="headerlink" title="网络服务的性能指标"></a>网络服务的性能指标</h4><h5 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h5><p>$\quad$  网络中某通道传输数据的能力，即单位时间内网络的某信道所能通过的最高数据率<br>$\quad$  单位是bit&#x2F;s，也可以写为bps</p><h5 id="包转发率"><a href="#包转发率" class="headerlink" title="包转发率"></a>包转发率</h5><p>$\quad$  全称是Packet Per Second，表示交换机或路由器等网络设备以包为单位的转发速率<br>$\quad$  线速转发：交换机在满负荷的情况下，对帧进行转发时能够达到该端口线路的最高速度（在交换机上，大包更容易实现线速）</p><h5 id="比特率（bit-rate）"><a href="#比特率（bit-rate）" class="headerlink" title="比特率（bit rate）"></a>比特率（bit rate）</h5><p>$\quad$  单位时间内，主机往数据信道上传输数据的数据量，也称为数据率或传输速率，单位是bps</p><h5 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h5><p>$\quad$  单位时间内，通过某个网络位置（或信道，接口）的数据量，单位是bps<br>$\quad$  有效吞吐量：正确地接收到的有用信息的数目，单位bps</p><h5 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h5><p>$\quad$  信道利用率指出某信道百分之几的时间是被利用的<br>$\quad$  网络利用率是全网络的信道利用率的加权平均<br><img src="/../CNP/CN06.png"></p><h5 id="丢包率"><a href="#丢包率" class="headerlink" title="丢包率"></a>丢包率</h5><p>$\quad$  所丢失的数据包的数量占所发送数据包的比率</p><h5 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h5><p>$\quad$  时延是指数据（一个报文或分组）从网络(或链路)的一端传送到另一端所需的时间，也称为延迟</p><h6 id="传输时延"><a href="#传输时延" class="headerlink" title="传输时延"></a>传输时延</h6><p>$\quad$  数据从结点进入到传输媒体所需要的时间，又称为发送时延（与设备有关）</p><h6 id="传播时延"><a href="#传播时延" class="headerlink" title="传播时延"></a>传播时延</h6><p>$\quad$  电磁波在信道中需要传输一定距离而花费的时间（与介质有关)</p><h6 id="处理时延"><a href="#处理时延" class="headerlink" title="处理时延"></a>处理时延</h6><p>$\quad$  主机或路由器在收到分组时，为处理分组（如分析首部，提取数据，差错校验或查找路由）所花费的时间（与设备有关）</p><h6 id="排队时延"><a href="#排队时延" class="headerlink" title="排队时延"></a>排队时延</h6><p>$\quad$  分组在路由器输入输出队列中排队等待处理所经历的时延<br>$\quad$  最不确定因素：L&#x3D;AxW （L：平均队列长度，A平均到达速率，W平均等待时间，A和W相对困难得到）</p><h6 id="总时延"><a href="#总时延" class="headerlink" title="总时延"></a>总时延</h6><p>$\quad$  通用方法：将一个大问题分解成多个小问题<br>$\quad$  总时延&#x3D;传输时延+传播时延+处理时延+排队时延<br><img src="/../CNP/CN07.png"><br>$\quad$  优化：设计专用芯片，开发系统系统模块（处理+传输），光纤等（排队+传播）</p><h6 id="往返时延-RTT"><a href="#往返时延-RTT" class="headerlink" title="往返时延 RTT"></a>往返时延 RTT</h6><p>$\quad$  从发送方发送数据开始，到发送方收到来自接收方的确认经历的总时间<br>$\quad$  可用于判断网络的通断性，测试网络时延，计算数据丢包率（PING）</p><h6 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h6><p>$\quad$  时延带宽积&#x3D;传播时延x带宽<br>$\quad$  若发送端连续发送数据，则在发送的第一个bit即将达到终点时，发送端就已经发送了时延带宽积个bit，而这些bit都在链路上向前移动</p><h6 id="时延抖动"><a href="#时延抖动" class="headerlink" title="时延抖动"></a>时延抖动</h6><p>$\quad$  变化的时延称为抖动<br>$\quad$  起源于网络中的个队列或缓冲，难以精确预测<br>$\quad$  在语音，视频多媒体业务中，抖动往往会严重影响用户的体验</p><h5 id="延迟丢包"><a href="#延迟丢包" class="headerlink" title="延迟丢包"></a>延迟丢包</h5><p>$\quad$  在多媒体应用中，由于数据包延迟到达，在接收端需要丢弃失去使用价值的包</p><h5 id="其他指标"><a href="#其他指标" class="headerlink" title="其他指标"></a>其他指标</h5><p>$\quad$  可靠性：发送的每个消息，接收方收到一次且仅收到一次<br>$\quad$  完整性：发送的数据无法篡改<br>$\quad$  隐私性：数据不被第三方截获（有时包含发送方身份不暴露）<br>$\quad$  可审计性：可追溯用户的传输行为</p><h3 id="协议：通信的内容"><a href="#协议：通信的内容" class="headerlink" title="协议：通信的内容"></a>协议：通信的内容</h3><p>$\quad$  网络协议：为进行网络中的数据交换而建立的规则、标准或规定<br>$\quad$  通信双方需要共同遵守，相互理解<br>$\quad$  发送方：发送某个消息时，应满足特定条件<br>$\quad$  接收方：收到某个消息后，要完成特定的工作<br>$\quad$  三要素:<br>$\quad$ $\quad$  语法：规定传输数据的格式<br>$\quad$ $\quad$  语义：规定所要完成的功能<br>$\quad$ $\quad$  时序：规定各种操作的顺序<br>$\quad$  设计目的：表明身份，可靠性，资源分配，拥塞问题，自适应性，安全问题<br>$\quad$  通信双方要说的事情多种多样，导致网络协议异常复杂</p><h4 id="协议封装"><a href="#协议封装" class="headerlink" title="协议封装"></a>协议封装</h4><p>$\quad$  网络协议以头部封装的形式定义<br>$\quad$  每个协议定义自己头部信息，数据被封装为协议载荷<br>$\quad$  头部定义了如何处理分组<br><img src="/../CNP/CN08.png"></p><h3 id="网络实现与管理"><a href="#网络实现与管理" class="headerlink" title="网络实现与管理"></a>网络实现与管理</h3><p>$\quad$  将网络分为多个层次，每层提供功能与服务保障，层与层之间有接口调用，同层实体通过该层协议进行对话，屏蔽各层实现细节<br><img src="/../CNP/CN09.png"></p><p>$\quad$  统一标准，模块独立<br>$\quad$  分层的好处：降低复杂度，增加灵活性<br>$\quad$  坏处：引入额外开销，跨层信息有时候也很重要</p><h4 id="计算机网络中的经典分层"><a href="#计算机网络中的经典分层" class="headerlink" title="计算机网络中的经典分层"></a>计算机网络中的经典分层</h4><p><img src="/../CNP/CN010.png"></p><h5 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h5><h6 id="物理层（Physical-Layer）"><a href="#物理层（Physical-Layer）" class="headerlink" title="物理层（Physical Layer）"></a>物理层（Physical Layer）</h6><p>$\quad$  定义如何在信道上传输0，1<br>$\quad$  机械接口：网线接口大小，形状，线缆排列等<br>$\quad$  电子信号：电压、电流等<br>$\quad$  时序接口：采样频率，波特率，比特率等<br>$\quad$  介质：各种线缆，无线频谱等</p><h6 id="数据链路层-Data-Link-Layer"><a href="#数据链路层-Data-Link-Layer" class="headerlink" title="数据链路层 (Data Link Layer)"></a>数据链路层 (Data Link Layer)</h6><p>$\quad$ •实现相邻（Neighboring）网络实体间的数据传输<br>$\quad$ •成帧（Framing）：从物理层的比特流中提取出完整的帧<br>$\quad$ •错误检测与纠正：为提供可靠数据通信提供可能<br>$\quad$ •物理地址（MAC address）：48位，理论上唯一网络标识，烧录在网卡，不便更改<br>$\quad$ •共享信道上的访问控制（MAC）：同一个信道，同时传输信号。<br>$\quad$ •流量控制，避免“淹没”（overwhelming）:当快速的发送端遇上慢速的接收端，接收端缓存溢出</p><h6 id="网络层-Network-Layer"><a href="#网络层-Network-Layer" class="headerlink" title="网络层 (Network Layer)"></a>网络层 (Network Layer)</h6><p>$\quad$ •将数据包跨越网络从源设备发送到目的设备（host to host）<br>$\quad$ •路由（Routing）：在网络中选取从源端到目的端转发路径，常常会根据网络可达性动态选取最佳路径，也可以使用静态路由<br>$\quad$ •路由协议：路由器之间交互路由信息所遵循的协议规范，使得单个路由器能够获取网络的可达性等信息<br>$\quad$ •服务质量（QoS）控制：处理网络拥塞、负载均衡、准入控制、保障延迟<br>$\quad$ •异构网络互联：在异构编址和异构网络中路由寻址和转发</p><h6 id="传输层-Transport-Layer"><a href="#传输层-Transport-Layer" class="headerlink" title="传输层 (Transport Layer)"></a>传输层 (Transport Layer)</h6><p>$\quad$ •将数据从源端口发送到目的端口（进程到进程）<br>$\quad$ •网络层定位到一台主机（host），传输层的作用域具体到主机上的某一个进程<br>$\quad$ •网络层的控制主要面向运营商，传输层为终端用户提供端到端的数据传输控制<br>$\quad$ •两类模式：可靠的传输模式，或不可靠传输模式<br>$\quad$ •可靠传输：可靠的端到端数据传输，适合于对通信质量有要求的应用场景，如文件传输等<br>$\quad$ •不可靠传输：更快捷、更轻量的端到端数据传输，适合于对通信质量要求不高，对通信响应速度要求高的应用场景，如语音对话、视频会议等</p><h6 id="会话层-Session-Layer"><a href="#会话层-Session-Layer" class="headerlink" title="会话层 (Session Layer)"></a>会话层 (Session Layer)</h6><p>$\quad$ •利用传输层提供的服务，在应用程序之间建立和维持会话，并能使会话获得同步</p><h6 id="表示层（Presentation-Layer）"><a href="#表示层（Presentation-Layer）" class="headerlink" title="表示层（Presentation Layer）"></a>表示层（Presentation Layer）</h6><p>$\quad$ •关注所传递信息的语法和语义，管理数据的表示方法，传输的数据结构</p><h6 id="应用层（Application-Layer）"><a href="#应用层（Application-Layer）" class="headerlink" title="应用层（Application Layer）"></a>应用层（Application Layer）</h6><p>$\quad$ •通过应用层协议，提供应用程序便捷的网络服务调用</p><h5 id="TCP-x2F-IP参考模型"><a href="#TCP-x2F-IP参考模型" class="headerlink" title="TCP&#x2F;IP参考模型"></a>TCP&#x2F;IP参考模型</h5><p>$\quad$  ARPNET  最终采用TCP和IP为主要协议<br>$\quad$  先有TCP&#x2F;IP协议栈，然后有TCP&#x2F;IP参考模型，参考模型只是用来描述协议栈的</p><h6 id="网络接口层（Host-to-network-Layer）"><a href="#网络接口层（Host-to-network-Layer）" class="headerlink" title="网络接口层（Host-to-network Layer）"></a>网络接口层（Host-to-network Layer）</h6><p>$\quad$  描述了为满足无连接的互联网络层需求，单跳链路必须具备的功能</p><h6 id="互联网层（Internet-Layer）"><a href="#互联网层（Internet-Layer）" class="headerlink" title="互联网层（Internet Layer）"></a>互联网层（Internet Layer）</h6><p>$\quad$  通过多跳连接，将数据包独立的传输至目的地，并定义了数据包格式和协议（IPv4协议和IPv6协议）</p><h6 id="传输层（Transport-Layer）"><a href="#传输层（Transport-Layer）" class="headerlink" title="传输层（Transport Layer）"></a>传输层（Transport Layer）</h6><p>$\quad$  允许源主机与目标主机上的对等实体，进行端到端的数据传输：TCP，UDP</p><h6 id="应用层（Application-Layer）-1"><a href="#应用层（Application-Layer）-1" class="headerlink" title="应用层（Application Layer）"></a>应用层（Application Layer）</h6><p>$\quad$  传输层之上的所有高层协议：DNS、HTTP、FTP、SMTP…</p><h5 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h5><p><img src="/../CNP/CN011.png"><br>$\quad$  网络分层没有对与错，只有是否符合需要</p><h4 id="接口与协议的关系"><a href="#接口与协议的关系" class="headerlink" title="接口与协议的关系"></a>接口与协议的关系</h4><p>$\quad$   协议是“水平”的，接口是“垂直”的<br>$\quad$  实体使用协议来实现其定义的接口<br>$\quad$  上层实体通过接口调用下层实体<br><img src="/../CNP/CN013.png"><br>$\quad$  发送端层层封装头部数据，接收端：层层解封装头部数据</p><h4 id="网络分层的实现"><a href="#网络分层的实现" class="headerlink" title="网络分层的实现"></a>网络分层的实现</h4><p>$\quad$ 端系统：实现所有分层(用户程序运行在端系统，比特流进入系统，要一直传输给用户程序)<br>$\quad$ 边缘网与网络核心：实现第一层到第三层功能<br>$\quad$ $\quad$ 交换机：物理层与数据链路层功能<br>$\quad$ $\quad$ 路由器：实现前三层功能<br>$\quad$ $\quad$ 传统路由器支持多跳传输，传统交互机不支持多跳传输，现代路由器和交换机已经不做区分</p><h6 id="特征1-复杂系统由端系统实现"><a href="#特征1-复杂系统由端系统实现" class="headerlink" title="特征1:复杂系统由端系统实现"></a>特征1:复杂系统由端系统实现</h6><p>$\quad$ 兵器电话系统中“笨终端，聪明网络”的设计思路<br>$\quad$ 端对端原则：采用”聪明终端，简单网络“，用端系统负责丢失恢复等复杂共功能<br>$\quad$ 实现了建立在简单的，不可靠部件上的可靠系统<br>$\quad$ 好处：简单的网络大大提升了可拓展性</p><h6 id="特征2：以IP协议为核心"><a href="#特征2：以IP协议为核心" class="headerlink" title="特征2：以IP协议为核心"></a>特征2：以IP协议为核心</h6><p>$\quad$ 可在各种底层物理网络上运行<br>$\quad$ 支持各类上层应用<br>$\quad$ 好处：IP分组独立处理，网络核心功能简单，适应爆炸性增长；容易实现多个网络互连（只要都支持IP）；屏蔽上层应用与底层通信</p><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>CN</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FMCW点云与深度学习</title>
    <link href="/2023/09/13/FMCW%20%E7%82%B9%E4%BA%91%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/09/13/FMCW%20%E7%82%B9%E4%BA%91%E4%B8%8E%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>对毫米波雷达采集到的点云进行处理</p><span id="more"></span><h3 id="人体定位"><a href="#人体定位" class="headerlink" title="人体定位"></a>人体定位</h3><p>利用速度对人体进行定位，利用微动（胸部呼吸心跳）对高度进行定位</p><h4 id="CFAR"><a href="#CFAR" class="headerlink" title="CFAR"></a>CFAR</h4><p>自适应阈值方法<br>通过区分出速度为0的个体分离出人体。</p><h3 id="坐标校准"><a href="#坐标校准" class="headerlink" title="坐标校准"></a>坐标校准</h3><p>小车运动利用SLAM得到世界坐标系下的直线，与雷达坐标系下的直线，求解出旋转矩阵</p><h4 id="SVD"><a href="#SVD" class="headerlink" title="SVD"></a>SVD</h4>]]></content>
    
    
    <categories>
      
      <category>CS科研</category>
      
      <category>FMCW</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FMCW</tag>
      
      <tag>ai</tag>
      
      <tag>deep</tag>
      
      <tag>learning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FMCW测距测速测角</title>
    <link href="/2023/09/12/FMCW%20%E6%B5%8B%E8%B7%9D%E6%B5%8B%E9%80%9F%E6%B5%8B%E8%A7%92/"/>
    <url>/2023/09/12/FMCW%20%E6%B5%8B%E8%B7%9D%E6%B5%8B%E9%80%9F%E6%B5%8B%E8%A7%92/</url>
    
    <content type="html"><![CDATA[<p>利用毫米波雷达测距测速测角度</p><span id="more"></span><h4 id="距离测量"><a href="#距离测量" class="headerlink" title="距离测量"></a>距离测量</h4><h5 id="距离计算"><a href="#距离计算" class="headerlink" title="距离计算"></a>距离计算</h5><p>$\quad$ 由于中频信号是一余弦信号，因此对中频信号做傅立叶变换（FFT）即可得到频率和相位。需要注意，在此处均是对一个chirp周期T内的中频信号做处理，由于周期T很短，可将一个周期内的时间t称为快时间（Fast Time）。根据傅立叶变换的性质，对一个中频信号s(t)做FFT，可以得到一列复数。每个复数对应于一个频率分量，其幅值和相位分别代表该频率分量的振幅和相位<br><img src="/../FMCWmg/F3.png"></p><blockquote><p>$R&#x3D;(c&#x2F;2k )f_b &#x3D;f_b(cT&#x2F;2B)$ </p></blockquote><h6 id="相关参数"><a href="#相关参数" class="headerlink" title="相关参数"></a>相关参数</h6><p>$\quad$ (a).距离分辨率。距离分辨率的意义是，仅当两个物体的距离大于分辨率$\Delta$R 时，他们才能在距离谱上被分辨出来。假设FMCW雷达的ADC采样率为$F_s$ ，对周期T的chirp信号做FFT，则FFT的频率分辨率为$\Delta f_b&#x3D;1&#x2F;T$ 。根据测距公式得到测距的分辨率为：$\Delta R &#x3D;cT&#x2F;(2B) \Delta f_b$ &#x3D;c&#x2F;2B .  可见距离分辨率仅与雷达信号的带宽.<br>$\quad$(b).测距精度。测距精度的意义是：一个物体距离测量的准确度，并不等同于雷达的距离分辨率。在雷达测距的实际应用中，测距精度是评定雷达和算法性能的重要指标。主要有两种方法提高测距精度：一是提高雷达接收机的ADC采样率，即以更多的采样点数采样中频信号，从而更好地估计周期性不完整的中频信号频率；二是在做FFT时应用补零或插值的方法。<br>$\quad$ (c).理论最远可测距离。根据采样定理，当雷达的采样率为$F_s$ 时，FFT可测的最大频率为$f_{max}&#x3D;F_s&#x2F;2$ 。因此，根据测距公式，雷达的理论最远可测距离为：$R_{max} &#x3D; cTF_s&#x2F;4B$ 与一个chirp的周期、带宽和系统采样率有关。假定雷达的采样率可以无限大，为了采样带宽为B的chirp信号，根据采样定理，采样率至少为2B，则此时最远可测距离为cT&#x2F;2。</p><p>$\quad$ (d).实际最远可测距离。在实际应用中，雷达的实际最远可测距离往往无法达到理论值，这是因为对于一些较远的物体，中频信号的振幅很小，使得信号的信噪比很低，导致物体无法被检测到。<br><img src="/../FMCWmg/F4.png"></p><h5 id="距离计算代码"><a href="#距离计算代码" class="headerlink" title="距离计算代码"></a>距离计算代码</h5><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs m">function [fft_data_all_frames] <span class="hljs-built_in">=</span> readRawDataAnd1DFFT(file_name, frame_num)<br><br>global N_CHIRP;<br><br>global RX_NUM;<br><br>global FFTR_SIZE;<br><br>global FRAME_SIZE;<br><br>global TX_NUM;<br><br>global RANGE_RESERVED_DOTS;<br><br>global FFTV_SIZE;<br><br>global CHIRPS_PER_FRAME;<br><br>global TX_ENABLE;<br><br>global RX_ENABLE;<br><br><span class="hljs-comment">%参数定义</span><br><br><span class="hljs-comment">% 包括N_CHIRP（每个Frame里chrip数）、RX_NUM（接收通道数）、FFTR_SIZE（FFT点数:每个chrip数据量）、FRAME_SIZE（每帧的样本数）、TX_NUM（发送通道数）、RANGE_RESERVED_DOTS（保留的距离向量长度）、FFTV_SIZE（FFT点数*速度点数）、CHIRPS_PER_FRAME（每帧的扫频数）、TX_ENABLE（启用的发送通道数）、RX_ENABLE（启用的接收通道数）。</span><br><br>file <span class="hljs-built_in">=</span> fopen(file_name);<span class="hljs-comment">%打开文件</span><br><br><span class="hljs-comment">% disp(&#x27;begin read&#x27;)</span><br><br>raw_data_array <span class="hljs-built_in">=</span> fread(file,<span class="hljs-string">&#x27;short=&gt;short&#x27;</span>);<br><br><span class="hljs-comment">%short=&gt;short 是source=&gt;output,raw_data_array意为原始数据向量</span><br><br><span class="hljs-comment">% disp(&#x27;finish read&#x27;)</span><br><br>raw_data_array <span class="hljs-built_in">=</span> single(raw_data_array);<br><br><span class="hljs-comment">% disp(&#x27;finish convert to single&#x27;)</span><br><br>raw_data_array <span class="hljs-built_in">=</span> raw_data_array / <span class="hljs-number">4</span>;<br><br>raw_data_array <span class="hljs-built_in">=</span> raw_data_array(<span class="hljs-number">1</span>:frame_num*FRAME_SIZE/<span class="hljs-number">2</span>);<br><br>raw_data_array <span class="hljs-built_in">=</span> reshape(raw_data_array, [FFTR_SIZE, RX_NUM * N_CHIRP * frame_num]);<br><br><span class="hljs-comment">%转为单精度浮点并缩放</span><br><br><span class="hljs-comment">% disp(&#x27;begin fft&#x27;)</span><br><br>window <span class="hljs-built_in">=</span> hamming(FFTR_SIZE);<br><br>raw_data_array <span class="hljs-built_in">=</span> raw_data_array .* window;<br><br>raw_data_array <span class="hljs-built_in">=</span> fft(raw_data_array);<br><br><span class="hljs-comment">% disp(&#x27;finish fft&#x27;)</span><br><br><span class="hljs-comment">% data_array_fft = data_array_fft(1:(RANGE_RESERVED_DOTS+1),:);</span><br><br><span class="hljs-comment">% data_array_fft = reshape(data_array_fft,[RANGE_RESERVED_DOTS+1, RX_NUM, N_CHIRP, frame_num]);</span><br><br>raw_data_array <span class="hljs-built_in">=</span> reshape(raw_data_array,[FFTR_SIZE, RX_NUM, N_CHIRP, frame_num]);<br><br>raw_data_array <span class="hljs-built_in">=</span> permute(raw_data_array, [<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]);<br><br><span class="hljs-comment">%这些行将FFT数据重塑为一个大小为frame_num * RX_NUM * N_CHIRP * FFTR_SIZE的数组，并对维度进行重新排列。</span><br><br><span class="hljs-comment">% disp(&#x27;begin TX&#x27;)</span><br><br>fft_data_all_frames <span class="hljs-built_in">=</span> zeros(frame_num,TX_NUM,CHIRPS_PER_FRAME,RX_NUM,RANGE_RESERVED_DOTS+<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;single&#x27;</span>);<br><br>for i <span class="hljs-built_in">=</span> <span class="hljs-number">1</span>:TX_NUM<br><br>fft_data_all_frames(:,i,:,:,:) <span class="hljs-built_in">=</span> raw_data_array(:, i:TX_NUM:N_CHIRP, :, <span class="hljs-number">1</span>:RANGE_RESERVED_DOTS+<span class="hljs-number">1</span>);<br><br>end<br><br><span class="hljs-comment">% disp(&#x27;finish TX&#x27;)</span><br><br>fft_data_all_frames <span class="hljs-built_in">=</span> permute(fft_data_all_frames,[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>]);<br><br>disp(<span class="hljs-string">&#x27;finish read and 1d FFT&#x27;</span>)<br><br>end<br><br></code></pre></td></tr></table></figure><p>$\quad$ 实际距离谱：<br><img src="/../FMCWmg/F5.png"></p><h4 id="速度测量"><a href="#速度测量" class="headerlink" title="速度测量"></a>速度测量</h4><h5 id="速度计算"><a href="#速度计算" class="headerlink" title="速度计算"></a>速度计算</h5><p>$\quad$ 物体速度是距离变化的体现，因此在获得了距离计算方法后可以进一步计算物体的运动速度<br>$\quad$ （1）距离谱法。在获得了距离谱之后，一个很直观的计算物体运动速度的方法是，对于慢时间的多个chirp<br>$\quad$ （2）相位改变法:基于相位的微小运动计算方法，计算步骤为：<br>$\quad$ $\quad$ a. 随着慢时间的改变共有N个chirp被发送，对每个chirp做傅立叶变换得到N个距离谱。由于物体位置变化远小于距离分辨率，因此计算得到的N个距离谱相同。<br>$\quad$ $\quad$ b. 在每个距离谱上均可以观察到该物体，选定该物体的距离域，对N个chirp中该物体的距离域均取相位，可以得到N个相位值。<br>$\quad$ $\quad$ c. 对这N个相位值取解绕，得到连续的相位变化。<br>$\quad$ $\quad$ d. 根据公式换算得到物体连续的距离变化。<br><img src="/../FMCWmg/F6.png"><br>$\quad$ $\quad$ (3).2Dfft 法<br>$\quad$ 可以选择连续的多个chirp计算相位变化。考虑$T_{tot}$时间（如0.01s）内连续的N个（如10个）chirp，先做FFT得到N个距离谱。在$T_{tot}$时间内物体距离的改变不超过一个距离域，因此这些距离谱中该物体对应的距离域相同。根据前文分析，任意两个chirp之间，该距离域的相位改变均为$\Delta \psi &#x3D; 4\pi f_c vT_c&#x2F;c$ ，因此在全部N个距离谱中该物体对应距离域的复数以为此为角速度在复平面上转动。进而，对于这一列复数做FFT，可以得到一个新的能量分布谱。对应物体速度为</p><blockquote><p>$v&#x3D;\varpi c &#x2F;(4 \pi f_c T_c)$<br><img src="/../FMCWmg/F0.png"></p></blockquote><h6 id="相关参数："><a href="#相关参数：" class="headerlink" title="相关参数："></a>相关参数：</h6><p>$\quad$ （a）速度测量的分辨率。由于共有N&#x3D;$T_{tot}&#x2F;T_c$ 个chrip，则FFT时共有N个采样点，则频率分辨率为$\Delta \varpi &#x3D; 2\pi&#x2F;N$ ，根据测速公式,速度分辨率计算为<br>$\Delta v &#x3D; \Delta \varpi c &#x2F;(4 \pi f_c T_c)&#x3D;c&#x2F;(2F_cT_{tot})$<br>$\quad$ （b）最大可测速度。考虑相邻两个chirp，即$T_c$ 内，一个向量最多只能旋转$\pm \pi$ ，否则会在FFT出现歧义，根据测速公式，最大可测速度为：$|v_{max}|&#x3D;c&#x2F;(4f_cT_c)$ </p><h5 id="速度计算代码"><a href="#速度计算代码" class="headerlink" title="速度计算代码"></a>速度计算代码</h5><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs m">fft_data_all_frames_static_elimi <span class="hljs-built_in">=</span> fft_data_all_frames - mean(fft_data_all_frames,<span class="hljs-number">4</span>);<br><br>fft2D_data_all_frames <span class="hljs-built_in">=</span> fftshift(fft(fft_data_all_frames_static_elimi,[],<span class="hljs-number">4</span>),<span class="hljs-number">4</span>);<br><br><span class="hljs-comment">%从每个帧中减去所有帧的平均值并作二维傅里叶变换， fftshift(X) 将零频分量移动到数组中心重新排列fft</span><br><br>figure();<br><br>frame_data <span class="hljs-built_in">=</span> double(squeeze(fft2D_data_all_frames(<span class="hljs-number">130</span>,:,:,:,:))); <span class="hljs-comment">% frame_index needs to be assigned a suitable value</span><br><br>rd_map <span class="hljs-built_in">=</span> squeeze(abs(frame_data(FOCUS_TX,FOCUS_RX,:,:))).<span class="hljs-string">&#x27;;%这行代码计算了距离-多普勒图。</span><br><span class="hljs-string"></span><br><span class="hljs-string">s_rd = mesh(velocity_seq,distance_seq,rd_map / max(max(rd_map)));</span><br><span class="hljs-string"></span><br><span class="hljs-string">axis([-5.2083 5.2083 0 11.2957] ); % The line needs to be adjusted according to the parameters or deleted</span><br><span class="hljs-string"></span><br><span class="hljs-string">view(2);</span><br><span class="hljs-string"></span><br><span class="hljs-string">s_rd.FaceColor = &#x27;</span>flat<span class="hljs-string">&#x27;;</span><br><span class="hljs-string"></span><br><span class="hljs-string">xlabel(&#x27;</span>Velocity(m/s)<span class="hljs-string">&#x27;)</span><br><span class="hljs-string"></span><br><span class="hljs-string">ylabel(&#x27;</span>Range(m)<span class="hljs-string">&#x27;)</span><br><span class="hljs-string"></span><br><span class="hljs-string">set(gca,&#x27;</span>FontName<span class="hljs-string">&#x27;,&#x27;</span>Helvetica<span class="hljs-string">&#x27;,&quot;FontSize&quot;,18);</span><br><span class="hljs-string"></span><br><span class="hljs-string">c_res = colorbar;</span><br><span class="hljs-string"></span><br><span class="hljs-string">c_res.Label.String = &#x27;</span>Normalized power<span class="hljs-string">&#x27;;</span><br><span class="hljs-string"></span><br><span class="hljs-string">c_res.Label.FontSize = 16;</span><br><span class="hljs-string"></span><br><span class="hljs-string">title(&quot;range-doppler spectrum&quot;)</span><br></code></pre></td></tr></table></figure><p>$\quad$ 实际速度谱：<br><img src="/../FMCWmg/F7.png"></p><h4 id="角度测量"><a href="#角度测量" class="headerlink" title="角度测量"></a>角度测量</h4><h5 id="角度计算"><a href="#角度计算" class="headerlink" title="角度计算"></a>角度计算</h5><p>$\quad$ <strong>普遍</strong>：<br><img src="/../FMCWmg/F10.png"><br>$\quad$ 距离为r，角度为$\theta$ ，雷达两个接收天线之间的距离为d。此时，信号经物体反射到达天线1和天线2的时延分别为$\tau_1 &#x3D; 2R&#x2F;c$ 和 $\tau_2 &#x3D; ( 2R+ \Delta R )&#x2F;c$ ,其中$\Delta R &#x3D; d sin\theta$ 为该信号到达两个天线的路径差.对物体所在的距离域分别取相位并计算两根天线的相位差为$\Delta \psi &#x3D; 2\pi d sin \theta &#x2F; \lambda$ ，则物体的角度可以计算为：</p><blockquote><p>$\theta &#x3D; arcsin(\lambda \Delta \psi&#x2F;(2 \pi d))$ </p></blockquote><p>$\quad$ <strong>3DFFT</strong><br>$\quad$ 为了区分速度和距离均相同的物体，需要增加天线数量。假设有M根等距离分布的天线，则相邻两根天线上同一物体导致的相位差是相同的，为∆φ&#x3D;2π∆R&#x2F;λ&#x3D;2πdsinθ&#x2F;λ，因此在全部M个速度谱中该物体对应速度域的复数以2πdsinθ&#x2F;λ  rad&#x2F;1为角速度在复平面上转动。如果此速度域存在多个物体，则该速度域为多个旋转复数的叠加。因此，对这一系列速度域做FFT可以计算出这两个旋转复数的频率，从而换算对应物体的角度。<br><img src="/../FMCWmg/F11.png"><br>$\quad$ <strong>DBF</strong>(数字波束成形)<br>$\qquad$ 1维<br><img src="/../FMCWmg/F12.png"><br>$\qquad$ 2维：<br><img src="/../FMCWmg/F13.png"></p><h5 id="角度计算代码"><a href="#角度计算代码" class="headerlink" title="角度计算代码"></a>角度计算代码</h5><figure class="highlight m"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs m">search_range<span class="hljs-built_in">=</span> [-<span class="hljs-number">90</span>:<span class="hljs-number">0.01</span>:<span class="hljs-number">90</span>];<br><br>tx1<span class="hljs-built_in">=</span>squeeze(fft_data_all_frames(<span class="hljs-number">8</span>,<span class="hljs-number">1</span>,:,<span class="hljs-number">1</span>,<span class="hljs-number">25</span>));<br><br>tx4<span class="hljs-built_in">=</span> squeeze(fft_data_all_frames(<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,:,<span class="hljs-number">1</span>,<span class="hljs-number">25</span>));<br><br>signal_in<span class="hljs-built_in">=</span>[tx1;tx4]; <span class="hljs-comment">%取出不同天线阵列对应的物体的信号向量并转化为信号向量数组</span><br><br>Wave_length <span class="hljs-built_in">=</span> <span class="hljs-number">3</span>e8/fc;<br><br>att_array<span class="hljs-built_in">=</span><span class="hljs-number">0</span>:<span class="hljs-number">7</span> ;<br><br>att_array<span class="hljs-built_in">=</span>att_array*Wave_length/<span class="hljs-number">2</span>;<br><br>[spectrum,doas] <span class="hljs-built_in">=</span> dbf(signal_in,att_array,fc,<span class="hljs-number">1</span>,search_range);<br><br>figure();<br><br>plot(-search_range,spectrum/<span class="hljs-number">10</span>);<br><br>disp(doas);<br><br>function [spectrum,doas] <span class="hljs-built_in">=</span> dbf(signal_in,antenna_array,fc,numOfSignal,search_range)<br><br><span class="hljs-comment">% 参数：输入信号signal_in、天线阵列antenna_array、中心频率fc、信号数量numOfSignal和搜索范围search_range</span><br><br>c <span class="hljs-built_in">=</span> <span class="hljs-number">3</span>e8;<br><br>signal_in <span class="hljs-built_in">=</span> reshape(signal_in,[],<span class="hljs-number">1</span>);<br><br>antenna_array <span class="hljs-built_in">=</span> reshape(antenna_array,<span class="hljs-number">1</span>,[]);<br><br>wave_length <span class="hljs-built_in">=</span> c / fc;<br><br><span class="hljs-comment">% 将输入信号signal_in和天线阵列antenna_array进行reshape操作，使其变为列向量和行向量。然后，根据光速c和中心频率fc计算波长wave_length</span><br><br>angle <span class="hljs-built_in">=</span> search_range / <span class="hljs-number">180</span> * pi;<br><br>angle <span class="hljs-built_in">=</span> reshape(angle,[],<span class="hljs-number">1</span>);<br><br>phase_shift_matrix <span class="hljs-built_in">=</span> exp(-<span class="hljs-number">1</span>i * <span class="hljs-number">2</span> * pi / wave_length * sin(angle) * antenna_array);<br><br><span class="hljs-comment">% 将搜索范围search_range转换为弧度，并将其reshape为列向量。然后，计算相移矩阵</span><br><br>spectrum <span class="hljs-built_in">=</span> abs(phase_shift_matrix*signal_in);<br><br><span class="hljs-comment">% find object in spectrum</span><br><br>[pks, locs] <span class="hljs-built_in">=</span> findpeaks(spectrum);<br><br><span class="hljs-comment">%在spectrum中找到峰值pks和对应的位置locs。将峰值按降序排序，选取前numOfSignal个峰值的位置max_index。</span><br><br>[~, pos] <span class="hljs-built_in">=</span> sort(pks,<span class="hljs-string">&#x27;descend&#x27;</span>);<br><br>max_index <span class="hljs-built_in">=</span> locs(pos(<span class="hljs-number">1</span>:numOfSignal));<br><br><span class="hljs-comment">% 最后，根据位置max_index在搜索范围search_range中找到对应的方向角doas。</span><br><br>doas <span class="hljs-built_in">=</span> search_range(max_index);<br><br><span class="hljs-comment">% % end</span><br>二位只需要把输入改成二位输入二维遍历即可<br></code></pre></td></tr></table></figure><h2 id="quad-一维测角角度谱-quad-二维测角角度谱："><a href="#quad-一维测角角度谱-quad-二维测角角度谱：" class="headerlink" title="$\quad$ 一维测角角度谱$\quad$ 二维测角角度谱："></a>$\quad$ 一维测角角度谱<br><img src="/../FMCWmg/F8.png"><br>$\quad$ 二维测角角度谱：<br><img src="/../FMCWmg/F9.png"></h2>]]></content>
    
    
    <categories>
      
      <category>CS科研</category>
      
      <category>FMCW</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FMCW</tag>
      
      <tag>测量</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FMCW基础</title>
    <link href="/2023/09/11/FMCW%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/09/11/FMCW%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>毫米波雷达基础知识</p><span id="more"></span><h1 id="FMCW基础"><a href="#FMCW基础" class="headerlink" title="FMCW基础"></a>FMCW基础</h1><h5 id="FMCW-雷达"><a href="#FMCW-雷达" class="headerlink" title="FMCW 雷达"></a>FMCW 雷达</h5><p>$\quad$ CW雷达不能提供距离信息的原因是缺乏一种能够计算距离的时延测量方法。利用脉冲进行测距是通过从发射脉冲和回波之间的时延计算来实现的，因此，可以通过诸如锯齿、三角形等的频率调制信号来实现两者的组合。<br>$\quad$ 一种最简单的频率调制波形是锯齿波信号，即频率随时间线性增加的信号。每个chirp的基本参数为起始频率$f_c$ ，带宽B和周期T。如图展示了回波和发送信号的时延关系。由于一个chirp的频率随时间变化，因此可以计算发送信号与反射回波信号的时延，从而计算物体的距离。这是使用FMCW雷达测距的基本思想。<br><img src="/../FMCWmg/F2.png"></p><h5 id="FMCW-雷达构成"><a href="#FMCW-雷达构成" class="headerlink" title="FMCW 雷达构成"></a>FMCW 雷达构成</h5><p><img src="/../FMCWmg/F1.png"></p><p>$\quad$ 一个FMCW雷达的基本结构主要由四部分组成：FM信号发生器(1)、发送天线(2)、接收天线(3)和混频器(4)。</p><p> $\quad$$\quad$ FM信号发生器生成调频信号（锯齿波或者三角波）</p><p>$\quad$ $\quad$ 混频器的输入分别是信号发生器和接收信号，<br>$\quad$ 混频器将发送信号和接受信号进行混频从而生成中频信号，输出一个频率为两个输入信号频率之差、相位也为两个输入信号相位之差的信号</p><blockquote><p>$x_{output}&#x3D;|x_1 (t)∙x_2 (t)|_{LPF}&#x3D;sin⁡[(ω_1-ω_2 )t+(φ_1-φ_2 )]$ </p></blockquote><h5 id="FMCW-信号收发流程："><a href="#FMCW-信号收发流程：" class="headerlink" title="FMCW 信号收发流程："></a>FMCW 信号收发流程：</h5><p>$\quad$（1）FM信号发生器生成调频信号（锯齿波或者三角波），该信号被分为相同的两路，其中一路连接混频器，另一路连接到发送天线；<br>$\quad$（2）发送天线向环境中发送信号；<br>$\quad$（3）信号在环境中沿不同路径传播，遇到物体后被反射回到雷达并被接收天线捕获。接收天线将接收信号发送到混频器；<br>$\quad$（4）混频器将发送信号和接受信号进行混频从而生成中频（Intermediate Frequency， IF）信号。<br>$\quad$基于以上FMCW雷达信号收发的流程，可以给出FMCW雷达收发信号的数学表达式：<br>$\quad$$\quad$（1）FM信号发生器生成连续的锯齿（chirp）波，设每个chirp的起始频率为$f_c$，周期为T，则该FMCW雷达发送的信号波长为$\lambda&#x3D;c&#x2F;T$ ，chirp斜率为$k&#x3D;B&#x2F;T$，其中c是光速。该信号每个chirp内的频率为$f_t&#x3D;f_c+kt$ ，相位为：$u(t)&#x3D;2\pi \int_0^t f(t)dt &#x3D; 2\pi (f_ct+\pi t^2&#x2F;2)$ ，则每个chirp时间内发送信号的表达式为：$x_{tx}(t) &#x3D;A cos (\mu (t))&#x3D;Acos(2 \pi (f_ct+kt^2&#x2F;2))$<br>$\quad$$\quad$(2）发送天线将以上信号发送，信号在空间中沿不同路径传播，并在遇到物体后被反射，回到雷达。为了简化推导而又不失一般性，假设环境中只有一个反射物体，其到雷达到距离为R<br>$\quad$$\quad$(3）反射信号到达接收天线，由于该反射信号在空间中传播的距离为2R，因此其传播时延为$\tau&#x3D;2R&#x2F;c$ ，则接收信号为：$x_{rx}(t)&#x3D;Bcos(\mu(t-\tau))$<br>$\quad$$\quad$ (4）混频器将接收信号与发送信号混频得到中频信号。中频信号的表达式为:$s(t)&#x3D;A’cos(2\pi (f_c\tau +k\tau t-k\tau ^2&#x2F;2)$ 其中，A’是中频信号的信号强度，与发送信号的强度、反射物体的性质、接收天线的增益等参数有关。由于$k\tau ^2&#x2F;2$ 项与为一高阶小量，因此可以忽略，则中频信号的最终表达式为：$s(t)&#x3D;A’cos(2\pi f_b t+\psi_b)$<br>$\quad$$\quad$假设空间中存在m个反射物体且每个物体的造成的信号时延为$\tau_m$ 则雷达的中频信号为：$s(t)&#x3D;\sum^M_{m&#x3D;1}A_m’(2\pi k \tau _m t+f_c\tau _m)$    </p><hr>]]></content>
    
    
    <categories>
      
      <category>CS科研</category>
      
      <category>FMCW</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FMCW</tag>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机组成与体系结构</title>
    <link href="/2023/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <url>/2023/06/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E4%B8%8E%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>北京大学计算机组成与体系结构总复习<br> 参考教材COD（计算机组成与设计-硬件&#x2F;软件接口）</p><span id="more"></span><h1 id="计算机组成与体系结构"><a href="#计算机组成与体系结构" class="headerlink" title="计算机组成与体系结构"></a>计算机组成与体系结构</h1><h2 id="线下内容"><a href="#线下内容" class="headerlink" title="线下内容"></a>线下内容</h2><h3 id="1-课程概述"><a href="#1-课程概述" class="headerlink" title="1-课程概述"></a><a href="https://aki-yzh.github.io/2023/03/19/1-%E8%AF%BE%E7%A8%8B%E6%A6%82%E8%BF%B0/">1-课程概述</a></h3><p>$\quad$ 世界上第一台电子计算机：ENIAC<br>$\quad$ 现代电子计算机之父：冯·诺伊曼</p><p>$\quad$ EDVAC：存储程序计算机<br>$\quad$ $\quad$ 特点：由五个基本部分组成（运算器，存储器，控制器，输入设备，输出设备）；指令和数据采用二进制，极大简化了逻辑线路；实现了存储程序概念，大幅提升任务效率。<br>$\quad$ 计算机的主要类别：<br>$\quad$ $\quad$ 1. 大型计算机<br>$\quad$ $\quad$ $\quad$ 强调高速输入与输出，海量存储空间和并行事务处理<br>$\quad$ $\quad$ $\quad$ 以面向大容量数据的事务处理为主，兼顾科学计算<br>$\quad$ $\quad$ 2.  超级计算机<br>$\quad$ $\quad$ $\quad$ 运算速度最快、性能最高、技术最复杂，代表该时期处理能力巅峰<br>$\quad$ $\quad$ $\quad$ 用于高度密集型的科学计算<br>$\quad$ $\quad$ $\quad$ 500强大部分分布于美国，中国，日本，主体为Intel x86架构，处理器主要为Intel，加速器主要为NVIDIA<br>$\quad$ $\quad$ 3. 小型计算机<br>$\quad$ $\quad$ $\quad$ 涉及事务处理和科学计算，逐渐被服务器替代<br>$\quad$ $\quad$ 4.  微型计算机<br>$\quad$ $\quad$ $\quad$ 以CPU为中央处理单元，主要以个人计算机和微控制器的形式出现。<br>$\quad$ $\quad$ $\quad$ 用于个人用途和仪器仪表</p><h3 id="2-计算机基本结构"><a href="#2-计算机基本结构" class="headerlink" title="2-计算机基本结构"></a><a href="https://aki-yzh.github.io/2023/03/19/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/">2-计算机基本结构</a></h3><p>$\quad$ 冯诺依曼结构的特点：<br>$\quad$ $\quad$ 1.  计算机由运算器（CA）、控制器（CC），存储器（M）、输入设备（I）和输出设备（O）五部分组成。<br>$\quad$ $\quad$ 2. 数据和程序均以二进制编码形式不加区别地存放在存储器中，存放位置由存储器的地址制定。<br>$\quad$ $\quad$ 3. 计算机在工作时能自动地从存储器中取出指令加以执行。<br>$\quad$  实现中，CC和CA对应CPU，M对应主存，I&#x2F;O对应外接设备，R（外部记录设备）对应硬盘</p><p>$\quad$ 指令运行的步骤：取指、译码，执行，访存</p><p> $\quad$ Intel 8086 （IA-16）<br> $\quad$ $\quad$ 特点：<br>$\quad$ $\quad$ $\quad$  1. 内部通用寄存器为16位<br> $\quad$ $\quad$ $\quad$ 2. 对外有16根数据线和20根地址线，可寻址的内存空间为1MByte<br> $\quad$ $\quad$ $\quad$ 3. 物理地址的形成采用“段加偏移”的方式<br> $\quad$  Intel 80386（IA-32）<br> $\quad$ $\quad$ 特点：<br> $\quad$ $\quad$ $\quad$ 1. 第一款32位微处理器<br> $\quad$ $\quad$ $\quad$ 2. 地址总线扩展到32位，可寻址4GB的内存空间<br> $\quad$ $\quad$ $\quad$ 3. 改进了“保护模式”<br> $\quad$ $\quad$ $\quad$ 4. 增加了“虚拟8086模式”</p><p> $\quad$ 寻址<br><img src="/../txmg/tx0001.png"><br> $\quad$ 指令指针寄存器：IP<br>  $\quad$ $\quad$ 保存一个内存地址，指向当前需要取出的指令<br>$\quad$  $\quad$   当CPU从内存中取出一个指令后，IP会自动增加指向下一个指令地址，程序员不能直接对IP进行存取操作，转移指令、过程调用&#x2F;返回指令等会改变IP的内容。<br> $\quad$ 段寄存器：CS（代码段），DS（数据段），ES（附加段），SS（堆栈段）。（FS，GS）<br>  $\quad$ $\quad$ 地址生成：段加偏移：物理地址&#x3D;段基值 X 16+偏移量（X16在16进制下即为左移1位）<br>   $\quad$  $\quad$ 开始时要把DS，SS，SP赋初值<br>  <img src="/../txmg/tx0002.png"><br>  汇编语言：<br> $\quad$  $\quad$ Intel格式：<br>  $\quad$  $\quad$  $\quad$ 寄存器和立即数没有前缀，整数有后缀<br>   $\quad$  $\quad$  $\quad$ 第一个是目的操作数，第二个是源操作数<br>   $\quad$  $\quad$  $\quad$ 基寄存器用【】<br>$\quad$ $\quad$ $\quad$ $\quad$ 间接寻址segreg【base+index x scale+disp】<br>  $\quad$  $\quad$ AT&amp;T格式：<br>   $\quad$  $\quad$  $\quad$ 寄存器使用前缀%，立即数使用前缀 “$” ,16进制数还要有前缀0x<br>  $\quad$  $\quad$  $\quad$ 第一个是源操作数，第二个是目的操作数<br>   $\quad$  $\quad$  $\quad$ 基寄存器用（）<br>   $\quad$ $\quad$ $\quad$ 间接寻址%segreg：disp（base，index，scale）<br>   $\quad$ $\quad$ $\quad$ 操作码带后缀以指出操作数的大小</p><h3 id="3-CISC-RISC-X86-MIPS指令"><a href="#3-CISC-RISC-X86-MIPS指令" class="headerlink" title="3-CISC,RISC,X86,MIPS指令"></a><a href="https://aki-yzh.github.io/2023/03/19/3-CISC,X86,RISC,MIPS%E6%8C%87%E4%BB%A4/">3-CISC,RISC,X86,MIPS指令</a></h3><p>$\quad$ CISC和RISC差别：<br>$\quad$ $\quad$ CISC指令丰富、功能强大、寻址方式灵活，但是指令使用率不均衡、结构复杂<br>$\quad$ $\quad$ RISC结构简单易于设计、指令精简程序执行效率高，但是指令数较少且寻址方式不灵活。</p><p>$\quad$ X86指令：变长<br>$\quad$ $\quad$ 最长指令15字节，最短指令1字节<br><img src="/../txmg/tx0003.png"><br><img src="/../txmg/tx0010.png"><br><img src="/../txmg/tx0009.png"><br><img src="/../txmg/tx0008.png"><br><img src="/../txmg/tx0007.png"><br><img src="/../txmg/tx0006.png"><br><img src="/../txmg/tx0005.png"><br><img src="/../txmg/tx0004.png"><br>$\quad$ MIPS<br>$\quad$ $\quad$ 减少指令类型，降低指令复杂度，属于上述的AT&amp;T格式<br>$\quad$ $\quad$ 指令定长（简化了从存储器取指令）、寻址模式简单（只有load和store可以访问存储器：简化了从存储器取操作数）、指令数量少、功能简单（简化了指令的执行过程)<br><img src="/../txmg/tx0011.png"><br>$\quad$ R型指令<br>$\quad$ $\quad$ opcode：用于指定指令的类型，对于所有R型指，该域的值均为0<br>$\quad$$\quad$  funct：与opcode域结合，精确指定指令的类型<br>$\quad$ $\quad$ rs（Source Register）：指定第一个源操作数所在的寄存器编号<br>$\quad$ $\quad$ rt（Target Register）：指定第二个源操作数所在的寄存器编号<br>$\quad$ $\quad$ rd（Destination Register）：指定目的操作数（保存运算结果）的寄存器编号<br>$\quad$ $\quad$ shamt（shift amount）：用于指定移位指令进行移位操作的位数，非移位指令设为0<br>$\quad$ $\quad$ 5-bit的域可表示0~31，对应32个通用寄存器<br>$\quad$ I型指令<br>$\quad$ $\quad$ 大部分域与R指令相同<br>$\quad$  $\quad$ opcode：用于指定指令的类型<br>$\quad$ $\quad$ rs：指定第一个源操作数所在的寄存器编号<br>$\quad$ $\quad$ rt：一般指定用于目的操作数的寄存器编号；对于某些指令指定第二个源操作数所在的寄存器编号<br>$\quad$ $\quad$ immediate：16-bit的立即数，可以表示$2^{16}$ 个不同数值</p><h3 id="4-数字电路设计"><a href="#4-数字电路设计" class="headerlink" title="4-数字电路设计"></a><a href="https://aki-yzh.github.io/2023/03/30/4-%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/">4-数字电路设计</a></h3><p><img src="/../txmg/tx0013.png"><br>$\quad$ NMOS晶体管：Gate为高电压时导通<br>$\quad$ PMOS晶体管：Gate为低电压时导通<br><img src="/../txmg/tx0012.png"><br><img src="/../txmg/tx0014.png"><br><img src="/../txmg/tx0015.png"><br><img src="/../txmg/tx0016.png"><br><img src="/../txmg/tx0019.png"><br><img src="/../txmg/tx0018.png"><br><img src="/../txmg/tx0017.png"></p><h3 id="5-控制器的原理和分类"><a href="#5-控制器的原理和分类" class="headerlink" title="5-控制器的原理和分类"></a><a href="https://aki-yzh.github.io/2023/05/01/5-%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%88%86%E7%B1%BB/">5-控制器的原理和分类</a></h3><p>$\quad$ 主要分为硬布线控制器和微程序控制器<br>$\quad$ $\quad$ 硬布线控制器用逻辑表达式来控制信号<br>$\quad$ $\quad$ $\quad$ 优点：指令执行速度快<br>$\quad$ $\quad$ $\quad$ 缺点：电路复杂，设计和验证难度大，修改困难<br><img src="/../txmg/tx0021.png"><br>$\quad$ $\quad$ 微程序控制器用微指令控制信号，发出为1，不发为0<br>$\quad$ $\quad$ $\quad$ 优点：规整灵活<br>$\quad$ $\quad$ $\quad$ 缺点：速度较慢<br><img src="/../txmg/tx0020.png"></p><h3 id="6-流水线优化技术"><a href="#6-流水线优化技术" class="headerlink" title="6-流水线优化技术"></a><a href="https://aki-yzh.github.io/2023/05/01/6-%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF/">6-流水线优化技术</a></h3><p>$\quad$ 五级流水线：取指——译码——地址生成——执行——写回(现在是4发射16级流水线)<br>$\quad$ 转移指令：改变指令流向，破坏流水模式<br>$\quad$ $\quad$ 占比：每4～7条指令就有一条转移指令，所占比例大约为15～25%<br>$\quad$ $\quad$ 损失：Alpha：7个，Pentium：10～15，AMD：10；<br>$\quad$ $\quad$ 总损失等于占比x损失<br>$\quad$ 转移开销：<br>$\quad$ $\quad$ 当转移指令被执行，并确实发生转移时，产生的开销称为“转移开销”，如将按顺序预取的指令废除，从 转移目标地址重新获取指令。<br>$\quad$ $\quad$ 构成：要不要转移（转移条件判定）？转移到哪里？（生成目标地址）<br>$\quad$ $\quad$ 减少开销：<br>$\quad$ $\quad$ $\quad$ 转移延迟<br>$\quad$ $\quad$ $\quad$ 转移预测：<br>$\quad$ $\quad$ $\quad$ $\quad$ 转移条件预测：固定预测、编译制导、基于偏移预测，基于历史信息预测（普遍采用）<br><img src="/../txmg/tx0021%201.png"><br>$\quad$ $\quad$ $\quad$ $\quad$ 转移地址预测:<br>$\quad$ $\quad$ $\quad$ $\quad$ $\quad$ BTB（转移目标缓冲器）：保存之前若干次转移指令执行时的目标地址。<br><img src="/../txmg/tx602.png"><br>$\quad$ $\quad$ $\quad$ 操作<br>$\quad$ $\quad$ $\quad$ $\quad$ 1. 分配BTB表项：转移目标第一次执行分配一个表项，自身地址保存在转移指令地址，转移目标地址保存在转移目标地址<br>$\quad$ $\quad$ $\quad$ $\quad$ 2. BTB表项比较：将需要预测的指令地址与BTB的转移指令地址进行比较，若命中则被执行过且为转移指令<br>$\quad$ $\quad$ $\quad$ $\quad$ 3. 产生转移目标地址：若命中则读出转移目标地址作为下一条指令地址<br>$\quad$ $\quad$ $\quad$ $\quad$ 4. 更新BTB<br><img src="/../txmg/tx603.png"><br><img src="/../txmg/tx604.png"><br><img src="/../txmg/tx605.png"><br>$\quad$ $\quad$ $\quad$ 返回地址栈：<br>$\quad$ $\quad$ $\quad$ $\quad$ 优点：<br>$\quad$ $\quad$ $\quad$ $\quad$ $\quad$ 1. 无需判定转移条件<br>$\quad$ $\quad$ $\quad$ $\quad$ $\quad$ 2. 转移目标地址已生成<br>$\quad$ $\quad$ $\quad$ $\quad$ $\quad$ 3. 出现可预期<br>$\quad$ $\quad$ $\quad$ $\quad$ 缺点：<br>$\quad$ $\quad$ $\quad$ $\quad$ $\quad$ 1. 同一条指令地址不同<br>$\quad$ $\quad$ $\quad$ $\quad$ $\quad$ 2. 转移目标地址访问时间较长<br>$\quad$ $\quad$ $\quad$ $\quad$ $\quad$ 3. 在流水线晚期才访问存储器获得转移目标地址</p><h3 id="7-输入输出接口"><a href="#7-输入输出接口" class="headerlink" title="7-输入输出接口"></a><a href="https://aki-yzh.github.io/2023/05/10/7-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8E%A5%E5%8F%A3/">7-输入输出接口</a></h3><p>$\quad$ 产生原因：CPU和外设间速度差距，外设处理的信息格式和接口信号形式多样<br>$\quad$ 基本功能：数据缓冲、提供联络信息、信号与信息格式的转换、设备选择、中断管理、可编程功能<br>$\quad$ 基本结构<br><img src="/../txmg/tx0023.png"><br>$\quad$ 两种编址方式：I&#x2F;O和存储器分开编址，I&#x2F;O端口和存储器统一编址<br>$\quad$ $\quad$ 统一编址：优点：1.可以用访问存储器的指令来访问I&#x2F;O端口，功能齐全2.可以将CPU中的I&#x2F;O操作设为同一套控制逻辑，简化内部结构；缺点：1. 使得存储地址相对减小2.指令更长，使得执行时间变长，译码不方便，指令更难理解<br>$\quad$ $\quad$ 分开编址：反过来即可<br>$\quad$ 简单外设字节0～7bit连接，复杂外设增加握手信号（准备好输入输出信号）<br>$\quad$ 数据输入过程：<br>$\quad$ $\quad$ 1. 系统初始化时，CPU执行OUT指令，将控制字写入接口的“控制寄存器”，从而设置接口的工作模式<br>$\quad$ $\quad$ 2. 外设将数据发到“并行数据输入”信号，并将“输入准备好”信号置为有效<br>$\quad$ $\quad$ 3. 接口发现“输入准备好”信号有效后，从“并行数据输入”信号接收数据，放入“输入缓冲寄存器”，并将“输入回答”信号置为有效，阻止外设输入新数据<br>$\quad$ $\quad$ 4. 接口将状态寄存器中的状态位“输入缓存器满”置为有效<br>$\quad$ $\quad$ 5. 在上述过程中，CPU反复执行IN指令从“状态寄存器“中读出状态字，直到发现”输入缓冲器满“，然后执行IN指令，从“输入缓冲寄存器”中读出数据<br>$\quad$ $\quad$ 6. 接口将“输入回答”信号置为无效，等待外设输入新数据<br> $\quad$ $\quad$ （此为程序控制方式，还可以采用终端控制方式）<br> $\quad$ 数据输出过程：<br>$\quad$  $\quad$ 1. CPU执行OUT指令，将控制字写入接口的“控制寄存器”，从而设置接口的工作模式<br>$\quad$  $\quad$ 2. CPU执行OUT指令，将数据写到接口的“输出缓冲寄存器”<br>$\quad$  $\quad$ 3. 接口将数据发到“并行数据输出”信号，并将“输出准备好”信号置为己有（亦可由CPU写控制字将该信息置为有效）<br>$\quad$  $\quad$ 4. 外设发现“输出准备好信号”后，从“并行数据输出”信号接收数据，并将“输出回答信号”置为有效<br>$\quad$  $\quad$ 5. 接口发现“输出回答”信号有效后，将“状态寄存器”中的状态位“输出缓存器空”置为有效<br>$\quad$  $\quad$ 6. 在这个过程中，CPU反复执行IN指令从“状态寄存”器中读出状态字，直到发现“输出缓冲器空”，然后开始下一个输出过程，继续输出新数据<br>$\quad$  $\quad$ （此为程序控制方式，还可以采用终端控制方式）<br> $\quad$  串&#x2F;并行通信<br>  $\quad$  $\quad$ 串行通信传输线数量少，需要通过复杂的串并转换，同频率下数据传输率低，但是避免了信号线间的窜扰。并行通信反过来。<br>   $\quad$  $\quad$ 差分信号传输时串行兴起的原因，优点是抗干扰能力强，能有效抑制电磁干扰，时序定位准确，缺点是布线难度高。</p><h3 id="8-中断和异常"><a href="#8-中断和异常" class="headerlink" title="8-中断和异常"></a><a href="https://aki-yzh.github.io/2023/05/18/8-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/">8-中断和异常</a></h3><p>$\quad$ 异常处理的起源：UNIAC（1951年）算术运算溢出时，转向地址0执行两条修复指令或者停机<br>$\quad$ 中断处理的起源：DYSEAC（1954年），有两个程序计数器根据I&#x2F;O信号进行切换</p><p>$\quad$ 外部中断优先级：<br>$\quad$ $\quad$ 1. 软件查询确定中断优先级（只需要少量硬件电路）<br>$\quad$ $\quad$ 2. 硬件终端优先级编码电路<br>$\quad$ $\quad$ 3. 可编程中断控制器（如8259A）：管理和控制CPU的外部中断请求，实现中断优先级的判决，为CPU提供中断类型码，选择屏蔽设备的中断请求<br><img src="/../txmg/tx0024.png"><br><img src="/../txmg/tx0025.png"><br>$\quad$ 可编程计数器&#x2F;定时器（8253）<br>$\quad$ $\quad$ 功能灵活使用方便<br><img src="/../txmg/tx812.png"></p><h3 id="9-总线"><a href="#9-总线" class="headerlink" title="9-总线"></a><a href="https://aki-yzh.github.io/2023/05/28/9-%E6%80%BB%E7%BA%BF/">9-总线</a></h3><p>$\quad$ 在多于两个模块（设备或子系统）间传送信息的公共通路<br>$\quad$ 由传输信息的电路和管理信息传输的协议组成<br>$\quad$  分类<br>$\quad$ $\quad$ 片上总线：中央处理器芯片内部的总线<br>$\quad$ $\quad$ 内总线：各插板之间的信息传输的通路<br>$\quad$ $\quad$ 外总线：计算机系统间的通路<br>$\quad$ 译码器：根据当前控制总线的主模块提供的地址，选择作为本次总线传输目标的从模块<br>$\quad$ 仲裁器：在总线上有多个主模块同时请求使用总线时，决定哪个主模块获得控制权<br><img src="/../txmg/tx906.png"><br>$\quad$ 总线标准的内容<br>$\quad$ $\quad$ 1- 机械特性： 规定模块插件的机械尺寸，总线插头、插座的规格及位置等。<br>$\quad$ $\quad$ 2- 电气特性： 规定总线信号的逻辑电平、噪声容限以及负载能力等<br>$\quad$ $\quad$ 3-功能特性：给出各总线信号的名称及功能定义<br>$\quad$ $\quad$ 4-规程特性：对各总线信号的动作过程及时序关系进行说明<br>$\quad$ 总线协议实例：<br>$\quad$ $\quad$ 会画时序图:HREADY两根线表示没关系，低电平表示没好，高电平表示好了</p><h3 id="10-计算机系统先进技术"><a href="#10-计算机系统先进技术" class="headerlink" title="10-计算机系统先进技术"></a><a href="https://aki-yzh.github.io/2023/05/30/10-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%85%88%E8%BF%9B%E6%8A%80%E6%9C%AF/">10-计算机系统先进技术</a></h3><p>$\quad$ 片上总线难以满足需求：长时间等待返回读数据时，大量与此无关的传输无法发起<br>$\quad$ PCI中断方案：1. PCI设备保证在数据到达目的地之后再提交中断请求；（硬件开销大，不容易实现，还会增加中断请求的延时）2. 中端服务程序使用读刷新方法（绝大数处理器采用）<br>$\quad$ MSI中断机制：<br><img src="/../txmg/tx0022.png"><br>$\quad$ $\quad$ 优点：解决了多个设备共享中断信号的问题，解决了每个功能设备只支持一个中断的问题，“异步”中断的数据完整性问题。<br>$\quad$ $\quad$ 缺点：要占用总线带宽</p><h2 id="线上内容"><a href="#线上内容" class="headerlink" title="线上内容"></a>线上内容</h2><p>$\quad$ 加法器：<br>$\quad$ 门延迟：通过一次门电路计为1<br>$\quad$ 关键路径：延迟最长的路径<br>$\quad$ $G_i &#x3D; A_i<em>B_i,P_i&#x3D;A_i+B_i$<br>$\quad$ 由$C_{i+1}&#x3D;G_i+P_i</em>C_i$ 提前计算进位信号，总延迟为4级门延迟<br>$\quad$ 乘法器<br><img src="/../txmg/tx608.png"><br><img src="/../txmg/tx609.png"><br><img src="/../txmg/tx610.png"><br>$\quad$ 除法器：<br><img src="/../txmg/tx611.png"><br><img src="/../txmg/tx612.png"><br><img src="/../txmg/tx613.png"><br><img src="/../txmg/tx0028.png"></p>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>COD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>目录</tag>
      
      <tag>COD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10-计算机系统先进技术</title>
    <link href="/2023/05/30/10-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%85%88%E8%BF%9B%E6%8A%80%E6%9C%AF/"/>
    <url>/2023/05/30/10-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%85%88%E8%BF%9B%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<p> 对应 北京大学计算机组成与体系结构第十讲<br> 参考教材COD（计算机组成与设计-硬件&#x2F;软件接口）</p><span id="more"></span><h1 id="计算机组成与体系结构"><a href="#计算机组成与体系结构" class="headerlink" title="计算机组成与体系结构"></a>计算机组成与体系结构</h1><hr><h2 id="计算机系统先进技术"><a href="#计算机系统先进技术" class="headerlink" title="计算机系统先进技术"></a>计算机系统先进技术</h2><h3 id="片上互连结构"><a href="#片上互连结构" class="headerlink" title="片上互连结构"></a>片上互连结构</h3><p>$\quad$ 未来单个芯片内将集成几百上千处理单元和存储单元</p><h3 id="内存技术的发展"><a href="#内存技术的发展" class="headerlink" title="内存技术的发展"></a>内存技术的发展</h3><p>$\quad$ 更低电压，更低功耗</p><h3 id="中断机制的发展"><a href="#中断机制的发展" class="headerlink" title="中断机制的发展"></a>中断机制的发展</h3><h4 id="PCI"><a href="#PCI" class="headerlink" title="PCI"></a>PCI</h4><p><img src="/../txmg/tx1002.png"><br>$\quad$ 当PCI设备使用DMA方式写存储器时。该设备在最后一个数据离开其发送FIFO时，会认为DMA写操作已经完成。此时这个设备将通过INTx信号通知处理器。但是当处理器收到中断信号时，并不意味着PCI设备已经将数据写入存储器中</p><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><h6 id="1-PCI设备保证在数据到达目的地之后，再提交中断请求"><a href="#1-PCI设备保证在数据到达目的地之后，再提交中断请求" class="headerlink" title="1. PCI设备保证在数据到达目的地之后，再提交中断请求"></a>1. PCI设备保证在数据到达目的地之后，再提交中断请求</h6><p>$\quad$PCI设备无法单纯通过硬件逻辑判断数据什么时候写入到存储器，需要使用“读刷新”的方法。PCI设备在提交中断请求之前，向DMA写的数据区域发出一个读请求，当PCI设备完成这个总线传输后，再向处理器提交中断请求。<br>$\quad$ 该方法硬件开销大，不容易实现，还将增加中断请求的延时</p><h6 id="中断服务程序使用“读刷新”方法"><a href="#中断服务程序使用“读刷新”方法" class="headerlink" title="中断服务程序使用“读刷新”方法"></a>中断服务程序使用“读刷新”方法</h6><p>$\quad$中断服务程序在使用“PCI设备写入存储器”的这些数据之前，对该设备进行读操作。该方法利用PCI总线的传送序规则，从而保证数据写入存储器。<br>$\quad$ 绝大多数处理器系统采用该方法<br>$\quad$<strong>操作</strong>：中断服务程序先读取PCI设备中断状态寄存器，判断中断产生原因后，才对PCI设备写入的数据进行操作<br>$\quad$<strong>作用</strong>：一方面可以获得设备的中断状态，另一方面是保证DMA写的数据最终到达存储器。如果不这样做，就可能产生数据完整性问题</p><h4 id="“异步”中断所带来的数据完整性问题"><a href="#“异步”中断所带来的数据完整性问题" class="headerlink" title="“异步”中断所带来的数据完整性问题"></a>“异步”中断所带来的数据完整性问题</h4><p>$\quad$ <strong>现实情况：</strong><br>$\quad$ $\quad$ 在操作系统中，即便中断服务程序没有先读取PCI设备的寄存器，一般<br>不会出现问题<br>$\quad$ <strong>原因：</strong><br>$\quad$ $\quad$ 在操作系统中，一个PCI设备从提交中断到处理器开始执行设备的中断服务程序，所需时间较长，基本上可以保证此时数据已经写入存储器<br>$\quad$ <strong>隐患：</strong><br>$\quad$ $\quad$ 虽然绝大多数时候不会出错，但是这个驱动程序依然有Bug存在，一旦出错则难以定位</p><h4 id="MSI中断机制"><a href="#MSI中断机制" class="headerlink" title="MSI中断机制"></a>MSI中断机制</h4><p>$\quad$ Message Signaled Interrupt<br>$\quad$ 当设备向一个特殊地址写入时，会向CPU产生一个中断，即MSI中断<br>$\quad$ PCI 2.2中定义了MSI，PCI 3.0中引入MSI-X<br><img src="/../txmg/tx1001.png"></p><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><p>$\quad$ 1. 解决了多个设备共享中中断信号的问题<br>$\quad$ 2. 解决了每个功能设备只能支持一个中断的问题<br>$\quad$ 3. “异步”中断的数据完整性问题</p><h5 id="缺点：要占用总线带宽"><a href="#缺点：要占用总线带宽" class="headerlink" title="缺点：要占用总线带宽"></a>缺点：要占用总线带宽</h5><h3 id="芯片封装技术"><a href="#芯片封装技术" class="headerlink" title="芯片封装技术"></a>芯片封装技术</h3><p>$\quad$ ·引线键合（Wire-bonding）<br>$\quad$ ·倒装片（Flip-chip）<br>$\quad$ ·双列直插式封装DIP(Dual Inline-pin Package)<br>$\quad$ ·薄型小尺寸封装TSOP(Thin Small Outline Package)<br>$\quad$ ·四侧引脚扁平封装QFP(Quad Flat Package)<br>$\quad$ ·引脚网格阵列PGA(Pin Grid Array)<br>$\quad$ ·球栅阵列BGA(Ball Grid Array)</p><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>COD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>COD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9-总线</title>
    <link href="/2023/05/28/9-%E6%80%BB%E7%BA%BF/"/>
    <url>/2023/05/28/9-%E6%80%BB%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<p> 对应 北京大学计算机组成与体系结构第九讲<br> 参考教材COD（计算机组成与设计-硬件&#x2F;软件接口）</p><span id="more"></span><h1 id="计算机组成与体系结构"><a href="#计算机组成与体系结构" class="headerlink" title="计算机组成与体系结构"></a>计算机组成与体系结构</h1><hr><h2 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h2><p>$\quad$ 在多于两个模块（设备或子系统）间传送信息的公共通路<br>$\quad$ 组成：传输信息的电路和管理信息传输的协议</p><h3 id="总线的分类"><a href="#总线的分类" class="headerlink" title="总线的分类"></a>总线的分类</h3><h4 id="1-片总线"><a href="#1-片总线" class="headerlink" title="1. 片总线"></a>1. 片总线</h4><p>$\quad$ 又称器件级总线——”片上总线“，是中央处理器芯片内部的总线</p><h4 id="2-内总线"><a href="#2-内总线" class="headerlink" title="2. 内总线"></a>2. 内总线</h4><p>$\quad$ 又称系统总线或板级总线，是计算机系统各插件版之间信息传输的通路，通常称为微型计算机总线的即指内总线。</p><h4 id="3-外总线"><a href="#3-外总线" class="headerlink" title="3. 外总线"></a>3. 外总线</h4><p>$\quad$ 又称通信总线，是计算机系统之间，或者计算机系统与其他系统之间信息传输的通路</p><h3 id="总线的基本结构"><a href="#总线的基本结构" class="headerlink" title="总线的基本结构"></a>总线的基本结构</h3><p><img src="/../txmg/tx901.png"></p><h4 id="总线模块"><a href="#总线模块" class="headerlink" title="总线模块"></a>总线模块</h4><h5 id="总线主模块（Bus-Master"><a href="#总线主模块（Bus-Master" class="headerlink" title="总线主模块（Bus Master)"></a>总线主模块（Bus Master)</h5><p>$\quad$ 具有总线控制能力，在获得总线控制权之后能启动总线传输（读数据或写数据）<br>$\quad$ 示例： CPU，DMA控制器</p><h5 id="总线从模块-（Bus-Slave）"><a href="#总线从模块-（Bus-Slave）" class="headerlink" title="总线从模块 （Bus Slave）"></a>总线从模块 （Bus Slave）</h5><p>$\quad$ 能够对总线传输作出响应（接收写数据、返回读数据、返回“错误”响应等），但本身不具备总线控制能力<br>$\quad$ 示例：存储器</p><h4 id="总线译码器"><a href="#总线译码器" class="headerlink" title="总线译码器"></a>总线译码器</h4><p>$\quad$ 功能：根据当前控制总线的主模块提供的地址，选择作为本次总线传输目标的从模块<br><img src="/../txmg/tx902.png"></p><h4 id="总线仲裁器"><a href="#总线仲裁器" class="headerlink" title="总线仲裁器"></a>总线仲裁器</h4><p>$\quad$ 功能：在总线上有多个主模块同时请求使用总线时，决定由哪个主模块获得总线控制权<br>$\quad$ 目的：让总线得到合理、高效地使用<br><img src="/../txmg/tx904.png"></p><h4 id="总线示意图"><a href="#总线示意图" class="headerlink" title="总线示意图"></a>总线示意图</h4><p><img src="/../txmg/tx905.png"><br><img src="/../txmg/tx906.png"><br><img src="/../txmg/tx907.png"><br><img src="/../txmg/tx903.png"></p><h3 id="总线协议"><a href="#总线协议" class="headerlink" title="总线协议"></a>总线协议</h3><h4 id="总线标准"><a href="#总线标准" class="headerlink" title="总线标准"></a>总线标准</h4><h5 id="产生途径"><a href="#产生途径" class="headerlink" title="产生途径"></a>产生途径</h5><p><strong>事实标准</strong><br>$\quad$ 计算机系统厂家所采用的一种总线，由于其性能优越，逐渐形 成一种被业界广泛支持和承认的事实总线标准<br><strong>国际标准</strong><br>$\quad$ 在国际标准组织或机构主持下开发和制定的总线标准，公布后由厂家和用户使用</p><h5 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h5><p>$\quad$ <strong>1- 机械特性</strong>： 规定模块插件的机械尺寸，总线插头、插座的规格及位置等。<br>$\quad$ <strong>2- 电气特性</strong>： 规定总线信号的逻辑电平、噪声容限以及负载能力等<br>$\quad$ <strong>3-功能特性</strong>：给出各总线信号的名称及功能定义<br>$\quad$ <strong>4-规程特性</strong>：对各总线信号的动作过程及时序关系进行说明</p><h5 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h5><p><img src="/../txmg/tx908.png"><br>$\quad$ 2000年前后EISA逐渐退出市场</p><h6 id="PCI-Express"><a href="#PCI-Express" class="headerlink" title="PCI Express"></a>PCI Express</h6><p>$\quad$ ◦ 串行方式传输数据，依靠高频率获得高性能<br>$\quad$ ◦ 全双工运作模式，同时进行数据发送和接收<br>$\quad$ ◦ 点对点连接结构，而非传统的共享结构<br>$\quad$ ◦ 使用“端到端的数据传送方式” ，两端都含有TX(发送逻辑)和RX(接收逻辑)<br>$\quad$ ◦ PCIe总线物理层采用差分信号传输<br>$\quad$ $\quad$ $\quad$ 优点：抗干扰能力强，能有效抑制电磁干扰，时序定位准确<br>$\quad$ $\quad$ $\quad$ 缺点：在电路板上，差分信号一定要走 两根等长、等宽、紧密靠近且在 同一层面的线，布线难度高</p><h4 id="协议实例-AMBA"><a href="#协议实例-AMBA" class="headerlink" title="协议实例-AMBA"></a>协议实例-AMBA</h4><p><img src="/../txmg/tx909.png"></p><h5 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h5><p><img src="/../txmg/tx910.png"></p><h5 id="场景一：最简单的传输"><a href="#场景一：最简单的传输" class="headerlink" title="场景一：最简单的传输"></a>场景一：最简单的传输</h5><h6 id="主模块读一个数据"><a href="#主模块读一个数据" class="headerlink" title="主模块读一个数据"></a>主模块读一个数据</h6><p><img src="/../txmg/tx911.png"><br><img src="/../txmg/tx912.png"></p><h6 id="主模块写一个数据"><a href="#主模块写一个数据" class="headerlink" title="主模块写一个数据"></a>主模块写一个数据</h6><p><img src="/../txmg/tx913.png"></p><h6 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h6><p>$\quad$ 1.在第一个时钟上升沿之后，主模块驱动HADDR和 Control信号<br>$\quad$ 2.在第二个时钟上升沿，从模块采样HADDR和Control信 号<br>$\quad$ 3. 在第二个时钟上升沿之后,写传输：主模块驱动HWDATA信号 ;   读传输：从模块驱动HRDATA信号<br>$\quad$ 4. 在第三个时钟上升沿 ,写传输：从模块采样HWDATA信号，完成传输;读传输：主模块采样HRDATA信号，完成传输</p><h5 id="场景二：主模块发起传输时，从模块未准备好"><a href="#场景二：主模块发起传输时，从模块未准备好" class="headerlink" title="场景二：主模块发起传输时，从模块未准备好"></a>场景二：主模块发起传输时，从模块未准备好</h5><p>$\quad$ 从模块无法提供读数据或从模块无法接收写数据<br><img src="/../txmg/tx914.png"><br><img src="/../txmg/tx915.png"></p><h6 id="要点："><a href="#要点：" class="headerlink" title="要点："></a>要点：</h6><p>$\quad$ 从模块可以在传输过程中插入等待周期，以便获得额外的时间 ，如暂存写数据的缓冲已满、读数据未准备好等<br>$\quad$ 在等待周期中，主模块必须保持地址、控制和写数据等信号的稳定。</p><h5 id="场景三：多个连续的传输"><a href="#场景三：多个连续的传输" class="headerlink" title="场景三：多个连续的传输"></a>场景三：多个连续的传输</h5><p>$\quad$ 一个主模块连续发起多个的传输或多个不同的主模块先后发起传输<br><img src="/../txmg/tx916.png"></p><h6 id="要点-1"><a href="#要点-1" class="headerlink" title="要点"></a>要点</h6><p>$\quad$ 1.时间重叠（overlap）<br>$\quad$ $\quad$ ◦ 不同传输的地址和数据在时间上存在重叠<br>$\quad$ $\quad$ ◦ 充分利用地址总线和数据总线<br>$\quad$ 2.等待周期<br>$\quad$ $\quad$ ◦ 地址A和C的传输中没有等待周期<br>$\quad$ $\quad$ ◦ 地址B的传输中有一个等待周期，该传输的数据阶段扩展了一个周期<br>$\quad$ 3.等待周期的副作用<br>$\quad$ $\quad$ ◦ 因为地址B的传输中的等待周期，所以地址C的传输的地址阶段受其影响 而扩展了一个周期</p><h5 id="场景四：大量连续数据的传输"><a href="#场景四：大量连续数据的传输" class="headerlink" title="场景四：大量连续数据的传输"></a>场景四：大量连续数据的传输</h5><p>$\quad$ 一次传输的数据量超过了数据总线的宽度， 例如，CPU需要从内存中读出连续的16字节（128位）的数据，但数据总线宽度为32位<br><img src="/../txmg/tx919.png"><br><img src="/../txmg/tx918.png"><br><img src="/../txmg/tx917.png"><br> $\quad$ BURST传输用于高速缓存的行填充（读）、行替换，外设和主存之间的大量连续数据传输以及主存中不同区域之间的大量连续数据传输</p><h6 id="要点-2"><a href="#要点-2" class="headerlink" title="要点"></a>要点</h6><p> $\quad$ T1 ：传输开始 ， 主模块发出第一个地址 ， 驱 动 HTRANS&#x3D;NONSEQ，HBURST&#x3D;INCR4<br>  $\quad$ T2 ：传输继续 ， 主模块发出第二个地址 ， 驱 动 HTRANS&#x3D;SEQ，保持HBURST&#x3D;INCR4<br> $\quad$ ……<br>$\quad$T6：主模块发出的第四个地址已被从模块采样，无需再 发出新的地址和控制信号，因此驱动HTRANS&#x3D;IDLE  $\quad$ T7：传输完成</p><h5 id="场景五：希望先得到Burst传输中的某个特定数据"><a href="#场景五：希望先得到Burst传输中的某个特定数据" class="headerlink" title="场景五：希望先得到Burst传输中的某个特定数据"></a>场景五：希望先得到Burst传输中的某个特定数据</h5><p><img src="/../txmg/tx920.png"><br><img src="/../txmg/tx921.png"><br><img src="/../txmg/tx922.png"></p><h6 id="要点-3"><a href="#要点-3" class="headerlink" title="要点"></a>要点</h6><p>$\quad$ 地址回卷的边界（假设数据宽度为4字节）<br>$\quad$$\quad$◦ WRAP4：在16的整数倍的地址处回卷（4×4）<br>$\quad$$\quad$◦ WRAP8：在32的整数倍的地址处回卷（4×8）<br>$\quad$$\quad$◦ WRAP16：在64的整数倍的地址处回卷（4×16）<br>$\quad$传输地址变化示例<br>$\quad$$\quad$◦ INCR4： 0x38 0x3C 0x40 0x44<br>$\quad$$\quad$◦ WRAP4：0x38 0x3C 0x30 0x34<br>$\quad$$\quad$◦ INCR4： 0x30 0x34 0x38 0x3C<br>$\quad$$\quad$$\quad$起始地址和访问区域相同</p><h5 id="场景六：在Burst传输的过程中，主模块未准备好"><a href="#场景六：在Burst传输的过程中，主模块未准备好" class="headerlink" title="场景六：在Burst传输的过程中，主模块未准备好"></a>场景六：在Burst传输的过程中，主模块未准备好</h5><p>主模块无法提供写数据 或主模块无法接收读数据<br><img src="/../txmg/tx923.png"><br><img src="/../txmg/tx924.png"></p><h5 id="场景七：需要传输的数据宽度比数据总线的宽度小"><a href="#场景七：需要传输的数据宽度比数据总线的宽度小" class="headerlink" title="场景七：需要传输的数据宽度比数据总线的宽度小"></a>场景七：需要传输的数据宽度比数据总线的宽度小</h5><p>$\quad$ 例如，需要传输1个16位的数据，而数据总线的宽度是32位的<br><img src="/../txmg/tx926.png"><br><img src="/../txmg/tx925.png"><br><img src="/../txmg/tx927.png"></p><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>COD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>COD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8-中断和异常</title>
    <link href="/2023/05/18/8-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/"/>
    <url>/2023/05/18/8-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/</url>
    
    <content type="html"><![CDATA[<p> 对应 北京大学计算机组成与体系结构第八讲<br> 参考教材COD（计算机组成与设计-硬件&#x2F;软件接口）</p><span id="more"></span><h1 id="计算机组成与体系结构"><a href="#计算机组成与体系结构" class="headerlink" title="计算机组成与体系结构"></a>计算机组成与体系结构</h1><hr><h2 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h2><h3 id="中断与异常"><a href="#中断与异常" class="headerlink" title="中断与异常"></a>中断与异常</h3><h4 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h4><p><strong>第一个带有异常处理的系统</strong>： UNIVAC，1951年：算术运算溢出时，转向地址0执行两条修复指令，或者停机。1955年新增外部中断用于风洞数据的实时收集。<br><strong>第一个带有外部中断的系统</strong>： DYSEAC，1954年：有两个程序计数器PC，根据I&#x2F;O信号进行切换。</p><h4 id="CPU遇到的事件"><a href="#CPU遇到的事件" class="headerlink" title="CPU遇到的事件"></a>CPU遇到的事件</h4><p>$\quad$ 在程序运行时，系统外部、内部或现行程序本身出现需要特殊处理的事件，CPU立即强行终止现行程序的运行，改变机器的工作状态并启动相应的程序来处理这些事件，处理完成后，CPU恢复原来的程序运行。这些事件被称为“中断”或者“异常”。</p><h5 id="MIPS-CPU的异常处理"><a href="#MIPS-CPU的异常处理" class="headerlink" title="MIPS CPU的异常处理"></a>MIPS CPU的异常处理</h5><p>$\quad$ 1. 在EPC（异常程序计数器）中保存出现异常的指令的地址（需要减4）<br>$\quad$ 2. 清空流水线中之后的指令<br>$\quad$ 3. 记录产生异常的原因<br>$\quad$ 4. 将控制权转交给操作系统的特定地址，转移到特定地址执行下一条指令</p><h5 id="中断向量"><a href="#中断向量" class="headerlink" title="中断向量"></a>中断向量</h5><p>$\quad$ 中断服务程序的入口地址<br>$\quad$ 每个中断类型对应一个中断向量（4字节），前两个字节单元存放中断服务程序入口地址的偏移量（IP），低字节在前，高字节在后；后两个字节单元存放中断服务程序入口地址的段基值（CS），低字节在前，高字节在后。<br><img src="/../txmg/tx801.png"></p><h6 id="中断的检测"><a href="#中断的检测" class="headerlink" title="中断的检测"></a>中断的检测</h6><p><img src="/../txmg/tx802.png"></p><h6 id="中断向量表"><a href="#中断向量表" class="headerlink" title="中断向量表"></a>中断向量表</h6><p><img src="/../txmg/tx803.png"><br><img src="/../txmg/tx804.png"></p><h3 id="中断控制器"><a href="#中断控制器" class="headerlink" title="中断控制器"></a>中断控制器</h3><p> $\quad$ 外部中断的需求：<br> $\quad$ $\quad$ - 优先级：多个中断请求同时出现，如何确定响应次序？<br> $\quad$ $\quad$ - 屏蔽：可否屏蔽指定I&#x2F;O接口设备的中断请求<br> <img src="/../txmg/tx805.png"></p><h4 id="优先级的确定"><a href="#优先级的确定" class="headerlink" title="优先级的确定"></a>优先级的确定</h4><h5 id="1-软件查询确定中断优先级"><a href="#1-软件查询确定中断优先级" class="headerlink" title="1.软件查询确定中断优先级"></a>1.软件查询确定中断优先级</h5><p>$\quad$ 只需要少量硬件电路<br><img src="/../txmg/tx806.png"><br>$\quad$ 查询程序：一般来说，先查速度较快或者实时性较高的设备，它们优先级较高。<br><img src="/../txmg/tx807.png"></p><h5 id="2-硬件中断优先级编码电路"><a href="#2-硬件中断优先级编码电路" class="headerlink" title="2.硬件中断优先级编码电路"></a>2.硬件中断优先级编码电路</h5><p> $\quad$ 菊花链优先级排队电路：在每个设备接口设置一个简单的逻辑电路，根据优先级顺序来传递或截流CPU发出的中断响应信号，以实现响应中断的顺序。<br> <img src="/../txmg/tx808.png"></p><h5 id="3-可编程中断控制器"><a href="#3-可编程中断控制器" class="headerlink" title="3.可编程中断控制器"></a>3.可编程中断控制器</h5><p>$\quad$ 现代PC机中多采用可编程中断控制器（PIC，高级APIC）来处理中断<br><img src="/../txmg/tx809.png"></p><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><h4 id="计数与定时"><a href="#计数与定时" class="headerlink" title="计数与定时"></a>计数与定时</h4><p>$\quad$ <strong>计数</strong><br>$\quad$ $\quad$ 对外部事件发生的次数进行计量<br>$\quad$ <strong>定时</strong><br>$\quad$ $\quad$ 主要是指产生一段准确的时延<br>$\quad$ $\quad$ 定时是对固定的时间单位进行计数，本质上也是计数，是以计数为基础的</p><h5 id="主要用途"><a href="#主要用途" class="headerlink" title="主要用途"></a>主要用途</h5><p>$\quad$ <strong>计算机系统</strong><br>$\quad$ $\quad$ 提供系统的日时钟<br>$\quad$ $\quad$ 接口电路的工作节拍，信息传送的同步信号<br>$\quad$ $\quad$ 保证在确定时刻完成规定动作<br>$\quad$ $\quad$ 提供时间基准，供操作系统切换进程<br>$\quad$ <strong>工业测控系统</strong><br>$\quad$ $\quad$ 对产品计数，定时进行某些行为<br>$\quad$ <strong>声音&#x2F;音乐</strong><br>$\quad$ $\quad$ 由计数&#x2F;定时的基本功能派生而来</p><h4 id="可编程计数-x2F-定时器"><a href="#可编程计数-x2F-定时器" class="headerlink" title="可编程计数&#x2F;定时器"></a>可编程计数&#x2F;定时器</h4><p>$\quad$ 软硬件相结合的定时计数方法<br>$\quad$ 特点：功能灵活，使用方便</p><h5 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h5><p><img src="/../txmg/tx810.png"><br>$\quad$ CLK:时钟输入信号<br>$\quad$ GATE：门控输入信号，对计数过程进行控制<br>$\quad$ OUT：计数输出信号，“计数到零&#x2F;定时时间到”输出</p><h6 id="方式2-分频器"><a href="#方式2-分频器" class="headerlink" title="方式2:分频器"></a>方式2:分频器</h6><p>$\quad$ 输出波形：每输入N个CLK脉冲，输出宽度为1个CLK周期的负脉冲<br><img src="/../txmg/tx811.png"><br>$\quad$ 触发方式：软件启动，自动重复，周期性输出固定频率的脉冲<br>$\quad$ 用途：脉冲速率发生器<br><strong>DRAM定时刷新</strong><br><img src="/../txmg/tx812.png"><br><img src="/../txmg/tx813.png"></p><h6 id="方式3-方波发生器"><a href="#方式3-方波发生器" class="headerlink" title="方式3:方波发生器"></a>方式3:方波发生器</h6><p>$\quad$ 输出波形：对称方波或基本对称的矩形波<br><img src="/../txmg/tx814.png"><br>$\quad$ 触发方式：软件启动，自动重复，周期性输出固定频率的方波<br>$\quad$ 用途：产生系统时钟，扬声器发声控制<br><img src="/../txmg/tx816.png"><br><img src="/../txmg/tx815.png"></p><h3 id="系统中的中断与定时"><a href="#系统中的中断与定时" class="headerlink" title="系统中的中断与定时"></a>系统中的中断与定时</h3><p><img src="/../txmg/tx818.png"></p><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>COD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>COD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7-输入输出接口</title>
    <link href="/2023/05/10/7-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8E%A5%E5%8F%A3/"/>
    <url>/2023/05/10/7-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<p> 对应 北京大学计算机组成与体系结构第七讲<br> 参考教材COD（计算机组成与设计-硬件&#x2F;软件接口）</p><span id="more"></span><h1 id="计算机组成与体系结构"><a href="#计算机组成与体系结构" class="headerlink" title="计算机组成与体系结构"></a>计算机组成与体系结构</h1><hr><h2 id="输入输出接口"><a href="#输入输出接口" class="headerlink" title="输入输出接口"></a>输入输出接口</h2><p>$\quad$ 第一台微型计算机： Altair 8800</p><h3 id="输入输出接口电路"><a href="#输入输出接口电路" class="headerlink" title="输入输出接口电路"></a>输入输出接口电路</h3><h5 id="I-x2F-O接口的产生原因"><a href="#I-x2F-O接口的产生原因" class="headerlink" title="I&#x2F;O接口的产生原因"></a>I&#x2F;O接口的产生原因</h5><p>$\quad$ 1. CPU和外设之间的速度差距<br>$\quad$ 2. 外设处理的信息格式和接口信号形式多样</p><h5 id="I-x2F-O接口的基本功能"><a href="#I-x2F-O接口的基本功能" class="headerlink" title="I&#x2F;O接口的基本功能"></a>I&#x2F;O接口的基本功能</h5><p>$\quad$ 1. 数据缓冲——解决CPU和外设之间的速度差距<br>$\quad$ 2. 提供联络信息——协调同步数据交换工程<br>$\quad$ 3. 信息和信息格式的转换<br>$\quad$ 4. 设备选择<br>$\quad$ 5. 中断管理<br>$\quad$ 6. 可编程功能</p><h5 id="I-x2F-O接口的基本结构"><a href="#I-x2F-O接口的基本结构" class="headerlink" title="I&#x2F;O接口的基本结构"></a>I&#x2F;O接口的基本结构</h5><p><img src="/../txmg/tx701.png"></p><h3 id="输入和输出的过程"><a href="#输入和输出的过程" class="headerlink" title="输入和输出的过程"></a>输入和输出的过程</h3><h4 id="I-x2F-O端口及其编址方式"><a href="#I-x2F-O端口及其编址方式" class="headerlink" title="I&#x2F;O端口及其编址方式"></a>I&#x2F;O端口及其编址方式</h4><h5 id="I-x2F-O端口"><a href="#I-x2F-O端口" class="headerlink" title="I&#x2F;O端口"></a>I&#x2F;O端口</h5><p>$\quad$ I&#x2F;O接口内部包含一组称为I&#x2F;O端口的寄存器，每个I&#x2F;O端口都需有自己的端口地址（端口号），以便CPU访问。<br>$\quad$ 与复杂外设连接时，握手（handshaking）信号成对出现，定时协调与联络。</p><p><img src="/../txmg/tx704.png"></p><h5 id="I-x2F-O端口编址方式"><a href="#I-x2F-O端口编址方式" class="headerlink" title="I&#x2F;O端口编址方式"></a>I&#x2F;O端口编址方式</h5><h6 id="I-x2F-O端口和存储器分开编址"><a href="#I-x2F-O端口和存储器分开编址" class="headerlink" title="I&#x2F;O端口和存储器分开编址"></a>I&#x2F;O端口和存储器分开编址</h6><p>示例：<br><img src="/../txmg/tx702.png"><br><strong>优点</strong><br>$\quad$ - I&#x2F;O端口不占用存储器地址，不会减少用户的存储器地址空间<br>$\quad$ -  I&#x2F;O指令编码短，执行速度快<br>$\quad$ - I&#x2F;O指令的地址码较短，地址译码方便<br>$\quad$ - 采用单独的I&#x2F;O指令，使程序中的I&#x2F;O操作和其他操作层次清晰便于理解<br><strong>缺点</strong><br>$\quad$ - 内部结构相对复杂，CPU引脚更多<br>$\quad$ - 处理数据相对间接</p><h6 id="I-x2F-O端口和存储器统一编址"><a href="#I-x2F-O端口和存储器统一编址" class="headerlink" title="I&#x2F;O端口和存储器统一编址"></a>I&#x2F;O端口和存储器统一编址</h6><p>示例：<br><img src="/../txmg/tx703.png"><br><strong>优点</strong><br>$\quad$ - 可以用访向存储器的指令来访问I&#x2F;O端口，访问存储器的指令功能比较齐全，可以实现直接对I&#x2F;O端口以内的数据进行处理<br>$\quad$ - 可以将CPU中的I&#x2F;O操作与访问存储器操作统一设计为一套控制逻辑，简化内部结构，同时减少CPU的引脚数目<br><strong>缺点</strong><br>$\quad$ - 由于I&#x2F;O端口占用了一部分存储器地址空间，因而使用户的存储地址空间相对减小<br>$\quad$  - 由于利用访问存储器的指令来进行I&#x2F;O操作指令的长度通常比单独I&#x2F;O指令长，因此指令的执行时间也较长</p><h5 id="I-x2F-O指令说明"><a href="#I-x2F-O指令说明" class="headerlink" title="I&#x2F;O指令说明"></a>I&#x2F;O指令说明</h5><h6 id="IN指令（输入）"><a href="#IN指令（输入）" class="headerlink" title="IN指令（输入）"></a>IN指令（输入）</h6><p>$\quad$ 格式： IN AC，PORT<br>$\quad$ 操作：把外设端口的内容输入到AL或AX</p><h6 id="OUT指令（输出）"><a href="#OUT指令（输出）" class="headerlink" title="OUT指令（输出）"></a>OUT指令（输出）</h6><p>$\quad$ 格式： OUT PORT，AC<br>$\quad$ 操作：把AL或AX的内容输出到外设端口</p><h6 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h6><p>$\quad$ <strong>端口地址为0～255</strong><br>$\quad$ $\quad$ 直接寻址：用一个字节立即数指定端口地址<br>$\quad$ $\quad$ 间接寻址：用DX的内容指定端口地址<br>$\quad$ <strong>端口地址大于255</strong><br>$\quad$ $\quad$ 直接寻址：用DX的内容制定端口地址</p><h4 id="数据输出过程"><a href="#数据输出过程" class="headerlink" title="数据输出过程"></a>数据输出过程</h4><p><img src="/../txmg/tx705.png"></p><p>$\quad$ 1. CPU执行OUT指令，将控制字写入接口的“控制寄存器”，从而设置接口的工作模式<br>$\quad$ 2. CPU执行OUT指令，将数据写到接口的“输出缓冲寄存器”<br>$\quad$ 3. 接口将数据发到“并行数据输出”信号，并将“输出准备好”信号置为己有（亦可由CPU写控制字将该信息置为有效）<br>$\quad$ 4. 外设发现“输出准备好信号”后，从“并行数据输出”信号接收数据，并将“输出回答信号”置为有效<br>$\quad$ 5. 接口发现“输出回答”信号有效后，将“状态寄存器”中的状态位“输出缓存器空”置为有效<br>$\quad$ 6. 在这个过程中，CPU反复执行IN指令从“状态寄存”器中读出状态字，直到发现“输出缓冲器空”，然后开始下一个输出过程，继续输出新数据<br>$\quad$ （此为程序控制方式，还可以采用终端控制方式）</p><h4 id="数据输入过程"><a href="#数据输入过程" class="headerlink" title="数据输入过程"></a>数据输入过程</h4><p> <img src="/../txmg/tx706.png"></p><p>$\quad$ 1. 系统初始化时，CPU执行OUT指令，将控制字写入接口的“控制寄存器”，从而设置接口的工作模式<br>$\quad$ 2. 外设将数据发到“并行数据输入”信号，并将“输入准备好”信号置为有效<br>$\quad$ 3. 接口发现“输入准备好”信号有效后，从“并行数据输入”信号接收数据，放入“输入缓冲寄存器”，并将“输入回答”信号置为有效，阻止外设输入新数据<br>$\quad$ 4. 接口将状态寄存器中的状态位“输入缓存器满”置为有效<br>$\quad$ 5. 在上述过程中，CPU反复执行IN指令从“状态寄存器“中读出状态字，直到发现”输入缓冲器满“，然后执行IN指令，从“输入缓冲寄存器”中读出数据<br>$\quad$ 6. 接口将“输入回答”信号置为无效，等待外设输入新数据<br> $\quad$ （此为程序控制方式，还可以采用终端控制方式）</p><h3 id="串行和并行的比较"><a href="#串行和并行的比较" class="headerlink" title="串行和并行的比较"></a>串行和并行的比较</h3><p>$\quad$ <strong>串行通信</strong>：数据在单条一位宽的传输线上按时间先后一位一位地进行传送<br>$\quad$ <strong>并行通信</strong> ：数据在多位宽的传输线上各位同时进行传送<br>$\quad$ 串口通常指的是RS-232接口（COM接口），并口常指IEEE-1284接口（LPT接口）</p><h5 id="传输线上："><a href="#传输线上：" class="headerlink" title="传输线上："></a>传输线上：</h5><p>$\quad$ 串行传输线数量少，并行传输线数量多<br><img src="/../txmg/tx707.png"></p><h5 id="转换上："><a href="#转换上：" class="headerlink" title="转换上："></a>转换上：</h5><p>$\quad$ 串行通信需要经过复杂的串&#x2F;并转换，并行不需要<br><img src="/../txmg/tx708.png"></p><h5 id="数据传输上："><a href="#数据传输上：" class="headerlink" title="数据传输上："></a>数据传输上：</h5><p>$\quad$ 同频率下，串行通信数据传输率低，并行通信数据传输率高</p><h5 id="串扰上："><a href="#串扰上：" class="headerlink" title="串扰上："></a>串扰上：</h5><p>$\quad$ 串行通信不存在信号线之间的串扰而并行存在</p><h5 id="差分信号传输技术"><a href="#差分信号传输技术" class="headerlink" title="差分信号传输技术"></a>差分信号传输技术</h5><p>$\quad$ 发送端在两根线上发送振幅相等、相位相反的信号，接收端比较两个电压差来判断发送的是0或1<br>$\quad$ <strong>优点</strong><br>$\quad$ $\quad$ 抗干扰能力强<br>$\quad$ $\quad$ 能有效抑制电磁干扰<br>$\quad$ $\quad$ 时序定位准确<br>$\quad$ <strong>缺点</strong><br>$\quad$ $\quad$ 在电路板上，差分信号一定要走两根等长，等宽，紧密靠近且在同一层面的线，布线难度高</p><h3 id="并口芯片的应用实例：可编程并行接口8255A"><a href="#并口芯片的应用实例：可编程并行接口8255A" class="headerlink" title="并口芯片的应用实例：可编程并行接口8255A"></a>并口芯片的应用实例：可编程并行接口8255A</h3><p><img src="/../txmg/tx709.png"></p><h5 id="与外设的连线（24条）"><a href="#与外设的连线（24条）" class="headerlink" title="与外设的连线（24条）"></a>与外设的连线（24条）</h5><p>$\quad$ 端口A，端口B：PA0～7，PB0～7，可分别设定为输入或输出端口<br>$\quad$ 端口C：PC0～7 ：通常不用于普通的数据传送，而是作为A和B的”握手信号“，称为“A组”，“B组”</p><h5 id="与系统总线的连线"><a href="#与系统总线的连线" class="headerlink" title="与系统总线的连线"></a>与系统总线的连线</h5><p>$\quad$ 地址A1，A0：端口选择信号，CS有效时启用<br><img src="/../txmg/tx710.png"></p><h5 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h5><p>$\quad$ 0- 基本输入&#x2F;输出：单向输入&#x2F;输出，无握手信号<br>$\quad$ 1- 选通输入&#x2F;输出：单向输入&#x2F;输出，C用于握手信号<br>$\quad$ 2- 双向传输：双向传输，C用于握手信号</p><h5 id="XLAT指令说明"><a href="#XLAT指令说明" class="headerlink" title="XLAT指令说明"></a>XLAT指令说明</h5><p>$\quad$ 格式：XLAT<br>$\quad$ 操作：（事先定义字节型数据表）<br>$\quad$ $\quad$ 1. 从BX中取得数据表起始地址的偏移量<br>$\quad$ $\quad$ 2. 从AL中取得数据表项索引值<br>$\quad$ $\quad$ 3. 在数据表中查得表项内容<br>$\quad$ $\quad$ 4. 将查得表项内容存入AL</p><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>COD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>COD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6-流水线优化技术</title>
    <link href="/2023/05/01/6-%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF/"/>
    <url>/2023/05/01/6-%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%BC%98%E5%8C%96%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<p> 对应 北京大学计算机组成与体系结构第六讲<br> 参考教材COD（计算机组成与设计-硬件&#x2F;软件接口）</p><span id="more"></span><h1 id="计算机组成与体系结构"><a href="#计算机组成与体系结构" class="headerlink" title="计算机组成与体系结构"></a>计算机组成与体系结构</h1><hr><h2 id="流水线优化技术"><a href="#流水线优化技术" class="headerlink" title="流水线优化技术"></a>流水线优化技术</h2><h3 id="转移指令的影响"><a href="#转移指令的影响" class="headerlink" title="转移指令的影响"></a>转移指令的影响</h3><p><img src="/../txmg/tx601.png"><br>$\quad$ 改变指令流向，破坏流水模式</p><p>$\quad$ 转移指令损失（Branch Penalty）<br>$\qquad$ · Alpha 21264:转移损失平均7个周期<br>$\qquad$ · Pentium III：转移损失平均10～15个周期<br>$\qquad$ · AMD Athlon K7:转移损失10周期以上<br>Pipeline stall cycles from branches &#x3D; Brach Frequency（转移指令占比：10～15%）X Branch Penalty</p><h3 id="转移预测技术"><a href="#转移预测技术" class="headerlink" title="转移预测技术"></a>转移预测技术</h3><h5 id="转移开销："><a href="#转移开销：" class="headerlink" title="转移开销："></a>转移开销：</h5><p>$\quad$ 当转移指令被执行，并确定发生转移时，产生如下的开销：<br>$\qquad$ 1. 将按顺序预取的指令废除（即排空流水线）<br>$\qquad$ 2. 从转移目标地址重新取指令<br>$\quad$ 构成：<br>$\qquad$ 1.要不要转移（判定引起的开销）<br>$\qquad$ 2.转移到哪里（生成目标地址引起的开销）</p><h5 id="转移延迟"><a href="#转移延迟" class="headerlink" title="转移延迟"></a>转移延迟</h5><p>$\quad$ 在编译过程中通过编辑器调度，在转移指令后插入一条或几条适当的指令，当被调度的指令执行完后，目标地址和判断条件已计算完成</p><h5 id="转移预测"><a href="#转移预测" class="headerlink" title="转移预测"></a>转移预测</h5><p>$\quad$ 预测“要不要转移”和“转移到哪里”</p><h6 id="转移条件预测"><a href="#转移条件预测" class="headerlink" title="转移条件预测"></a>转移条件预测</h6><p>$\quad$ <strong>硬件固定预测不转移</strong>：在转移条件判定之前总是顺序地取下一条指令<br>$\quad$ $\quad$ 优点：实现简单；缺点：预测效果不佳<br>$\quad$ <strong>编译制导的预测</strong>：在转移指令的编码中增加一位，编译器通过该位预测，1转移0不转移。<br>$\quad$ $\quad$ 优点：可对不同指令进行不同预测；缺点：需要软件支持和修改ISA，不适应多变的执行环境<br>$\quad$ <strong>基于偏移的预测</strong>：如果相对偏移为负则预测转移<br>$\quad$ <strong>基于历史信息的预测</strong>（普遍采用）：转移与否取决于先前转移指令的执行情况。</p><h6 id="转移目标地址预测"><a href="#转移目标地址预测" class="headerlink" title="转移目标地址预测"></a>转移目标地址预测</h6><p>$\quad$ 转移目标缓冲器BTB（Branch Target Buffer），保存此前若干次转移指令执行时的目标地址<br><img src="/../txmg/tx602.png"></p><p>$\quad$ 基本操作：<br>$\quad$ $\quad$ 1. 分配BTB表项：转移目标第一次执行分配一个表项<br>$\quad$ $\quad$ 2. BTB表项比较：将需要预测的指令地址与BTB的转移指令地址进行比较，若命中则被执行过且为转移指令<br>$\quad$ $\quad$ 3. 产生转移目标地址：<br>$\quad$ $\quad$ 4. 更新BTB</p><p>$\quad$ 比较时机：<br><img src="/../txmg/tx603.png"><br>$\quad$ 工作机制：<br><img src="/../txmg/tx604.png"></p><h3 id="返回地址栈RAS"><a href="#返回地址栈RAS" class="headerlink" title="返回地址栈RAS"></a>返回地址栈RAS</h3><p>$\quad$ 特殊转移指令：过程返回指令RET<br>$\quad$ 专用预测部件：返回地址栈RAS<br><img src="/../txmg/tx605.png"></p><h6 id="指令特点："><a href="#指令特点：" class="headerlink" title="指令特点："></a>指令特点：</h6><p>$\quad$ 优点：<br>$\quad$ $\quad$ 1. 无需判定转移条件<br>$\quad$ $\quad$ 2. 转移目标地址已生成<br>$\quad$ $\quad$ 3. 出现可预期<br>$\quad$ 缺点：<br>$\quad$ $\quad$ 1. 同一条指令地址不同<br>$\quad$ $\quad$ 2. 转移目标地址访问时间较长<br>$\quad$ $\quad$ 3. 在流水线晚期才访问存储器获得转移目标地址</p><h6 id="运行示例："><a href="#运行示例：" class="headerlink" title="运行示例："></a>运行示例：</h6><p><img src="/../txmg/tx607.png"></p><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>COD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>COD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5-控制器的原理和分类</title>
    <link href="/2023/05/01/5-%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%88%86%E7%B1%BB/"/>
    <url>/2023/05/01/5-%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p> 对应 北京大学计算机组成与体系结构第五讲<br> 参考教材COD（计算机组成与设计-硬件&#x2F;软件接口）</p><span id="more"></span><h1 id="计算机组成与体系结构"><a href="#计算机组成与体系结构" class="headerlink" title="计算机组成与体系结构"></a>计算机组成与体系结构</h1><hr><h2 id="控制器的原理与分类"><a href="#控制器的原理与分类" class="headerlink" title="控制器的原理与分类"></a>控制器的原理与分类</h2><h3 id="控制器基本原理"><a href="#控制器基本原理" class="headerlink" title="控制器基本原理"></a>控制器基本原理</h3><p>$\quad$ 基本任务：按照指令每一步操作的需要，发出特定的命令信号<br>$\quad$ 简化控制信号示例：<br><img src="/../txmg/tx501.png"><br>$\quad$ 主要分类：<strong>硬布线控制器</strong>和<strong>微程序控制器</strong></p><h3 id="硬布线控制器"><a href="#硬布线控制器" class="headerlink" title="硬布线控制器"></a>硬布线控制器</h3><p>$\quad$ 也称硬连线控制器或组合逻辑控制器<br>$\quad$ 主要部件：环形脉冲发生器、指令编码器、微命令编码器<br>$\quad$ 原理图：<br><img src="/../txmg/tx502.png"><br>用·表示与，用+表示或，Ti表示第i个机器周期的节拍脉冲信号<br><img src="/../txmg/tx503.png"><br>$\quad$ <strong>优点</strong>：指令执行速度快<br>$\quad$ <strong>缺点</strong>：控制逻辑的电路复杂，设计和验证难度大，扩充和修改困难</p><h3 id="微程序控制器"><a href="#微程序控制器" class="headerlink" title="微程序控制器"></a>微程序控制器</h3><p>$\quad$ 发出信号计为1，不发为0，形成信号序列，称为微指令，一段微程序由多个微指令构成<br>$\quad$ 优点：规整性、灵活性<br>$\quad$ 缺点：速度较慢<br>$\quad$ 编码方式：直接表示法、编码表示法、混合表示法</p><h6 id="直接表示法"><a href="#直接表示法" class="headerlink" title="直接表示法"></a>直接表示法</h6><p>$\quad$ 将每个控制信号都作为微指令中的一位来编码<br>$\quad$ 优点：简单直观，输出直接用于控制<br>$\quad$ 缺点：编码效率低</p><h6 id="编码表示法"><a href="#编码表示法" class="headerlink" title="编码表示法"></a>编码表示法</h6><p>$\quad$ 将微指令代码进行分组编码，将不能同时出现的相斥信号分在一组<br>$\quad$ 优点：减少存储代码量<br>$\quad$ 缺点：增加硬件开销与信号延迟</p><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>COD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>COD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4-数字电路设计</title>
    <link href="/2023/03/30/4-%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/03/30/4-%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p> 对应 北京大学计算机组成与体系结构第四讲<br> 参考教材COD（计算机组成与设计-硬件&#x2F;软件接口）</p><span id="more"></span><h1 id="计算机组成与体系结构"><a href="#计算机组成与体系结构" class="headerlink" title="计算机组成与体系结构"></a>计算机组成与体系结构</h1><hr><h2 id="数字电路设计"><a href="#数字电路设计" class="headerlink" title="数字电路设计"></a>数字电路设计</h2><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><p>$\quad$ 莱布尼茨：二进制<br>$\quad$ 布尔：布尔代数（两个元素（真、假）；三种运算（与、或、非））<br>$\quad$ 香农：开关电路：模拟布尔逻辑运算，形成现代电子计算机的基本思路</p><h4 id="晶体管与门电路"><a href="#晶体管与门电路" class="headerlink" title="晶体管与门电路"></a>晶体管与门电路</h4><p>$\quad$ 现代集成电路通常使用MOS晶体管（Metal-Oxide-Semiconductor）<br>$\quad$ CMOS集成电路（Complementary MOS）：由PMOS和NMOS共同构成的互补型MOS集成电路<br>$\quad$ NMOS晶体管：Gate为高电压时导通<br>$\quad$ PMOS晶体管：Gate为低电压时导通</p><h6 id="非门"><a href="#非门" class="headerlink" title="非门"></a>非门</h6><p><img src="/../txmg/tx41.png"></p><h6 id="与门"><a href="#与门" class="headerlink" title="与门"></a>与门</h6><p><img src="/../txmg/tx42.png"></p><h6 id="或门"><a href="#或门" class="headerlink" title="或门"></a>或门</h6><p><img src="/../txmg/tx43.png"></p><h6 id="异或门"><a href="#异或门" class="headerlink" title="异或门"></a>异或门</h6><p><img src="/../txmg/tx44.png"></p><h6 id="运算的实现"><a href="#运算的实现" class="headerlink" title="运算的实现"></a>运算的实现</h6><p>例：<br><img src="/../txmg/tx45.png"><br>$\quad$ 其他运算同理</p><h6 id="半加器"><a href="#半加器" class="headerlink" title="半加器"></a>半加器</h6><p><img src="/../txmg/tx46.png"></p><h6 id="全加器"><a href="#全加器" class="headerlink" title="全加器"></a>全加器</h6><p><img src="/../txmg/tx47.png"></p><p>减法运算的实现：<br>A-B&#x3D;A+(~B+1)</p><h6 id="多路选择器"><a href="#多路选择器" class="headerlink" title="多路选择器"></a>多路选择器</h6><p><img src="/../txmg/tx48.png"></p><h4 id="时钟和触发器"><a href="#时钟和触发器" class="headerlink" title="时钟和触发器"></a>时钟和触发器</h4><h6 id="D触发器（D-flip-flop，DFF）"><a href="#D触发器（D-flip-flop，DFF）" class="headerlink" title="D触发器（D flip-flop，DFF）"></a>D触发器（D flip-flop，DFF）</h6><p>$\quad$ 具有存储信息能力的基本单元<br>$\quad$ 由若干逻辑门构成，有多种实现方式<br>$\quad$ 主要有一个数据输入，一个数据输出和一个时钟输入<br>$\quad$ 在时钟clock的上升沿（0-&gt;1），采样输入D的值，传送到输出Q，其余时间输出Q的值不变。<br><img src="/../txmg/tx49.png"></p><h6 id="D锁存器："><a href="#D锁存器：" class="headerlink" title="D锁存器："></a>D锁存器：</h6><p><img src="/../txmg/tx410.png"></p><h6 id="SRAM"><a href="#SRAM" class="headerlink" title="SRAM"></a>SRAM</h6><p><img src="/../txmg/tx417.png"><br>$\quad$ 基本存储单元（1 bit）：<br><img src="/../txmg/tx411.png"><br>$\quad$ 写入过程：<br><img src="/../txmg/tx412.png"><br><img src="/../txmg/tx413.png"><br><img src="/../txmg/tx414.png"><br>$\quad$ 读出过程：<br><img src="/../txmg/tx415.png"><br><img src="/../txmg/tx416.png"></p><h4 id="加法器，减法器，乘法器与除法器"><a href="#加法器，减法器，乘法器与除法器" class="headerlink" title="加法器，减法器，乘法器与除法器"></a>加法器，减法器，乘法器与除法器</h4><h5 id="加法器："><a href="#加法器：" class="headerlink" title="加法器："></a>加法器：</h5><h6 id="行波进位加法器"><a href="#行波进位加法器" class="headerlink" title="行波进位加法器"></a>行波进位加法器</h6><p>$\quad$ 多个串联，低位$C_{out}$连接高位$C_{in}$<br>$\quad$ 优点：布局简单，设计方便<br>$\quad$ 缺点：必须等待低位运算完成，延迟时间长<br>$\quad$ 门延迟：通过一次门电路计为1<br>$\quad$ 关键路径：延迟最长的路径</p><h6 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h6><p>$\quad$ $G_i &#x3D; A_i<em>B_i,P_i&#x3D;A_i+B_i$<br>$\quad$ 由$C_{i+1}&#x3D;G_i+P_i</em>C_i$ 提前计算进位信号，总延迟为4级门延迟</p><h5 id="减法器："><a href="#减法器：" class="headerlink" title="减法器："></a>减法器：</h5><p>$\quad$ 同加法器</p><h5 id="乘法器："><a href="#乘法器：" class="headerlink" title="乘法器："></a>乘法器：</h5><h6 id="实现结构："><a href="#实现结构：" class="headerlink" title="实现结构："></a>实现结构：</h6><p><img src="/../txmg/tx608.png"><br><img src="/../txmg/tx609.png"></p><h6 id="优化"><a href="#优化" class="headerlink" title="优化:"></a>优化:</h6><p><img src="/../txmg/tx610.png"></p><h5 id="除法器："><a href="#除法器：" class="headerlink" title="除法器："></a>除法器：</h5><h6 id="实现结构：-1"><a href="#实现结构：-1" class="headerlink" title="实现结构："></a>实现结构：</h6><p><img src="/../txmg/tx611.png"><br><img src="/../txmg/tx612.png"></p><h6 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h6><p><img src="/../txmg/tx613.png"></p><h4 id="集成电路的制造过程"><a href="#集成电路的制造过程" class="headerlink" title="集成电路的制造过程"></a>集成电路的制造过程</h4><p>​<br>第一阶段：硅$\rightarrow$ 硅锭<br>第二阶段：硅锭切割$\rightarrow$ 晶圆<br>第三阶段：光刻胶$\rightarrow$ 光刻<br>第四阶段：溶解光刻胶$\rightarrow$ 蚀刻$\rightarrow$ 清除光刻胶<br>第五阶段：再次光刻$\rightarrow$ 离子注入$\rightarrow$ 清除光刻胶<br>第六阶段：覆盖绝缘体并蚀刻孔洞$\rightarrow$ 电镀$\rightarrow$ 形成铜层<br>第七阶段：抛光$\rightarrow$ 金属层<br>第八阶段：晶圆测试$\rightarrow$ 晶圆切片$\rightarrow$ 丢弃瑕疵内核<br>第九阶段：从晶圆切下单个CPU裸片$\rightarrow$ 封装<br>第十阶段：等级测试$\rightarrow$ 装箱</p><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>COD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>COD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法设计与分析</title>
    <link href="/2023/03/25/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/"/>
    <url>/2023/03/25/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>   北京大学算法设计与分析课程相关算法repo<br>  <span id="more"></span></p><h1 id="引言部分："><a href="#引言部分：" class="headerlink" title="引言部分："></a>引言部分：</h1><p>   算法是有限条指令的序列，算法的时间复杂度是对算法效率的度量<br>   算法的描述：伪代码<img src="/../sfmg/sf0.png"></p><h2 id="算法的数学基础"><a href="#算法的数学基础" class="headerlink" title="算法的数学基础"></a>算法的数学基础</h2><p>   函数渐进的界：<br>   <img src="/../sfmg/sf1.png"><br>   <img src="/../sfmg/sf2.png"><br>   <img src="/../sfmg/sf4.png"><br>   <img src="/../sfmg/sf3.png"><br>   多项式时间的算法：存在多项式p(n)使得算法的时间复杂度为O(p(n))<br>   对数函数：<br>        $log_b n &#x3D; o(n^\alpha),\alpha &gt; 0$ $a^{log_b n } &#x3D; n^{log_b a}$  $log_k n &#x3D; \Theta (log n)$<br>   阶乘：<br>       Stirling公式： $n!&#x3D; \sqrt{2\pi n }(\frac{n}{e})^n(1+\Theta(1&#x2F;n))$<br>       log(n!) &#x3D; $\Theta(nlogn)$<br> 取整函数：<br> <img src="/../sfmg/sf5.png"><br> <img src="/../sfmg/sf6.png"><br> 估算和式上界的方法：<br> <img src="/../sfmg/sf8.png"></p><h2 id="递推方程："><a href="#递推方程：" class="headerlink" title="递推方程："></a>递推方程：</h2><p>$\quad$ 设$序列 a_0,a_1…a_n,…$ 简记为{$a_n$ } ，一个把$a_n与某个a_i$联系起来的等式叫做关于序列的递推方程。<br><img src="/../sfmg/sf9.png"><br>递归树：<br>$\quad$ 结点带杈的二叉树，初始的递归树只有一个结点，它的权标记为W(n),然后不断进行迭代，直到树中不再含有权为函数的结点为止。<br><img src="/../sfmg/sf10.png"></p><p><img src="/../sfmg/sf11.png"></p><h1 id="算法设计"><a href="#算法设计" class="headerlink" title="算法设计:"></a>算法设计:</h1><h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2><p>一般性描述：</p><blockquote><p><strong>Divide-and-Conquer(P)</strong></p><ol><li>if |P| $\leq$ c then S(P)</li><li>divide P into $P_1,P_2···P_k$ </li><li>for i&#x3D;1 to k do </li><li>$\quad$ $y_i$ $\leftarrow$ Divide-and-Conquer( $P_i$ )</li><li>return Merge( $y_1,y_2···y_k$ )</li></ol></blockquote><h3 id="1-二分查找"><a href="#1-二分查找" class="headerlink" title="1.二分查找"></a>1.二分查找</h3><blockquote><p><strong>BinarySearch(T,x)</strong><br>输入：排好序的数组T；数x<br>输出：j</p><ol><li>l  $\leftarrow$  1;r $\leftarrow$ n</li><li>while l $\leq$ r do<br>3.$\quad$ m $\leftarrow$ $\lfloor (l+r)&#x2F;2 \rfloor$<br>4.$\quad$ if T[m]&#x3D;x then return m   &#x2F;&#x2F; x恰好等于中位元素</li><li>$\quad$ else if T[m]&gt; x then r $\leftarrow$ m-1 </li><li>$\quad$ else l $\leftarrow$ m+1</li><li>return 0</li></ol></blockquote><h3 id="2-芯片测试"><a href="#2-芯片测试" class="headerlink" title="2. 芯片测试"></a>2. 芯片测试</h3><blockquote><p><strong>Test(n)</strong><br>输入：n片芯片构成的数组，其中好芯片至少比坏芯片多一片<br>输出：1片好芯片</p><ol><li>k $\leftarrow$ n</li><li>while  k&gt;3  do</li><li>$\quad$ 将芯片分成$\lfloor k&#x2F;2 \rfloor$ 组</li><li>$\quad$ for i&#x3D;1 to $\lfloor k&#x2F;2 \rfloor$ do<br>  $\quad$  $\quad$ if 2片好，任取一片留下<br>$\quad$ $\quad$ else 2片同时丢掉</li><li>$\quad$ k $\leftarrow$ 剩下的芯片数</li><li>if k&#x3D;3<br>then 任取两片芯片测试<br> $\quad$ if  1好1坏，取没测的芯片<br> $\quad$   else  任取一片被测芯片</li><li>if k&#x3D;2 or 1 then 任取一片芯片</li></ol></blockquote><h3 id="3-平面两点最短距离"><a href="#3-平面两点最短距离" class="headerlink" title="3.  平面两点最短距离"></a>3.  平面两点最短距离</h3><blockquote><p><strong>MinDistance（P,X,Y)</strong><br>输入：n个点的集合P，X和Y分别给出P中点的横，纵坐标<br>输出：最近的两个点及距离</p><ol><li>如果P中点数小于等于3，则直接计算其中的最小距离</li><li>排序X，Y</li><li>做垂直线l将P近似划分为大小相等的点集 $P_L和P_R$  , $P_L$  的点在l左边，$P_R$ 的点在l右边</li><li>$MinDistance(P_L,X_L,Y_L);\theta _L&#x3D;P_L中的最小距离$&#x2F;&#x2F;递归计算左半平面最邻近点对</li><li>$MinDistance(P_R,X_R,Y_R);\theta _R&#x3D;P_R中的最小距离$&#x2F;&#x2F;递归计算右半平面最邻近点对</li><li>$\theta \leftarrow min(\theta _L,\theta _R)$ </li><li>对于在线l左边距离$\theta$ 范围内的每一个点，检查l右边是否有点与它的距离小于$\theta$ ,如果存在则将$\theta$ 修改为新值</li></ol></blockquote><h3 id="4-快速排序算法"><a href="#4-快速排序算法" class="headerlink" title="4. 快速排序算法"></a>4. 快速排序算法</h3><blockquote><p><strong>Quicksort(A,p,r)</strong><br>输入：数组A[p..r],1$\leq p \leq r \leq n$<br>输出：从A[p]到A[r]按照递增顺序排好序的数组A</p><ol><li>if p &lt; r</li><li>then q $\leftarrow$ Partition(A,p,r) </li><li>$\quad$ A[p]$\leftrightarrow$ A[q]</li><li>$\quad$ Quicksort(A,p,q-1)</li><li>$\quad$ Quicksort(A,q+1,r)</li></ol></blockquote><p>时间复杂度O（nlogn）</p><h3 id="5-选择问题"><a href="#5-选择问题" class="headerlink" title="5. 选择问题"></a>5. 选择问题</h3><blockquote><p><strong>Select(S,k)</strong><br>输入： n个数的数组S，正整数k<br>输出： S中的第k小元素</p><ol><li>将S划分成5个一组，共$\lceil n&#x2F;5 \rceil$ 个组</li><li>每组找一个中位数，把这些中位数放到集合M中</li><li>$m^* \leftarrow Select(M,\lceil |M|&#x2F;2 \rceil)$ &#x2F;&#x2F;选M的中位数，将S中的数划分为A，B，C，D是个部分</li><li>把A和D中的每个元素与$m^*$ 比较，小的构成$S_1$,大的构成$S_2$ </li><li>$S_1 \leftarrow S_1 \cup C;S_2 \leftarrow S_2 \cup B;$</li><li>if k&#x3D; $|S_1|$ +1 then 输出 $m^*$</li><li>else if k $\leq$ $|S_1|$</li><li>$\quad$ then Select($S_1$,k)</li><li>$\quad$ else Select($S_2,k-|S_1|-1$)</li></ol></blockquote><p>时间复杂度O(n)</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>优化原则： 一个最优决策序列的人任何子序列本身一定是相对于子序列的初始和结束状态的最优决策序列<br>设计要素：</p><ol><li>划分子问题，用参数表述子问题的边界，将问题求解转换为多步判断的过程。</li><li>确定优化函数，以函数的极大&#x2F;极小作为判断的依据，确定是否满足优化原则</li><li>列出关于优化函数的递推方程和边界条件</li><li>考虑是否需要设计标记函数，以记录划分位置</li><li>自底向上计算，以表格存储中间结果</li><li>根据表格和标记函数通过追溯给出最优解</li></ol><h3 id="1-背包问题"><a href="#1-背包问题" class="headerlink" title="1. 背包问题"></a>1. 背包问题</h3><p><img src="/../sfmg/sf13.png"></p><h3 id="2-LCS最长公共子序列"><a href="#2-LCS最长公共子序列" class="headerlink" title="2. LCS最长公共子序列"></a>2. LCS最长公共子序列</h3><blockquote><p>**LCS(X,Y,m,n)<br>输入：序列X、Y，其中X[1..m],Y[1..n]<br>输出：最长公共子序列长度C[i,j],标记B[i,j],$1 \leq i \leq m,1 \leq j \leq n$ </p><ol><li>for i $\leftarrow$ 1 to m do</li><li>$\quad$ C[i,0]$\leftarrow$ 0</li><li>for i $\leftarrow$ 1 to n do </li><li>$\quad$ C[0,i]$\leftarrow$ 0</li><li>for i $\leftarrow$ 1 to m do</li><li>$\quad$ for j $\leftarrow$ 1 to n do</li><li>$\quad$ $\quad$ if X[i]&#x3D;Y[j]$\quad$ &#x2F;&#x2F;X[i]和Y[j]都被选入公共子序列<br>8.$\quad$ $\quad$ then C[i,j]$\leftarrow$ C[i-1,j-1]+1</li><li>$\quad$ $\quad$ $\quad$ $\quad$ B[i,j]$\leftarrow$ “↖️”<br>10.$\quad$ $\quad$ else if C[i-1,j] $\geq$ C[i,j-1]</li><li>$\quad$ $\quad$ $\quad$ then C[i,j]$\leftarrow$ C[i-1,j]</li><li>$\quad$ $\quad$ $\quad$ $\quad$ B[i,j]$\leftarrow$ “⬆️”</li><li>$\quad$ $\quad$ else C[i,j]$\leftarrow$ C[i,j-1]</li><li>$\quad$ $\quad$ $\quad$ $\quad$ B[i,j]$\leftarrow$ “⬅️”</li></ol></blockquote><h3 id="3-整备类问题"><a href="#3-整备类问题" class="headerlink" title="3. 整备类问题"></a>3. 整备类问题</h3><p>F[j]表示1～j天加工任务的最大数目<br>w[i+1,j]表示在第i天进行检修，从第i+1到第j天连续工作的加工量</p><h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><p>贪心法必须进行正确性证明<br>证明方法：<br>归纳论证<br>交换论证：用最优解交换得到有限步骤得到贪心法的解</p><h3 id="1-活动选择问题"><a href="#1-活动选择问题" class="headerlink" title="1. 活动选择问题"></a>1. 活动选择问题</h3><p>按截止时间从小到大排序，从前往后挑选，只要相容便加入</p><blockquote><p><strong>Greedy Select</strong><br>输入：活动集S&#x3D;{1,2,···,n},活动i的开始时间$s_i$和截止时间$f_i$<br>输出：A$\subseteq$S,选中的活动子集</p><ol><li>A$\leftarrow$ {1}</li><li>j $\leftarrow$ 1</li><li>for i $\leftarrow$ 2 to n do</li><li>$\quad$ if $s_i \ge f_i$ </li><li>$\quad$ then A $\leftarrow$ A $\cup$ {i}</li><li>$\quad$ $\quad$ j $\leftarrow$ i</li><li>return A</li></ol></blockquote><h3 id="2-集装箱问题"><a href="#2-集装箱问题" class="headerlink" title="2. 集装箱问题"></a>2. 集装箱问题</h3><p>轻者先装</p><blockquote><p><strong>Loading</strong><br>输入：集装箱集合N，集装箱i的重量$w_i$<br>输出：I $\subseteq$ N，准备装入船的集装箱集合</p><ol><li>对集装箱重量按从小到大排序</li><li>I $\leftarrow$ {1}</li><li>W $\leftarrow w_1$</li><li>for j $\leftarrow$ 2 to n do</li><li>$\quad$ if W+$w_i \leq$ C</li><li>$\quad$ then W $\leftarrow$ W+$w_i$</li><li>$\quad$ $\quad$     I $\leftarrow$ I $\cup$ {j}</li><li>$\quad$ else return I,W</li></ol></blockquote><h3 id="3-调度问题"><a href="#3-调度问题" class="headerlink" title="3. 调度问题"></a>3. 调度问题</h3><blockquote><p><strong>Schedule</strong><br>输入：A，T，D &#x2F;&#x2F;A为等待的客户集合，T为预计对客户的服务时间，D为客户希望的完成时间<br>输出：f</p><ol><li>排序A使得$d_1 \leq d_2 \leq ··· d_n$</li><li>f(1) $\leftarrow$ 0</li><li>i $\leftarrow$ 2</li><li>while i $\leq$ n do </li><li>$\quad$ f(i) $\leftarrow$ f(i-1)+$t_{i-1}$</li><li>$\quad$ i $\leftarrow$ i+1</li></ol></blockquote><h3 id="4-哈夫曼树（最优前缀码问题）"><a href="#4-哈夫曼树（最优前缀码问题）" class="headerlink" title="4. 哈夫曼树（最优前缀码问题）"></a>4. 哈夫曼树（最优前缀码问题）</h3><p>可扩展到k叉树</p><blockquote><p><strong>Huffman(C)</strong><br>输入：C&#x3D;{$x_1,x_2···x_n$}是字符集，每个字符频率f($x_i$)<br>输出：Q</p><ol><li>n $\leftarrow$ |C|</li><li>Q $\leftarrow$ C</li><li>for i $\leftarrow$ 1 to n-1 do</li><li>$\quad$ z  $\leftarrow$  Allocate-Node()  &#x2F;&#x2F;生成结点z</li><li>$\quad$ z.left $\leftarrow$ Q中最小元    &#x2F;&#x2F;左儿子</li><li>$\quad$ z.right $\leftarrow$  Q中最小元.  &#x2F;&#x2F;右儿子</li><li>$\quad$ f(z) $\leftarrow$ f(x)+f(y)</li><li>$\quad$ Insert(Q,z)     &#x2F;&#x2F;z插入Q</li><li>return Q</li></ol></blockquote><h3 id="5-最小生成树"><a href="#5-最小生成树" class="headerlink" title="5. 最小生成树"></a>5. 最小生成树</h3><h4 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h4><blockquote><p><strong>Prim</strong><br>输入：连通图G&#x3D;&lt;V,E,W&gt;<br>输出：G的最小生成树T</p><ol><li>S $\leftarrow$ {1};T&#x3D;$\emptyset$ </li><li>while V-S $\ne \emptyset$ do</li><li>从V $\rightarrow$ S中选择j使得j到S中顶点的边e的权最小；T $\leftarrow$ T$\cup$ {e}</li><li>S  $\leftarrow$ S$\cup$ {j}</li></ol></blockquote><h4 id="Krusal算法"><a href="#Krusal算法" class="headerlink" title="Krusal算法"></a>Krusal算法</h4><blockquote><p><strong>Krusal</strong><br>输入：连通图G&#x3D;&lt;V，E，W&gt;<br>输出：G的最小生成树</p><ol><li>按照权从小到大顺序排序G中的边，使得E&#x3D;{$e_1,e_2···e_m$}</li><li>T $\leftarrow \emptyset$</li><li>repeat</li><li>$\quad$ e $\leftarrow$ E中最短边</li><li>$\quad$ if e的两端点不在同一个连通分支</li><li>$\quad$ then T  $\leftarrow$ T$\cup$ {e}</li><li>$\quad$ E $\leftarrow$  E-{e}</li><li>until T 包含了n-1条边</li></ol></blockquote><h3 id="6-单源最短路径"><a href="#6-单源最短路径" class="headerlink" title="6. 单源最短路径"></a>6. 单源最短路径</h3><blockquote><p><strong>Dijkstra</strong><br>输入：带权有向图&lt;V,E,W&gt;，源点s$\in$ V<br>输出：数组L，对所有j$\in$ V-{s},L[j]表示s到j的最短路径上j前一个结点的标号</p><ol><li>S  $\leftarrow$ {s}</li><li>dist[s] $\leftarrow$ 0</li><li>for i $\in$ V-{s} do </li><li>$\quad$ dist[i] $\leftarrow$ w(s,i)   &#x2F;&#x2F;如果没边，w为无限</li><li>while V-S $\ne \emptyset$ do </li><li>$\quad$ 从V-S中取出具有相对S的最短路径的结点j，k是路径上连接j的结点</li><li>$\quad$ S $\leftarrow$  S$\cup$ {j};L[j] $\leftarrow$ k </li><li>$\quad$ for i$\in$ V-S do </li><li>$\quad$ $\quad$ if dist[j]+w(j,i) &lt; dist[j]</li><li>$\quad$ $\quad$ then dist[i] $\leftarrow$ dist[j]+w(j,i)   &#x2F;&#x2F;修改结点i相对S的最短路径长度</li></ol></blockquote><h3 id="耗油问题"><a href="#耗油问题" class="headerlink" title="耗油问题"></a>耗油问题</h3><p>从起点向终点扫描，一遇到没有油的情况取经过加油站能加油的最大值进行加油</p><h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><p>解空间：搜索问题的解所在的集合，又称为搜索空间，通常为树形结构，如排列树，子集树<br>搜索策略：深度优先，广度优先<br>多米诺性质：P($x_1,x_2···x_n+1$)为真蕴含P($x_1,x_2···x_n$)为真<br>代价函数小于界立刻剪枝<br>0-1类：O($2^n$);<br>m着色: O($nm^n$);<br>排列类：O(n!);</p><h2 id="线性规划"><a href="#线性规划" class="headerlink" title="线性规划"></a>线性规划</h2><h6 id="一般形式："><a href="#一般形式：" class="headerlink" title="一般形式："></a>一般形式：</h6><blockquote><p>$min(max) z &#x3D; \sum^n_{j &#x3D; 1}c_jx_j$<br>s.t. $\sum^n_{j&#x3D;1}a_{ij}x_j\le(&#x3D;,\ge)b_i$,i&#x3D;1,2···m<br>$x_j\ge 0$ -非负条件<br>$x_j$任意 - 自由变量</p></blockquote><p>$\quad$ 可行解 满足约束条件 和非负条件的变量<br>$\quad$ 可行域 全体可行解<br>$\quad$ 最优解 目标函数值最小(最大)的可行解<br>$\quad$ 最优值 最优解的目标函数值</p><h6 id="图解法"><a href="#图解法" class="headerlink" title="图解法"></a>图解法</h6><p>高中内容</p><h6 id="标准形"><a href="#标准形" class="headerlink" title="标准形"></a>标准形</h6><blockquote><p>min z &#x3D; $\sum^n_{j &#x3D; 1}c_jx_j$<br>s.t. $\sum^n_{j&#x3D;1}a_{ij}x_j&#x3D;b_i$,i&#x3D;1,2···m<br>$x_j \ge 0$</p></blockquote><p>对于不等式引入新的变量构造等式，对于自由变量引入两个新变量</p><h6 id="对偶线性规划："><a href="#对偶线性规划：" class="headerlink" title="对偶线性规划："></a>对偶线性规划：</h6><p><img src="/../sfmg/sf14.png"></p><h2 id="网络流"><a href="#网络流" class="headerlink" title="网络流:"></a>网络流:</h2><p><strong>FF算法</strong><br>O（mC）<br><strong>Dinic算法</strong><br>O（n^3)</p><h2 id="近似算法"><a href="#近似算法" class="headerlink" title="近似算法:"></a>近似算法:</h2><p> $\quad$ A是一个多项式时间算法且对组合优化问题 Ⅱ 的每一个实例I输出一个可行解$\sigma$ .记A(I)&#x3D;c(σ)， c(σ)是σ的值<br>$\quad$ 性能估计:当II是最小化问题时，记rA(I)&#x3D;A(I)&#x2F;OPT(I)；当II是最大化问题时，记rA(2)&#x3D;OPT(I&#x2F;A(I)<br>$\quad$ 最优化算法:恒有A(I)&#x3D;OPT(I)，即rA(I)&#x3D;1.<br>$\quad$ A的近似比为r（A是r-近似算法）：对每一个实例I，rA（I）$\leq$ r<br>$\quad$ A具有常数近似比：r是一个常数。</p><p>$\quad$ 可近似性分类<br>$\quad$ （1)完全可近似的：对任意小的ε&gt;0，存在(1+ε)-近似：算法背包问题<br>$\quad$   (2)可近似的：存在具有常数比的近似算法：最小顶点覆盖问题、多机调度问题<br>$\quad$   (3)不可近似的：不存在具有常数比的近似算法：货郎问题</p><h2 id="随机算法："><a href="#随机算法：" class="headerlink" title="随机算法："></a>随机算法：</h2><p>$\quad$ <strong>ZPP</strong>：有效的Las Vegas算法<br>$\quad$ <strong>BPP</strong>：有效的Monte Carlo算法<br>$\quad$ <strong>RP</strong>：弃真型单侧错误概率有界算法<br>$\quad$ <strong>coRP</strong>：取伪型单侧错误概率有界算法</p><h4 id="Las-Vegas-型随机算法"><a href="#Las-Vegas-型随机算法" class="headerlink" title="Las Vegas 型随机算法"></a>Las Vegas 型随机算法</h4><p>$\quad$ 通过修改确定性算法得到,一般将算法的某步的确定型选择变成随机选择<br>$\quad$ 一次运行可能得不到解;若得到解,则解一定是正确的<br>$\quad$ 与确定型算法相结合有可能改进确定型算法平均情况下的时间复杂度</p><p><strong>随机快速排序</strong></p><blockquote><p>算法输入：包含 n 个元素的数组<br>输出:经过排序的n个元素的数组<br>1.若数组包含0或1个元素则返回<br>2.从数组中随机选择一个元素作为枢轴元素<br>3.把数组元素分为三个子数组,并且按照A,B,C顺序排列<br>$\quad$ $\quad$ A:包含比枢轴元素小的元素;B:包含与枢轴元素相等的元素;C:包含比枢轴元素大的元素.<br>4.对A和C递归地执行上述步骤</p></blockquote><p><strong>算法RandSelect(A, p,r,k)</strong>  &#x2F;&#x2F;从A[p..r]中选第k小</p><blockquote><ol><li>if p&#x3D; r then return A[p]</li><li>i←Random(p, r)</li><li>3.以A[i]为标准划分A</li><li>j&lt;划分后小于等于A[i]的数构成数组的大小</li><li>if k$\leq$j</li><li>then return RandSelect (A, p, p+j-1, k)</li><li>return RandSelect (A, p+j, r, k-j)</li></ol></blockquote><p><strong>算法BoolQueen(n)</strong></p><blockquote><ol><li>k$\leftarrow$ 1. &#x2F;&#x2F; k 放皇后的行号</li><li>count$\leftarrow$ 0  &#x2F;&#x2F; count 放好的皇后数</li><li>while k$\leq$ n do</li><li>for i←1 to n do &#x2F;&#x2F;i为待选列号</li><li>检查i与前面k-1个皇后的相容性</li><li>如果相容则将i加入S</li><li>ifS$\ne$  $\emptyset$ ，then</li><li><pre><code class="hljs">j←Random(1,S)</code></pre></li><li><pre><code class="hljs">$x_k \leftarrow S[j]$ </code></pre></li><li>count $\leftarrow$ count+1</li><li><pre><code class="hljs">k$\leftarrow$ k+1</code></pre></li><li>else k←n + 1</li><li>return count<br>**算法QueenLV(n)</li><li>p$\leftarrow$ BoolQueen(n)</li><li>while p&lt;n ,do<br>3 .    p$\leftarrow$ BoolQueen(n)</li></ol></blockquote><h4 id="Monte-Carlo型随机算法"><a href="#Monte-Carlo型随机算法" class="headerlink" title="Monte Carlo型随机算法"></a>Monte Carlo型随机算法</h4><p>$\quad$ 这种算法有时会给出错误的答案<br>$\quad$ 运行时间和出错概率都是随机变量<br>$\quad$ 多项式时间内运行切出错概率不超过1&#x2F;3的随机算法称为有效的蒙特卡罗型算法</p><p>$\quad$ <strong>弃真型单侧错误</strong>：接受一定对，拒绝可能错<br>$\quad$ <strong>取伪型单侧错误</strong>：拒绝一定对，接受可能错<br>$\quad$ <strong>双侧错误</strong>：所有输入上同时出现上述两种</p><p>$\quad$ <strong>素数检测算法</strong></p><blockquote><p>输入：自然数n<br>输出：n是否素数</p><ol><li>若n是偶数且n$\ne$ 2,则宣布n是合数，结束计算</li><li>若n&#x3D;2，则宣布n是素数，结束计算</li><li>若n&#x3D;1，则宣布n&#x3D;1，结束计算</li><li>从{1,……n-1}中随机选择自然数a</li><li>若gcd（n，a）&gt;1（最大公因数）或（a&#x2F;n）$\ne$ a^{n-1&#x2F;2}(mod n),则宣布n是合数</li><li>否则，宣布n是素数</li></ol></blockquote><h1 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h1><h2 id="平摊分析"><a href="#平摊分析" class="headerlink" title="平摊分析"></a>平摊分析</h2><p>$\quad$ 求一系列操作在最坏情况下的时间,不涉及概率<br>$\quad$ 三种方法:</p><h6 id="聚集分析"><a href="#聚集分析" class="headerlink" title="聚集分析"></a>聚集分析</h6><p>$\quad$ 暴力得到总运行时间再除以n</p><h6 id="记账法"><a href="#记账法" class="headerlink" title="记账法"></a>记账法</h6><p>$\quad$ 要求：余额大于0<br>$\quad$ 实际上就是猜测平摊代价后进行验证</p><h6 id="势能法"><a href="#势能法" class="headerlink" title="势能法"></a>势能法</h6><p>$\quad$ 要求：最终势能大于0<br>$\quad$ 和记账法类似</p><h2 id="问题的计算复杂度"><a href="#问题的计算复杂度" class="headerlink" title="问题的计算复杂度"></a>问题的计算复杂度</h2><h4 id="平凡下界："><a href="#平凡下界：" class="headerlink" title="平凡下界："></a>平凡下界：</h4><p>$\quad$ 问题的输入或输出规模是它的平凡下界<br>$\quad$ 下界的计算：找最少运算数</p><h4 id="决策树："><a href="#决策树：" class="headerlink" title="决策树："></a>决策树：</h4><p>$\quad$ 以比较作基本运算的算法模型<br>$\quad$ 一个问题确定了一类决策树，具有相同的构造规则，该决策树类决定了求解该问题的一个算法类<br>$\quad$ 结点数(或树叶数)等于输入分类的总数<br>$\quad$ 最坏情况下的时间复杂度对应于决策树的深度<br>$\quad$ 平均情况下的时间复杂度对应于决策树的平均路径长度</p><p><img src="/../sfmg/sf15.png"><br><img src="/../sfmg/sf16.png"><br><img src="/../sfmg/sf17.png"></p><h2 id="NP-完全性"><a href="#NP-完全性" class="headerlink" title="NP 完全性"></a>NP 完全性</h2><p><strong>多项式时间算法</strong>：以多项式为时间复杂度<br><strong>易解的问题</strong>：有多项式时间算法<br><strong>难解的问题</strong>：不存在多项式时间算法</p><p><strong>哈密顿回路（HC）</strong>：任给无向图G，问G有哈密顿回路吗？<br><strong>货郎问题（TSP）</strong>：任给n个城市，城市i与城市j之间的正整数距离d（i，j），i$\ne$j,以及正整数D，问有一条每一个城市恰好经过一次最后回到出发点且长度不超过D的巡回路线吗？</p><h4 id="组合优化问题"><a href="#组合优化问题" class="headerlink" title="组合优化问题"></a>组合优化问题</h4><p>II* 由3部分组成：<br>(1)实例集$D_{II*}$<br>(2) $\forall I \in D_{II*}$ ，有一个有穷非空集S(I)，其元素称作 I的可行解<br>(3) $\forall s \in S(I)$,有一个正整数 c(s)，称作s的值<br>如果s$* \in S(I)$，对所有的 s$\in$ S(I)，当II<em>是最小（大）化问题时，c(s$</em>$) $\leq$ c (s)(c(s*) $\leq$ c(s))则称s $<em>$是I的最优解，c(s</em>)是 I的最优值，记作OPT(I).</p><h4 id="II-对应的判定问题"><a href="#II-对应的判定问题" class="headerlink" title="II$*$ 对应的判定问题"></a>II$*$ 对应的判定问题</h4><p>$D_{II}$&#x3D;{$(I,K)|I \in D_{II*},K \in Z*$}<br>当II$<em>$是最小化问题时，Yn&#x3D;{(I,K)|OPT(I)$\leq$K);当П</em>是最大化问题时，Yn&#x3D;{(I，K)|OPT(I)$\ge$ K).</p><h4 id="P类与NP类"><a href="#P类与NP类" class="headerlink" title="P类与NP类"></a>P类与NP类</h4><p>$\quad$ 所有多项式时间可解的判定问题组成的问题称为P类<br>$\quad$ 设判定问题II&#x3D;&lt;D,Y&gt;,如果存在两个输入变量的多项式时间算法A和多项式p，对每一个实例$I\in D,I \in Y$ 当且仅当存在t，｜t｜$\leq$ p(|I|),且A对输入I和t输出“Yes”，则称II是多项式时间可验证的，A是II的多项式时间验证算法，而当I$\in$ Y时，称t是I$\in$ Y的证据。<br>$\quad$ 由所有多项式时间可验证的判定问题组成的问题称为NP类</p><p>$\quad$ <strong>非确定型多项式时间算法:</strong><br>$\quad$ $\quad$ (1)对给定的实例 I，首先“猜想”一个 t,|t| $\leq$ p(I)<br>$\quad$ $\quad$ (2)然后检查t是否是证明I$\in$ Y的证据<br>$\quad$ $\quad$ (3)猜想和检查可以在多项试时间内完成<br>$\quad$ $\quad$ (4)当且仅当I$\in$ Y时能够正确地猜想到一个证据t<br>$\quad$ $\quad$ *注:非确定型多项式时间算法不是真正的算法</p><p>$\quad$ P$\subseteq$ NP </p><p>$\quad$ <strong>多项式时间变换</strong><br>$\quad$ 定义 设判定问题П1&#x3D;&lt;D1,Y1&gt;,П2&#x3D;&lt;D2,Y2&gt;. 如果函数f:D1→D2满足条件：(1)f是多项式时间可计算的；(2)对所有的$I\in D_1,I \in Y_1 \leftrightarrow f(I) \in Y_2$ ;则称f是П1到П2的多项式时间变换.如果存在П1到П2的多项式时间变换,则称П1可多项式时间变换到П2,记作$П1 \leq_p П2$ </p><h4 id="NP完全性-NPC）"><a href="#NP完全性-NPC）" class="headerlink" title="NP完全性(NPC）"></a>NP完全性(NPC）</h4><p>$\quad$ 定义 :如果对所有的 П’$\in$ NP,П’$\leq_p$ Π,则称 П是NP难的.如果 П 是 NP 难的且 Π$\in$ NP，则称 Π 是 NP完全的.<br>$\quad$ 定理:如果存在NP难的问题 Π$\in$ P，则P&#x3D;NP.<br>$\quad$ 推论 :假设P $\ne$ NP,那么，如果 Π是NP难的，则 Π $\notin$ P.<br>$\quad$ 定理:如果存在NP难的问题 П’ 使得 П’$\leq_p  Π$  则 Π 是NP难的.<br>$\quad$ 推论:如果 П$\in$ NP并且存在 NP完全问题  Π’使得  Π’$\leq_p$ Π,则 Π是NP完全的.</p><p><strong>$\quad$ 证明NP完全性的“捷径”<br>$\quad$ (1)证明Π$\in$ NP;<br>$\quad$ (2)找到一个已知的NP完全问题I’，并证明 Π’$\leq_p$ П.</strong></p><p>$\quad$ 可满足性问题（SAT）：任给一个合取范式F，问F是可满足的吗？<br>$\quad$ SAT是NP完全的（NPC）<br><img src="/../sfmg/sf18.png"></p><p>$\quad$ 设无向图G&#x3D;&lt;V,E&gt;,V’$\subseteq$ V.V’是G的一个<br>$\quad$ $\quad$ 顶点覆盖：G的每一条边都至少有一个顶点在V’中。<br>$\quad$ $\quad$ 团：对任意的u,v$\in$ V’,且u$\ne$ v,都有(u,v)$\in$ E.<br>$\quad$ $\quad$ 独立集：对任意的u,v$\in$ V’，都有(u,v)$\notin$ E.</p><p>$\quad$ 引理 对任意的无向图G&#x3D;&lt;V,E&gt;和子集V’$\subseteq$ V,下述命题是等价的<br>$\quad$ $\quad$ (1) V’是G的顶点覆盖，<br>$\quad$ $\quad$ (2) V-V ‘ 是G的独立集;<br>$\quad$ $\quad$ (3) V-V’是补图 G&#x3D;&lt;V,E&gt;的团.</p><p>$\quad$ 顶点覆盖(VC)： 任给一个无向图G&#x3D;&lt;V,E&gt;和非负整数K$\leq$ ｜V｜，问G有顶点数不超过K的顶点覆盖吗？<br>$\quad$ 团：任给一个无向图G&#x3D;&lt;V,E&gt;和非负整数J$\leq$ ｜V｜，问G有顶点数不小于J的团吗？<br>$\quad$ 独立集：任给一个无向图G&#x3D;&lt;V,E&gt;和非负整数J$\leq$ ｜V｜，问G有顶点数不小于J的独立集吗？<br>$\quad$ 顶点覆盖（VC）是NP完全的</p><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3-CISC,X86,RISC,MIPS指令</title>
    <link href="/2023/03/19/3-CISC,X86,RISC,MIPS%E6%8C%87%E4%BB%A4/"/>
    <url>/2023/03/19/3-CISC,X86,RISC,MIPS%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p> 对应 北京大学计算机组成与体系结构第三讲<br> 参考教材COD（计算机组成与设计-硬件&#x2F;软件接口）</p><span id="more"></span><h1 id="计算机组成与体系结构"><a href="#计算机组成与体系结构" class="headerlink" title="计算机组成与体系结构"></a>计算机组成与体系结构</h1><hr><h2 id="CISC-X86-RISC-MIPS指令"><a href="#CISC-X86-RISC-MIPS指令" class="headerlink" title="CISC ,X86,RISC,MIPS指令"></a>CISC ,X86,RISC,MIPS指令</h2><p>$\quad$ CISC：Complex Instruction Set Computer：复杂指令系统计算机<br>$\quad$ RISC：Reduced Instruction Set Computer：精简指令系统计算机</p><h4 id="X86指令"><a href="#X86指令" class="headerlink" title="X86指令"></a>X86指令</h4><h5 id="传送类"><a href="#传送类" class="headerlink" title="传送类"></a>传送类</h5><p>$\quad$ 作用：把数据或地址传送到寄存器或存储器单元中。<br>$\quad$ 分为四大类14条指令<br><img src="/../txmg/tx30.png"></p><h6 id="MOV指令"><a href="#MOV指令" class="headerlink" title="MOV指令"></a>MOV指令</h6><p>$\quad$ 格式：MOV DST，SRC<br>$\quad$ 操作： DST$\leftarrow$ SRC<br>$\quad$ 说明：DST指令表示目的操作数，SRC表示源操作数。MOV指令把一个字节或字节操作数从源传送到目的，源操作数保持距离不变。<br>$\quad$ 传送方向和限制：<br><img src="/../txmg/tx31.png"></p><h6 id="XCHG指令（交换）"><a href="#XCHG指令（交换）" class="headerlink" title="XCHG指令（交换）"></a>XCHG指令（交换）</h6><p>$\quad$ 格式：XCHG OPR1，OPR2<br>$\quad$ 操作： OPTR1 $\leftrightarrow$ OPTR2<br>$\quad$ 说明：两个操作数的位宽要相同，类型包括寄存器&#x2F;存储器，存储器&#x2F;寄存器，寄存器&#x2F;寄存器，不允许使用段寄存器</p><h6 id="XLAT指令（换码，查表）"><a href="#XLAT指令（换码，查表）" class="headerlink" title="XLAT指令（换码，查表）"></a>XLAT指令（换码，查表）</h6><p>$\quad$ 格式：XLAT<br>$\quad$ 操作：<br>$\qquad$ 1. 从BX中取得数据表起始地址的偏移量<br>$\qquad$ 2. 从AL中取得数据表项索引值<br>$\qquad$ 3. 在数据表中查得表项内容<br>$\qquad$ 4. 将查得的表项内容存入AL</p><h5 id="运算类"><a href="#运算类" class="headerlink" title="运算类"></a>运算类</h5><p>$\quad$ 作用：完成加、减、乘、除等算术运算，提供运算结果调整，符号扩展等功能。<br>$\quad$ 操作数限制：对于双操作数的指令，限制与MOV指令相同（目的操作数不能是立即数或CS寄存器，两个操作数不能同时为存储器操作数）<br>$\quad$ 分类：五大类20条指令<br><img src="/../txmg/tx32.png"><br><img src="/../txmg/tx33.png"></p><h6 id="加法类指令"><a href="#加法类指令" class="headerlink" title="加法类指令"></a>加法类指令</h6><p>$\quad$ ADD：加<br>$\quad$ $\quad$ 格式：ADD DST，SRC<br>$\quad$ $\quad$ 操作：DST$\leftarrow$ DST+SRC<br>$\quad$ ADC：带进位的加<br>$\quad$ $\quad$ 格式：ADC DST，SRC<br>$\quad$ $\quad$ 操作：DST$\leftarrow$ DST+SRC+CF<br>$\quad$ INC：加1<br>$\quad$ $\quad$ 格式：INC OPR<br>$\quad$ $\quad$ 操作：OPR$\leftarrow$ OPR+1</p><h6 id="十进制调整指令"><a href="#十进制调整指令" class="headerlink" title="十进制调整指令"></a>十进制调整指令</h6><p>$\quad$ 格式：DAA<br>$\quad$ 操作：跟在二进制加法指令之后，将AL中的和调整为压缩BCD数形式，结果返回AL<br>示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">MOV AL,<span class="hljs-number">27</span>H; AL=<span class="hljs-number">27</span>H<br>ADD AL,<span class="hljs-number">15</span>H; AL=<span class="hljs-number">3</span>CH<br>DAA.      ; AL=<span class="hljs-number">42</span>H<br></code></pre></td></tr></table></figure><p>$\qquad$ BCD（binary-Coded Decimal）具有二进制编码的形式，又保持了十进制的特点，可以作为人与计算机联系时的中间表示。<br><img src="/../txmg/tx34.png"></p><h5 id="转移类"><a href="#转移类" class="headerlink" title="转移类"></a>转移类</h5><p>$\quad$ 作用：改变指令执行顺序<br>$\quad$ 分类：根据是否有判断条件，分为无条件转移和条件转移指令；根据转移目的地址的提供方式，分为直接转移和间接转移。</p><h6 id="无条件转移指令"><a href="#无条件转移指令" class="headerlink" title="无条件转移指令"></a>无条件转移指令</h6><p><img src="/../txmg/tx35.png"><br>$\quad$ 直接转移：<br>$\qquad$ 短转移： JMP SHORT LABEL<br>$\quad$ $\quad$ 操作：IP$\leftarrow$ IP+8位的偏移量（-128～127Byte）<br>$\qquad$ 近转移：JMP NEAR PTR LABEL<br>$\quad$ $\quad$ 操作：IP$\leftarrow$ IP+16位的偏移量（+-32KByte）<br>$\qquad$ 远转移：JMP FAR PTR LABEL<br>$\quad$ $\quad$ 操作：IP$\leftarrow$ LABEL的偏移地址；CS$\leftarrow$ LABEL的段基值<br><img src="/../txmg/tx36.png"><br>$\quad$ 间接转移：JMP DWORD PTR OPR<br>$\quad$ $\quad$ 操作：寻址到OPR指定的存储器单元双字-&gt;将该双字中的低字送到IP寄存器中-&gt;将该双字中的高字送到CS寄存器中</p><h6 id="条件转移指令"><a href="#条件转移指令" class="headerlink" title="条件转移指令"></a>条件转移指令</h6><p><img src="/../txmg/tx37.png"><br><img src="/../txmg/tx38.png"><br>$\quad$ 操作：根据当前的状态标志位判断是否发生转移<br>$\quad$ 说明：8086中，所有的条件转移都是短转移，80386起，条件转移指令可以使用32位的长位移量</p><h6 id="循环控制指令"><a href="#循环控制指令" class="headerlink" title="循环控制指令"></a>循环控制指令</h6><p><img src="/../txmg/tx39.png"><br>LOOPNE&#x2F;LOOPNZ指令说明<br>$\quad$ 格式：LOOPNE LABEL或LOOPNZ LABEL<br>$\quad$ 操作：CX$\leftarrow$CX-1,若CX不为0且ZF为0，转移到LABEL处继续执行，否则结束循环顺序执行下一条指令</p><h5 id="串操作指令"><a href="#串操作指令" class="headerlink" title="串操作指令"></a>串操作指令</h5><p>$\quad$ 作用：对存储器中的数据串进行每次一个元素的操作<br>$\quad$ 分类：共5条串操作指令，3种重复前缀<br>$\quad$ 串的基本单位是字节或字，长度可达64KB<br><img src="/../txmg/tx320.png"></p><h6 id="重复前缀"><a href="#重复前缀" class="headerlink" title="重复前缀"></a>重复前缀</h6><p>$\quad$ <strong>REP</strong>（无条件重复）<br>$\qquad$ 当CX！&#x3D;0时，重复执行串操作指令，适用于MOVS，STO<br>$\qquad$ 处理完一个串元素后，CX减一<br><img src="/../txmg/tx321.png"><br>$\quad$ 串传送方向：DF&#x3D;0从低地址开始，DF&#x3D;1从高地址开始<br>$\quad$ <strong>REPNE&#x2F;REPNZ</strong>（不相等&#x2F;不为零重复）<br>$\qquad$ 当CX！&#x3D;0且ZF&#x3D;0时，重复执行串操作指令，适用于CMPS，SCAS</p><h5 id="处理器控制指令"><a href="#处理器控制指令" class="headerlink" title="处理器控制指令"></a>处理器控制指令</h5><p>$\quad$ 作用：控制CPU的功能，对标志位进行操作<br><img src="/../txmg/tx310.png"></p><h5 id="X86指令的发展历程："><a href="#X86指令的发展历程：" class="headerlink" title="X86指令的发展历程："></a>X86指令的发展历程：</h5><p><img src="/../txmg/tx311.png"><br><img src="/../txmg/tx312.png"></p><h4 id="MIPS指令"><a href="#MIPS指令" class="headerlink" title="MIPS指令"></a>MIPS指令</h4><p>$\quad$ 全称：Microprocessor without Interlocked Piped Stages<br>$\quad$ 主要关注点：减少指令的类型，降低指令的复杂度<br>$\quad$ 基本原则：A simpler CPU is a faster CPU</p><h5 id="指令示例"><a href="#指令示例" class="headerlink" title="指令示例"></a>指令示例</h5><h6 id="装载"><a href="#装载" class="headerlink" title="装载"></a>装载</h6><p>$\quad$ 格式：lw $8,($19)<br>$\quad$ 操作：以19号寄存器的内容为地址，取出存储器中的32位数据，存入八号寄存器</p><h6 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h6><p>$\quad$ 格式：add $10 , $9 ,  $8<br>$\quad$ 操作：将八号和九号寄存器的内容相加存入十号寄存器中（减法即为sub）</p><h6 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h6><p>$\quad$ 格式：sw $10,32 ($19)<br>$\quad$ 操作：将10号寄存器的内容存入存储器，地址为19号存储器的内容</p><h5 id="MIPS的通用寄存器"><a href="#MIPS的通用寄存器" class="headerlink" title="MIPS的通用寄存器"></a>MIPS的通用寄存器</h5><p>$\quad$ 32个，每个都是32位宽<br><img src="/../txmg/tx313.png"></p><h5 id="MIPS指令的特点"><a href="#MIPS指令的特点" class="headerlink" title="MIPS指令的特点"></a>MIPS指令的特点</h5><p>$\quad$ 1. 固定的指令长度（32-bit，即1word）<br>$\qquad$ 简化了从存储器取指令<br>$\qquad$ 对比x86长度不定，1～15字节<br>$\quad$ 2. 只有Load和Store指令可以访问存储器<br>$\quad$ 3. 简单的寻址模式<br>$\qquad$ 简化了从存储器取操作数<br>$\quad$ 4. 指令数量少，指令功能简单<br>$\qquad$ 一条指令只完成一个操作，简化指令的执行过程<br>$\qquad$ 影响：处理器设计简单，运行速度快，编程复杂，代码程序量大，需要优秀的编译器</p><h5 id="MIPS指令的基本格式"><a href="#MIPS指令的基本格式" class="headerlink" title="MIPS指令的基本格式"></a>MIPS指令的基本格式</h5><p>$\quad$ R： Register，寄存器<br>$\quad$  I：Immediate，立即数<br>$\quad$ J：Jump，无条件转移<br><img src="/../txmg/tx315.png"><br><img src="/../txmg/tx314.png"></p><h6 id="R型指令"><a href="#R型指令" class="headerlink" title="R型指令"></a>R型指令</h6><p><img src="/../txmg/tx317.png"><br>$\quad$ R型指令格式包括6个域，2个6-bit域（可表示0～63的数），4个5-bit域（可表示0～31的数）<br>$\quad$ opcode：用于指定指令的类型，对于所有R型指，该域的值均为0<br>$\quad$ funct：与opcode域结合，精确指定指令的类型<br>$\quad$ rs（Source Register）：指定第一个源操作数所在的寄存器编号<br>$\quad$ rt（Target Register）：指定第二个源操作数所在的寄存器编号<br>$\quad$ rd（Destination Register）：指定目的操作数（保存运算结果）的寄存器编号<br>$\quad$ shamt（shift amount）：用于指定移位指令进行移位操作的位数，非移位指令设为0<br>$\quad$ 5-bit的域可表示0~31，对应32个通用寄存器</p><h6 id="I型指令"><a href="#I型指令" class="headerlink" title="I型指令"></a>I型指令</h6><p><img src="/../txmg/tx316.png"><br>$\quad$ 大部分域与R指令相同<br>$\quad$  opcode：用于指定指令的类型<br>$\quad$ rs：指定第一个源操作数所在的寄存器编号<br>$\quad$ rt：一般指定用于目的操作数的寄存器编号；对于某些指令指定第二个源操作数所在的寄存器编号<br>$\quad$ immediate：16-bit的立即数，可以表示$2^{16}$ 个不同数值</p><h5 id="分支指令"><a href="#分支指令" class="headerlink" title="分支指令"></a>分支指令</h5><p>$\quad$ 分类：<br>$\qquad$ <strong>Branch</strong>：分支， 改变控制流<br>$\qquad$ <strong>Conditional Branch</strong>：条件分支，根据比较的结果改变控制流；两条指令：  <em>branch if equal（beg）；branch if not equal（bne）</em><br>$\qquad$ <strong>Unconditional Branch</strong> :非条件分支，无条件改变控制流：指令：<em>jump (j)</em> </p><h6 id="I型（条件分支）"><a href="#I型（条件分支）" class="headerlink" title="I型（条件分支）"></a>I型（条件分支）</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">beq rs,rt,imm   <span class="hljs-meta">#opcode=4</span><br>bne rs,rt,imm   <span class="hljs-meta">#opcode=5</span><br></code></pre></td></tr></table></figure><p>$\quad$ 目标地址计算方法：<br>$\qquad$ 分支条件不成立：PC&#x3D;PC+4<br>$\qquad$ 分支条件成立：PC&#x3D;PC+4+（immediate*4）</p><h6 id="J型（非条件分支）"><a href="#J型（非条件分支）" class="headerlink" title="J型（非条件分支）"></a>J型（非条件分支）</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">j addr<br></code></pre></td></tr></table></figure><p>$\quad$ 目标地址计算方法：PC &#x3D; { $(PC+4)[31..28],address,00$ }<br>$\quad$ 目标地址范围：$2^{28}bytes$ </p><h6 id="R型（非条件分支）"><a href="#R型（非条件分支）" class="headerlink" title="R型（非条件分支）"></a>R型（非条件分支）</h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">jr rs<br></code></pre></td></tr></table></figure><h5 id="串操作指令-1"><a href="#串操作指令-1" class="headerlink" title="串操作指令"></a>串操作指令</h5><p><strong>MOVSB（字节串传送）</strong><br>$\quad$ 格式：MOVSB<br>$\quad$ 操作：将地址DS:SI所指向的存储器字节单元传送到地址ES:DI；修改SI和DI的内容，指向串的下一元素<br><strong>MOVSW（字串传送）</strong><br>$\quad$ 格式：MOVSW<br>$\quad$ 操作：将地址DS：SI所指向的存储器字单元传送到地址ES：DI；修改SI和DI的内容，指向串的下一元素</p><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>COD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>COD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2-计算机基本结构</title>
    <link href="/2023/03/19/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/"/>
    <url>/2023/03/19/2-%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>  对应 北京大学计算机组成与体系结构第二讲<br>  参考教材COD（计算机组成与设计-硬件&#x2F;软件接口）</p><span id="more"></span><h1 id="计算机组成与体系结构"><a href="#计算机组成与体系结构" class="headerlink" title="计算机组成与体系结构"></a>计算机组成与体系结构</h1><hr><h2 id="计算机基本结构"><a href="#计算机基本结构" class="headerlink" title="计算机基本结构"></a>计算机基本结构</h2><h4 id="1-冯·诺依曼计算机结构"><a href="#1-冯·诺依曼计算机结构" class="headerlink" title="1. 冯·诺依曼计算机结构"></a>1. 冯·诺依曼计算机结构</h4><p> 要点：<br>$\quad$ 1. 计算机应该由运算器，控制器，存储器，输入设备和输出设备共五个部分组成。<br>$\quad$ 2. 数据和程序均以二进制代码形式不加区别地放在存储器中，存放位置由存储器的地址指定<br>$\quad$ 3. 计算机在工作时能够自动地从存储器中取出指令加以执行<br><img src="/../txmg/tx20.png"><br> 冯·诺伊曼计算机的主要构成：<br> $\quad$ 1. 运算器，CA：central arithmetical<br> $\quad$ 2. 控制器，CC：central control<br> $\quad$ 3. 存储器，M：memory<br> $\quad$ 4. 输入设备，I：input<br> $\quad$ 5. 输出设备，O：output<br> $\quad$ 外部记录设备，R：outside recording medium</p><h4 id="2-x86指令系统概览"><a href="#2-x86指令系统概览" class="headerlink" title="2. x86指令系统概览"></a>2. x86指令系统概览</h4><p><img src="/../txmg/tx21.png"><br>代表：<br> <strong>字长16位</strong>：<br>$\quad$ <em>Intel 8086</em>(1978年)<br> $\qquad$ 字长16位，内部的通用寄存器为16位，既能处理16位数据，也能处理8位数据。<br>  $\qquad$ 对外有16根数据线和20根地址线，可寻址的内存空间为1MByte($2^{20}$)。<br>   $\qquad$ 物理地址的形成采用“段加偏移”的方式。<br>$\quad$ <em>Intel 80286</em>（1982年）<br>  $\qquad$ 字长16位，地址总线扩展到24位，可寻址16MB的内存空间。<br>   $\qquad$ 引入了“保护模式”，但是机制有缺陷。<br> $\qquad$  为保持兼容，保留了8086的工作模式，被称为实模式（实地址模式)。<br> <strong>字长32位</strong>：<br>  $\quad$ <em>Intel 80386</em>（1985年）<br>$\qquad$ 80x86系列中的第一款32位微处理器。<br>$\qquad$ 地址总线扩展到32位，可寻址4GB的内存空间<br>$\qquad$ 改进了“保护模式”：（80386及以上的微处理器的主要工作模式，支持多任务，支持设置特权级，可以访问4GB的物理存储空间，引入了虚拟存储器的概念）<br>$\qquad$ 增加了“虚拟8086模式”，可以同时模拟多个8086微处理器<br><img src="/../txmg/tx22.png"><br> <strong>字长64位</strong>：<br>$\quad$ <em>AMD Opteron</em> （2003年）<br>$\qquad$ x86扩展到64位的第一款处理器<br>$\qquad$ 可以访问高于4GB的存储器<br>$\qquad$ 兼容32位x86程序，且不降低性能<br><img src="/../txmg/tx23.png"></p><h4 id="3-x86的地址空间"><a href="#3-x86的地址空间" class="headerlink" title="3. x86的地址空间"></a>3. x86的地址空间</h4><p><img src="/../txmg/tx24.png"><br> <strong>指令指针寄存器IP（Instruction Pointer）</strong>：<br> $\quad$ 保存一个内存地址，指向当前需要取出的指令。<br> $\quad$ 当CPU从内存中取出一个指令后，IP会自动增加，指向下一指令的地址。<br> $\quad$ 程序员不能直接对IP进行存取操作<br> $\quad$ 转移指令，过程调用与返回等会改变IP的内容。<br> <strong>段寄存器</strong><br> $\quad$ 与处理器中其他寄存器联合生成存储器地址<br> $\quad$ 段寄存器的功能在实模式下和保护模式下是不同的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp">DATA SEGMENT ; 数据段<br>    NUM DW <span class="hljs-number">0011101000000111B</span>;<br>    NOTES DB <span class="hljs-string">&#x27;The result is :&#x27;</span>,<span class="hljs-string">&#x27;$&#x27;</span><br>DATA ENDS ; 数据段结束<br><br>STACK SEGMENT ; 堆栈段<br>    STA DB <span class="hljs-number">50</span> <span class="hljs-built_in">DUP</span>(?)<br>    TOP EQU LENGTH STA<br>STACK ENDS ; 堆栈段结束<br><br>CODE SEGMENT ; 代码段<br>    ASSUME CS:CODE,DS:DATA,SS:STACK<br>BEGIN:<br>    MOV AX, DATA<br>    MOV DS, AX   ;为DS赋初值<br>    MOV AX, STACK <br>    MOV SS, AX   ;为SS赋初值<br>    MOV AX, TOP<br>    MOV SP, AX   ;为SP赋初值<br>    ...<br>CODE ENDS       ;  代码段结束<br>    END    BEGIN   ;模块结束<br></code></pre></td></tr></table></figure><p> $\quad$ ( 1 ) 代码段寄存器 CS (Code Segment)<br> $\qquad$ 保存了代码段(一个存储区域，用以保存微处理器使用的代码）的起始地址 。<br>  $\qquad$ 用CS:IP指示下一条要执行的指令地址<br>  <img src="/../txmg/tx25.png"></p><p>$\quad$ ( 2 ) 数据段寄存器 DS (Data Segment)<br>  $\qquad$ 保存了数据段（一个存储区域，包含程序所使用的大部分数据）的起始地址。<br>  $\qquad$ 实模式数据段的长度限制为64KB，保护模式数据段长度限制为4GB。<br>$\quad$（ 3 ）附加段寄存器 ES (Extra Segment)<br>  $\qquad$ 保存了附加段（附加的数据段，也用于数据的保存，某些串操作指令将附加段作为其目的操作数的存放区域，长度限制与代码段以及数据段相同。）的起始地址。<br>  $\qquad$ 用ES:DI指示串操作的目的操作数的地址<br>  <img src="/../txmg/tx26.png"></p><p>  $\qquad$ 如果数据存在放在数据段以外的其他段（例如附加段），则应在指令中给出“段跨越前缀”。<br>  如  MOV  AX，ES:[3000H]   或   ES:MOV AX，[3000H]<br>$\quad$（ 4 ）堆栈段寄存器 SS (Stack Segment)<br>$\qquad$ 用以指示堆栈段的首地址<br>$\qquad$ ESP&#x2F;SP或EBP&#x2F;BP指示堆栈栈顶的偏移地址<br>$\qquad$用SS:SP等组合操作堆栈中的数据<br><img src="/../txmg/tx27.png"><br>$\quad$ （ 5 ）新增加的附加段寄存器FS和GS<br>$\qquad$ 80386起新增了这两个附加段寄存器<br>$\qquad$ FS和GS的功能和ES相同<br>$\qquad$ 增加FS和GS可以减轻ES寄存器的负担，以便程序灵活访问相应的两个附加数据段。</p><p> <strong>8086的物理地址生成</strong><br> <img src="/../txmg/tx28.png"><br>  $\quad$ 实例：<br>  <img src="/../txmg/tx29.png"><br>  <strong>直观的存储器分段方法</strong><br>$\quad$ 实现方法：把20位物理地址分为2部分，高4位为段号，用段号寄存器来保存，低16位为段内地址，也称便宜地址。<br>$\quad$ 不足之处：段号寄存器和其他寄存器不兼容，且每个逻辑段固定占用16K字节，浪费存储空间，相比而言8086的分段技术更灵活。<br> <strong>IA-32的存储器寻址</strong><br>  实模式 CS:IP<br>  保护模式：CS:EIP，保护模式下，段基地不在CS中，而是在内存中。<img src="/../txmg/tx210.png"></p><h4 id="4-x86汇编语言的格式"><a href="#4-x86汇编语言的格式" class="headerlink" title="4. x86汇编语言的格式"></a>4. x86汇编语言的格式</h4><h6 id="Intel-和AT-amp-T-格式的区别"><a href="#Intel-和AT-amp-T-格式的区别" class="headerlink" title="Intel 和AT&amp;T 格式的区别"></a>Intel 和AT&amp;T 格式的区别</h6><p> <strong>Intel 格式</strong><br>$\quad$ Intel制定，x86相关的文档手册使用该格式<br>$\quad$ 主要应用在MS-DOS和Windows等系统中<br> <strong>AT&amp;T格式</strong><br>$\quad$ AT&amp;T制定，起源于贝尔实验室研发的Unix<br>$\quad$ 最初用在PDP-11&#x2F;VAX等机型，后移植到x86<br>$\quad$ 主要应用于Unix和Linux等系统中</p><ol><li>前缀（后缀）：<br> $\quad$ Intel语法：寄存器和立即数都没有前缀，十六进制、十进制、八进制和二进制立即数后缀分别为h,d，o(q)和b。整数默认为10进制，以字母开头的十六进制数必须加0，字符串常数用单引号括起。实数即为 （）E（）<br>  $\quad$ AT&amp;T语法“寄存器使用前缀”%“，立即数使用前缀”$“，十六进制立即数使用前缀0x<br>  <img src="/../txmg/tx211.png"></li><li>操作数方向<br>  $\quad$ Intel语法：第一个操作数是目的操作数，第二个操作数是源操作数<br>  $\quad$ AT&amp;T语法：第一个操作数是源操作数，第二个操作数是目的操作数</li><li>内存单元操作数<br>  $\quad$ Intel语法：基寄存器用[ ]标明<br>  $\quad$ AT&amp;T语法：基寄存器用（ ）标明</li><li>间接寻址方法<br>  $\quad$ Intel语法：segreg:[base+index*scale+disp]<br>  $\quad$ AT&amp;T语法：%segreg:disp(base,index,scale)<br>  <img src="/../txmg/tx212.png"></li><li>操作码后缀<br>  $\quad$ AT&amp;T语法： 操作码带后缀，以指出操作数的大小<br>  $\qquad$ I:32位；w: 16位 ；b：8位<br>  $\quad$ Intel语法：内存单元操作数带前缀，以指出操作数的大小<br>  $\qquad$ dword ptr; word ptr ;byte ptr<br>  <img src="/../txmg/tx213.png"></li></ol><h6 id="汇编语言程序"><a href="#汇编语言程序" class="headerlink" title="汇编语言程序"></a>汇编语言程序</h6><p> <strong>组成</strong><br>$\quad$ 分段结构：按段进行组织，最多由四个段组成（代码，数据 ，附加，堆栈），每个段以“段名   SEGMENT”开始，以“段名  ENDS”结束。<br>$\quad$ 语句行：段由若干语句行组成，语句行的三种类型：指令、伪指令<br>宏指令。<br> <strong>语句的执行</strong><br>$\quad$ 指令语句的执行：汇编器计算指令语句中表达式的值-&gt;汇编器将指令语句翻译成机器指令代码-&gt;程序运行时，由CPU按机器指令代码的要求完成各种运算与操作。<br>$\quad$ 伪指令语句的执行：汇编器计算伪指令语句中表达式的值，不产生机器代码，汇编器解释伪指令语句的含义并遵照执行。<br>$\qquad$ 数据定义：变量（编程时只能确定其初始值，程序运行期间可修改其值的数据对象称为变量）是存储单元中的数据，可定义在任何段，由伪指令说明符DB、DW、DD等定义<br>$\qquad$ 符号定义：常量（编程时已确定其值，程序运行期间不会改变其值）可由伪指令说明符”EQU”或“&#x3D;”定义，不产生目标代码，不占用存储单元。EQU左边的符号名不可重复定义，但&#x3D;可以。<br>$\qquad$ 段定义：说明符SEGMENT（段开始），ENDS（段结束），ASSUME（指定段寄存器）<br>$\qquad$ 指定段内的偏移地址：<br>$\qquad$ $\qquad$ “ORG 常数表达式”指定当前可用的存储单元的偏移地址为常数表达式的值。<br>$\qquad$ $\qquad$ “EVEN”将当前可用的存储单元的偏移地址调整为最近的偶数值。<br>$\qquad$ 示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp">DATA SEGMENT<br>  ORG <span class="hljs-number">1000</span>H<br>  A DB <span class="hljs-number">47</span>H,<span class="hljs-number">12</span>H,<span class="hljs-number">45</span>H<br>  EVEN<br>  B DB <span class="hljs-number">47</span>H<br>DATA ENDS<br><span class="hljs-comment">//ORG指令将A的偏移地址部分指定为1000H，从A开始存放3个字节变量，占用地址1000H，1001H和1002H，EVEN指令会将B的偏移地址部分从1003H调整为偶数地址1004H</span><br><br></code></pre></td></tr></table></figure><p>$\qquad$ 过程定义：<br>$\qquad$ $\qquad$ “过程名  PROC  类型属性名”：从过程名代表的地址开始定义一个过程；“类型属性名”可以选择NEAR（近过程）或FAR（远过程），默认为NEAR<br>$\qquad$ $\qquad$ “过程名 ENDP”：表示该过程到此结束，此处的过程名必须与过程开始时PROC左边的过程名相同。</p><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>COD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>COD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1-课程概述</title>
    <link href="/2023/03/19/1-%E8%AF%BE%E7%A8%8B%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/03/19/1-%E8%AF%BE%E7%A8%8B%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p> 对应 北京大学计算机组成与体系结构第一讲<br> 参考教材COD（计算机组成与设计-硬件&#x2F;软件接口）</p><span id="more"></span><h1 id="计算机组成与体系结构"><a href="#计算机组成与体系结构" class="headerlink" title="计算机组成与体系结构"></a>计算机组成与体系结构</h1><hr><h2 id="课程概述"><a href="#课程概述" class="headerlink" title="课程概述"></a>课程概述</h2><h4 id="1-电子计算机的兴起"><a href="#1-电子计算机的兴起" class="headerlink" title="1. 电子计算机的兴起"></a>1. 电子计算机的兴起</h4><p>$\quad$ ENIAC：世界第一台电子计算机 设计者：约翰·莫克利和约翰·埃克特<br>$\quad$ 现代电子计算机之父：冯·诺依曼<br>$\quad$ EDVAC 第一台存储程序计算机（冯诺依曼结构)<br>$\quad$ UNIVAC：开启了商用计算机的时代<br>$\quad$ 第一台实际运行的冯·诺依曼结构：EDSAC，出现在英国</p><h4 id="2-计算机的主要类别"><a href="#2-计算机的主要类别" class="headerlink" title="2. 计算机的主要类别"></a>2. 计算机的主要类别</h4><p>$\quad$ 1. 超级计算机<br>$\quad$ $\quad$ 溯源：1964年，CDC6600<br>$\quad$ $\quad$ 特点：运算速度最快，性能最高，技术最复杂，代表该时期处理能力巅峰，解决科技领域中某些巨大的挑战性问题<br>$\quad$ $\quad$ 用途： 用于高度计算密集型的科学计算任务<br>$\quad$ $\quad$ 最多：美国<br>$\quad$ $\quad$ 目前排名：美国Frontier，日本Fugaku，芬兰LUMI<br>$\quad$ 2. 微型计算机<br>$\quad$ $\quad$ 溯源：1975年，Altair8800<br>$\quad$ $\quad$ 特点：以微处理器为中央处理单元（CPU）而组成的计算机系统，一大类为个人计算机，另一大类为微控制器嵌入到其他设备<br>$\quad$ $\quad$ 用途：个人处理，家用电器等<br>$\quad$ 3. 大型计算机<br>$\quad$ $\quad$ 溯源：1952年，IBM701<br>$\quad$  $\quad$ 特点：使用所在时代的先进技术构成的一类高性能，大容量通用计算机，强调高速输入输出，海量存储空间和并行事务处理 。<br>$\quad$ $\quad$ 用途：用于大容量数据的事务处理，兼顾科学计算<br>$\quad$ 4. 小型计算机<br>$\quad$ $\quad$ 溯源：1965年，PDP-8<br>$\quad$ $\quad$ 特点：规模介于大型计算机和微型计算机之间<br>$\quad$ $\quad$ 用途：非常广泛，事务处理和科学计算</p><p>摩尔定律：当价格不变时，集成电路可容纳的晶体管数数量，约每隔18个月便会增加一倍，性能也将提升一倍<br>衍生反摩尔定律：一个IT公司如果今天和18个月前卖掉同样多，同样的产品，它的营业额就要降一半。</p><p>$\quad$ </p><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>COD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>COD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>铃芽之旅</title>
    <link href="/2023/03/19/%E9%93%83%E8%8A%BD%E4%B9%8B%E6%97%85/"/>
    <url>/2023/03/19/%E9%93%83%E8%8A%BD%E4%B9%8B%E6%97%85/</url>
    
    <content type="html"><![CDATA[<h2 id="”有点过誉“"><a href="#”有点过誉“" class="headerlink" title="”有点过誉“"></a>”有点过誉“<br><span id="more"></span></h2><p>$\quad$ 三年之期已到，新海诚的新作《铃芽之旅》还未正式上映就已然吸引了各位的目光，各位也是很期待国内宣发的“集大成之作”到底会是什么样子。<br>$\quad$ PKU很给力的搞到了首映式的举办机会，无所谓，算分小班会出手（寄）</p><p><img src="/../post_img/suzume4.jpg"></p><p>$\quad$ でも大丈夫,元火还是给力的垄断了（bushi）北京地区的提前观影资格，身为元火子的本鼠鼠自然是参加了的</p><p><img src="/../post_img/suzume2.jpg"></p><p>$\quad$ 两个小时下来，怎么说呢，节奏过于快了，感觉换成12集的tv会比较好些，很多地方的细节都没有给出明确的解释，电影便结束了，目前看来口碑&lt;君名，$\approx$ 天气之子，应该是没有什么悬念的。（灾难三部曲疑似成为退步三部曲）。<br>$\quad$ 最后也是用chatgpt摸了个观后感（主人的任务罢了）</p><blockquote><p>$\quad$ 《铃芽之旅》是新海诚导演的第八部动画电影，也是他继《你的名字》和《天气之子》后，第三部涉及灾难题材的作品，被称为新海诚的“灾难三部曲”。该片讲述了17岁的少女岩户铃芽与负责关闭连接往生者世界“常世”的“后门”的“闭门师”宗像草太相遇，两人一起去关闭灾难源头之门的冒险故事。 $\newline$<br>在我看来，《铃芽之旅》是新海诚导演的集大成作，不仅展现了他惯有的细腻情感、精美画面和动听音乐，还突破了他以往作品的局限和套路，尝试了公路电影、日本庭园、万叶集等新颖元素，并直面了东日本大震災等现实问题。该片不仅有着浪漫而又悲伤的爱情故事，还有着对生命、时间和自我成长的深刻思考。  $\newline$<br>$\quad$ 首先，《铃芽之旅》延续了新海诚导演对于青春爱情故事的独特魅力。铃芽和草太两个性格迥异、身份悬殊、相貌平凡的主角，在经历了一系列奇遇和危机后，逐渐产生了超越友情和亲情的感情。他们在彼此身上找到了自己缺失或忘却的东西：铃芽找到了自己想要追寻和守护的目标；草太找到了自己想要珍惜和拥有的人生。他们在一起时互相开导、互相支持、互相取暖；分开时思念如潮、心痛如刀、坚持如命。他们用行动证明了爱情不分年龄、地域、身份，只要有勇气去追求就能跨越一切障碍。$\newline$<br>$\quad$ 其次，《铃芽之旅》展现了新海诚导演对于视觉美学和音乐艺术的高超水准。该片以日本列岛为舞台，从九州宫崎县到四国爱媛县再到东京都区内等地方都有精心描绘出来³。无论是港口小镇、山中废墟、市郊游乐园还是摩天轮上空，都充满了细节与真实感。该片还运用了多种色彩与光影效果来营造出不同场景与氛围：暗红色烟雾代表着灾难与危机；蓝色天空代表着希望与梦想；白色雨滴代表着洗涤与重生；金色阳光代表着温暖与幸福。该片还运用了多种镜头语言和动画技巧来表达出不同情感与意境：慢镜头、定格、倒带等手法突出了主角之间的心理变化和时间流逝；分屏、对比、重叠等手法展现了主角之间的距离感和相互联系；变形、抽象、隐喻等手法创造了主角之间的梦境和幻想。该片的音乐由日本摇滚乐队RADWIMPS负责，他们为该片创作了多首歌曲和配乐，其中有些歌曲还由原菜乃华和松村北斗亲自演唱。这些音乐不仅符合电影的风格和主题，还能够引起观众的共鸣和感动。$\newline$<br>$\quad$ 最后，《铃芽之旅》突破了新海诚导演对于灾难题材的固有模式，尝试了更加深刻和现实的探讨。该片中出现的灾难不仅是一种外在的威胁，也是一种内在的寓言。灾难源于人类对于时间和生命的扭曲，也反映了人类对于自我和他者的冲突。灾难既是一种惩罚，也是一种救赎。灾难让人类失去了很多东西，也让人类重新思考了很多东西。灾难让人类面临着选择，也让人类看到了希望。该片还直接引入了东日本大震災这一历史事件，并以此为契机展开了对于生死、记忆、责任等话题的思考。$\newline$<br>$\quad$ 综上所述，《铃芽之旅》是新海诚导演的集大成作，不仅有着动人心弦的爱情故事，还有着精彩绝伦的视听享受，更有着深刻而又现实的主题思想。这部电影值得每一个喜欢新海诚作品或者喜欢动画电影或者喜欢爱情故事或者喜欢冒险旅程或者喜欢灵异神秘或者喜欢日本文化或者喜欢美丽风景或者喜欢优美音乐或者喜欢感动落泪或者喜欢思考哲理或者只是单纯想要看一部好电影而已……总之就是值得每一个观众去观看并从中获得自己想要得到的东西。$\newline$</p></blockquote><p>$\quad$ u1s1，ai写的比我好（<br>$\quad$ 音乐和画面一如既往地发挥优秀吧，但是剧情有一说一，不大行了</p><h2 id=""><a href="#" class="headerlink" title=""></a><img src="/../post_img/suzume.png"></h2>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
      <category>影评</category>
      
    </categories>
    
    
    <tags>
      
      <tag>二次元</tag>
      
      <tag>杂谈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>番剧</title>
    <link href="/2023/03/12/anime/"/>
    <url>/2023/03/12/anime/</url>
    
    <content type="html"><![CDATA[<p>记录已看番剧<br>！ 2023.12.01后无补充，<a href="http://bgm.tv/anime/list/aki_yzh/collect">无遗漏请跳转bgm</a></p><span id="more"></span><h3 id="Key社："><a href="#Key社：" class="headerlink" title="Key社："></a>Key社：</h3><p><a href="https://bgm.tv/subject/51">CLANNAD</a><br><a href="https://bgm.tv/subject/876">CLANNAD ～AFTER STORY～</a><br><a href="https://bgm.tv/subject/1851">Angel Beats!</a></p><h3 id="高达类系列："><a href="#高达类系列：" class="headerlink" title="高达类系列："></a>高达类系列：</h3><h5 id="UC"><a href="#UC" class="headerlink" title="UC:"></a>UC:</h5><p><a href="https://bgm.tv/subject/62680">機動戦士ガンダム THE ORIGIN</a><br><a href="https://bgm.tv/subject/349442">機動戦士ガンダム ククルス・ドアンの島</a><br><a href="https://bgm.tv/subject/50">機動戦士ガンダム UC0079</a><br><a href="https://bgm.tv/subject/2664">機動戦士ガンダム 第08MS小隊 UC0079</a><br><a href="https://bgm.tv/subject/1015">機動戦士ガンダム0080 ポケットの中の戦争 UC0080</a><br><a href="https://bgm.tv/subject/804">機動戦士ガンダム0083 STARDUST MEMORY UC0083</a><br><a href="https://bgm.tv/subject/9622">機動戦士Ζガンダム UC0084</a><br><a href="https://bgm.tv/subject/4213">機動戦士ガンダムZZ UC0088</a><br><a href="https://bgm.tv/subject/4583">機動戦士ガンダム 逆襲のシャア UC0093</a><br><a href="https://bgm.tv/subject/3113">機動戦士ガンダム Unicon UC0096</a><br><a href="https://bgm.tv/subject/243428">機動戦士ガンダム NT UC0097</a><br><a href="https://bgm.tv/subject/243429">機動戦士ガンダム 閃光のハサウェイ UC0105</a><br><a href="https://bgm.tv/subject/4482">機動戦士ガンダム F91 UC0123</a><br><a href="https://bgm.tv/subject/985">機動戦士Vガンダム UC0153</a><br><a href="https://bgm.tv/subject/3553">∀ ガンダム</a><br><a href="https://bgm.tv/subject/106834">機動戦士ガンダムさん</a><br><a href="https://bgm.tv/subject/298573">機動戦士SDガンダム</a></p><h5 id="00"><a href="#00" class="headerlink" title="00:"></a>00:</h5><p><a href="https://bgm.tv/subject/286">機動戦士ガンダム 00</a><br><a href="https://bgm.tv/subject/1010">機動戦士ガンダム 00 セカンドシーズン</a><br><a href="https://bgm.tv/subject/5972">劇場版 機動戦士ガンダム 00 -A wakening of the Trailblazer</a></p><h5 id="W"><a href="#W" class="headerlink" title="W:"></a>W:</h5><p><a href="https://bgm.tv/subject/2774">新機動戦記ガンダム W</a><br><a href="https://bgm.tv/subject/2772">新機動戦記ガンダム W Endless Waltz 特別篇</a></p><h5 id="X"><a href="#X" class="headerlink" title="X:"></a>X:</h5><p><a href="https://bgm.tv/subject/3633">機動新世紀ガンダム X</a></p><h5 id="铁华团："><a href="#铁华团：" class="headerlink" title="铁华团："></a>铁华团：</h5><p><a href="https://bgm.tv/subject/139324">機動戦士ガンダム 鉄血のオルフェンズ </a><br><a href="https://bgm.tv/subject/170191">機動戦士ガンダム 鉄血のオルフェンズ 弐</a></p><h5 id="SEED"><a href="#SEED" class="headerlink" title="SEED:"></a>SEED:</h5><p><a href="https://bgm.tv/subject/1860">機動戦士ガンダム SEED</a><br><a href="https://bgm.tv/subject/1861">機動戦士ガンダム SEED DESTINY</a></p><h5 id="雷霆宙域："><a href="#雷霆宙域：" class="headerlink" title="雷霆宙域："></a>雷霆宙域：</h5><p><a href="https://bgm.tv/subject/151345">機動戦士ガンダム サンダーボルト</a><br><a href="https://bgm.tv/subject/198380">機動戦士ガンダム サンダーボルト 第2シーズン </a></p><h5 id="水星的魔女"><a href="#水星的魔女" class="headerlink" title="水星的魔女:"></a>水星的魔女:</h5><p><a href="https://bgm.tv/subject/349441">機動戦士ガンダム 水星の魔女</a><br><a href="https://bgm.tv/subject/403238">機動戦士ガンダム 水星の魔女 Season2</a></p><h5 id="三国伝"><a href="#三国伝" class="headerlink" title="三国伝:"></a>三国伝:</h5><p><a href="https://bgm.tv/subject/4294">SDガンダム三国伝 Brave Battle Warriors</a></p><h5 id="创战"><a href="#创战" class="headerlink" title="创战"></a>创战</h5><p><a href="https://bgm.tv/subject/105875">ガンダムビルドファイターズトライ</a><br><a href="https://bgm.tv/subject/182406">ガンダムビルドファイターズトライ アイランド・ウォーズ</a><br><a href="https://bgm.tv/subject/434818">ガンダムビルドメタバース</a><br><a href="https://bgm.tv/subject/339095">ガンダムブレイカー バトローグ</a></p><h5 id="天使与龙的轮舞"><a href="#天使与龙的轮舞" class="headerlink" title="天使与龙的轮舞"></a>天使与龙的轮舞</h5><p><a href="https://bgm.tv/subject/109948">クロスアンジュ 天使と竜の輪舞</a></p><h3 id="异世界类"><a href="#异世界类" class="headerlink" title="异世界类:"></a>异世界类:</h3><h5 id="盾娘："><a href="#盾娘：" class="headerlink" title="盾娘："></a>盾娘：</h5><p><a href="https://bgm.tv/subject/302766">痛いのは嫌なので防御力に極振りしたいと思います。2 </a><br><a href="https://bgm.tv/subject/268545">痛いのは嫌なので防御力に極振りしたいと思います</a></p><h5 id="OVERLORD："><a href="#OVERLORD：" class="headerlink" title="OVERLORD："></a>OVERLORD：</h5><p><a href="https://bgm.tv/subject/112146">OVERLORD</a><br><a href="https://bgm.tv/subject/211027">OVERLORD II</a><br><a href="https://bgm.tv/subject/242170">OVERLORD III</a><br><a href="https://bgm.tv/subject/335389">OVERLORD IV</a></p><h5 id="无职："><a href="#无职：" class="headerlink" title="无职："></a>无职：</h5><p><a href="https://bgm.tv/subject/277554">無職転生 ～異世界行ったら本気だす～</a><br><a href="https://bgm.tv/subject/325585">無職転生 ～異世界行ったら本気だす～ 第2クール</a><br><a href="https://bgm.tv/subject/373247">無職転生Ⅱ ～異世界行ったら本気だす～</a></p><h5 id="异世界四重奏："><a href="#异世界四重奏：" class="headerlink" title="异世界四重奏："></a>异世界四重奏：</h5><p><a href="https://bgm.tv/subject/262865">異世界かるてっと</a><br><a href="https://bgm.tv/subject/285422">異世界かるてっと 2</a><br><a href="https://bgm.tv/subject/303126">劇場版 異世界かるてっと ～あなざーわーるど～</a></p><h5 id="素晴："><a href="#素晴：" class="headerlink" title="素晴："></a>素晴：</h5><p><a href="https://bgm.tv/subject/135275">この素晴らしい世界に祝福を！</a><br><a href="https://bgm.tv/subject/174043">この素晴らしい世界に祝福を！2</a><br><a href="https://bgm.tv/subject/220631">映画 この素晴らしい世界に祝福を！紅伝説</a><br><a href="https://bgm.tv/subject/385209">この素晴らしい世界に爆焔を!</a></p><h5 id="Re0"><a href="#Re0" class="headerlink" title="Re0:"></a>Re0:</h5><p><a href="https://bgm.tv/subject/140001">Re:ゼロから始める異世界生活</a><br><a href="https://bgm.tv/subject/278826">Re:ゼロから始める異世界生活 2nd season</a><br><a href="https://bgm.tv/subject/316247">Re:ゼロから始める異世界生活 2nd season 後半クール</a><br><a href="https://bgm.tv/subject/225462">Re:ゼロから始める異世界生活 Memory Snow</a></p><h5 id="幼女战记："><a href="#幼女战记：" class="headerlink" title="幼女战记："></a>幼女战记：</h5><p><a href="https://bgm.tv/subject/167655">幼女戦記</a><br><a href="https://bgm.tv/subject/234771">劇場版 幼女戦記</a></p><h5 id="エロ："><a href="#エロ：" class="headerlink" title="エロ："></a>エロ：</h5><p><a href="https://bgm.tv/subject/295017">回復術士のやり直し</a><br><a href="https://bgm.tv/subject/285482">異種族レビュアーズ</a><br><a href="https://bgm.tv/subject/291195">ピーター・グリルと賢者の時間</a><br><a href="https://bgm.tv/subject/356793">ピーター・グリルと賢者の時間 Super Extra</a><br><a href="https://bgm.tv/subject/373712">不徳のギルド</a><br><a href="https://bgm.tv/subject/374319">犬になったら好きな人に拾われた。</a></p><h5 id="default："><a href="#default：" class="headerlink" title="default："></a>default：</h5><p><a href="https://bgm.tv/subject/339326">異世界おじさん</a><br><a href="https://bgm.tv/subject/326868">天才王子の赤字国家再生術</a><br><a href="https://bgm.tv/subject/333176">このヒーラー、めんどくさい</a><br><a href="https://bgm.tv/subject/336458">異世界美少女受肉おじさんと</a><br><a href="https://bgm.tv/subject/264089">乙女ゲームの破滅フラグしかない悪役令嬢に転生してしまった…</a><br><a href="https://bgm.tv/subject/353657">勇者、辞めま</a><br><a href="https://bgm.tv/subject/48669">戦勇。</a><br><a href="https://bgm.tv/subject/69165">戦勇。第2期</a><br><a href="https://bgm.tv/subject/379639">勇者が死んだ！</a><br><a href="https://bgm.tv/subject/377607">神無き世界のカミサマ活動</a><br><a href="https://bgm.tv/subject/389571">マッシュル-MASHLE-</a><br><a href="https://bgm.tv/subject/376106">Lv1魔王とワンルーム勇者</a><br><a href="https://bgm.tv/subject/369784">Helck</a><br><a href="https://bgm.tv/subject/390980">シャングリラ・フロンティア～クソゲーハンター、神ゲーに挑まんとす～</a></p><h3 id="恋爱番："><a href="#恋爱番：" class="headerlink" title="恋爱番："></a>恋爱番：</h3><h5 id="高木类："><a href="#高木类：" class="headerlink" title="高木类："></a>高木类：</h5><p><a href="https://bgm.tv/subject/219200">からかい上手の高木さん</a><br><a href="https://bgm.tv/subject/271151">からかい上手の高木さん②</a><br><a href="https://bgm.tv/subject/347887">からかい上手の高木さん③</a><br><a href="https://bgm.tv/subject/347888">劇場版 からかい上手の高木さん</a><br><a href="https://bgm.tv/subject/324728">それでも歩は寄せてくる</a></p><h5 id="告白实行委员会："><a href="#告白实行委员会：" class="headerlink" title="告白实行委员会："></a>告白实行委员会：</h5><p><a href="https://bgm.tv/subject/212005">いつだって僕らの恋は10センチだった。</a><br><a href="https://bgm.tv/subject/140020">ずっと前から好きでした。～告白実行委員会～</a><br><a href="https://bgm.tv/subject/126798">告白実行委員会 告白予行練習 ショートストーリー</a><br><a href="https://bgm.tv/subject/175543">好きになるその瞬間を。～告白実行委員会～</a></p><h5 id="辉夜："><a href="#辉夜：" class="headerlink" title="辉夜："></a>辉夜：</h5><p><a href="https://bgm.tv/subject/248175">かぐや様は告らせたい～天才たちの恋愛頭脳戦～</a><br><a href="https://bgm.tv/subject/293049">かぐや様は告らせたい？～天才たちの恋愛頭脳戦～</a><br><a href="https://bgm.tv/subject/317613">かぐや様は告らせたい-ウルトラロマンティック-</a><br><a href="https://bgm.tv/subject/389474">かぐや様は告らせたい-ファーストキッスは終わらない-</a></p><h5 id="新海诚："><a href="#新海诚：" class="headerlink" title="新海诚："></a>新海诚：</h5><p><a href="https://bgm.tv/subject/927">秒速5センチメートル</a><br><a href="https://bgm.tv/subject/269235">天気の子</a><br><a href="https://bgm.tv/subject/160209">君の名は</a><br><a href="https://bgm.tv/subject/58949">言の葉の庭</a><br><a href="https://bgm.tv/subject/362577">すずめの戸締まり</a></p><h5 id="中二病："><a href="#中二病：" class="headerlink" title="中二病："></a>中二病：</h5><p><a href="https://bgm.tv/subject/29648">中二病でも恋がしたい！</a><br><a href="https://bgm.tv/subject/72942">中二病でも恋がしたい！戀</a><br><a href="https://bgm.tv/subject/215425">映画 中二病でも恋がしたい！ -Take On Me-</a></p><h5 id="鸭志田一："><a href="#鸭志田一：" class="headerlink" title="鸭志田一："></a>鸭志田一：</h5><p><a href="https://bgm.tv/subject/212278">Just Because!</a><br><a href="https://bgm.tv/subject/41488">さくら荘のペットな彼女</a><br><a href="https://bgm.tv/subject/240038">青春ブタ野郎はバニーガール先輩の夢を見ない</a><br><a href="https://bgm.tv/subject/260680">青春ブタ野郎はゆめみる少女の夢を見ない</a><br><a href="https://bgm.tv/subject/402656">青春ブタ野郎はおでかけシスターの夢を見ない</a><br><a href="https://bgm.tv/subject/426239">青春ブタ野郎はランドセルガールの夢を見ない</a></p><h5 id="XX学妹类："><a href="#XX学妹类：" class="headerlink" title="XX学妹类："></a>XX学妹类：</h5><p><a href="https://bgm.tv/subject/299498">宇崎ちゃんは遊びたい!</a><br><a href="https://bgm.tv/subject/315744">宇崎ちゃんは遊びたい！ω</a><br><a href="https://bgm.tv/subject/309753">イジらないで、長瀞さん</a><br><a href="https://bgm.tv/subject/354042">イジらないで、長瀞さん 2nd Attack</a></p><h5 id="五等分的花嫁："><a href="#五等分的花嫁：" class="headerlink" title="五等分的花嫁："></a>五等分的花嫁：</h5><p><a href="https://bgm.tv/subject/256114">五等分の花嫁</a><br><a href="https://bgm.tv/subject/282000">五等分の花嫁∬</a><br><a href="https://bgm.tv/subject/331489">映画 五等分の花嫁</a></p><h5 id="default：-1"><a href="#default：-1" class="headerlink" title="default："></a>default：</h5><p><a href="https://bgm.tv/subject/117153">俺物語!!</a><br><a href="https://bgm.tv/subject/301541">トニカクカワイイ</a><br><a href="https://bgm.tv/subject/909">とらドラ!</a><br><a href="https://bgm.tv/subject/327055">死神坊ちゃんと黒メイド</a><br><a href="https://bgm.tv/subject/349319">死神坊ちゃんと黒メイド 第2期</a><br><a href="https://bgm.tv/subject/343656">阿波連さんははかれない</a><br><a href="https://bgm.tv/subject/100449">月刊少女野崎くん</a><br><a href="https://bgm.tv/subject/40533">となりの怪物くん</a><br><a href="https://bgm.tv/subject/271145">理系が恋に落ちたので証明してみた</a><br><a href="https://bgm.tv/subject/317042">理系が恋に落ちたので証明してみた。r&#x3D;1-sinθ</a><br><a href="https://bgm.tv/subject/332446">恋は世界征服のあとで</a><br><a href="https://bgm.tv/subject/207573">月がきれい</a><br><a href="https://bgm.tv/subject/208754">徒然チルドレン</a><br><a href="https://bgm.tv/subject/55113">たまこまーけっと</a><br><a href="https://bgm.tv/subject/90880">たまこラブストーリー</a><br><a href="https://bgm.tv/subject/48034">琴浦さん</a><br><a href="https://bgm.tv/subject/27364">氷菓</a><br><a href="https://bgm.tv/subject/309670">先輩がうざい後輩の話</a><br><a href="https://bgm.tv/subject/100444">四月は君の嘘</a><br><a href="https://bgm.tv/subject/114685">プラスティック・メモリーズ</a><br><a href="https://bgm.tv/subject/172498">エロマンガ先生</a><br><a href="https://bgm.tv/subject/356774">よふかしのうた</a><br><a href="https://bgm.tv/subject/375735">恋愛フロップス</a><br><a href="https://bgm.tv/subject/343106">継母の連れ子が元カノだった</a><br><a href="https://bgm.tv/subject/375817">Engage Kiss</a><br><a href="https://bgm.tv/subject/324295">可愛いだけじゃない式守さん</a><br><a href="https://bgm.tv/subject/333158">その着せ替え人形は恋をする</a><br><a href="https://bgm.tv/subject/194877">月曜日のたわわ</a><br><a href="https://bgm.tv/subject/349616">月曜日のたわわ2</a><br><a href="https://bgm.tv/subject/346242">がんばれ同期ちゃん</a><br><a href="https://bgm.tv/subject/295778">ジョゼと虎と魚たち</a><br><a href="https://bgm.tv/subject/117777">聲の形</a><br><a href="https://bgm.tv/subject/221736">君の膵臓をたべたい</a><br><a href="https://bgm.tv/subject/363308">ツンデレ悪役令嬢リーゼロッテと実況の遠藤くんと解説の小林さん</a><br><a href="https://bgm.tv/subject/390618">トモちゃんは女の子!</a><br><a href="https://bgm.tv/subject/49278">境界の彼方</a><br><a href="https://bgm.tv/subject/118908">境界の彼方 -I’LL BE HERE- 未来篇</a><br><a href="https://bgm.tv/subject/221293">ネト充のススメ</a><br><a href="https://bgm.tv/subject/394260">僕の心のヤバイやつ</a><br><a href="https://bgm.tv/subject/365437">君は放課後インソムニア</a><br><a href="https://bgm.tv/subject/253628">ドメスティックな彼女</a><br><a href="https://bgm.tv/subject/174143">クズの本懐</a><br><a href="https://bgm.tv/subject/315069">ホリミヤ</a><br><a href="https://bgm.tv/subject/45842">変態王子と笑わない猫。</a><br><a href="https://bgm.tv/subject/100403">冴えない彼女の育てかた</a><br><a href="https://bgm.tv/subject/132734">冴えない彼女の育てかた ♭</a><br><a href="https://bgm.tv/subject/231497">冴えない彼女の育てかた Fine</a><br><a href="https://bgm.tv/subject/278557">空の青さを知る人よ</a><br><a href="https://bgm.tv/subject/119344">心が叫びたがってるんだ。</a><br><a href="https://bgm.tv/subject/319513">カノジョも彼女</a><br><a href="https://bgm.tv/subject/398949">カノジョも彼女 Season 2</a><br><a href="https://bgm.tv/subject/208450">アホガール</a><br><a href="https://bgm.tv/subject/28230">さんかれあ</a><br><a href="https://bgm.tv/subject/41612">さんかれあ OAD</a><br><a href="https://bgm.tv/subject/424379">君のことが大大大大大好きな100人の彼女</a><br><a href="https://bgm.tv/subject/416019">てんぷる</a></p><h3 id="轻百："><a href="#轻百：" class="headerlink" title="轻百："></a>轻百：</h3><h5 id="京吹："><a href="#京吹：" class="headerlink" title="京吹："></a>京吹：</h5><p><a href="https://bgm.tv/subject/115908">響け！ユーフォニアム</a><br><a href="https://bgm.tv/subject/152091">響け！ユーフォニアム2</a><br><a href="https://bgm.tv/subject/216372">劇場版 響け！ユーフォニアム～誓いのフィナーレ～</a><br><a href="https://bgm.tv/subject/386195">特別編 響け！ユーフォニアム～アンサンブルコンテスト～</a><br><a href="https://bgm.tv/subject/216371">リズと青い鳥</a></p><h5 id="少歌："><a href="#少歌：" class="headerlink" title="少歌："></a>少歌：</h5><p><a href="https://bgm.tv/subject/214265">少女☆歌劇 レヴュースタァライト</a><br><a href="https://bgm.tv/subject/294135">劇場版 少女☆歌劇 レヴュースタァライト</a></p><h5 id="轻音："><a href="#轻音：" class="headerlink" title="轻音："></a>轻音：</h5><p><a href="https://bgm.tv/subject/1424">けいおん!</a><br><a href="https://bgm.tv/subject/3774">けいおん!!</a><br><a href="https://bgm.tv/subject/12426">映画 けいおん!</a></p><h5 id="default：-2"><a href="#default：-2" class="headerlink" title="default："></a>default：</h5><p><a href="https://bgm.tv/subject/328609">ぼっち・ざ・ろっく!</a><br><a href="https://bgm.tv/subject/9717">魔法少女まどか☆マギカ</a><br><a href="https://bgm.tv/subject/241158">となりの吸血鬼さん</a><br><a href="https://bgm.tv/subject/179949">小林さんちのメイドラゴン</a><br><a href="https://bgm.tv/subject/274234">小林さんちのメイドラゴンS</a><br><a href="https://bgm.tv/subject/364450">リコリス・リコイル</a><br><a href="https://bgm.tv/subject/292970">魔女の旅々</a><br><a href="https://bgm.tv/subject/188091">ガヴリールドロップアウト</a><br><a href="https://bgm.tv/subject/193282">にゃんこデイズ</a><br><a href="https://bgm.tv/subject/376565">4人はそれぞれウソをつく</a><br><a href="https://bgm.tv/subject/395714">転生王女と天才令嬢の魔法革命</a><br><a href="https://bgm.tv/subject/378862">お兄ちゃんはおしまい！</a><br><a href="https://bgm.tv/subject/276187">ソウナンですか？</a><br><a href="https://bgm.tv/subject/428735">BanG Dream! It’s MyGO!!!!!</a><br><a href="https://bgm.tv/subject/400551">でこぼこ魔女の親子事情</a></p><h3 id="EVA"><a href="#EVA" class="headerlink" title="EVA:"></a>EVA:</h3><p><a href="https://bgm.tv/subject/265">新世紀エヴァンゲリオン</a><br><a href="https://bgm.tv/subject/6048">新世紀エヴァンゲリオン劇場版 シト新生</a><br><a href="https://bgm.tv/subject/6049">新世紀エヴァンゲリオン劇場版 Air&#x2F;まごころを、君に</a><br><a href="https://bgm.tv/subject/772">ヱヴァンゲリヲン新劇場版:序</a><br><a href="https://bgm.tv/subject/3302">ヱヴァンゲリヲン新劇場版:破</a><br><a href="https://bgm.tv/subject/22505">ヱヴァンゲリヲン新劇場版:Q</a><br><a href="https://bgm.tv/subject/29883">シン・エヴァンゲリオン劇場版:│▌</a></p><h3 id="进击的巨人"><a href="#进击的巨人" class="headerlink" title="进击的巨人"></a>进击的巨人</h3><p><a href="https://bgm.tv/subject/55770">進撃の巨人</a><br><a href="https://bgm.tv/subject/118335">進撃の巨人 Season 2</a><br><a href="https://bgm.tv/subject/217300">進撃の巨人 Season 3</a><br><a href="https://bgm.tv/subject/285666">進撃の巨人 The Final Season</a><br><a href="https://bgm.tv/subject/376739">進撃の巨人 The Final Season 完結編</a></p><h3 id="魔禁系列："><a href="#魔禁系列：" class="headerlink" title="魔禁系列："></a>魔禁系列：</h3><p><a href="https://bgm.tv/subject/1014">とある魔術の禁書目録</a><br><a href="https://bgm.tv/subject/7843">とある魔術の禁書目録Ⅱ</a><br><a href="https://bgm.tv/subject/226540">とある魔術の禁書目録Ⅲ</a><br><a href="https://bgm.tv/subject/26804">とある魔術の禁書目録 エンデュミオンの奇蹟</a><br><a href="https://bgm.tv/subject/2585">とある科学の超電磁砲</a><br><a href="https://bgm.tv/subject/51928">とある科学の超電磁砲S</a><br><a href="https://bgm.tv/subject/262940">とある科学の超電磁砲T</a><br><a href="https://bgm.tv/subject/262939">とある科学の一方通行</a></p><h3 id="鲁邦："><a href="#鲁邦：" class="headerlink" title="鲁邦："></a>鲁邦：</h3><p><a href="https://bgm.tv/subject/115661">ルパン三世 PART4</a><br><a href="https://bgm.tv/subject/219164">ルパン三世 PART5</a><br><a href="https://bgm.tv/subject/337430">ルパン三世 PART6</a><br><a href="https://bgm.tv/subject/100437">LUPIN THE IIIRD 次元大介の墓標</a><br><a href="https://bgm.tv/subject/36355">LUPIN the Third ～峰不二子という女～</a><br><a href="https://bgm.tv/subject/192442">LUPIN THE IIIRD 血煙の石川五ェ門</a><br><a href="https://bgm.tv/subject/286238">ルパン三世 THE FIRST</a><br><a href="https://bgm.tv/subject/405990">LUPIN ZERO ルパンゼロ</a><br><a href="https://bgm.tv/subject/314">ルパン三世 カリオストロの城</a></p><h3 id="鲁鲁修："><a href="#鲁鲁修：" class="headerlink" title="鲁鲁修："></a>鲁鲁修：</h3><p><a href="https://bgm.tv/subject/793">コードギアス 反逆のルルーシュ</a><br><a href="https://bgm.tv/subject/8">コードギアス 反逆のルルーシュR2</a><br><a href="https://bgm.tv/subject/199228">コードギアス 復活のルルーシュ</a></p><h3 id="Love-Live-："><a href="#Love-Live-：" class="headerlink" title="Love Live!："></a>Love Live!：</h3><p><a href="https://bgm.tv/subject/49294">ラブライブ!</a><br><a href="https://bgm.tv/subject/75989">ラブライブ! 第2期</a><br><a href="https://bgm.tv/subject/107199">ラブライブ! The School Idol Movie</a><br><a href="https://bgm.tv/subject/165553">ラブライブ! サンシャイン!!</a><br><a href="https://bgm.tv/subject/210272">ラブライブ! サンシャイン!! 第2期</a><br><a href="https://bgm.tv/subject/234295">ラブライブ!サンシャイン!! The School Idol Movie Over the Rainbow</a><br><a href="https://bgm.tv/subject/389772">幻日のヨハネ -SUNSHINE in the MIRROR-</a><br><a href="https://bgm.tv/subject/296659">ラブライブ！虹ヶ咲学園スクールアイドル同好会</a><br><a href="https://bgm.tv/subject/335579">ラブライブ！虹ヶ咲学園スクールアイドル同好会 2期</a><br><a href="https://bgm.tv/subject/408883">ラブライブ！虹ヶ咲学園スクールアイドル同好会 NEXT SKY</a><br><a href="https://bgm.tv/subject/401960">にじよん あにめーしょん</a><br><a href="https://bgm.tv/subject/306742">ラブライブ！スーパースター!!</a><br><a href="https://bgm.tv/subject/376703">アイドルマスター シンデレラガールズ U149</a></p><h3 id="少战："><a href="#少战：" class="headerlink" title="少战："></a>少战：</h3><p><a href="https://bgm.tv/subject/40310">ガールズ&amp;パンツァー</a><br><a href="https://bgm.tv/subject/72266">ガールズ&amp;パンツァー 劇場版</a><br><a href="https://bgm.tv/subject/191302">ガールズ&amp;パンツァー 最終章 第1話</a><br><a href="https://bgm.tv/subject/208825">ガールズ&amp;パンツァー 最終章 第2話</a><br><a href="https://bgm.tv/subject/208826">ガールズ&amp;パンツァー 最終章 第3話</a><br><a href="https://bgm.tv/subject/208827">ガールズ&amp;パンツァー 最終章 第4話</a></p><h3 id="美漫"><a href="#美漫" class="headerlink" title="美漫"></a>美漫</h3><p><a href="https://bgm.tv/subject/93377">Rick and Morty Season 1~6</a><br><a href="https://bgm.tv/subject/406268">Family Guy Season 1~15</a><br><a href="https://bgm.tv/subject/19889">The Simpsons Season 1~31</a></p><h3 id="JOJO"><a href="#JOJO" class="headerlink" title="JOJO:"></a>JOJO:</h3><p><a href="https://bgm.tv/subject/43558">ジョジョの奇妙な冒険</a><br><a href="https://bgm.tv/subject/85631">ジョジョの奇妙な冒険 スターダストクルセイダース</a><br><a href="https://bgm.tv/subject/113292">ジョジョの奇妙な冒険 スターダストクルセイダース</a><br><a href="https://bgm.tv/subject/150490">ジョジョの奇妙な冒険 ダイヤモンドは砕けない</a><br><a href="https://bgm.tv/subject/235128">ジョジョの奇妙な冒険 黄金の風</a><br><a href="https://bgm.tv/subject/332261">ジョジョの奇妙な冒険 ストーンオーシャン</a><br><a href="https://bgm.tv/subject/375913">ジョジョの奇妙な冒険 ストーンオーシャン 第2クール</a><br><a href="https://bgm.tv/subject/395782">ジョジョの奇妙な冒険 ストーンオーシャン 第3クール</a><br><a href="https://bgm.tv/subject/289138">岸辺露伴は動かない</a></p><h3 id="民工漫："><a href="#民工漫：" class="headerlink" title="民工漫："></a>民工漫：</h3><p><a href="https://bgm.tv/subject/247">銀魂 全季度</a><br><a href="https://bgm.tv/subject/1600">BLEACH</a><br><a href="https://bgm.tv/subject/302286">BLEACH 千年血戦篇</a><br><a href="https://bgm.tv/subject/412916">BLEACH 千年血戦篇-訣別譚-</a><br><a href="https://bgm.tv/subject/34373">NARUTO -ナルト-</a><br><a href="https://bgm.tv/subject/351712">名探偵コナン 犯人の犯沢さん</a><br><a href="https://bgm.tv/subject/2784">犬夜叉</a><br><a href="https://bgm.tv/subject/28496">NARUTO-ナルト- SD ロック・リーの青春フルパワー忍伝</a><br><a href="https://bgm.tv/subject/411246">ポケットモンスター めざせポケモンマスター</a><br><a href="https://bgm.tv/subject/364468">うる星やつら</a><br><a href="https://bgm.tv/subject/294993">呪術廻戦</a><br><a href="https://bgm.tv/subject/369304">呪術廻戦 第2期</a><br><a href="https://bgm.tv/subject/331559">劇場版 呪術廻戦 0</a><br><a href="https://bgm.tv/subject/402128">Fate&#x2F;strange Fake -Whispers of Dawn-</a></p><h3 id="数码宝贝"><a href="#数码宝贝" class="headerlink" title="数码宝贝"></a>数码宝贝</h3><p><a href="https://bgm.tv/subject/3128">デジモンアドベンチャー</a><br><a href="https://bgm.tv/subject/3129">デジモンアドベンチャー02</a><br><a href="https://bgm.tv/subject/3130">デジモンテイマーズ</a><br><a href="https://bgm.tv/subject/3131">デジモンフロンティア</a><br><a href="https://bgm.tv/subject/3132">デジモンセイバーズ</a><br><a href="https://bgm.tv/subject/4631">デジモンクロスウォーズ</a><br><a href="https://bgm.tv/subject/183216">デジモンユニバース アプリモンスターズ</a><br><a href="https://bgm.tv/subject/109739">デジモンアドベンチャー tri. 第1章「再会」</a><br><a href="https://bgm.tv/subject/156734">デジモンアドベンチャー tri. 第2章「決意」</a><br><a href="https://bgm.tv/subject/165892">デジモンアドベンチャー tri. 第3章「告白</a><br><a href="https://bgm.tv/subject/192202">デジモンアドベンチャー tri. 第4章「喪失」</a><br><a href="https://bgm.tv/subject/192203">デジモンアドベンチャー tri. 第5章「共生」</a><br><a href="https://bgm.tv/subject/192204">デジモンアドベンチャー tri. 第6章「ぼくらの未来」</a><br><a href="https://bgm.tv/subject/255547">デジモンアドベンチャー LAST EVOLUTION 絆</a></p><h3 id="日常番："><a href="#日常番：" class="headerlink" title="日常番："></a>日常番：</h3><p><a href="https://bgm.tv/subject/9912">日常</a><br><a href="https://bgm.tv/subject/24790">男子高校生の日常</a><br><a href="https://bgm.tv/subject/265708">女子高生の無駄づかい</a><br><a href="https://bgm.tv/subject/235130">ぐらんぶる</a><br><a href="https://bgm.tv/subject/165829">坂本ですが？</a><br><a href="https://bgm.tv/subject/204145">ブレンド・S </a><br><a href="https://bgm.tv/subject/127563">ワンパンマン</a><br><a href="https://bgm.tv/subject/193619">ワンパンマン 第2期</a><br><a href="https://bgm.tv/subject/333664">であいもん</a><br><a href="https://bgm.tv/subject/387803">江戸前エルフ</a><br><a href="https://bgm.tv/subject/5649">生徒会役員共+OAD+OVA</a><br><a href="https://bgm.tv/subject/85204">生徒会役員共*+OAD+OVA</a><br><a href="https://bgm.tv/subject/200887">劇場版 生徒会役員共</a><br><a href="https://bgm.tv/subject/295918">劇場版 生徒会役員共2</a><br><a href="https://bgm.tv/subject/120187">干物妹! うまるちゃん</a><br><a href="https://bgm.tv/subject/212775">干物妹! うまるちゃんR</a><br><a href="https://bgm.tv/subject/80548">ディーふらぐ!</a><br><a href="https://bgm.tv/subject/414461">ゾン100～ゾンビになるまでにしたい100のこと～</a><br><a href="https://bgm.tv/subject/384672">デキる猫は今日も憂鬱</a><br><a href="https://bgm.tv/subject/294991">どうにかなる日々</a><br>[斉木楠雄のΨ難](<a href="https://bgm.tv/subject/181354">https://bgm.tv/subject/181354</a> “)<br><a href="https://bgm.tv/subject/204027">斉木楠雄のΨ難 第2期</a><br><a href="https://bgm.tv/subject/251831">斉木楠雄のΨ難 完結編</a><br><a href="https://bgm.tv/subject/278899">斉木楠雄のΨ難 Ψ始動編</a><br><a href="https://bgm.tv/subject/69214">私がモテないのはどう考えてもお前らが悪い!</a><br><a href="https://bgm.tv/subject/4019">四畳半神話大系</a><br><a href="https://bgm.tv/subject/202240">夜は短し歩けよ乙女</a><br><a href="https://bgm.tv/subject/345980">四畳半タイムマシンブルース</a></p><h3 id="default"><a href="#default" class="headerlink" title="default:"></a>default:</h3><h5 id="国创："><a href="#国创：" class="headerlink" title="国创："></a>国创：</h5><p><a href="https://bgm.tv/subject/29399">围棋少年</a><br><a href="https://bgm.tv/subject/23446">Q版三国</a><br><a href="https://bgm.tv/subject/358660">中国奇谭</a><br><a href="https://bgm.tv/subject/151101">深海</a></p><h5 id="间谍过家家："><a href="#间谍过家家：" class="headerlink" title="间谍过家家："></a>间谍过家家：</h5><p><a href="https://bgm.tv/subject/329906">SPY×FAMILY</a><br><a href="https://bgm.tv/subject/373267">SPY×FAMILY 第2クール</a></p><h5 id="赛马娘："><a href="#赛马娘：" class="headerlink" title="赛马娘："></a>赛马娘：</h5><p><a href="https://bgm.tv/subject/212003">ウマ娘 プリティーダービー</a><br><a href="https://bgm.tv/subject/315574">ウマ娘 プリティーダービー Season 2</a><br><a href="https://bgm.tv/subject/407332">ウマ娘 プリティーダービー Season 3</a><br><a href="https://bgm.tv/subject/380448">ウマ娘 プリティーダービー Road to the Top</a></p><h5 id="狂赌之渊："><a href="#狂赌之渊：" class="headerlink" title="狂赌之渊："></a>狂赌之渊：</h5><p><a href="https://bgm.tv/subject/209408">賭ケグルイ</a><br><a href="https://bgm.tv/subject/234778">賭ケグルイ××</a><br><a href="https://bgm.tv/subject/356658">賭ケグルイ双</a></p><h5 id="鬼灭："><a href="#鬼灭：" class="headerlink" title="鬼灭："></a>鬼灭：</h5><p><a href="https://bgm.tv/subject/245665">鬼滅の刃</a><br><a href="https://bgm.tv/subject/291494">劇場版 鬼滅の刃 無限列車編</a><br><a href="https://bgm.tv/subject/328195">鬼滅の刃 遊郭編</a><br><a href="https://bgm.tv/subject/369768">鬼滅の刃 刀鍛冶の里編</a></p><h5 id="极主夫道："><a href="#极主夫道：" class="headerlink" title="极主夫道："></a>极主夫道：</h5><p><a href="https://bgm.tv/subject/317691">極主夫道</a><br><a href="https://bgm.tv/subject/332696">極主夫道 パート2</a><br><a href="https://bgm.tv/subject/402740">極主夫道 シーズン2</a></p><h5 id="人类痛经："><a href="#人类痛经：" class="headerlink" title="人类痛经："></a>人类痛经：</h5><p><a href="https://bgm.tv/subject/212279">ポプテピピック</a><br><a href="https://bgm.tv/subject/363600">ポプテピピック TVアニメーション作品第二シリーズ</a></p><h5 id="动物狂想曲："><a href="#动物狂想曲：" class="headerlink" title="动物狂想曲："></a>动物狂想曲：</h5><p><a href="https://bgm.tv/subject/273843">BEASTARS</a><br><a href="https://bgm.tv/subject/297224">BEASTARS 2nd Season</a></p><h5 id="虚构推理："><a href="#虚构推理：" class="headerlink" title="虚构推理："></a>虚构推理：</h5><p><a href="https://bgm.tv/subject/271687">虚構推理</a><br><a href="https://bgm.tv/subject/320839">虚構推理 Season2</a></p><h5 id="逆天："><a href="#逆天：" class="headerlink" title="逆天："></a>逆天：</h5><p><a href="https://bgm.tv/subject/182341">おなら吾郎</a><br><a href="https://bgm.tv/subject/37567">悪いのを倒せ！！サラリーマンマン</a><br><a href="https://bgm.tv/subject/389450">アキバ冥途戦争</a><br><a href="https://bgm.tv/subject/110048">監獄学園</a></p><h5 id="default：-3"><a href="#default：-3" class="headerlink" title="default："></a>default：</h5><p><a href="https://bgm.tv/subject/1773">DEATH NOTE</a><br><a href="https://bgm.tv/subject/88433">寄生獣 セイの格率</a><br><a href="https://bgm.tv/subject/218453">伊藤潤二『コレクション』</a><br><a href="https://bgm.tv/subject/384280">伊藤潤二『マニアック』</a><br><a href="https://bgm.tv/subject/240838">どろろ</a><br><a href="https://bgm.tv/subject/297022">憂国のモリアーティ</a><br><a href="https://bgm.tv/subject/319252">憂国のモリアーティ 2クール目</a><br><a href="https://bgm.tv/subject/347818">憂国のモリアーティ～百合の追憶～</a><br><a href="https://bgm.tv/subject/1959">MONSTER</a><br><a href="https://bgm.tv/subject/158316">モブサイコ100</a><br><a href="https://bgm.tv/subject/240760">モブサイコ100 Ⅱ</a><br><a href="https://bgm.tv/subject/353605">モブサイコ100 Ⅲ</a><br><a href="https://bgm.tv/subject/325285">オッドタクシー</a><br><a href="https://bgm.tv/subject/316607">ワンダーエッグ・プライオリティ</a><br><a href="https://bgm.tv/subject/37785">新世界より</a><br><a href="https://bgm.tv/subject/326895">サマータイムレンダ</a><br><a href="https://bgm.tv/subject/90597">トモダチゲーム</a><br><a href="https://bgm.tv/subject/321885">チェンソーマン</a><br><a href="https://bgm.tv/subject/193378">サクラダリセット</a><br><a href="https://bgm.tv/subject/10440">あの日見た花の名前を僕達はまだ知らない</a><br><a href="https://bgm.tv/subject/223563">映画大好きポンポさん</a><br><a href="https://bgm.tv/subject/965">BACCANO! -バッカーノ!-</a><br><a href="https://bgm.tv/subject/294713">かくしごと</a><br><a href="https://bgm.tv/subject/356756">パリピ孔明</a><br><a href="https://bgm.tv/subject/249637">私に天使が舞い降りた！</a><br><a href="https://bgm.tv/subject/320493">私に天使が舞い降りた！プレシャス・フレンズ</a><br><a href="https://bgm.tv/subject/309311">Cyberpunk: Edgerunners</a><br><a href="https://bgm.tv/subject/20851">Another</a><br><a href="https://bgm.tv/subject/335036">Arcane</a><br><a href="https://bgm.tv/subject/22759">花咲くいろは</a><br><a href="https://bgm.tv/subject/49892">劇場版 花咲くいろは HOME SWEET HOME</a><br><a href="https://bgm.tv/subject/289">ひぐらしのなく頃に</a><br><a href="https://bgm.tv/subject/325808">地獄楽</a><br><a href="https://bgm.tv/subject/404804">天国大魔境</a><br><a href="https://bgm.tv/subject/388067">マイホームヒーロー</a><br><a href="https://bgm.tv/subject/3892">逆境無頼カイジ Ultimate Survivor </a><br><a href="https://bgm.tv/subject/12317">逆境無頼カイジ 破戒録篇</a><br><a href="https://bgm.tv/subject/311">千と千尋の神隠し</a><br><a href="https://bgm.tv/subject/310">もののけ姫</a><br><a href="https://bgm.tv/subject/307">紅の豚</a><br><a href="https://bgm.tv/subject/386809">【推しの子】</a><br> <a href="https://bgm.tv/subject/82572">ノラガミ</a><br><a href="https://bgm.tv/subject/129988">ノラガミ ARAGOTO</a><br><a href="https://bgm.tv/subject/302189">86―エイティシックス―</a><br><a href="https://bgm.tv/subject/331887">86―エイティシックス― 第2クール</a><br><a href="https://bgm.tv/subject/425937">終末のワルキューレⅡ 後編</a><br><a href="https://bgm.tv/subject/346982">終末のワルキューレⅡ 前編</a><br><a href="https://bgm.tv/subject/322900">終末のワルキューレ</a><br><a href="https://bgm.tv/subject/62893">グラップラー刃牙</a><br><a href="https://bgm.tv/subject/317852">範馬刃牙</a><br><a href="https://bgm.tv/subject/375541">範馬刃牙 2期</a><br><a href="https://bgm.tv/subject/199373">バキ</a><br><a href="https://bgm.tv/subject/278202">バキ 大擂台賽編</a><br><a href="https://bgm.tv/subject/10380">STEINS;GATE</a><br><a href="https://bgm.tv/subject/93545">甘城ブリリアントパーク</a><br><a href="https://bgm.tv/subject/373390">HIGH CARD</a><br><a href="https://bgm.tv/subject/397808">アンデッドアンラック</a><br><a href="https://bgm.tv/subject/420628">薬屋のひとりごと</a><br><a href="https://bgm.tv/subject/276705">グレイプニル</a><br><a href="https://bgm.tv/subject/118783">すべてがFになる THE PERFECT INSIDER</a><br><a href="https://bgm.tv/subject/916">魍魎の匣</a><br><a href="https://bgm.tv/subject/362335">グリッドマン ユニバース</a><br><a href="https://bgm.tv/subject/4028">ねこぢる草</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>高达</title>
    <link href="/2023/03/12/GUNPLA/"/>
    <url>/2023/03/12/GUNPLA/</url>
    
    <content type="html"><![CDATA[<hr><span id="more"></span><h1 id="GUNPLA"><a href="#GUNPLA" class="headerlink" title="GUNPLA"></a>GUNPLA</h1><h2 id="BANDAI"><a href="#BANDAI" class="headerlink" title="BANDAI"></a>BANDAI</h2><h3 id="PB-HGUC-1-x2F-144-MS-06F-量产型璃子专用扎古"><a href="#PB-HGUC-1-x2F-144-MS-06F-量产型璃子专用扎古" class="headerlink" title="PB HGUC 1&#x2F;144 MS-06F 量产型璃子专用扎古"></a>PB HGUC 1&#x2F;144 MS-06F 量产型璃子专用扎古</h3><p>购入价格：145（2300日元发售）<br>都是冲着封面的与田祐希去的，换色的新生扎古闹麻了</p><h3 id="PB-HGUC-1-x2F-144-MS-06F-多安专用扎古"><a href="#PB-HGUC-1-x2F-144-MS-06F-多安专用扎古" class="headerlink" title="PB HGUC 1&#x2F;144 MS-06F 多安专用扎古"></a>PB HGUC 1&#x2F;144 MS-06F 多安专用扎古</h3><p>购入价格：115（2200日元发售）<br>真男人机体，外甲部分新规，自带战损，相当于扎古I和扎古II的结合体（省下了买GTO扎古I和扎古II的钱），废件过多（高情商：可还原GTO扎古II）按照万代按重量定价的尿性，血亏。组合度和可动优秀。<br><img src="/../GUNDAM/duoan.jpg"></p><h3 id="RG-01-1-x2F-144-RX-78-2-元祖高达"><a href="#RG-01-1-x2F-144-RX-78-2-元祖高达" class="headerlink" title="RG 01 1&#x2F;144 RX-78-2 元祖高达"></a>RG 01 1&#x2F;144 RX-78-2 元祖高达</h3><p>购入价格 86（2500日元发售）<br>外形T0级别的元组，一体成型骨架和色差分色的理念很好，就是太软了，名不虚传</p><h3 id="RG-1-x2F-144-MSN-02-基地限定-吉翁号-彩色透明版"><a href="#RG-1-x2F-144-MSN-02-基地限定-吉翁号-彩色透明版" class="headerlink" title="RG 1&#x2F;144 MSN-02 基地限定 吉翁号 彩色透明版"></a>RG 1&#x2F;144 MSN-02 基地限定 吉翁号 彩色透明版</h3><p>购入价格 469（5500日元发售）<br>高贵的基地限定85算，不过吉翁号优美的内购确实得搭配透明外甲才好看，逛高达基地时脑子一热买下的，不过倒也不错。</p><h3 id="MG-1-x2F-100-ASW-G-08-巴巴托斯第四形态"><a href="#MG-1-x2F-100-ASW-G-08-巴巴托斯第四形态" class="headerlink" title="MG 1&#x2F;100 ASW-G-08 巴巴托斯第四形态"></a>MG 1&#x2F;100 ASW-G-08 巴巴托斯第四形态</h3><p>购入价格：205（4500日元发售）<br>铁血的机设比较合胃口，液压管骨架结构很戳人，能和rg牛掰手腕的19年最佳拼装<br><img src="/../GUNDAM/mbs.jpg"><br><img src="/../GUNDAM/bs1.jpg"></p><h3 id="HG-TWFM-01-1-x2F-144-XGF-02-魔灵高达"><a href="#HG-TWFM-01-1-x2F-144-XGF-02-魔灵高达" class="headerlink" title="HG TWFM 01  1&#x2F;144 XGF-02 魔灵高达"></a>HG TWFM 01  1&#x2F;144 XGF-02 魔灵高达</h3><p>购入价格：79（1600日元发售）<br>在番剧热映期间五算购入主角机实属不易，分色优秀，细节刻画优秀，感受到了万代的技术进步</p><h3 id="HG-1-x2F-144-RX-78-2-超越全球元祖"><a href="#HG-1-x2F-144-RX-78-2-超越全球元祖" class="headerlink" title="HG 1&#x2F;144 RX-78-2 超越全球元祖"></a>HG 1&#x2F;144 RX-78-2 超越全球元祖</h3><p> 购入价格：66 （2 000日元发售价）<br> 组合度优秀，可动性极度优秀，非常值得入手<br><img src="/../GUNDAM/rx1.jpg"><img src="/../GUNDAM/rx2.jpg"><br><img src="/../GUNDAM/rx3.jpg"><img src="/../GUNDAM/rx4.jpg"></p><h3 id="HGCE-1-x2F-144-ZGMF-0X19A-无限正义-新生版"><a href="#HGCE-1-x2F-144-ZGMF-0X19A-无限正义-新生版" class="headerlink" title="HGCE 1&#x2F;144 ZGMF-0X19A 无限正义 新生版"></a>HGCE 1&#x2F;144 ZGMF-0X19A 无限正义 新生版</h3><p>购入价格：95 （2 200日元发售价）<br>最佳hg，分色优秀，枪上的贴纸是作为hg最后的倔强，可动优秀，组合度优秀。<br><img src="/../GUNDAM/jst3.jpg"><br><img src="/../GUNDAM/jst2.jpg"></p><h3 id="HGUC-1-x2F-144-RX-178-MK—II提坦斯配色-新生版"><a href="#HGUC-1-x2F-144-RX-178-MK—II提坦斯配色-新生版" class="headerlink" title="HGUC 1&#x2F;144 RX-178 MK—II提坦斯配色 新生版"></a>HGUC 1&#x2F;144 RX-178 MK—II提坦斯配色 新生版</h3><p>购入价格：1（1500日元发售）<br>组合度不错，造型耐看，马克兔全品类值得入手</p><p><img src="/../GUNDAM/MK2.jpg"><br><img src="/../GUNDAM/m2.jpg"></p><h3 id="HGUC-1-x2F-144-MSM-07S-夏亚专用魔蟹"><a href="#HGUC-1-x2F-144-MSM-07S-夏亚专用魔蟹" class="headerlink" title="HGUC 1&#x2F;144 MSM-07S 夏亚专用魔蟹"></a>HGUC 1&#x2F;144 MSM-07S 夏亚专用魔蟹</h3><p>购入价格：34 （700日元发售价）<br>组合度一般，可动性优秀，由于关节多的原因能倒立，值得入手，吉翁水产谁不爱呢<br><img src="/../GUNDAM/red2.jpg"><br><img src="/../GUNDAM/red4.jpg"></p><h3 id="HGUC-1-x2F-144-MSM-04-龟霸"><a href="#HGUC-1-x2F-144-MSM-04-龟霸" class="headerlink" title="HGUC 1&#x2F;144 MSM-04 龟霸"></a>HGUC 1&#x2F;144 MSM-04 龟霸</h3><p> 购入价格：60（1400日元发售）<br> 组合度优秀，内构优秀，值得入手，龟霸可爱捏<br><img src="/../GUNDAM/gb.jpg"></p><h3 id="HGUC-1-x2F-144-MSM-07E-实验型魔蟹E"><a href="#HGUC-1-x2F-144-MSM-07E-实验型魔蟹E" class="headerlink" title="HGUC 1&#x2F;144 MSM-07E 实验型魔蟹E"></a>HGUC 1&#x2F;144 MSM-07E 实验型魔蟹E</h3><p>购入价格： 48（1200日元发售价）<br>组合度拉垮，可动性拉垮，分色优秀，价格低不是没有原因的，0080情怀产品，谁叫口袋里的战争是鼠鼠最喜欢的一部呢<br><img src="/../GUNDAM/mxe.jpg"></p><h3 id="MICRO-WARS-食玩-吉姆"><a href="#MICRO-WARS-食玩-吉姆" class="headerlink" title="MICRO WARS 食玩 吉姆"></a>MICRO WARS 食玩 吉姆</h3><p>购入价格：21（发售价500日元）<br>大腿致命偷胶，部分需补色，相比hg更喜欢三头身的</p><h3 id="MICRO-WARS-食玩-老虎"><a href="#MICRO-WARS-食玩-老虎" class="headerlink" title="MICRO WARS 食玩 老虎"></a>MICRO WARS 食玩 老虎</h3><p>购入价格：21（发售价500日元）<br>大腿致命偷胶，部分需补色，相比hg更喜欢三头身的</p><h3 id="HG-Amplified-IMGN-龙神丸"><a href="#HG-Amplified-IMGN-龙神丸" class="headerlink" title="HG Amplified IMGN 龙神丸"></a>HG Amplified IMGN 龙神丸</h3><p>购入价格： 113（5000 日元发售）<br>组合度优秀，可动良好，极致の金属色表现！版件质感很好，有种自带消光&#x2F;光油的感觉，电镀部分容易被腐蚀，发售价偏贵，3算不到入的话还挺不错，也算还童年债了<br><img src="/../GUNDAM/ls.jpg"></p><h3 id="EVA-FRAME-食玩-3号机-8号机"><a href="#EVA-FRAME-食玩-3号机-8号机" class="headerlink" title="EVA  FRAME 食玩 3号机+8号机"></a>EVA  FRAME 食玩 3号机+8号机</h3><p>购入价格： 128（5盒+1枪）（590日元单盒发售价）<br>组合度优秀，可动优秀，有完整骨架与外甲，可玩性丰富，万代良心产品,可以做出鬼畜姿势（</p><p><img src="/../GUNDAM/eva_8.jpg"></p><p><img src="/../GUNDAM/eva_8_2.jpg"><br><img src="/../GUNDAM/eva_8_3.jpg"></p><h3 id="EG-PAC-MAN-吃豆人"><a href="#EG-PAC-MAN-吃豆人" class="headerlink" title="EG PAC-MAN 吃豆人"></a>EG PAC-MAN 吃豆人</h3><p>购入价格 ： 26（1 000日元发售）<br>组合度一般，可动性良好，比较好玩<br><img src="/../GUMDAM/../GUNDAM/PAC1.jpg"><br><img src="/../GUNDAM/PAC.jpg"></p><h3 id="宝可梦快拼-PLAMO-04-伊布"><a href="#宝可梦快拼-PLAMO-04-伊布" class="headerlink" title="宝可梦快拼 PLAMO 04 伊布"></a>宝可梦快拼 PLAMO 04 伊布</h3><p>购入价格：15（500日元发售）<br>可爱捏</p><h3 id="宝可梦快拼-PLAMO-08-迷拟Q"><a href="#宝可梦快拼-PLAMO-08-迷拟Q" class="headerlink" title="宝可梦快拼 PLAMO 08 迷拟Q"></a>宝可梦快拼 PLAMO 08 迷拟Q</h3><p>购入价格： 25 （500日元发售）<br>组合度优秀，可动性无，可爱捏<br><img src="/../GUMDAM/../GUNDAM/Q.jpg"></p><h3 id="MSE-重装重奏-MSM-04-龟霸"><a href="#MSE-重装重奏-MSM-04-龟霸" class="headerlink" title="MSE 重装重奏 MSM-04 龟霸"></a>MSE 重装重奏 MSM-04 龟霸</h3><p>购入价格 ： 28（500日元随机扭蛋发售）<br>组合读拉垮，有缩胶，基本无可动，手部有替换件，可爱的捏<br><img src="/../GUNDAM/qb1.jpg"><img src="/../GUNDAM/qb2.jpg"></p><h3 id="Petitrits-尼禄·克劳狄乌斯-Caster"><a href="#Petitrits-尼禄·克劳狄乌斯-Caster" class="headerlink" title="Petitrits 尼禄·克劳狄乌斯 Caster"></a>Petitrits 尼禄·克劳狄乌斯 Caster</h3><p>购入价格 ： 3（1400日元发售）<br>券前23的价格很不错的豆丁魂。按发售价的话就是冤大头了</p><h3 id="三国传-10周年特典-玉玺"><a href="#三国传-10周年特典-玉玺" class="headerlink" title="三国传 10周年特典 玉玺"></a>三国传 10周年特典 玉玺</h3><p>购入价格： 12<br>还可以，主打一个情怀</p><h2 id="DABAN"><a href="#DABAN" class="headerlink" title="DABAN"></a>DABAN</h2><h3 id="PG-1-x2F-60-MBF-02-AQM-x2F-E-X01-嫣红强袭-空中霸王"><a href="#PG-1-x2F-60-MBF-02-AQM-x2F-E-X01-嫣红强袭-空中霸王" class="headerlink" title="PG 1&#x2F;60 MBF-02+AQM&#x2F;E+X01 嫣红强袭+空中霸王"></a>PG 1&#x2F;60 MBF-02+AQM&#x2F;E+X01 嫣红强袭+空中霸王</h3><p>购入价格：253<br>比较划算的pg，内构细节丰富，联动丰富，万代的里程碑产品，兼备内构、联动与外设。但是优点全是万代的，组合度一般，可动优秀。</p><h3 id="MG-MSZ-006-1-x2F-100-8801-Z高达-Ver2-0"><a href="#MG-MSZ-006-1-x2F-100-8801-Z高达-Ver2-0" class="headerlink" title="MG MSZ-006 1&#x2F;100 8801 Z高达 Ver2.0"></a>MG MSZ-006 1&#x2F;100 8801 Z高达 Ver2.0</h3><p>购入价格：64<br>组合度还行，但是全装起来就松，变形机通病，从价格上看还行</p><h3 id="MB式样-1-x2F-100-8802-ZGMF-X20A-强袭自由"><a href="#MB式样-1-x2F-100-8802-ZGMF-X20A-强袭自由" class="headerlink" title="MB式样 1&#x2F;100 8802 ZGMF- X20A 强袭自由"></a>MB式样 1&#x2F;100 8802 ZGMF- X20A 强袭自由</h3><p>购入价格： 127<br>经典大班科目二，组合度比初版好些但还是拉垮，头部等巨缝使用分子料理，外观很不错<br><img src="/../GUNDAM/8802_1.jpg"><br><img src="/../GUNDAM/8802_2.jpg"></p><h3 id="MB式样-1-x2F-100-8804-MBF-P01-Re2-金异端天蜜娜"><a href="#MB式样-1-x2F-100-8804-MBF-P01-Re2-金异端天蜜娜" class="headerlink" title="MB式样 1&#x2F;100  8804 MBF-P01-Re2 金异端天蜜娜"></a>MB式样 1&#x2F;100  8804 MBF-P01-Re2 金异端天蜜娜</h3><p>购入价格：155（初三入的，历史悠久）<br>组合度地狱，可动性地狱，背包过重，站尸没问题，外观好看,似乎已绝版<br><img src="/../GUNDAM/tianmina1.jpg"><img src="/../GUNDAM/tianmina2.jpg"><br><img src="/../GUNDAM/tianmina3.jpg"></p><h3 id="MB式样-1-x2F-100-8821-F91"><a href="#MB式样-1-x2F-100-8821-F91" class="headerlink" title="MB式样 1&#x2F;100 8821 F91"></a>MB式样 1&#x2F;100 8821 F91</h3><p>购入价格：101<br>本体组合度优秀，武器组合度地狱，极度需要搭配三红水贴。<br><img src="/../GUNDAM/F91.jpg"><br><img src="/../GUNDAM/F91_!.jpg"></p><h3 id="HIRM式样-1-x2F-100-8825-XXXG-01W-飞翼高达EW"><a href="#HIRM式样-1-x2F-100-8825-XXXG-01W-飞翼高达EW" class="headerlink" title="HIRM式样 1&#x2F;100 8825 XXXG-01W 飞翼高达EW"></a>HIRM式样 1&#x2F;100 8825 XXXG-01W 飞翼高达EW</h3><p>购入价格：95<br>组合度不错，HIRM无毛比掉毛好看，值得购买<br><img src="/../GUNDAM/fy.jpg"></p><h3 id="MG-1-x2F-100-老6601-MBF-P01KAI-红异端改"><a href="#MG-1-x2F-100-老6601-MBF-P01KAI-红异端改" class="headerlink" title="MG 1&#x2F;100  老6601 MBF-P01KAI 红异端改"></a>MG 1&#x2F;100  老6601 MBF-P01KAI 红异端改</h3><p>购入价格 ：70（初中入的）<br>入坑作，地狱难度，组合地狱可动地狱掉件地狱，现在只剩下个尸体，能站着就不错了<br><img src="/../GUNDAM/Red.jpg"></p><h3 id="MG-1-x2F-100-6619-Ka版-限定版-RX-93-牛高达-中国限定配色"><a href="#MG-1-x2F-100-6619-Ka版-限定版-RX-93-牛高达-中国限定配色" class="headerlink" title="MG 1&#x2F;100 6619 Ka版 限定版 RX-93 牛高达 中国限定配色"></a>MG 1&#x2F;100 6619 Ka版 限定版 RX-93 牛高达 中国限定配色</h3><p>购入价格： 130<br>降价入的还算不错，本体组合度优秀，武器浮游炮组合度拉垮，内构丰富<br><img src="/../GUNDAM/v.jpg"></p><h3 id="MG-1-x2F-100-6642-RX-0-独角兽三号机菲尼克斯"><a href="#MG-1-x2F-100-6642-RX-0-独角兽三号机菲尼克斯" class="headerlink" title="MG 1&#x2F;100 6642 RX-0  独角兽三号机菲尼克斯"></a>MG 1&#x2F;100 6642 RX-0  独角兽三号机菲尼克斯</h3><p>购入价格： 129(大怨种)<br>组合度一般，可动性一般，香槟金挺好看的，喷镀漆面一般但能看，但建议入6642S<br><img src="/../GUNDAM/pynix2.jpg"><br><img src="/../GUNDAM/pynix3.jpg"></p><h3 id="MG-1-x2F-100-6651-MSN-00100-百式2-0-米加粒子炮-空降背包"><a href="#MG-1-x2F-100-6651-MSN-00100-百式2-0-米加粒子炮-空降背包" class="headerlink" title="MG 1&#x2F;100 6651 MSN-00100 百式2.0+米加粒子炮+空降背包"></a>MG 1&#x2F;100 6651 MSN-00100 百式2.0+米加粒子炮+空降背包</h3><p>购入价：130<br>本体组合度不错，米加粒子炮纯屎，可惜6648不再版了<br><img src="/../GUNDAM/bs.jpg"></p><h3 id="MG-1-x2F-100-6653-GN-002-力天使"><a href="#MG-1-x2F-100-6653-GN-002-力天使" class="headerlink" title="MG 1&#x2F;100 6653 GN-002 力天使"></a>MG 1&#x2F;100 6653 GN-002 力天使</h3><p>购入价格：77<br>组合度不错，可动性不错，细节相比万代有所阉割，但作为比较新的款式有这不错的表现<br><img src="/../GUNDAM/lt.jpg"></p><h3 id="HGUC-1-x2F-144-175-RX-0-独角兽二号机报丧女妖命运女神形态毁灭模式"><a href="#HGUC-1-x2F-144-175-RX-0-独角兽二号机报丧女妖命运女神形态毁灭模式" class="headerlink" title="HGUC 1&#x2F;144  175 RX-0 独角兽二号机报丧女妖命运女神形态毁灭模式"></a>HGUC 1&#x2F;144  175 RX-0 独角兽二号机报丧女妖命运女神形态毁灭模式</h3><p>购入价格： 20<br>组合度一般，可动一般，外观好看，站尸不错<br><img src="/../GUNDAM/lion1.jpg"><img src="/../GUNDAM/lion2.jpg"><br><img src="/../GUNDAM/lion3.jpg"><img src="/../GUNDAM/lion4.jpg"></p><h3 id="HGGT-1-x2F-144-HT01-雷霆宙域-FA-78-全装甲高达"><a href="#HGGT-1-x2F-144-HT01-雷霆宙域-FA-78-全装甲高达" class="headerlink" title="HGGT 1&#x2F;144 HT01 雷霆宙域 FA-78 全装甲高达"></a>HGGT 1&#x2F;144 HT01 雷霆宙域 FA-78 全装甲高达</h3><p>购入价格 32<br>组合度良好，可动一般，配件多，性价比不错<br><img src="/../GUNDAM/full2.jpg"><br><img src="/../GUNDAM/full3.jpg"></p><h2 id="龙桃子"><a href="#龙桃子" class="headerlink" title="龙桃子"></a>龙桃子</h2><h3 id="MB式样-1-x2F-100-ZGMF-X42S-海涅配色命运"><a href="#MB式样-1-x2F-100-ZGMF-X42S-海涅配色命运" class="headerlink" title="MB式样 1&#x2F;100  ZGMF-X42S 海涅配色命运"></a>MB式样 1&#x2F;100  ZGMF-X42S 海涅配色命运</h3><p>购入价格 159（差不多这价，记不清了，初中入的）<br>组合度优秀，可动性良好，值得入手（然而龙桃子已经凉了，价格翻了几倍了都）<br><img src="/../GUNDAM/fate2.jpg"><br><img src="/../GUNDAM/fate3.jpg"></p><h2 id="模匠魂"><a href="#模匠魂" class="headerlink" title="模匠魂"></a>模匠魂</h2><h3 id="MG-Hirm式样-1-x2F-100-MBF-02-红异端-EW猩猩臂"><a href="#MG-Hirm式样-1-x2F-100-MBF-02-红异端-EW猩猩臂" class="headerlink" title="MG Hirm式样 1&#x2F;100 MBF-02 红异端 +EW猩猩臂"></a>MG Hirm式样 1&#x2F;100 MBF-02 红异端 +EW猩猩臂</h3><p>购入价格 160+80+80<br>EW配件包组合度优秀，MJH组合度部分良好，部分组合度拉垮，Hirm的肌肉感很适合红异端<br><img src="/../GUNDAM/red_m.jpg"></p><h2 id="闪闪"><a href="#闪闪" class="headerlink" title="闪闪"></a>闪闪</h2><h3 id="HG-1-x2F-144-RX-78-2-超越全球元祖-G3配色"><a href="#HG-1-x2F-144-RX-78-2-超越全球元祖-G3配色" class="headerlink" title="HG 1&#x2F;144 RX-78-2 超越全球元祖 G3配色"></a>HG 1&#x2F;144 RX-78-2 超越全球元祖 G3配色</h3><p>购入价格 34<br>组合度优秀，可动性优秀，假G3配色（x），堪比万代，值的入手<br><img src="/../GUNDAM/78g.jpg"></p><h2 id="星峰社"><a href="#星峰社" class="headerlink" title="星峰社"></a>星峰社</h2><h3 id="HGBF-RX-93-v-2-Hi-v高达勇气式"><a href="#HGBF-RX-93-v-2-Hi-v高达勇气式" class="headerlink" title="HGBF RX-93-v-2 Hi-v高达勇气式"></a>HGBF RX-93-v-2 Hi-v高达勇气式</h3><p>购入价格：15<br>组合度一般，整体值得入手<br><img src="/../GUNDAM/hv.jpg"></p><h3 id="HGUC-RX-124-高达TR-6-伍德沃特"><a href="#HGUC-RX-124-高达TR-6-伍德沃特" class="headerlink" title="HGUC RX-124 高达TR-6 伍德沃特"></a>HGUC RX-124 高达TR-6 伍德沃特</h3><p>购入价格：18<br>组合度一般，值得入手</p><h3 id="HGUC-RX-124-高达TR-6-海兹尔II"><a href="#HGUC-RX-124-高达TR-6-海兹尔II" class="headerlink" title="HGUC RX-124 高达TR-6 海兹尔II"></a>HGUC RX-124 高达TR-6 海兹尔II</h3><p>购入价格：13<br>组合度一般，值得入手</p><h3 id="HGUC-ARZ-124-高达TR-6【伍德沃特】精神力女神天线"><a href="#HGUC-ARZ-124-高达TR-6【伍德沃特】精神力女神天线" class="headerlink" title="HGUC ARZ-124 高达TR-6【伍德沃特】精神力女神天线"></a>HGUC ARZ-124 高达TR-6【伍德沃特】精神力女神天线</h3><p>购入价格：16<br>组合度一般，天线锐度不错，值得入手</p><h3 id="HGUC-RGM-79S-吉姆-斯巴达"><a href="#HGUC-RGM-79S-吉姆-斯巴达" class="headerlink" title="HGUC RGM-79S 吉姆 斯巴达"></a>HGUC RGM-79S 吉姆 斯巴达</h3><p>购入价格：11<br>非常不错的一款产品，万代网限价格都炒上200了，机设很杰出的一款量产机<br><img src="/../GUNDAM/jm.jpg"></p><h2 id="集模社"><a href="#集模社" class="headerlink" title="集模社"></a>集模社</h2><h3 id="HGTWFM-MDX-0003-战骑高达"><a href="#HGTWFM-MDX-0003-战骑高达" class="headerlink" title="HGTWFM MDX-0003 战骑高达"></a>HGTWFM MDX-0003 战骑高达</h3><p>购入价格：17<br>水口有所修改，值得入手<br><img src="/../GUNDAM/zq.jpg"></p><h2 id="星动"><a href="#星动" class="headerlink" title="星动"></a>星动</h2><h3 id="HG-TWFM-风灵高达-彩透版"><a href="#HG-TWFM-风灵高达-彩透版" class="headerlink" title="HG TWFM 风灵高达 彩透版"></a>HG TWFM 风灵高达 彩透版</h3><p>购入价格： 23<br>组合度优秀，彩透有模有样，比万代先发布，牛逼<br><img src="/../GUNDAM/ctfl.jpg"></p><h3 id="HGCE-MHF-01Ω-君王异端"><a href="#HGCE-MHF-01Ω-君王异端" class="headerlink" title="HGCE MHF-01Ω 君王异端"></a>HGCE MHF-01Ω 君王异端</h3><p>购入价格：17<br>组合度纯纯的一坨狗屎，除了外观一无是处<br><img src="/../GUNDAM/yd.jpg"></p><h3 id="HGGTO-MS-06J-陆战型扎古II-白色食人魔"><a href="#HGGTO-MS-06J-陆战型扎古II-白色食人魔" class="headerlink" title="HGGTO MS-06J 陆战型扎古II 白色食人魔"></a>HGGTO MS-06J 陆战型扎古II 白色食人魔</h3><p>购入价格：9.8<br>组合度良好，比较紧实，水贴建议自购，EVO的水贴太容易碎了<br><img src="/../GUNDAM/zg.jpg"><br><img src="/../GUNDAM/zg1.jpg"></p><h3 id="HGGT-MS-06R-高机动扎古II-精神力扎古"><a href="#HGGT-MS-06R-高机动扎古II-精神力扎古" class="headerlink" title="HGGT MS-06R 高机动扎古II 精神力扎古"></a>HGGT MS-06R 高机动扎古II 精神力扎古</h3><p>购入价格 27<br>组合度除了喷口都不错，量大管饱，但是喷口地狱<br><img src="/../GUNDAM/zg2.jpg"></p><h3 id="HGGTO-MS-06CK-扎古半加农型"><a href="#HGGTO-MS-06CK-扎古半加农型" class="headerlink" title="HGGTO MS-06CK 扎古半加农型"></a>HGGTO MS-06CK 扎古半加农型</h3><p>购入价格 6.5<br>本体组合度不错，镭射大炮组合度垃圾，长条贴纸难贴<br><img src="/../GUNDAM/zgs.jpg"></p><h2 id="高高"><a href="#高高" class="headerlink" title="高高"></a>高高</h2><h3 id="HGI-BO-1-x2F-144-01-ASW-G-08-巴巴托斯第四形态"><a href="#HGI-BO-1-x2F-144-01-ASW-G-08-巴巴托斯第四形态" class="headerlink" title="HGI-BO  1&#x2F;144 01 ASW-G-08 巴巴托斯第四形态"></a>HGI-BO  1&#x2F;144 01 ASW-G-08 巴巴托斯第四形态</h3><p>购入价格 5<br>性价比神中神，组合度一般，可动性一般，这价格还考虑个啥啊<br><img src="/../GUNDAM/babatosi2.jpg"><br><img src="/../GUNDAM/babatosi3.jpg"><img src="/../GUNDAM/babatosi4.jpg"></p><h3 id="HGCE-1-x2F-144-ORB-01-不知火·拂晓"><a href="#HGCE-1-x2F-144-ORB-01-不知火·拂晓" class="headerlink" title="HGCE 1&#x2F;144 ORB-01 不知火·拂晓"></a>HGCE 1&#x2F;144 ORB-01 不知火·拂晓</h3><p>购入价格： 22.5<br>组合度拉垮，可动性拉垮，喷镀漆面拉垮，看在喷镀金入的，稍微还能看<br><img src="/../GUNDAM/gold2.jpg"><br><img src="/../GUNDAM/gold3.jpg"></p><h3 id="HGI-BO-1-x2F-144-33-ASW-G-08-巴巴托斯天狼座帝王形态"><a href="#HGI-BO-1-x2F-144-33-ASW-G-08-巴巴托斯天狼座帝王形态" class="headerlink" title="HGI-BO 1&#x2F;144  33  ASW-G-08 巴巴托斯天狼座帝王形态"></a>HGI-BO 1&#x2F;144  33  ASW-G-08 巴巴托斯天狼座帝王形态</h3><p>购入价格 21<br>组合度良好，可动性良好，补色贴纸地狱，媲美万代的水准<br><img src="/../GUNDAM/king1.jpg"><br><img src="/../GUNDAM/king3.jpg"><img src="/../GUNDAM/king4.jpg"></p><h3 id="HGTWFM-XVX-016RN-风灵高达改修型"><a href="#HGTWFM-XVX-016RN-风灵高达改修型" class="headerlink" title="HGTWFM XVX-016RN 风灵高达改修型"></a>HGTWFM XVX-016RN 风灵高达改修型</h3><p>购入价格 21.5<br>组合度良好，可动性良好，细节有点糊，总体不错，挑衅万代<br><img src="/../GUNDAM/gfl.jpg"></p><h3 id="HG-RX-78-2-元祖高达-industrial-design-ver"><a href="#HG-RX-78-2-元祖高达-industrial-design-ver" class="headerlink" title="HG RX-78-2 元祖高达 industrial design ver."></a>HG RX-78-2 元祖高达 industrial design ver.</h3><p>购入价格 ：20<br>组合度没有传闻那么糟糕，可动优秀，设计不错</p><h3 id="HGGTO-MS-06R-1A-高机动扎古II-黑色三连星"><a href="#HGGTO-MS-06R-1A-高机动扎古II-黑色三连星" class="headerlink" title="HGGTO MS-06R-1A 高机动扎古II  黑色三连星"></a>HGGTO MS-06R-1A 高机动扎古II  黑色三连星</h3><p>购入价格 9.46 ，9.74，6<br>组合度还行，就是PC件很松需要蓝丁胶加固<br><img src="/../GUNDAM/h1.jpg"></p><h4 id="奥尔迪加机"><a href="#奥尔迪加机" class="headerlink" title="奥尔迪加机"></a>奥尔迪加机</h4><p><img src="/../GUNDAM/h6.jpg"></p><h4 id="盖亚机"><a href="#盖亚机" class="headerlink" title="盖亚机"></a>盖亚机</h4><p><img src="/../GUNDAM/h3.jpg"></p><h4 id="马修机"><a href="#马修机" class="headerlink" title="马修机"></a>马修机</h4><p><img src="/../GUNDAM/h2.jpg"></p><h3 id="MGSD-ZGMF-X10A-自由高达"><a href="#MGSD-ZGMF-X10A-自由高达" class="headerlink" title="MGSD ZGMF- X10A 自由高达"></a>MGSD ZGMF- X10A 自由高达</h3><p>购入价格:40<br>组合度一般，万代太贵了，用来体验万代设计不错<br><img src="/../GUNDAM/MGSD.jpg"></p><h2 id="“新厂”"><a href="#“新厂”" class="headerlink" title="“新厂”"></a>“新厂”</h2><h3 id="HGI-BO-ASW-G-29-亚斯塔禄"><a href="#HGI-BO-ASW-G-29-亚斯塔禄" class="headerlink" title="HGI-BO ASW-G-29 亚斯塔禄"></a>HGI-BO ASW-G-29 亚斯塔禄</h3><p>购入价：10<br>垃圾中的垃圾，除了价格一无是处</p><h2 id="ZY模型"><a href="#ZY模型" class="headerlink" title="ZY模型"></a>ZY模型</h2><h3 id="FRS-战斗暴龙兽"><a href="#FRS-战斗暴龙兽" class="headerlink" title="FRS 战斗暴龙兽"></a>FRS 战斗暴龙兽</h3><p>购入价：69<br>可动拉胯，不知道怎么做到拼的时候紧把玩的时候松的，外观表现不错</p><h2 id="迈高"><a href="#迈高" class="headerlink" title="迈高"></a>迈高</h2><h3 id="RG-EVA初号机"><a href="#RG-EVA初号机" class="headerlink" title="RG EVA初号机"></a>RG EVA初号机</h3><p>购入价：55<br>性价比不错，组合度中等</p><h2 id="国模“原创”"><a href="#国模“原创”" class="headerlink" title="国模“原创”"></a>国模“原创”</h2><h3 id="铁创-星灭原型机"><a href="#铁创-星灭原型机" class="headerlink" title="铁创 星灭原型机"></a>铁创 星灭原型机</h3><p>购入价：158<br>组合度纯纯的垃圾，铁骨拉垮外甲也拉垮，除了惊异能天使的外表外一无是处<br><img src="/../GUNDAM/xm.jpg"></p><hr>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>12-并发编程</title>
    <link href="/2023/02/18/12-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/02/18/12-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="对应-CSAPP-第十二章节"><a href="#对应-CSAPP-第十二章节" class="headerlink" title="对应 CSAPP 第十二章节"></a>对应 CSAPP 第十二章节</h2><span id="more"></span><h1 id="ICS"><a href="#ICS" class="headerlink" title="ICS"></a><a href="https://aki-yzh.github.io/2023/02/18/1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8&%E7%9B%AE%E5%BD%95">ICS</a></h1><hr><h2 id="十二、并发编程"><a href="#十二、并发编程" class="headerlink" title="十二、并发编程"></a>十二、并发编程</h2><p>$\quad$ 使用应用级并发的应用程序称为并发程序，现代操作系统提供三种基本的构造并发程序的方法：<br>$\qquad$ 1. 进程<br>$\qquad$ 2.I&#x2F;O多路复用<br>$\qquad$ 3.线程</p><h4 id="12-1-基于进程的并发编程"><a href="#12-1-基于进程的并发编程" class="headerlink" title="12.1 基于进程的并发编程"></a>12.1 基于进程的并发编程</h4><p>$\quad$ 在父进程中接受客户端连接请求，然后创建一个新的子进程来为每个新客户端提供服务。<br>服务器接收客户端的连接请求后，服务器<code>fork</code>出一个子进程-&gt;子进程关闭<code>listenfd</code>，父进程关闭<code>connfd</code>，避免内存泄漏-&gt;子进程执行完后自动关闭连接，父进程继续监听<br>$\quad$ 优点：简单，地址空间独立，共享状态信息<br>$\quad$ 缺点：难共享信息，进程间通信开销高</p><p><strong>基于进程的并发echo服务器</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;csapp.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">echo</span><span class="hljs-params">(<span class="hljs-type">int</span> connfd)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sigchld_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> sig)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-built_in">waitpid</span>(<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,WNOHANG)&gt;<span class="hljs-number">0</span>)<br>        ;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> listenfd,connfd;<br>    <span class="hljs-type">socklen_t</span> clientlen;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_storage</span> clientaddr;<br>    <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;usage: %s &lt;port&gt;\n&quot;</span>,argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-built_in">Signal</span>(SIGCHLD,sigchld_handler);<br>    listenfd = <span class="hljs-built_in">Open_listenfd</span>(argv[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        clientfdlen = <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr_storage);<br>        connfd = <span class="hljs-built_in">Accept</span>(listenfd,(SA *) &amp;clientaddr,&amp;clientlen);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Fork</span>() == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">Closr</span>(listenfd);<br>            <span class="hljs-built_in">echo</span>(connfd);<br>            <span class="hljs-built_in">Close</span>(connfd);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>        <span class="hljs-built_in">Close</span>(connfd);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="12-2-基于I-x2F-O多路复用的并发编程"><a href="#12-2-基于I-x2F-O多路复用的并发编程" class="headerlink" title="12.2 基于I&#x2F;O多路复用的并发编程"></a>12.2 基于I&#x2F;O多路复用的并发编程</h4><p>  I&#x2F;O 多路复用的思想：同时监测若干个文件描述符是否可以执行IO操作的能力</p><p>当描述符准备好可读时再去读，读的时候再判断是从哪个描述符读的</p><p>  <code>select</code>确定要等待的描述符：<em>读集合</em><br> 状态机：等待描述符准备好、描述符准备好可以读、从描述符读一个文本行</p><p>$\quad$ 优点：一个逻辑控制流，一个地址空间，没有进程&#x2F;线程管理<br>$\quad$ 缺点：编码复杂，只能在一个核上跑</p><p><strong>基于I&#x2F;O多路复用的迭代echo服务器</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;csapp.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">echo</span> <span class="hljs-params">(<span class="hljs-type">int</span> connfd)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">command</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> listenfd,connfd;<br>    <span class="hljs-type">socklen_t</span> clientlen;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_storage</span> clientaddr;<br>    fd_set read_set,ready_set;<br>    <span class="hljs-keyword">if</span>(argc!=<span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;usage: %s &lt;port&gt;\n&quot;</span>,argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    listenfd = <span class="hljs-built_in">Open_listenfd</span>(argc[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">FD_ZERO</span>(read_set);<span class="hljs-comment">/* clear read set */</span><br>    <span class="hljs-built_in">FD_SET</span>(STDIN_FILENO,&amp;read_set);<span class="hljs-comment">/* add stdin to read set */</span><br>    <span class="hljs-built_in">FD_SET</span>(listenfd,&amp;read_set);<span class="hljs-comment">/* add listenfd to read set */</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        ready_set=read set;<br>        <span class="hljs-built_in">Select</span>(listenfd+<span class="hljs-number">1</span>,&amp;ready_set,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">FD_ISSET</span>(STDIN_FILENO,&amp;ready_set))<br>            <span class="hljs-built_in">command</span>();<span class="hljs-comment">/* Read command line from stdin */</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">FD_ISSET</span>(listenfd,&amp;ready_set))<br>        &#123;<br>            clientlen = <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr_storage);<br>            connfd = <span class="hljs-built_in">Accept</span>(listenfd,(SA*) &amp;clientaddr,&amp;clientlen);<br>            <span class="hljs-built_in">echo</span>(connfd);<span class="hljs-comment">/* echo client input until EOF */</span><br>            <span class="hljs-built_in">Close</span>(connfd);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">command</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">char</span> buf[MAXLINE];<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">Fgets</span>(buf,MAXLINE,stdin))<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,buf);<span class="hljs-comment">/* process to the input command */</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>基于I&#x2F;O多路复用的并发echo服务器</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#inlcude<span class="hljs-string">&quot;csapp.h&quot;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-comment">/* represents a pool of connected descriptors */</span><br>&#123;<br>    <span class="hljs-type">int</span> maxfd;<span class="hljs-comment">/* largest descriptor in read_set */</span><br>    fd_set read_set;<span class="hljs-comment">/* set of all active descriptors */</span><br>    fd_set ready_set;<span class="hljs-comment">/* Subset of descriptors ready for reading */</span><br>    <span class="hljs-type">int</span> nready;<span class="hljs-comment">/* Number of ready descriptors from select */</span><br>    <span class="hljs-type">int</span> maxi;<span class="hljs-comment">/* High water index into client array */</span><br>    <span class="hljs-type">int</span> clientfd[FD_SETSIZE];<span class="hljs-comment">/* Set of active descriptors */</span><br>    <span class="hljs-type">rio_t</span> clientrio[FD_SETSIZE];<span class="hljs-comment">/* Set of active read buffers */</span><br>&#125; pool ;<br><span class="hljs-type">int</span> byte_cnt =<span class="hljs-number">0</span>;<span class="hljs-comment">/* Counts total bytes received by server */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc ,<span class="hljs-type">char</span> ** argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> listenfd,connfd;<br>    <span class="hljs-type">socklen_t</span> clientlen;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_storage</span> clientaddr;<br>    <span class="hljs-type">static</span> pool pool;<br>    <span class="hljs-keyword">if</span>(argc!=<span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprinf</span>(stderr,<span class="hljs-string">&quot;usage: %s &lt;port&gt;\n&quot;</span>,argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    listenfd=<span class="hljs-built_in">Open_listenfd</span>(argv[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">init_pool</span>(listenfd,&amp;pool);<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">/* wait for listening/connected descriptors to be ready */</span><br>        pool.ready_set=pool.read_set;<br>        pool.nready=<span class="hljs-built_in">Select</span>(pool.maxfd+<span class="hljs-number">1</span>,&amp;pool.readyset,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>,<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-comment">/* if listening descriptor ready , add new client to pool */</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">FD_ISSET</span>(listenfd,&amp;pool.ready_set))<br>        &#123;<br>            clientlen=<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr_storage);<br>            connfd=<span class="hljs-built_in">Accept</span>(listenfd,(SA*)&amp;clientaddr,&amp;clientlen);<br>            <span class="hljs-built_in">add_client</span>(connfd,&amp;pool);<br>        &#125;<br>        <span class="hljs-comment">/* echo a text line from each ready connected descriptor */</span><br>        <span class="hljs-built_in">check_clients</span>(&amp;pool);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init_pool</span><span class="hljs-params">(<span class="hljs-type">int</span> listenfd,pool *p)</span><span class="hljs-comment">//初始化客户端池</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/* initially ,there are no connected descriptors */</span><br>    <span class="hljs-type">int</span> i;<br>    p-&gt;maxi =<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span> ;i&lt;FD_SETSIZE;i++)<br>        p-&gt;clientfd[i]=<span class="hljs-number">-1</span>;<br>    <span class="hljs-comment">/* initially ,listenfd is only member of select read set */</span><br>    p-&gt;maxfd = listenfd;<br>    <span class="hljs-built_in">FD_ZERO</span>(&amp;p-&gt;read_set);<br>    <span class="hljs-built_in">FD_SET</span>(listenfd,&amp;p-&gt;read_set);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add_client</span><span class="hljs-params">(<span class="hljs-type">int</span> connfd,pool *p)</span><span class="hljs-comment">//向池中添加一个新的客户端连接</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    p-&gt;nready--;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;FD_SETSIZE,i++)<span class="hljs-comment">/* find an available slot */</span><br>        <span class="hljs-keyword">if</span>(p-&gt;clientfd[i]&lt;<span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-comment">/* Add connected descriptor to the pool */</span><br>            p-&gt;clientfd[i]=connfd;<br>            <span class="hljs-built_in">Rio_readinitb</span>(&amp;p-&gt;clientrio[i],connfd);<br>            <span class="hljs-comment">/* add the descriptor to descriptor set */</span><br>            <span class="hljs-built_in">FD_SET</span>(connfd,&amp;p-&gt;read_set);<br>            <span class="hljs-comment">/* update max descriptor and pool high water mark */</span><br>            <span class="hljs-keyword">if</span>(connfd&gt;p-&gt;maxfd)<br>                p-&gt;maxfd=connfd;<br>            <span class="hljs-keyword">if</span>(i&gt;p-&gt;maxi)<br>                p-&gt;maxi=i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    <span class="hljs-keyword">if</span>(i==FD_SETSIZE)<span class="hljs-comment">/* couldn&#x27;t find an empty slot */</span><br>        <span class="hljs-built_in">app_error</span>(<span class="hljs-string">&quot;add_client error: too mant clients&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">check_clients</span><span class="hljs-params">(pool *p)</span><span class="hljs-comment">//服务准备好的客户端链接</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i,connfd,n;<br>    <span class="hljs-type">char</span> buf[MAXLINE];<br>    <span class="hljs-type">rio_t</span> rio;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;(i&lt;=p-&gt;maxi)&amp;&amp;(p-&gt;nready&gt;<span class="hljs-number">0</span>);i++)<br>    &#123;<br>        connfd = p-&gt;clientfd[i];<br>        rio=p-&gt;clientrio[i];<br>        <span class="hljs-comment">/* if the descriptor is ready ,echo a text line from it */</span><br>        <span class="hljs-keyword">if</span>((connfd&gt;<span class="hljs-number">0</span>)&amp;&amp;(<span class="hljs-built_in">FD_ISSET</span>(connfd,&amp;p-&gt;ready_set)))<br>        &#123;<br>            p-&gt;nready--;<br>            <span class="hljs-keyword">if</span>((n=<span class="hljs-built_in">Rio_readlineb</span>(&amp;rio,buf,MAXLINE))!=<span class="hljs-number">0</span>)<br>            &#123;<br>                byte_cnt+=n;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Server received %d (%d total) bytes on fd %d\n&quot;</span>,n,byte_cnt,connfd);<br>                <span class="hljs-built_in">Rio_writen</span>(connfd,buf,n);<br>            &#125;<br>            <span class="hljs-comment">/* EOF decteced ,remove descriptor from pool */</span><br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-built_in">Close</span>(connfd);<br>                <span class="hljs-built_in">FD_CLR</span>(connfd,&amp;p-&gt;read_set);<br>                p-&gt;clientfd[i]=<span class="hljs-number">-1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="12-3-基于线程的并发编程"><a href="#12-3-基于线程的并发编程" class="headerlink" title="12.3 基于线程的并发编程"></a>12.3 基于线程的并发编程</h4><p>线程：进程上下文中的逻辑流<br>$\quad$ 共享代码、数据、堆、共享库和打开的文件<br>$\quad$ 私有的线程ID、栈、栈指针、寄存器<br>$\quad$ 和一个进程相关的线程组成一个对等线程池<br>$\quad$ 上下文切换、创建和终止比进程快<br>每个进程开始生命周期时都是单一线程，这个线程称为主线程，在某一时刻，主线程创建一个对等线程，从这个时间点开始，两个线程并发运行。</p><p><strong>Posix</strong>线程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-type">void</span> *<span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">void</span> *)</span></span><br><span class="hljs-function"><span class="hljs-comment">/* 创建其他线程 */</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_create</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> *tid, <span class="hljs-type">pthread_attr_t</span> *attr, func *f, <span class="hljs-type">void</span> *arg)</span></span>;<span class="hljs-comment">//成功返回0，出错非0</span><br><span class="hljs-comment">/* 返回调用者的线程id */</span><br><span class="hljs-function"><span class="hljs-type">pthread_t</span> <span class="hljs-title">pthread_self</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><span class="hljs-comment">/* 终止线程 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pthread_exit</span><span class="hljs-params">(<span class="hljs-type">void</span> *thread_return)</span></span>;<span class="hljs-comment">//从不返回</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_cancel</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> tid)</span></span>;<span class="hljs-comment">//成功返回0，出错非0</span><br><span class="hljs-comment">/* 等待其他线程终止 */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_join</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> tid, <span class="hljs-type">void</span> **thread_return)</span></span>;<span class="hljs-comment">//成功返回0，出错非0</span><br><span class="hljs-comment">/* 分离线程 */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_detach</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> tid)</span></span>;<span class="hljs-comment">//成功返回0，出错非0</span><br><span class="hljs-comment">/* 初始化线程 */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_once</span><span class="hljs-params">(<span class="hljs-type">pthread_once_t</span> *once_control, <span class="hljs-type">void</span> (*init_routine)(<span class="hljs-type">void</span>))</span></span>;<span class="hljs-comment">//总是返回0</span><br></code></pre></td></tr></table></figure><p><strong>基于线程的并发echo服务器</strong>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;csapp.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">echo</span><span class="hljs-params">(<span class="hljs-type">int</span> connfd)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">thread</span><span class="hljs-params">(<span class="hljs-type">void</span> vargp)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> listenfd,*connfdp;<br>    <span class="hljs-type">socklen_t</span> clientlen;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_storage</span> clientaddr;<br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-keyword">if</span>(argc != <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;usage: %s &lt;port&gt;\n&quot;</span>,argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    listenfd = <span class="hljs-built_in">Open_listenfd</span>(argc[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        clientlen = <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr_storage);<br>        connfdp = <span class="hljs-built_in">Malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>        *connfdp = <span class="hljs-built_in">Accept</span>(listenfd ,(SA *) &amp;clientaddr,&amp;clientlen);<br>        <span class="hljs-built_in">Pthread_creat</span>(&amp;tid,<span class="hljs-literal">NULL</span>,thread,connfdp);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/* Thread routine */</span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *vargp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> connfd = *((<span class="hljs-type">int</span> *)vargp);<br>    <span class="hljs-built_in">Pthread_detach</span>(<span class="hljs-built_in">pthread_self</span>());<br>    <span class="hljs-built_in">Free</span>(vargp);<br>    <span class="hljs-built_in">echo</span>(connfd);<br>    <span class="hljs-built_in">Close</span>(connfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="12-4-多线程程序中的共享变量"><a href="#12-4-多线程程序中的共享变量" class="headerlink" title="12.4 多线程程序中的共享变量"></a>12.4 多线程程序中的共享变量</h4><p>多线程的C程序中变量根据他们的存储类型倍映射到虚拟内存：<br>$\quad$ <strong>全局变量</strong>：虚拟内存的读 &#x2F; 写区域只包含每个全局变量的一个实例<br>$\quad$ <strong>本地自动变量</strong>：定义在函数内部但不<code>static</code>，每个线程的栈都包含它自己的所有本地自动变量的实例<br>$\quad$ <strong>本地静态变量</strong>：只有一个实例，每个对等线程都读 &#x2F; 写这个实例</p><p><strong>共享变量</strong><br>变量是共享的 ⇔ 它的一个实例被一个以上的线程引用<br>本地自动变量也能被共享</p><h4 id="12-5-用信号量同步线程"><a href="#12-5-用信号量同步线程" class="headerlink" title="12.5 用信号量同步线程"></a>12.5 用信号量同步线程</h4><p><strong>进程图</strong><br>$\quad$ 将n个并发线程的执行模型化为一条n维笛卡尔空间中的轨迹线，每条轴k对应于线程k的进度。<br>$\qquad$ 对$H_1,L_1,U_1,H_2,L_2,S_1,T_1,U_2,S_2,T_2$ 的轨迹线：<br><img src="/../icsmg/20230216212506.png"><br><strong>信号量</strong><br><img src="/../icsmg/20230216215854.png"><br>$\quad$ 具有非负整数值的全局变量<code>s</code>，两种操作：<br>$\quad$ <code>P(s)</code>：如果<code>s</code>非零，则将<code>s</code>减1，返回；<code>s</code>为0，就挂起线程，直到<code>s</code>变为非0，<code>V</code>会重启这个线程，重启后<code>P</code>将<code>s</code>减1，返回<br>$\quad$ <code>V(s)</code>：将<code>s</code>加1，如果有线程阻塞在<code>P</code>且等着<code>s</code>变为非零，则<code>V</code>会重启这些线程中的一个<br>$\quad$ 同一时间，只有一个<code>P</code>或一个<code>V</code>能改变<code>s</code>变量；<br>$\quad$ 多个线程在等待同一个信号量时，无法预测<code>V</code>要重启哪个线程<br>$\quad$ 信号量不变性_：信号量不会为负<br>P和V的包装函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">P</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *s)</span></span>;<span class="hljs-comment">/* Wrapper function for sem_wait */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">V</span><span class="hljs-params">(<span class="hljs-type">sem_t</span> *s)</span></span>;<span class="hljs-comment">/* Wrapper function for sem_post */</span><br></code></pre></td></tr></table></figure><p><strong>调度共享资源</strong></p><ol><li><strong>生产者 - 消费者问题</strong></li></ol><p>$\quad$ 生产者和消费者线程共享一个有<code>n</code>个槽的有限缓冲区，生产者反复生成新的项目并加入缓冲区中，消费者不断从缓冲区中取出这些项目，然后处理<br>$\quad$ 插入和去除项目都涉及更新共享变量，所以必须保证对缓冲区的访问是互斥的，同时要调度对缓冲区的访问：<br>$\quad$ 如果缓冲区是满的，生产者必须等待，直到有槽位可用<br>$\quad$ 如果缓冲区是空的。消费者必须等待，直到有槽位不为空</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;csapp.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;sbuf.h&quot;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">int</span> *buf;<span class="hljs-comment">/* Buffer array */</span><br>    <span class="hljs-type">int</span> n;<span class="hljs-comment">/* Maxium number of slots */</span><br>    <span class="hljs-type">int</span> front;<span class="hljs-comment">/* buf[(front+1)%n] is first item */</span><br>    <span class="hljs-type">int</span> rear;<span class="hljs-comment">/* buf[rear%n] is last item */</span><br>    <span class="hljs-type">sem_t</span> mutex;<span class="hljs-comment">/* Protect accesses to buf */</span><br>    <span class="hljs-type">sem_t</span> slots;<span class="hljs-comment">/* Counts available slots */</span><br>    <span class="hljs-type">sem_t</span> items;<span class="hljs-comment">/* Counts available items */</span><br>&#125; <span class="hljs-type">sbuf_t</span>;<br><br><span class="hljs-comment">/* Creat an empty bounded shared FIFO buffer with n slots */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sbuf_init</span><span class="hljs-params">(<span class="hljs-type">sbuf_t</span> *sp, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    sp-&gt;buf = <span class="hljs-built_in">Calloc</span>(n, <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>    sp-&gt;n = n;<span class="hljs-comment">/* buffer holds max of n items */</span><br>    sp-&gt;front=sp-&gt;rear=<span class="hljs-number">0</span>;<span class="hljs-comment">/* Empty buffer iff front=rear */</span><br>    <span class="hljs-built_in">Sem_init</span>(&amp;sp-&gt;mutex, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>); <span class="hljs-comment">/*Binary semaphore for locking */</span><br>    <span class="hljs-built_in">Sem_init</span>(&amp;sp-&gt;slots, <span class="hljs-number">0</span>, n); <span class="hljs-comment">/* initially buf has n empty slots */</span><br>    <span class="hljs-built_in">Sem_init</span>(&amp;sp-&gt;items, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">/* initially, buf has zeor dara items */</span><br>&#125;<br><span class="hljs-comment">/* clean up buffer sp */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sbuf_deinit</span><span class="hljs-params">(<span class="hljs-type">sbuf_t</span> *sp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">Free</span>(sp-&gt;buf);<br>&#125;<br><span class="hljs-comment">/* insert item onto the rear of shared buffer sp */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sbuf_insert</span><span class="hljs-params">(<span class="hljs-type">sbuf_t</span> *sp, <span class="hljs-type">int</span> item)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">P</span>(&amp;sp-&gt;slots); <span class="hljs-comment">/* wait for available slots */</span><br>    <span class="hljs-built_in">P</span>(&amp;sp-&gt;mutex); <span class="hljs-comment">/* lock the buffer */</span><br>    sp-&gt;buf[(++sp-&gt;rear)%(sp-&gt;n)]=item ;<span class="hljs-comment">/* insert the item */</span><br>    <span class="hljs-built_in">V</span>(&amp;sp-&gt;mutex); <span class="hljs-comment">/* Unlock the buffer */</span><br>    <span class="hljs-built_in">V</span>(&amp;sp-&gt;items); <span class="hljs-comment">/* Announce available item */</span><br>&#125;<br><span class="hljs-comment">/* Remove and return the first item from buffer sp */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sbuf_remove</span><span class="hljs-params">(<span class="hljs-type">sbuf_t</span> *sp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> item;<br>    <span class="hljs-built_in">P</span>(&amp;sp-&gt;items);<span class="hljs-comment">/* wait for available item */</span><br>    <span class="hljs-built_in">P</span>(&amp;sp-&gt;mutex);<span class="hljs-comment">/* lock the buffer */</span><br>    item = sp-&gt;buf[(++sp-&gt;front)%(sp-&gt;n)];<span class="hljs-comment">/* remove the item */</span><br>    <span class="hljs-built_in">V</span>(&amp;sp-&gt;mutex);<span class="hljs-comment">/* Unlock the buffer */</span><br>    <span class="hljs-built_in">V</span>(&amp;sp-&gt;slots);<span class="hljs-comment">/* Announce available item */</span><br>    <span class="hljs-keyword">return</span> item;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><strong>读者-写者模型</strong><br>$\qquad$ 一组并发的线程要访问一个共享对象，有些线程只读对象，其他的修改对象。只读对象的线程为读者，修改对象的为写者。写者必须独占对象，读者可以和其他读者共享对象，考虑有无限多个并发的读者和写者.<br>$\qquad$ <strong>第一类</strong>：不让读者等待，除非此时有写者。读者不会因为有写者在等待而等待：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-type">int</span> readcnt;<span class="hljs-comment">/* initially = 0 */</span><br><span class="hljs-type">sem_t</span> mutex, w; <span class="hljs-comment">/* initially 1 */</span>  <span class="hljs-comment">// mutex为readcnt的互斥锁</span><br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reader</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) <br>    &#123;<br>        <span class="hljs-built_in">P</span>(&amp;mutex);<br>        readcnt++;<br>        <span class="hljs-keyword">if</span> (readcnt == <span class="hljs-number">1</span>)<span class="hljs-comment">/* first in */</span><br>            <span class="hljs-built_in">P</span>(&amp;w);<br>        <span class="hljs-built_in">V</span>(&amp;mutex);<br>        <br>    <span class="hljs-comment">/*  reading happens */</span><br>        <br>        <span class="hljs-built_in">P</span>(&amp;mutex);<br>        readcnt--;<br>        <span class="hljs-keyword">if</span> (readcnt == <span class="hljs-number">0</span>)<span class="hljs-comment">/* last out */</span><br>            <span class="hljs-built_in">V</span>(&amp;w);<br>        <span class="hljs-built_in">V</span>(&amp;mutex);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">writer</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-built_in">P</span>(&amp;w);<br>        <br>       <span class="hljs-comment">/* writing happens*/</span><br>        <br>        <span class="hljs-built_in">V</span>(&amp;w);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>$\qquad$ <strong>第二类</strong>：写者优先，写者后到达的读者也必须等待这个写者完成<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> readcnt, writecnt;<span class="hljs-comment">/* initially 0 */</span><br><span class="hljs-type">sem_t</span> rmutex, wmutex, r, w;<span class="hljs-comment">/* initially 1 */</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reader</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) <br>    &#123;<br>        <span class="hljs-built_in">P</span>(&amp;r);<br>        <span class="hljs-built_in">P</span>(&amp;rmutex);<br>        readcnt++;<br>        <span class="hljs-keyword">if</span> (readcnt == <span class="hljs-number">1</span>)<br>            <span class="hljs-built_in">P</span>(&amp;w);<br>        <span class="hljs-built_in">V</span>(&amp;rmutex);<br>        <span class="hljs-built_in">V</span>(&amp;r);<br>        <br>        <span class="hljs-comment">/* reading */</span><br>        <br>        <span class="hljs-built_in">P</span>(&amp;rmutex);<br>        readcnt--;<br>        <span class="hljs-keyword">if</span> (readcnt == <span class="hljs-number">0</span>)<br>            <span class="hljs-built_in">V</span>(&amp;w);<br>        <span class="hljs-built_in">V</span>(&amp;rmutex);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">writer</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">P</span>(&amp;wmutex);<br>        writecnt++;<br>        <span class="hljs-keyword">if</span> (writecnt == <span class="hljs-number">1</span>)<br>            <span class="hljs-built_in">p</span>(&amp;r);<br>        <span class="hljs-built_in">V</span>(wmutex);<br>        <br>        <span class="hljs-built_in">P</span>(&amp;w);<br>        <span class="hljs-comment">/*  writing */</span><br>        <span class="hljs-built_in">V</span>(&amp;w);<br>        <br>        <span class="hljs-built_in">P</span>(&amp;wmutex);<br>        writecnt--;<br>        <span class="hljs-keyword">if</span> (writecnt == <span class="hljs-number">0</span>)<br>            <span class="hljs-built_in">V</span>(&amp;r);<br>        <span class="hljs-built_in">V</span>(&amp;wmutex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p><strong>基于预线程化的并发服务器</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;csapp.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&quot;sbuf.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NTHREADS 4</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SBUFSIZE 16</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">echo_cnt</span><span class="hljs-params">(<span class="hljs-type">int</span> connfd)</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *vargp)</span></span>;<br><span class="hljs-type">sbuf_t</span> sbuf;<span class="hljs-comment">/* shared buffer of connected descriptors */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i,listenfd,counnfd;<br>    <span class="hljs-type">socklen_t</span> clientlen;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_storage</span> clientaddr;<br>    <span class="hljs-type">pthread_t</span> tid;<br>    <span class="hljs-keyword">if</span>(argc!=<span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr,<span class="hljs-string">&quot;usage: %s &lt;port&gt;\n&quot;</span>,argv[<span class="hljs-number">0</span>]);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    listenfd = <span class="hljs-built_in">Open_listenfd</span>(argv[<span class="hljs-number">1</span>]);<br>    <span class="hljs-built_in">sbuf_init</span>(&amp;sbuf,SBUFSIZE);<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span> ;i&lt;NTHREADS;i++)<span class="hljs-comment">/* Creat worker threads */</span><br>    &#123;<br>        <span class="hljs-built_in">Pthread_creat</span>(&amp;tid,<span class="hljs-literal">NULL</span>,thread,<span class="hljs-literal">NULL</span>);<br>    &#125;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        clientlen=<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr_storage);<br>        connfd=<span class="hljs-built_in">Accept</span>(listenfd,(SA*)&amp;clientaddr,&amp;clientlen);<br>        <span class="hljs-built_in">sbuf_insert</span>(&amp;sbuf,connfd);<span class="hljs-comment">/* insert connfd in buffer */</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">thread</span> <span class="hljs-params">(<span class="hljs-type">void</span> *vargp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">Pthread_detach</span>(<span class="hljs-built_in">pthread_self</span>());<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-type">int</span> connfd = <span class="hljs-built_in">sbuf_remove</span>(&amp;sbuf);<span class="hljs-comment">/* remove connfd from buffer */</span><br>        <span class="hljs-built_in">echo_cnt</span>(connfd);<span class="hljs-comment">/* service client */</span><br>        <span class="hljs-built_in">Close</span>(connfd);<br>    &#125;<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> byte_cnt;<span class="hljs-comment">/* byte counter */</span><br><span class="hljs-type">static</span> <span class="hljs-type">sem_t</span> mutex;<span class="hljs-comment">/* and the mutex thar protects it */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">init_echo_cnt</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">Sem_init</span>(&amp;mutex,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>    byte_cnt=<span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">echo_cnt</span><span class="hljs-params">(<span class="hljs-type">int</span> connfd)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">char</span> buf[MAXLINE];<br>    <span class="hljs-type">rio_t</span> rio;<br>    <span class="hljs-type">static</span> <span class="hljs-type">pthread_once_t</span> once = PTHREAD_ONCE_INIT;<br>    <span class="hljs-built_in">Pthread_once</span> (&amp;once ,init_echo_cnt);<br>    <span class="hljs-built_in">Rio_readinitb</span>(&amp;rio,connfd);<br>    <span class="hljs-keyword">while</span>((n=<span class="hljs-built_in">Rio_readlineb</span>(&amp;rio,buf,MAXLINE))!=<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">P</span>(&amp;mutex);<br>        byte_cnt+=n;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;server received %d (%d total) bytes on fd %d \n&quot;</span>,n.byte_cnt,connfd);<br>        <span class="hljs-built_in">V</span>(&amp;mutex);<br>        <span class="hljs-built_in">Rio_writen</span>(connfd,buf,n);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="12-6-使用线程提高并行性"><a href="#12-6-使用线程提高并行性" class="headerlink" title="12.6 使用线程提高并行性"></a>12.6 使用线程提高并行性</h4><p>同步（互斥锁）开销巨大，要尽可能避免。如果无可避免，必须要用尽可能多的有用计算弥补这个开销</p><p>如：不要用互斥锁保护同一个全局变量，在每个对等线程中用私有变量计算部分和（每个对等线程把部分和累计到一个私有数组元素中）</p><p>再优化：累积到一个局部变量中，最后再移动到数组中</p><p><strong>刻画并行程序的性能</strong></p><p>$\quad$ 线程数 &lt; 核数：时间降低：线程数增加一倍，时间下降一半<br>$\quad$ 线程数 &gt; 核数：时间增加（一点）：上下文切换开销</p><p>公式：<br>$\quad$<strong>加速比</strong>：$S_p &#x3D; \frac{T_1}{T_p}$，$p$ 为处理器核数，$T_K$ 为在 k 个核上的运行时间<br>$\qquad$ T1 为程序顺序执行版本的执行时间：$S_p$ 为 <em>绝对加速比</em><br>$\qquad$ T1 为程序并行版本在一个核上的执行时间：$S_p$ 为 <em>相对加速比</em><br>$\quad$<strong>效率</strong>：$E_p &#x3D; \frac{S_p}{p}&#x3D;\frac{T_1}{p{T_p}}$：百分比，对由于并行化造成的开销的衡量<br>$\quad$<strong>弱扩展</strong>：增加处理器数量的同时，增加问题的规模，使得每个处理器执行的工作量保持不变：更加真实</p><h4 id="12-7-其他并发问题"><a href="#12-7-其他并发问题" class="headerlink" title="12.7 其他并发问题"></a>12.7 其他并发问题</h4><h5 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h5><p>$\quad$<strong>线程安全的函数</strong>：当且仅当它被多个并发线程反复调用时，能够一直产生正确的结果<br>$\quad$ 线程不安全函数类：<br>$\quad$ 1.  不保护共享变量的函数<br>$\quad$ 2.  保持跨越多个调用的状态的函数（如：<code>rand</code>，<code>srand</code>，当前调用的结果取决于前一次调用的结果，多线程中无法获得相同的序列）<br>$\quad$ 3.  返回指向静态变量指针的函数：<code>ctime, gethostbyname</code>：正在被一个线程使用的结果可能被另一个线程覆盖<br>$\quad$ 解决方法：<br>$\quad$ $\quad$ 1.  重写函数<br>$\quad$ $\quad$ 2.  将线程不安全函数与互斥锁联系起来：每次调用时用互斥锁加锁，将返回的结果复制到一个私有的内存位置，再解锁（包装函数）<br>$\quad$ 4.  调用线程不安全函数的函数（不一定：如果是1，3类函数，加了互斥锁就是安全的，2只有重写函数）</p><h5 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h5><p>$\quad$ 被多个线程调用时，不会引用_任何_共享数据<br>$\quad$ 线程安全包含可重入<br>$\quad$ <strong>显式可重入</strong>：所有的函数参数都是传值传递，所有的数据引用都是本地的自动栈变量<br>$\quad$ 隐式可重入：参数有传指针：小心使用就是可重入的</p><h5 id="竞争"><a href="#竞争" class="headerlink" title="竞争"></a>竞争</h5><p>$\quad$ 一个程序的正确性依赖于一个线程要在另一个线程到达 y 点之前到达它的控制流中的 x 点：程序员假定线程将通过某种特殊的轨迹线穿过执行状态空间<br>$\quad$ 消除竞争：通过<code>Malloc - Free</code>传参等</p><h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>$\quad$ 一组线程被阻塞，等待一个永远不会为真的条件</p><p><img src="/../icsmg/20230216205835.png"></p><p>$\quad$ 出现：程序员使用P和V信号不当，导致两个信号量的禁止区域重叠<br>$\quad$ 避免死锁：<code>互斥锁加锁顺序规则</code>：给定所有互斥操作的一个全序，如果每个线程都是以一种顺序获得互斥锁并以相反的顺序释放，那么这个程序就是无死锁的</p><h5 id="活锁：冲突碰撞"><a href="#活锁：冲突碰撞" class="headerlink" title="活锁：冲突碰撞"></a>活锁：冲突碰撞</h5><h5 id="饥饿：如高优先度进程阻塞低优先度进程"><a href="#饥饿：如高优先度进程阻塞低优先度进程" class="headerlink" title="饥饿：如高优先度进程阻塞低优先度进程"></a>饥饿：如高优先度进程阻塞低优先度进程</h5><hr><h3 id="LAB"><a href="#LAB" class="headerlink" title="LAB:"></a>LAB:</h3><p><strong>此章节后完成<a href="https://github.com/Aki-yzh/PKU-ICS-2022/tree/main/LABS/8-proxylab">proxylab(75.0&#x2F;100.0)</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11-网络编程</title>
    <link href="/2023/02/18/11-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/02/18/11-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="对应-CSAPP-第十一章节"><a href="#对应-CSAPP-第十一章节" class="headerlink" title="对应 CSAPP 第十一章节"></a>对应 CSAPP 第十一章节</h2><span id="more"></span><h1 id="ICS"><a href="#ICS" class="headerlink" title="ICS"></a><a href="https://aki-yzh.github.io/2023/02/18/1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8&%E7%9B%AE%E5%BD%95">ICS</a></h1><hr><h2 id="十一、网络编程"><a href="#十一、网络编程" class="headerlink" title="十一、网络编程"></a>十一、网络编程</h2><h4 id="11-1-客户端-服务器编程模型"><a href="#11-1-客户端-服务器编程模型" class="headerlink" title="11.1 客户端-服务器编程模型"></a>11.1 客户端-服务器编程模型</h4><p> $\quad$ 每个网络应用都是基于客户端-服务器编程模型的。采用这个模型，一个应用是由一个服务器进程和一个或者多个客户端进程组成。服务器管理某种资源，并且通过操作这种资源来为他的客户端提供某种服务。（<strong>客户端和服务器都是进程</strong>）<br> $\quad$ 客户端-服务器变成模型的基本操作是事务：<br>  $\qquad$ 1) 当一个客户端需要服务时，向服务器发送一个请求<br>  $\qquad$ 2) 服务器收到请求，进行解释并以适当方式操作它的资源<br>  $\qquad$ 3) 服务器给客户端发送一个响应，并等待下一个请求<br>  $\qquad$ 4) 客户端收到响应并处理它<br>  <img src="/../icsmg/20230117150926.png"></p><h4 id="11-2-网络"><a href="#11-2-网络" class="headerlink" title="11.2 网络"></a>11.2 网络</h4><p>$\quad$ 对于主机而言，网络只是又一种I&#x2F;O设备，是数据源和数据的接收方。<br>$\quad$ 物理上来说，网络是一个按照地理位置远近组织的层次系统<br>$\quad$ 最底层是LAN（局域网），最流行的局域网技术是以太网（Ethernet）<br><img src="/../icsmg/20230117152239.png"><br>$\quad$ 一个以太网段包括一些电缆和一个集线器。以太网段中每台主机都能看到每个位。</p><p>$\qquad$ 每个以太网适配器都有一个全球唯一的48位地址。一台主机可以发送一段位（称为帧）到这个网段内的任何其他主机。每个帧包括一些固定数量的头部位，用来标识此帧的源和目的地址以及此帧的长度，此后紧随的就是数据位的有效载荷。每个主机适配器都能看到这个帧，但只有目的主机实际读取它。</p><p>$\quad$ 使用电缆和网桥，多个以太网段可以连接成较大的局域网，称为桥接以太网。<br><img src="/../icsmg/20230117152253.png"><br>$\quad$ 多个不兼容的局域网通过路由器连接，组成一个互联网络（internet）<br><img src="/../icsmg/20230117152436.png"><br>$\quad$ 路由器间点到点高速连接称为广域网（WAN）</p><p>$\quad$ 互联网协议用于消除不同局域网和广域网之间的差异，控制主机和路由器协同工作实现数据传输。<br>$\quad$ 具有两种基本能力：<br>$\qquad$ 命名机制：唯一标识主机<br>$\qquad$ 传送机制：把数据位捆扎成不连续的片（称为包（包头包含包的大小与源主机目的主机的地址））的同一方式。<br>$\quad$ 数据传输的8个基本步骤：<br>$\qquad$ 1)  客户端从虚拟地址空间复制数据到内核缓冲区<br>$\qquad$ 2) 主机A协议软件在数据前附加包头和帧头创建帧<br>$\qquad$ 3) LAN1适配器将帧复制到网络上<br>$\qquad$ 4) 路由器读取帧并传送到协议软件<br>$\qquad$ 5) 路由器从包头提取目的互联网地址，脱落旧帧头，加上新帧头，将帧传送到适配器<br>$\qquad$ 6) LAN2适配器将帧复制到网络上<br>$\qquad$ 7) 主机B的适配器读取此帧并把它传送到协议软件<br>$\qquad$ 8) 主机B读取帧，剥落包头和帧头<br><img src="/../icsmg/20230117152936.png"></p><h4 id="11-3-全球IP因特网"><a href="#11-3-全球IP因特网" class="headerlink" title="11.3 全球IP因特网"></a>11.3 全球IP因特网</h4><p>$\quad$ 因特网应用程序的基本硬件与软件结构：<br><img src="/../icsmg/20230117153046.png"><br>$\quad$ TCP&#x2F;IP协议（传输控制协议&#x2F;互联网络协议）：<br>   $\quad$ 几乎每个现代计算机系统都支持<br>   $\quad$ 实际上是个协议族：<br>$\qquad$ $\quad$ IP：基本命名方法和递送机制<br>$\qquad$ $\qquad$ IP机制是不可靠的，不会试图恢复丢失的数据报<br>$\qquad$ $\quad$ UDP：扩展IP协议（进程间传送）<br>$\qquad$ $\quad$ TCP：可靠的全双工连接<br>$\quad$ 从程序员角度看因特网：<br>$\qquad$ 主机集合，32位IP地址<br>$\qquad$ P地址映射为标识符（因特网域名）<br>$\qquad$ 因特网主机上的进程能通过连接和任何其他因特网主机上的进程通信</p><h6 id="IP地址："><a href="#IP地址：" class="headerlink" title="IP地址："></a>IP地址：</h6><p> $\quad$ 一个IP地址就是个32位无符号整数，因特网客户端和服务器相互通信时使用的就是IP地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* IP address structure */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">in_addr</span>&#123;<br>    <span class="hljs-type">uint32_t</span> s_addr;<span class="hljs-comment">/* Address in network byte order(big - endian)*/</span><br>&#125;;<span class="hljs-comment">//in后缀表示internet</span><br></code></pre></td></tr></table></figure><p>$\quad$ 网络字节顺序：大端字节顺序-&gt;主机字节顺序可能和网络字节顺序不一样<br>$\quad$ 通过如下函数实现网络与主机字节顺序转换<br><img src="/../icsmg/20230117153705.png"><br>$\quad$ 表示：点分十进制（每个字节用它的十进制表示）<br>$\quad$ 如 128.2.194.242就是地址0x8002c2f2的点分十进制表示。<br>$\quad$ 通过如下函数进行转换<br><img src="/../icsmg/20230117153847.png"></p><h6 id="因特网域名："><a href="#因特网域名：" class="headerlink" title="因特网域名："></a>因特网域名：</h6><p>$\quad$ 用句点风格的单词，域名集合形成了一个层次结构，每个域名编码了它在这个层次结构中的位置。<br><img src="/../icsmg/20230117154126.png"><br>$\quad$ 域名系统DNS<br>$\quad$ 从概念上讲，程序员可以把DNS数据库视为数百万条主机条目的集合<br>$\quad$ 每个主机条目定义了域名和IP地址之间的映射<br>$\quad$ 在数字意义上，主机条目是域名和IP地址的等价类</p><h6 id="因特网连接："><a href="#因特网连接：" class="headerlink" title="因特网连接："></a>因特网连接：</h6><p>$\quad$ 点对点的：连接一对进程<br>$\quad$ 全双工的：数据可以同时双向流动<br>$\quad$ 可靠的：由源进程发出的字节流最后被目的进程以它发出的顺序收到它<br>$\quad$ 套接字：一个套接字是连接的一个端点，每个套接字都有相应的套接字地址<br>$\quad$ 套接字由一个因特网地址和一个16位的整数端口组成<br>$\quad$ 客户端套接字地址中的端口由内核自动分配，称为临时端口<br>$\quad$ 服务器套接字地址端口通常是某个知名端口<br>$\qquad$ echo servers: echo 7<br>$\qquad$  ftp servers: ftp 21<br>$\qquad$ ssh servers: ssh 22<br>$\qquad$  email servers: smtp 25<br>$\qquad$ Web servers: http 80<br>$\quad$ 套接字对唯一确定一个连接<br>$\quad$(cliaddr:cliport, servaddr:servport)<br>$\qquad$ cliaddr:客户端IP地址，cliport：客户端端口，servaddr：服务器Ip地址，servport： 服务器端口</p><h4 id="11-4-套接字接口"><a href="#11-4-套接字接口" class="headerlink" title="11.4 套接字接口"></a>11.4 套接字接口</h4><p>$\quad$ 套接字接口是与UnixI&#x2F;O结合使用的一组系统级函数，用于构建网络应用程序，适用于所有现代系统<br><img src="/../icsmg/20230117155314.png"></p><p>$\quad$ 对于内核来说，套接字是与应用程序通信的端点。<br>$\quad$ 对应用来说，套接字是一个文件描述符，允许应用程序从网络读取或写入数据<br>套接字地址结构：<br><img src="/../icsmg/20230117155524.png"><br><strong>socket函数</strong>：创建一个套接字描述符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">socket</span><span class="hljs-params">(<span class="hljs-type">int</span> domain, <span class="hljs-type">int</span> type,<span class="hljs-type">int</span> protocol)</span></span>;<span class="hljs-comment">//若成功则返回非负描述符，否则返回-1；</span><br></code></pre></td></tr></table></figure><p>$\quad$使套接字称为连接的一个端点<br>$\quad$clientfd &#x3D; Socket(AF_INET,SOCK_STREAM,0);<br>$\quad$其中AF_INET表示我们正在使用32位IP地址，SOCK_STREAM表示这个套接字是连接的一个端点。<br><strong>connect函数</strong>：建立和服务器的连接</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-type">int</span> clientfd,<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr* addr,<span class="hljs-type">socklen_t</span> addrlen)</span></span>;<span class="hljs-comment">//成功返回0，否则-1</span><br></code></pre></td></tr></table></figure><p><strong>bind函数</strong>：服务器套接字地址和套接字描述符结合</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bind</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr* addr, <span class="hljs-type">socklen_t</span> addrlen)</span></span>;<span class="hljs-comment">//成功返回0，否则-1</span><br></code></pre></td></tr></table></figure><p><strong>listen函数</strong>： socket主动套接字-&gt;监听套接字</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">listen</span><span class="hljs-params">(<span class="hljs-type">int</span> sockfd,<span class="hljs-type">int</span> backlog)</span></span>;<span class="hljs-comment">//成功返回0，否则-1</span><br></code></pre></td></tr></table></figure><p><strong>accept函数</strong>：等待客户端连接请求</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">accept</span><span class="hljs-params">(<span class="hljs-type">int</span> listenfd,<span class="hljs-keyword">struct</span> sockaddr* addr,<span class="hljs-type">int</span> *addrlen)</span><span class="hljs-comment">//成功返回0，否则-1</span></span><br></code></pre></td></tr></table></figure><p><img src="/../icsmg/20230117161134.png"><br><strong>主机与服务器之间的转换</strong><br>  getaddrinfo:将主机名，主机地址，服务名和端口号的字符串表示转化成套接字地址结构<br>$\qquad$ 可重入的、与协议无关的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getaddrinfo</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *host,<span class="hljs-type">const</span> <span class="hljs-type">char</span> *service,cosnt <span class="hljs-keyword">struct</span> addrinfo* hints,<span class="hljs-keyword">struct</span> addrinfo **result)</span></span>;<span class="hljs-comment">//成功返回0，否则返回非0的错误代码</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">freeaddrinfo</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> addrinfo *result)</span></span>;<br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">gai_strerror</span><span class="hljs-params">(<span class="hljs-type">int</span> errcode)</span></span>;<span class="hljs-comment">//返回错误消息</span><br></code></pre></td></tr></table></figure><p>$\quad$ result指向一个addrinfo结构的链表，其中每个结构指向一个对应于host和service的套接字地址结构，host可以是域名，也可以是数字地址，service参数可以是服务名，也可以是十进制端口号。hints是个addrinfo结构，提供对getaddrinfo返回的套接字地址列表更好的控制。<br>如果不想把主机名转换成地址，可以把host设置为NULL，对于service来说也是一样，但是必须制定两者中其中一个。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">addrinfo</span><br>&#123;<br>    <span class="hljs-type">int</span>   ai_flags;<span class="hljs-comment">//AI_ADDRCONFIG-&gt;使用连接推荐使用，返回地址与主机设置一致；AI_CANONNAME-&gt;ai_canonname指向host的官方名；AI_NUMERICSERV-&gt;强制service为端口号；</span><br>    <span class="hljs-type">int</span>   ai_family;<span class="hljs-comment">//AF_INET-&gt;IPv4,AF_INET6-&gt;IPv6</span><br>    <span class="hljs-type">int</span>   ai_socktype;<br>    <span class="hljs-type">int</span>   ai_protocol;<br>    <span class="hljs-type">char</span>  *ai_canonname;<br>    <span class="hljs-type">size_t</span> ai_addrlen;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr</span> *addr;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">addrinfo</span> *ai_next;<br>&#125;<span class="hljs-comment">//如果要传递hints参数，只能设置flag，family，socktype和protocol，其他必须设0；</span><br></code></pre></td></tr></table></figure><p><img src="/../icsmg/20230117161728.png"><br> $\quad$ 客户端(服务器)调用getaddrinfo后会遍历result指向的列表，依次尝试每个套接字地址直到socket和connect(bind)成功<br> $\quad$ getnameinfo: 将套接字地址结构转换成主机和服务名字符串<br>$\qquad$ $\quad$ 可重入的、与协议无关的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getnameinfo</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sockaddr *sa ,<span class="hljs-type">socklen_t</span> salen,<span class="hljs-type">char</span> *host,<span class="hljs-type">size_t</span> hostlen,<span class="hljs-type">char</span> *service, <span class="hljs-type">size_t</span> servlen,<span class="hljs-type">int</span> flags)</span></span>;<span class="hljs-comment">//成功返回0，错误返回非0的错误代码</span><br></code></pre></td></tr></table></figure><p>$\quad$ sa指向大小为salen的套接字地址结构，host指向大小为hostlen字节的缓冲区，service指向大小为servlen字节的缓冲区，getnameinfo将套接字地址结构转换成对应的主机和服务名字符串，并把它们复制到host和service缓冲区。flags是一个位掩码，修改默认行为(NI_NUMERICHOST-&gt;使函数返回数字地址字符串；NI_NUMERICSERV-&gt;函数跳过查找简单返回端口号)<br>$\quad$ 如果不想要主机名，可以把host设定为NULL，hostlen设置为0，对服务字段也是一样，不过两者只能设置其中之一。</p><p><strong>套接字接口的辅助函数</strong></p><p>$\quad$ open_clientfd:建立与服务器之间的连接</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;csapp.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">openclientfd</span><span class="hljs-params">(<span class="hljs-type">char</span> *hostname,<span class="hljs-type">char</span> *port)</span></span>;<span class="hljs-comment">//成功返回描述符，出错返回-1；</span><br></code></pre></td></tr></table></figure><p>$\quad$ open_listenfd:服务器创建监听描述符，准备接收连接请求,是可重入，与协议无关的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">open_listenfd</span><span class="hljs-params">(<span class="hljs-type">char</span> *port)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">addrinfo</span> hints,*listp,*p;<br>    <span class="hljs-type">int</span> listenfd,optval=<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">/* get a list of potential server addresses */</span><br>    <span class="hljs-built_in">memset</span> (&amp;hints,<span class="hljs-number">0</span>,<span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> addrinfo));<br>    hints.ai_socktype = SOCK_STREAM;<span class="hljs-comment">/* accept connections */</span><br>    hints.ai_flags = AI_PASSIVE | AI_ADDRCONFIG;<span class="hljs-comment">/* on any IP address */</span><br>    hints.ai_flags = AI_NUMERICSERV;<span class="hljs-comment">/* usng port number */</span><br>    <span class="hljs-built_in">Getaddrinfo</span>(<span class="hljs-literal">NULL</span>,port,&amp;hints,&amp;listp);<br><br>    <span class="hljs-comment">/* walk the list for one that we can bind to */</span><br>    <span class="hljs-keyword">for</span>(p = listp;p;p=p-&gt;ai_next)<br>    &#123;<br>        <span class="hljs-comment">/* creat a socket descriptor */</span><br>        <span class="hljs-keyword">if</span>((listenfd = <span class="hljs-built_in">socket</span>(p-&gt;ai_family,p -&gt; ai_socketype,p-&gt;ai_protocol))&lt;<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">continue</span>;<span class="hljs-comment">/* socket failed ,try the next */</span><br><br>        <span class="hljs-comment">/* eliminates &quot;address already in use&quot; error from bind */</span><br>        <span class="hljs-built_in">Setsockopt</span>(listenfd,SOL_SOCKET,SO_REUSEADDR,(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *)&amp;optval,<span class="hljs-built_in">sizeof</span>(hint));<br><br>        <span class="hljs-comment">/* bind the descriptor to the address */</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">bind</span>(listenfd,p-&gt;ai_addr,p-&gt;ai_addrlen)==<span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<span class="hljs-comment">/* success */</span><br>        <span class="hljs-built_in">Close</span>(listenfd);<span class="hljs-comment">/* bind failed, try the next */</span><br>    &#125;<br>    <span class="hljs-comment">/* clean up */</span><br>    <span class="hljs-built_in">Freeaddrinfo</span>(listp);<br>    <span class="hljs-keyword">if</span>(!p)<span class="hljs-comment">/* no address worked */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-comment">/* make it a listening socket ready to accept connection requests */</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">listen</span>(listenfd, LISTENQ)&lt;<span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">Close</span>(listenfd);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> listenfd;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="11-5-Web服务器"><a href="#11-5-Web服务器" class="headerlink" title="11.5 Web服务器"></a>11.5 Web服务器</h4><p>$\quad$ 迭代服务器：一次一个地在客户端间迭代<br>$\quad$ 并发服务器：能同时处理多个客户端<br><strong>Web基础</strong><br>$\quad$ Web客户端和服务器之间的交互用的是一个基于文本的应用级协议，叫做HTTP协议。<br>$\quad$ HTTP是一个简单的协议。一个Web客户端打开一个到服务器的因特网连接，并且请求某些内容，服务器响应所请求的内容，然后关闭连接，浏览器读取这些内容并把它显示在屏幕上。<br>$\quad$ Web内容采用html语言编写，一个HTML程序包括指令，它们告诉浏览器如何显示这页中的各种文本和图形对象<br><strong>Web内容</strong><br>$\quad$ 内容是与一个MIME类型相关的字节序列。</p><table><thead><tr><th>MIME类型</th><th>描述</th></tr></thead><tbody><tr><td>text&#x2F;html</td><td>html界面</td></tr><tr><td>text&#x2F;plain</td><td>无格式文本</td></tr><tr><td>application&#x2F;postscript</td><td>postscript 文档</td></tr><tr><td>image&#x2F;gif</td><td>GIF格式编码的二进制图像</td></tr><tr><td>image&#x2F;png</td><td>PNG格式编码的二进制图像</td></tr><tr><td>image&#x2F;jepg</td><td>JEPG格式编码的二进制图像</td></tr></tbody></table><p>$\quad$ Web服务器用两种不同的方式向客户端提供内容：<br>$\quad$ ·- 取一个磁盘文件，并将它的内容返回给客户端，磁盘文件称为静态内容，此过程称为服务静态内容<br>$\quad$ ·- 运行一个可执行文件，并把它的输出返回到客户端，运行可执行文件时的输出称为动态内容，此过程称为服务动态内容。<br>$\quad$ URL唯一标识服务器管理的文件<br>$\qquad$ 最小的URL后缀:“&#x2F;”所有服务器将其扩展为默认的主页 </p><p><strong>HTTP事务</strong><br>$\quad$ 1.HTTP请求：请求行+多个请求报头+一个空文本行（终止）<br>$\qquad$ GET方法：服务器生成和返回URI（文件名+可选参数<br>$\quad$ $\quad$ 请求行： method URI version（method 方法，一般用GET，URI：URL后缀，包括文件名和可选参数；version：HTTP版本）<br>$\quad$ $\quad$ 请求报头：header-name：header-data<br>$\quad$ 2.HTTP响应：响应行+多个响应报头+终止空行+响应主体<br>$\quad$ $\quad$ 响应行： version status-code status- message（version：http版本；status-code状态码）</p><table><thead><tr><th>状态码</th><th>状态消息</th><th>描述</th></tr></thead><tbody><tr><td>200</td><td>成功</td><td>处理请求无误</td></tr><tr><td>301</td><td>永久移动</td><td>内容已移动到location头中指明的主机上</td></tr><tr><td>400</td><td>错误请求</td><td>服务器不能理解请求</td></tr><tr><td>403</td><td>禁止</td><td>服务器无权访问所请求的文本</td></tr><tr><td>404</td><td>未发现</td><td>服务器不能找到所请求的文件</td></tr><tr><td>501</td><td>未实现</td><td>服务器不支持请求的方法</td></tr><tr><td>505</td><td>HTTP版本不支持</td><td>服务器不支持请求的版本</td></tr></tbody></table><p><strong>服务动态内容</strong></p><p>$\quad$ CGI（通用网关接口）<br>$\quad$（参数）客户端-&gt;服务器（URI）：<br>$\quad$ 用 ？分隔文件名和参数，&amp;分隔各个参数，空格写作%20<br>$\quad$（参数）服务器-&gt;子进程：设置环境变量<br>$\quad$ 子进程输出直接重定向至和客户端相关联的已连接描述符</p><h4 id="11-6-TINY-Web服务器"><a href="#11-6-TINY-Web服务器" class="headerlink" title="11.6 TINY Web服务器"></a>11.6 TINY Web服务器</h4><p>$\quad$ main：打开监听套接字，无限循环，接受请求，执行事务，并关闭连接的它的那一端</p><p>$\quad$ doit：处理一个HTTP事务</p><p>$\quad$ clienterror：检查明显错误并报告给客户端</p><p>$\quad$ read_requesthdrs：读取并忽略报头</p><p>$\quad$ parse_uri：解析URI为一个文件名和一个可选的CGI字符串</p><p>$\quad$ serve_static：提供静态内容</p><p>$\quad$ serve_dynamic：提供动态内容</p><p>$\quad$ 详见<a href="https://github.com/Aki-yzh/PKU-ICS-2022/tree/main/LABS/8-proxylab">proxylab</a></p><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>10-系统级IO</title>
    <link href="/2023/02/18/10-%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/"/>
    <url>/2023/02/18/10-%E7%B3%BB%E7%BB%9F%E7%BA%A7IO/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="对应-CSAPP-第十章节"><a href="#对应-CSAPP-第十章节" class="headerlink" title="对应 CSAPP 第十章节"></a>对应 CSAPP 第十章节</h2><span id="more"></span><h1 id="ICS"><a href="#ICS" class="headerlink" title="ICS"></a><a href="https://aki-yzh.github.io/2023/02/18/1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8&%E7%9B%AE%E5%BD%95">ICS</a></h1><hr><h2 id="十、系统级I-x2F-O"><a href="#十、系统级I-x2F-O" class="headerlink" title="十、系统级I&#x2F;O"></a>十、系统级I&#x2F;O</h2><p>$\quad$ 输入&#x2F;输出是在主存和外部设备之间复制数据的过程。</p><h4 id="10-1-Unix-I-x2F-O"><a href="#10-1-Unix-I-x2F-O" class="headerlink" title="10.1 Unix I&#x2F;O"></a>10.1 Unix I&#x2F;O</h4><p>$\quad$ 一个Linux文件就是一个m个字节的序列：$ B_0,B_1……B_{m-1} $<br>$\quad$ 所有的I&#x2F;O设备都被模型化为文件，所有的输入输出都被当作对相应文件的读和写来执行。<br>$\qquad$ 打开文件：创建描述符<br>$\qquad$ 每个进程开始时都有三个打开的文件：标准输入(0), 标准输出(1), 标准错误(2)<br>$\qquad$ 改变当前的文件位置：每个打开的文件内核保持一个文件位置k。<br>$\qquad$ 读写文件：读：从文件复制n个字节到内存，将文件位置从k增加到k+n，当文件位置超过文件大小触发EOF，文件结尾没有EOF符号，写类似。<br>$\qquad$ 关闭文件：当应用完成了对文件的访问之后，它就通知内核关闭这个文件</p><h4 id="10-2-文件"><a href="#10-2-文件" class="headerlink" title="10.2 文件"></a>10.2 文件</h4><p>$\quad$ 每个Linux文件都有一个类型来表明它在系统中的角色。<br>$\qquad$ <strong>普通文件</strong>包括任意数据。区分文本文件和二进制文件<br>$\qquad$ <strong>目录</strong>是包含一组连接的文件。其中每个链接都将一个文件名映射到一个文件（mkdir创建，ls查看，rmdir删除）.是到目录自身的链接，..是到父目录的链接。<br>$\qquad$ <strong>套接字</strong>是用来与另一个进程进行跨网络通信的文件<br>Linux内核将所有文件都组合成一个目录层次结构，由名为&#x2F;的根目录确定。系统中的每一个文件都是根目录的直接或间接后代。<br>$\qquad$ <strong>其它类型</strong>诸如命名通道，符号链接，字符，块设备。<br><img src="/../icsmg/20230214221030.png"><br>$\quad$ 每一个进程都有一个当前工作目录，可以用cd命令修改<br>$\qquad$ 绝对路径名：以一个斜杠开始，表示从根节点开始的路径<br>$\qquad$ 相对路径名：以文件名开始，表示从当前工作目录开始的路径</p><h4 id="10-3-打开和关闭文件"><a href="#10-3-打开和关闭文件" class="headerlink" title="10.3 打开和关闭文件"></a>10.3 打开和关闭文件</h4><p>$\quad$ 调用open函数来打开一个已经存在的文件或者创建一个新文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">char</span> *filename,<span class="hljs-type">int</span> flags,<span class="hljs-type">mode_t</span> mode)</span></span>;<span class="hljs-comment">//成功返回文件描述符，出错返回-1；</span><br></code></pre></td></tr></table></figure><p>$\qquad$ flags:访问模式：O_RDONLY只读；O_WRONLY只写；ORDWR可读可写<br>$\qquad$ $\qquad$ 写｜接上掩码为写提供一些额外的指示：<br>$\qquad$ $\qquad$ $\qquad$ O_CREAT：如果文件不存在，创建截断的文件<br>$\qquad$ $\qquad$ $\qquad$ O_TRUNC：文件已经存在，截断它<br>$\qquad$ $\qquad$ $\qquad$ O_APPEND：设定文件位置在文件的结尾<br>$\qquad$ mode：访问权限<br><img src="/../icsmg/20230214222419.png"><br>$\quad$ close函数用于关闭已经打开的文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span>;<span class="hljs-comment">//成功返回0，出错-1</span><br></code></pre></td></tr></table></figure><h4 id="10-4-读和写文件"><a href="#10-4-读和写文件" class="headerlink" title="10.4 读和写文件"></a>10.4 读和写文件</h4><p>$\quad$ 调用read和write函数来执行输入与输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">void</span> *buf,<span class="hljs-type">size_t</span> n)</span></span>;<span class="hljs-comment">//成功返回读的字节数，EOF返回0，出错-1</span><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf,<span class="hljs-type">size_t</span> n)</span></span>;<span class="hljs-comment">//成功返回写的字节数，出错-1</span><br></code></pre></td></tr></table></figure><p>$\quad$ 不足值：<br>$\qquad$ 读时遇到EOF<br>$\qquad$ 从终端读文本行：不足值等于文本行大小<br>$\qquad$ 读和写网络套接字：内部缓冲约束和网络延迟</p><h4 id="10-5-用RIO包健壮地读写"><a href="#10-5-用RIO包健壮地读写" class="headerlink" title="10.5 用RIO包健壮地读写"></a>10.5 用RIO包健壮地读写</h4><p><strong>无缓冲的输入输出函数</strong><br>$\quad$ 直接在内存和文件之间传送数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">rio_readn</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">void</span> *usrbuf,<span class="hljs-type">size_t</span> n)</span></span>;<br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">rio_writen</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-type">void</span> *usrbuf,<span class="hljs-type">size_t</span> n)</span></span>;<span class="hljs-comment">//返回规则同上</span><br></code></pre></td></tr></table></figure><p><strong>带缓冲的输入函数</strong><br>$\quad$ 带缓冲函数的调用不应和无缓冲的函数交叉使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">rio_readlineb</span>(<span class="hljs-type">rio_t</span> *rp,<span class="hljs-type">int</span> fd);<br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">rio_readlineb</span><span class="hljs-params">(<span class="hljs-type">rio_t</span> *rp,<span class="hljs-type">void</span> *usrbuf,<span class="hljs-type">size_t</span> maxlen)</span></span>;<br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">rio_readnb</span><span class="hljs-params">(<span class="hljs-type">rio_t</span> *rp,<span class="hljs-type">void</span> *usrbuf,<span class="hljs-type">size_t</span> n)</span></span>;<br></code></pre></td></tr></table></figure><h4 id="10-6-读取文件元数据"><a href="#10-6-读取文件元数据" class="headerlink" title="10.6 读取文件元数据"></a>10.6 读取文件元数据</h4><p>$\quad$ 调用stat和fstat，检索文件元数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">stat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename,<span class="hljs-keyword">struct</span> stat *buf)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fstat</span><span class="hljs-params">(<span class="hljs-type">int</span> fd,<span class="hljs-keyword">struct</span> stat *buf)</span></span>;<span class="hljs-comment">//成功返回0，出错-1</span><br></code></pre></td></tr></table></figure><p>$\quad$ stat参数文件名，fstat参数描述符作为输入<br>填写stat数据结构</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">stat</span><br>&#123;<br>    <span class="hljs-type">dev_t</span>          st_dev;<span class="hljs-comment">/* Devive */</span><br>    <span class="hljs-type">ino_t</span>          st_ino;<span class="hljs-comment">/* inode */</span><br>    <span class="hljs-type">mode_t</span>         st_mode;<span class="hljs-comment">/* Protection and file type (S_ISREG(普通文件），S_ISDIR（目录文件），S_ISSOCK（网络套接字））*/</span><br>    <span class="hljs-type">nlink_t</span>        st_nlink;<span class="hljs-comment">/* number of hard links */</span><br>    <span class="hljs-type">uid_t</span>          st_uid;<span class="hljs-comment">/* User ID of owner */</span><br>    <span class="hljs-type">gid_t</span>          st_gid;<span class="hljs-comment">/* Group ID of owner */</span><br>    <span class="hljs-type">dev_t</span>          st_rdev;<span class="hljs-comment">/* Device type */</span><br>    <span class="hljs-type">off_t</span>          st_size;<span class="hljs-comment">/* Total size,in bytes */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>  st_blksize;<span class="hljs-comment">/* Block size for filesystem I/O */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>  st_blocks;<span class="hljs-comment">/* Number of blocks allocated */</span><br>    <span class="hljs-type">time_t</span>         st_atime;<span class="hljs-comment">/* Time of last access */</span><br>    <span class="hljs-type">time_t</span>         st_mtime;<span class="hljs-comment">/* Time of last modiffication */</span><br>    <span class="hljs-type">time_t</span>         st_ctime;<span class="hljs-comment">/* Time of last change */</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="10-7-读取目录内容"><a href="#10-7-读取目录内容" class="headerlink" title="10.7 读取目录内容"></a>10.7 读取目录内容</h4><p>$\quad$ 用readdir系列函数来读取目录内容</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">DIR *<span class="hljs-title">opendir</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *name)</span></span>;<span class="hljs-comment">//成功返回处理指针，否则NULL</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dirent</span> *<span class="hljs-built_in">readdir</span>(DIR *dirp);<span class="hljs-comment">//返回指向下一个目录项的指针，否则NULL</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">closedir</span><span class="hljs-params">(DIR *dirp)</span></span>;<span class="hljs-comment">//成功0，错误-1</span><br></code></pre></td></tr></table></figure><h4 id="10-8-共享文件"><a href="#10-8-共享文件" class="headerlink" title="10.8 共享文件"></a>10.8 共享文件</h4><p>$\quad$ 内核用三个相关的数据结构来表示打开的文件<br><strong>描述符表</strong><br>$\quad$ 每个进程都有独立的描述符表，每个打开的描述符表项指向文件表中的一个表项。<br><strong>文件表</strong><br>$\quad$ 所有进程共享<br><strong>v-node表</strong><br>$\quad$ 所有进程共享，包含stat信息</p><h4 id="10-9-I-x2F-O重定向"><a href="#10-9-I-x2F-O重定向" class="headerlink" title="10.9 I&#x2F;O重定向"></a>10.9 I&#x2F;O重定向</h4><p>$\quad$ 使用dup2函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dup2</span><span class="hljs-params">(<span class="hljs-type">int</span> oldfd,<span class="hljs-type">int</span> newfd)</span></span>;<span class="hljs-comment">//成功返回非负描述符，错误返回-1</span><br></code></pre></td></tr></table></figure><p>$\quad$ 复制oldfd并覆盖至newfd，若newfd已打开，则会先关闭newfd</p><h4 id="10-10-标准I-x2F-O"><a href="#10-10-标准I-x2F-O" class="headerlink" title="10.10 标准I&#x2F;O"></a>10.10 标准I&#x2F;O</h4><p>$\quad$ C语言库，<br>$\quad$ 流：指向FILE类型结构的指针<br>$\quad$ 标准输入(stdin), 标准输出(stdout), 标准错误(stderr)<br>$\quad$ 高级输入输出函数（fopen和fclose，fread和fwrite，fgets和fputs，scanf和printf）</p><p>$\quad$ 只要有可能就使用标准I&#x2F;O<br>$\quad$ 不要用scanf或rio_readlineb来读二进制文件<br>$\quad$ 对网络套接字I&#x2F;O使用RIO<br><img src="/../icsmg/20230214230707.png"></p><hr><h3 id="LAB"><a href="#LAB" class="headerlink" title="LAB:"></a>LAB:</h3><p><strong>此章节后完成<a href="https://github.com/Aki-yzh/PKU-ICS-2022/tree/main/LABS/6-shelllab">shelllab(134.0&#x2F;138.0)</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>9-虚拟内存</title>
    <link href="/2023/02/18/9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    <url>/2023/02/18/9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="对应-CSAPP-第九章节"><a href="#对应-CSAPP-第九章节" class="headerlink" title="对应 CSAPP 第九章节"></a>对应 CSAPP 第九章节</h2><span id="more"></span><h1 id="ICS"><a href="#ICS" class="headerlink" title="ICS"></a><a href="https://aki-yzh.github.io/2023/02/18/1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8&%E7%9B%AE%E5%BD%95">ICS</a></h1><hr><h2 id="九、虚拟内存"><a href="#九、虚拟内存" class="headerlink" title="九、虚拟内存"></a>九、虚拟内存</h2><p>$\quad$ 虚拟内存是硬件异常，硬件地址翻译，主存，磁盘文件和内核软件的完美交互，它为每个进程提供了一个大的，一致的和私有的地址空间。<br>$\quad$ 虚拟内存提供了三个重要能力：<br>$\quad$  1. 它将主存看成是一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存之间来回传送数据，高效地使用了主存。<br>$\quad$  2. 它为每个进程提供了一致的地址空间，从而简化了内存管理<br>$\quad$  3. 它保护了每个进程的地址空间不被其他进程破坏</p><h4 id="9-1-物理和虚拟寻址"><a href="#9-1-物理和虚拟寻址" class="headerlink" title="9.1 物理和虚拟寻址"></a>9.1 物理和虚拟寻址</h4><p>$\quad$ 主存被组织成一个由M个连续的字节大小的单元组成的数组，每个字节都有一个唯一的物理地址。<br>$\quad$ CPU访问内存的最自然的方式就是使用物理地址，我们把这种方式称为物理寻址。</p><p>$\quad$ 使用虚拟寻址，CPU通过生成一个虚拟地址来访问主存，这个虚拟地址在被传送到内存之前先转换成适当的物理地址。<br>$\quad$ 将一个虚拟地址转换为物理地址的任务叫做地址翻译，CPU上叫做内存管理单元的专用硬件利用存放在主存中的查询表来动态翻译虚拟地址，该表的内容由操作系统管理。</p><h4 id="9-2-地址空间"><a href="#9-2-地址空间" class="headerlink" title="9.2 地址空间"></a>9.2 地址空间</h4><p>$\quad$ 地址空间是一个非负整数地址的有序集合。<br>$\quad$ 线性地址空间：地址空间中整数是连续的<br>$\quad$ 虚拟地址空间(N&#x3D;2^n)（n位地址空间）<br>$\quad$ 物理地址空间(M&#x3D;2^m)</p><h4 id="9-3-虚拟内存作为缓存的工具"><a href="#9-3-虚拟内存作为缓存的工具" class="headerlink" title="9.3 虚拟内存作为缓存的工具"></a>9.3 虚拟内存作为缓存的工具</h4><p>$\quad$ 虚拟内存被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组，每个字节有唯一的虚拟地址，作为到数组的索引。<br>$\quad$ 磁盘上数组的内容被缓存在主页中。<br>$\quad$ VM系统通过将虚拟内存分割为称为虚拟页的大小固定的块来处理这个问题。每个虚拟页的大小为$P&#x3D;2^p$ 个字节。类似的，物理内存被分配为物理页，大小也为P字节。（物理页也被称为页帧）<br>$\quad$ 在任意时刻，虚拟页面的集合都分为三个不相交的子集：<br>$\qquad$ 1. 未分配的：VM还未分配（或者创建）的页。没有任何数据与之相关联，因此也不占用任何磁盘空间<br>$\qquad$ 2. 缓存的：已缓存在物理内存中的已分配页<br>$\qquad$ 3. 未缓存的： 未缓存在物理内存中的已分配页</p><p>$\quad$ DRAM缓存（虚拟内存系统的缓存）：虚拟页往往很大，全相联，总是使用写回</p><p><strong>页表</strong><br>$\quad$ 页表存放在物理内存中，将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转化为物理地址时，都会读取页表。<br>$\quad$ 页表就是个页表条目(PTE)的数组，每个PTE是由一个有效位和一个n位地址字段组成的。<br><img src="/../icsmg/20230215212321.png"><br><strong>页命中</strong><br>$\quad$ 虚拟地址-&gt;索引-&gt;有效位1-&gt;物理地址<br><img src="/../icsmg/20230215212633.png"><br><strong>缺页</strong><br>$\quad$ DRAM缓存不命中-&gt;调用内核中的异常处理程序-&gt;页面调度（按需页面调度）<br><img src="/../icsmg/20230215213456.png"><br><strong>分配页面</strong><br><img src="/../icsmg/20230215212920.png"><br>$\quad$ 局部性保证了任意时刻程序趋向于在一个较小的活动页面集合上工作</p><h4 id="9-4-虚拟内存作为内存管理的工具"><a href="#9-4-虚拟内存作为内存管理的工具" class="headerlink" title="9.4 虚拟内存作为内存管理的工具"></a>9.4 虚拟内存作为内存管理的工具</h4><p>$\quad$ 按需页面调度+独立地址空间&#x3D;简化链接、简化加载、简化共享、简化内存分配</p><h4 id="9-5-虚拟内存作为内存保护的工具"><a href="#9-5-虚拟内存作为内存保护的工具" class="headerlink" title="9.5 虚拟内存作为内存保护的工具"></a>9.5 虚拟内存作为内存保护的工具</h4><p>$\quad$ 三个许可位：SUP，READ，WRITE表示权限</p><h4 id="9-6-地址翻译"><a href="#9-6-地址翻译" class="headerlink" title="9.6 地址翻译"></a>9.6 地址翻译</h4><p><img src="/../icsmg/20230215213421.png"><br>$\quad$ 形式上来说，地址翻译是一个N元素的虚拟地址空间中的元素（VAS）和一个M元素的物理地址空间（PAS）中元素之间的映射<br>$\qquad \qquad \quad MAP:VAS\rightarrow PAS \cup \emptyset$<br><img src="/../icsmg/20230215214022.png"><br>$\quad$ PPO和VPO是相同的<br><img src="/../icsmg/20230215214156.png"><br>$\quad$ 页面命中后，CPU硬件：<br>$\qquad$ 1. 处理器生成一个虚拟地址，并把它传给MMU<br>$\qquad$ 2. MMU生成PTE地址，并从高速缓存&#x2F;主存中请求得到它<br>$\qquad$ 3. 高速缓存&#x2F;主存向MMU返回PTE<br>$\qquad$ 4. MMU构造物理地址，并把它传送给高速缓存&#x2F;主存<br>$\qquad$ 5. 高速缓存&#x2F;主存返回所请求的数据字给处理器<br>$\quad$ 缺页时：<br>$\qquad$ 1. 处理器生成一个虚拟地址，并把它传给MMU<br>$\qquad$ 2. MMU生成PTE地址，并从高速缓存&#x2F;主存中请求得到它<br>$\qquad$ 3. 高速缓存&#x2F;主存向MMU返回PTE<br>$\qquad$ 4. PTE的有效位是0，MMU触发了一次异常，传递CPU中的控制到操作系统内核中的缺页异常处理程序<br>$\qquad$ 5. 缺页处理程序确定出物理内存中的牺牲页，如果这个页面已经被修改了，则把它换出到磁盘<br>$\qquad$ 6. 缺页处理程序调入新的页面，并更新内存中的PTE<br>$\qquad$ 7. 缺页处理程序返回到原来的进程，再次执行导致缺页的指令。CPU将引起缺页的虚拟地址重新发送给MMU。因为虚拟页面现在换存在物理内存中，所以就会命中，在MMU执行了页面命中后，主存将所请求字返回给处理器。</p><p><img src="/../icsmg/20230215214326.png"><br><strong>结合高速缓存和虚拟内存</strong><br><img src="/../icsmg/20230215215737.png"><br><strong>利用TLB加速地址翻译</strong><br>$\quad$ TLB：小的，虚拟寻址的缓存，称为快表，每一行保存着一个由单个PTE组成的块。<br>$\quad$ 若TLB有2^t个组，则VPN最低t位为TLB索引（TLBI）</p><p><img src="/../icsmg/20230215220155.png"><br>$\quad$ 1. CPU产生一个虚拟地址<br>$\quad$ 2. MMU从TLB中取出相应的PTE<br>$\quad$ 3. MMU将这个虚拟地址翻译成一个物理地址，并且将它发送到高速缓存&#x2F;主存。<br>$\quad$ 4. 高速缓存&#x2F;主存将所请求的数据字返回给CPU<br><img src="/../icsmg/20230215215804.png"><br><strong>多级页表</strong></p><p><img src="/../icsmg/20230215220457.png"><br>$\quad$ 每个高级PTE指向一个下一级页表的基址，逐级访问直到最终访问到目标地址，只有一级页表才需要总是保存在主存中。<br>$\quad$ 能减小内存要求<br>$\quad$ 若一级页表中一个PTE是空的，相应的二级页表根本不会存在<br><img src="/../icsmg/20230215220429.png"></p><h4 id="9-7-Intel-Core-i7-x2F-Linux-内存系统"><a href="#9-7-Intel-Core-i7-x2F-Linux-内存系统" class="headerlink" title="9.7 Intel Core i7&#x2F;Linux 内存系统"></a>9.7 Intel Core i7&#x2F;Linux 内存系统</h4><p><strong>Intel Core i7</strong><br>$\quad$ 四级页表层次结构，64位内存地址，40位PPN，4个许可位，1个标记位，引用位(A)，修改位(D)<br><strong>Linux虚拟内存系统</strong><br>$\quad$ 基本同上述虚拟内存系统</p><h4 id="9-8-内存映射"><a href="#9-8-内存映射" class="headerlink" title="9.8 内存映射"></a>9.8 内存映射</h4><p>$\quad$ 将一个虚拟内存区域与一个磁盘上的对象关联起来，以初始化这个虚拟内存区域的内容<br>$\quad$ 映射对象：普通文件和匿名文件</p><p><strong>共享对象&amp;私有对象</strong><br>$\quad$ 映射了同一个共享对象的各进程对这个对象的写是相互可见的，也会反映到磁盘上的原始对象中<br>$\quad$ 对私有区域的写操作不会反映到磁盘上的对象中<br>$\quad$ 写时复制：试图写时会触发保护故障，创建一个新的副本（写操作仅执行在该副本上，且其他进程不可见）<br><img src="/../icsmg/20230215224447.png"><br><strong>再看fork</strong><br>$\quad$ 为新进程创建各种数据结构，PID<br>$\quad$ 两个进程的每个页面都标记为只读<br>$\quad$ 每个区域结构都标记为私有的写时复制<br>$\quad$ 为每个进程维护私有地址空间的抽象概念</p><p><strong>再看execve</strong><br>$\quad$ 删除已存在的用户区域<br>$\quad$ 映射私有区域（都是私有的，写时复制的）<br>$\quad$ 映射共享区域<br>$\quad$ 设置程序计数器(PC)，指向代码区域入口</p><p><strong>mmap与munmap：用户级内存映射</strong><br>$\quad$ mmap：创建新的虚拟内存区域，并将对象映射到这些区域中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *start,<span class="hljs-type">size_t</span> length,<span class="hljs-type">int</span> prot,<span class="hljs-type">int</span> flags,<span class="hljs-type">int</span> fd,<span class="hljs-type">off_t</span> offfset)</span></span>;<br><span class="hljs-comment">//成功返回指向映射区域的指针，出错返回MAP——FAILED（-1）</span><br></code></pre></td></tr></table></figure><p>$\quad$ prot：访问权限位：PROT_EXEC（页面可以被CPU执行的指令组成）；PROT_READ（页面可读）；PROT_WRITE（页面可写）；PROT_NONE（页面不能被访问）<br><img src="/../icsmg/20230215224830.png"></p><p>$\quad$ munmap：删除虚拟内存的start开始由接下来length字节构成的区域</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">munmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *start,<span class="hljs-type">size_t</span> length)</span></span>;<span class="hljs-comment">//成功返回0，出错返回-1</span><br></code></pre></td></tr></table></figure><h4 id="9-9-动态内存分配"><a href="#9-9-动态内存分配" class="headerlink" title="9.9 动态内存分配"></a>9.9 动态内存分配</h4><p><img src="/../icsmg/20230215225518.png"></p><p><strong>显示分配器</strong>：显式地释放已分配的块</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* 分配块 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">malloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span></span>;<span class="hljs-comment">//成功返回已分配块的指针，否则NULL</span><br><span class="hljs-comment">/* 释放块 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">free</span><span class="hljs-params">(<span class="hljs-type">void</span> *ptr)</span></span>;<br><span class="hljs-comment">/* 扩展/收缩堆 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">sbrk</span><span class="hljs-params">(<span class="hljs-type">intptr_t</span> incr)</span></span>;<br></code></pre></td></tr></table></figure><p>要求<br>$\quad$ 处理任意请求序列：约束：每个释放必须对应一个已分配的块<br>$\quad$ 立即响应请求：不允许重排或缓冲<br>$\quad$ 只使用堆<br>$\quad$ 对齐块：对齐块使得能保存任何类型的数据对象<br>$\quad$ 不修改已分配的块<br>目标<br>$\quad$ 最大化吞吐率<br>$\quad$ 吞吐率：单位时间完成的请求数<br>$\quad$ 最大化内存利用率<br>$\quad$ 峰值利用率：聚集有效载荷&#x2F;堆大小<br><img src="/../icsmg/20230215225953.png"><br><strong>碎片</strong><br>$\quad$ 内部碎片：已分配块比有效载荷大<br>$\quad$ 外部碎片：空闲内存分散</p><p><strong>隐式空闲链表</strong></p><p>$\quad$ 整个链表需要一个特殊标记的结束块<br>$\quad$ 空闲块之间通过头部的块大小隐式地连接<br><img src="/../icsmg/20230215230110.png"><br>放置已分配的块<br> $\quad$ 首次适配<br> $\quad$ 下一次适配（内存利用率最低）<br> $\quad$ 最佳适配（内存利用率最高）<br>分割空闲块<br>$\quad$ 获取额外堆内存<br>合并空闲块<br> 立即合并<br> 推迟合并<br> 带边界标记的合并（脚部）<br><img src="/../icsmg/20230215230135.png"><br><strong>显式空闲链表</strong><br><img src="/../icsmg/20230215230249.png"></p><p><strong>分离空闲链表</strong><br>$\quad$ 维护多个空闲链表，每个链表中的块有相似的大小<br>$\quad$ 简单分离存储：一个类中所有块大小都一样，不分割不合并<br>$\quad$ 分离适配：首次适配，分割，释放后合并<br>$\quad$ 伙伴系统：按2的幂进行分配、分割、合并</p><p>详见malloclab</p><h4 id="9-10-垃圾收集"><a href="#9-10-垃圾收集" class="headerlink" title="9.10 垃圾收集"></a>9.10 垃圾收集</h4><p>$\quad$ 垃圾收集器：动态内存分配器<br>$\quad$ 自动释放程序不再需要的已分配块<br>$\quad$ 内存视为有向可达图，不可达节点-&gt;垃圾<br>$\quad$ Mark&amp;Sweep垃圾收集器<br>$\quad$ Mark阶段：标记根节点和所有可达的后继<br>$\quad$ Sweep阶段：释放每个未标记的已分配块</p><h4 id="9-11-C程序中与内存有关的错误"><a href="#9-11-C程序中与内存有关的错误" class="headerlink" title="9.11 C程序中与内存有关的错误"></a>9.11 C程序中与内存有关的错误</h4><p>$\quad$ 间接引用坏指针、读未初始化的内存、允许栈缓冲区溢出、造成错位错误、假设指针和它们指向的对象是相同大小的、引用指针而不是它所指向的对象、误解指针运算、引用不存在的变量、引用空闲堆块中的数据、引起内存泄漏……</p><hr><h3 id="LAB"><a href="#LAB" class="headerlink" title="LAB:"></a>LAB:</h3><p><strong>此章节后完成<a href="https://github.com/Aki-yzh/PKU-ICS-2022/tree/main/LABS/7-malloclab">malloclab(103.0&#x2F;120.0)</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>8-异常控制流</title>
    <link href="/2023/02/18/8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/"/>
    <url>/2023/02/18/8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="对应-CSAPP-第八章节"><a href="#对应-CSAPP-第八章节" class="headerlink" title="对应 CSAPP 第八章节"></a>对应 CSAPP 第八章节</h2><span id="more"></span><h1 id="ICS"><a href="#ICS" class="headerlink" title="ICS"></a><a href="https://aki-yzh.github.io/2023/02/18/1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8&%E7%9B%AE%E5%BD%95">ICS</a></h1><hr><h2 id="八、异常控制流（ECF）"><a href="#八、异常控制流（ECF）" class="headerlink" title="八、异常控制流（ECF）"></a>八、异常控制流（ECF）</h2><p>$\quad$ ECF是操作系统用来实现I&#x2F;O，进程和虚拟内存的基本机制。</p><h4 id="8-1-异常"><a href="#8-1-异常" class="headerlink" title="8.1 异常"></a>8.1 异常</h4><p>$\quad$ 异常就是控制流中的突变，用来响应处理器状态中的某种变化。<br>$\quad$ 当处理器状态发生一个重要的变化时，处理器正在执行某个当前指令 $I_{curr}$ .在处理器中，状态被编码为不同的位和信号。状态变化称为事件，事件可能和当前指令的执行直接相关。<br><img src="/../icsmg/20230214154528.png"><br>$\quad$ 在任何情况下，当处理器检测到有事件发生时，它就会通过一张叫做异常表的跳转表，进行一个间接过程调用（异常），到一个专门设计用来处理这类事件的操作系统子程序（异常处理程序）。当异常处理程序完成处理后，根据引起异常的事件的类型，会发生以下三种情况中的一种：<br>$\quad$ 1) 处理程序将控制返回给当前指令 $I_{curr}$ ,即当事件发生时正在执行的指令。<br>$\quad$ 2) 处理程序将控制返回给 $I_{next}$ ,如果没有异常将会执行的下一条指令<br>$\quad$ 3) 处理程序终止被中断的程序</p><p><strong>异常的分类</strong><br><img src="/../icsmg/20230214155537.png"><br>$\quad$ 1. 中断：<br>$\quad$  中断是异步发生的，是来自处理器外部的I&#x2F;O设备的信号的结果。<br><img src="/../icsmg/20230214155452.png"><br>造成以下异常的指令称为故障指令。<br>$\quad$ 2. 陷阱：<br>$\quad$   陷阱是有意的异常，是执行一条指令的结果，是同步的，总是返回到下一条指令，陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做系统调用。<br><img src="/../icsmg/20230214155811.png"><br>$\quad$ 3. 故障：<br>$\quad$   故障由错误情况引起，它可能被故障处理程序修正。如果能被修正，则将控制返回到引起故障的指令，否则返回内核中的abort例程。</p><p><img src="/../icsmg/20230214155859.png"><br>$\quad$ 4.  终止：<br>$\quad$  终止是不可恢复的致命错误造成的结果，通常是一些硬件错误。</p><p><strong>Linux&#x2F;x86-64 系统中的异常</strong></p><table><thead><tr><th>异常号</th><th>描述</th><th>异常类别</th></tr></thead><tbody><tr><td>0</td><td>除法错误（浮点异常）</td><td>故障</td></tr><tr><td>13</td><td>一般保护故障</td><td>故障</td></tr><tr><td>14</td><td>缺页</td><td>故障</td></tr><tr><td>18</td><td>机器检查</td><td>终止</td></tr><tr><td>32~255</td><td>操作系统定义的异常</td><td>中断或陷阱</td></tr></tbody></table><p><strong>Linux&#x2F;x86-64 系统调用</strong><br><img src="/../icsmg/20230214161004.png"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//用write写helloword</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">write</span>(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;hello,world\n&quot;</span>,<span class="hljs-number">13</span>);<br>    _exit(<span class="hljs-number">0</span>);<br>&#125;<span class="hljs-comment">//第一个参数将输出发送到stdout，第二个参数是要写的字节序列，第三个参数是要写的字节数。</span><br></code></pre></td></tr></table></figure><h4 id="8-2-进程"><a href="#8-2-进程" class="headerlink" title="8.2 进程"></a>8.2 进程</h4><p>$\quad$ 进程的经典定义是一个执行中程序的实例。系统中的每个程序都在某个进程的上下文中。上下文是由程序正确运行所需的状态组成的，这个状态包括存放在内存中的程序的代码和数据，它的栈，通用目的寄存器的内容，程序计数器，环境变量以及打开文件描述符的集合。</p><p><strong>逻辑控制流</strong><br>$\quad$ 进程是轮流使用处理器的，每个进程执行它的流的一部分，然后被抢占（暂时挂起），然后轮到其他进程。<br><strong>并发流</strong><br>$\quad$ 一个逻辑流的执行在时间上与另一个流重叠<br>$\quad$ 并发流的进程实际上仍是交错的，处理器不会同时处理两个进程<br><strong>私有地址空间</strong><br>$\quad$ 这个空间中某个地址关联的内存不能被其他进程读写<br>$\quad$ 每个私有地址空间都有相同的通用结构<br><strong>用户模式与内核模式</strong><br>$\quad$ 设置了模式位就运行在内核模式中，否则运行在用户模式中。<br>$\quad$ 内核模式可以执行任何指令，访问系统的任何位置。<br>$\quad$ 进程从用户模式变为内核模式的唯一方法是通过异常，处理程序运行在内核模式中，当它返回到$\quad$ 应用程序代码时，处理器改回到用户模式<br><strong>上下文切换（控制转移）</strong><br>$\quad$ 保存当前进程的上下文-&gt;恢复某个先前被抢占的进程保存的上下文-&gt; 将控制传递给新恢复的进程<br><img src="/../icsmg/20230214162756.png"></p><h4 id="8-3-系统调用错误处理"><a href="#8-3-系统调用错误处理" class="headerlink" title="8.3 系统调用错误处理"></a>8.3 系统调用错误处理</h4><p>$\quad$ 默认使用错误处理包装函数，使代码简洁</p><h4 id="8-4-进程控制"><a href="#8-4-进程控制" class="headerlink" title="8.4 进程控制"></a>8.4 进程控制</h4><p><strong>获取进程id</strong><br>$\quad$ 每个进程都有一个唯一的正数进程ID（PID）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">getpid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<span class="hljs-comment">//返回调用进程的pid</span><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">getppid</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<span class="hljs-comment">//返回父进程的pid</span><br></code></pre></td></tr></table></figure><p><strong>创建和终止进程</strong><br>$\quad$ 进程总是处于以下三种状态之一：<br>$\quad$ $\quad$ 运行：要么在CPU上执行，要么在等待被执行且最终会被内核调度<br>$\quad$ $\quad$ 停止： 进程的执行被挂起，且不会被调度。<br>$\quad$ $\quad$ 终止： 收到终止信号&#x2F;从主程序返回&#x2F;调用exit函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">exit</span><span class="hljs-params">(<span class="hljs-type">int</span> status)</span></span>;<span class="hljs-comment">//exit函数以status退出状态来终止进程。</span><br></code></pre></td></tr></table></figure><p>$\quad$父进程通过调用fork函数创建一个新的运行的子进程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>$\quad$ 两个进程并发执行，地址空间相同但独立，共享打开的文件<br>$\quad$ 调用一次，返回两次，父进程返回子进程的PID，子进程总是返回0。<br>$\quad$ 父进程和子进程之间最大的区别在于他们拥有不同的PID。<br>$\quad$ 返回值提供了一个明确的方法来分辨程序是在父进程还是在子进程中执行。<br>进程图<br>$\quad$ 每个顶点是一条语句的执行<br>$\quad$ main是起始点<br>$\quad$ 并发式程序的语句执行存在拓扑排序<br><img src="/../icsmg/20230214164108.png"><br><strong>回收子进程</strong><br>$\quad$ 子进程终止后保持一个已终止的状态直到被父进程回收<br>$\quad$ 父进程终止后内核会安排init(PID&#x3D;1)为其所有孤儿进程的养父<br>$\quad$ 一个进程可以通过调用waitpid函数来等待它的子进程终止或停止,成功返回子进程的pid，如果WNOHANG，返回0，否则返回-1.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">waitpid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid , <span class="hljs-type">int</span> *statusp,<span class="hljs-type">int</span> options)</span></span>;<br></code></pre></td></tr></table></figure><p>$\quad$ pid: 判定等待集合（&gt;0，单一子进程；&#x3D;-1，所有子进程）<br>$\quad$options：可修改的默认行为(WNOHANG：任何子进程都未终止返回0； WUNTRACED：$\quad$挂起调用进程的执行，直到等待集合中的一个进程变为已终止或被停止； WCONTINUED：挂起调用进程的执行，知道等待集合中的一个被停止的进程收到SIGCONT信号重新开始执行)（也可以用｜组合起来）<br>$\quad$ statusp：检查已回收子进程的退出状态<br>$\qquad$ WIFEXITED：子进程通过调用exit或者return正常终止，true<br>$\qquad$ WEXITSIATUS：返回一个正常终止子进程的退出状态<br>$\qquad$ WIFSIGNALED： 如果子进程是因为一个未被捕获的信号终止的，那么就返回真<br>$\qquad$ WTERMSIG：返回导致子进程终止的信号的编号<br>$\qquad$ WIFSTOPPED： 如果引起返回的子进程当前是停止的，那么就返回真<br>$\qquad$ WSTOPSIG：返回引起子进程停止的信号的编号<br>$\qquad$ WIFCONTINUED：如果子进程收到SIGCONT信号重新启动，则返回真。<br>$\quad$ 错误条件：如果调用进程没有子进程，那么waitpid返回-1，并设置errno为ECHILD，如果waidpid函数被一个信号中断，返回-1，设置errno为EINTR。<br><strong>wait函数</strong><br>$\quad$ 等价于waitpid(-1,&amp;status,0);<br><strong>让进程休眠</strong><br>$\quad$ sleep函数将一个进程挂起一段指定的时间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> secs)</span></span>;<br></code></pre></td></tr></table></figure><p>$\quad$ 如果请求的时间量已经到了，返回0，否则返回还剩下要休眠的秒数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pause</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>$\quad$ pause函数让调用函数休眠直到该进程收到一个信号<br><strong>加载并运行程序</strong><br>$\quad$ execve函数在当前进程的上下文中加载并运行一个新程序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execve</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename,<span class="hljs-type">const</span> <span class="hljs-type">char</span> *argv[],<span class="hljs-type">const</span> <span class="hljs-type">char</span> *envp[])</span></span>;<br></code></pre></td></tr></table></figure><p>$\quad$ 加载并运行可执行目标文件filename，且带参数列表argv和环境变量列表envp。成功不返回，错误返回-1。<br><strong>shell：交互型应用级程序</strong><br>$\quad$ 命令行-&gt;parseline-&gt;builtincommand<br>$\quad$ 最后一个参数：<br>$\qquad$ &amp;-&gt;后台执行<br>$\qquad$ 其他-&gt;前台执行</p><h4 id="8-5-信号"><a href="#8-5-信号" class="headerlink" title="8.5 信号"></a>8.5 信号</h4><p><img src="/../icsmg/20230214174524.png"><br><strong>发送信号</strong><br>$\quad$ 内核通过更新目的进程中上下文中的某个状态，发送一个信号给目的进程。<br>$\quad$ 原因：1.内核检测到一个系统事件，比如除0错误或子进程终止2.一个进程调用了kill函数，显式地要求内核发送一个信号给目的进程。<br>$\quad$ 一个进程可以发送信号给它自己。<br>$\quad$ 发送信号基于进程组，进程组由一个正整数进程组ID来标识。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">getpgrp</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<span class="hljs-comment">//返回当前进程的进程组ID</span><br></code></pre></td></tr></table></figure><p>$\quad$ 默认地，一个子进程和它的父进程同属于一个进程组，一个进程可以通过setpgid来改变自己或者其他进程的进程组。将进程pid的进程组改为pgid，如果pid是0，那么就使用当前进程的PID，如果pgid是0，那么就用pid指定的进程的PID作为进程组id。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">setpgid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid,<span class="hljs-type">pid_t</span> pgid)</span></span>;<span class="hljs-comment">//成功返回0，错误返回-1；</span><br></code></pre></td></tr></table></figure><p>发送途径：<br>$\qquad$ <em>用&#x2F;bin&#x2F;kill程序发送信号</em>：&#x2F;bin&#x2F;kill -9 114514 -&gt;发送信号9给进程114514，符号表示发给进程组中的每个进程。<br>$\qquad$ 从键盘发送信号<br>$\qquad$ 用kill函数发送信号 ,pid大于0，发送sig到pid；pid等于0，发送sig到调用进程所在进程组中的每个进程，pid小于0，发送sig到|pid|中的每个进程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kill</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid ,<span class="hljs-type">int</span> sig)</span></span>;<span class="hljs-comment">//成功返回0，错误返回-1</span><br></code></pre></td></tr></table></figure><p>$\qquad$ 用alarm函数发送信号：向自己发送SIGALRM信号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">alarm</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> secs)</span></span>;<span class="hljs-comment">//返回前一次闹钟剩余的秒数，若没设定，返回0</span><br></code></pre></td></tr></table></figure><p>$\qquad$<br><strong>接收信号</strong><br>$\quad$ 目的进程被内核强迫对信号作出反应，进程p从内核模式切换到用户模式时，若待处理信号集合为空，控制传递到p的下一条指令；若非空，选择某个信号k，强制p接受k</p><p><img src="/../icsmg/20230214193024.png"></p><p><strong>待处理信号</strong></p><p>$\quad$ 发出但没有被接收的信号<br>$\quad$ 任何时候一个类型至多有一个待处理信号（用pending位向量维护，传送时设置，接收时清除）</p><p><strong>阻塞&#x2F;解除阻塞信号</strong></p><p>$\quad$ 隐式阻塞：默认阻塞当前正在处理信号的同类型信号<br>$\quad$ 显式阻塞：sigprocmask函数和相关函数，明确地阻塞&#x2F;解除阻塞指定的信号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;signal.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigprocmask</span><span class="hljs-params">(<span class="hljs-type">int</span> how,<span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *set,<span class="hljs-type">sigset_t</span> *oldset)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigemptyset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *set)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigfillset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *set)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigaddset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *set,<span class="hljs-type">int</span> signum)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigdelset</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *set,<span class="hljs-type">int</span> signum)</span></span>;<br><span class="hljs-comment">/* 成功返回0，出错-1 */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigismember</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *set,<span class="hljs-type">int</span> signum)</span></span>;<br><span class="hljs-comment">//signum是set成员返回1，不是则0，出错-1</span><br></code></pre></td></tr></table></figure><p>how：<br>$\qquad$ SIG_BLOCK：把set中的信号添加到blocked中<br>$\qquad$ SIGUNBLOCK：从block中删除set中的信号<br>$\qquad$ SIG_SETMASK：BLOCK&#x3D;set</p><p><strong>编写信号处理程序</strong><br>$\quad$ 安全的信号处理：<br>$\qquad$ 处理程序尽可能简单<br>$\qquad$ 只调用异步信号安全的函数（可重入，不可被信号处理程序中断）<br>$\qquad$ $\qquad$ SIO包：安全打印简单信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;csapp.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">sio_putl</span><span class="hljs-params">(<span class="hljs-type">long</span> v)</span></span>;<span class="hljs-comment">//向标准输出传送long类型数</span><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">sio_puts</span><span class="hljs-params">(<span class="hljs-type">char</span> s[])</span></span>;<span class="hljs-comment">//向标准输出传送一个字符串</span><br></code></pre></td></tr></table></figure><p>$\qquad$ 保存和恢复errno<br>$\qquad$ 阻塞所有信号，保护对共享全局数据结构的访问<br>$\qquad$ 用volatile声明全局变量-&gt;阻止编译器缓存变量<br>$\qquad$ 用sig_atomic_t声明标志<br><strong>同步流以避免并发错误</strong><br>$\qquad$ 由于父进程和子进程并发进行，可能存在竞争，导致信号丢失<br>$\qquad$ 解决：调用前阻塞信号</p><h4 id="8-6-非本地跳转"><a href="#8-6-非本地跳转" class="headerlink" title="8.6 非本地跳转"></a>8.6 非本地跳转</h4><p>$\quad$ 将控制直接从一个函数转移到另一个函数（无需调用返回）<br>$\quad$ 通过setjmp和longjmp提供</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;setjmp.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">setjmp</span><span class="hljs-params">(jmp_buf env)</span></span>;<span class="hljs-comment">//在env缓冲区中保存当前调用环境</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigsetjmp</span><span class="hljs-params">(sigjmp_buf env,<span class="hljs-type">int</span> savesigs)</span></span>;<span class="hljs-comment">//从env缓冲区恢复调用环境，并触发最近一个setjmp的返回</span><br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>7-链接</title>
    <link href="/2023/02/18/7-%E9%93%BE%E6%8E%A5/"/>
    <url>/2023/02/18/7-%E9%93%BE%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="对应-CSAPP-第七章节"><a href="#对应-CSAPP-第七章节" class="headerlink" title="对应 CSAPP 第七章节"></a>对应 CSAPP 第七章节</h2><span id="more"></span><h1 id="ICS"><a href="#ICS" class="headerlink" title="ICS"></a><a href="https://aki-yzh.github.io/2023/02/18/1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8&%E7%9B%AE%E5%BD%95">ICS</a></h1><hr><h2 id="七、链接"><a href="#七、链接" class="headerlink" title="七、链接"></a>七、链接</h2><p>$\quad$ 链接是把各种代码和数据片段收集并组合成一个单一文件的过程，这个文件可被加载（复制）到内存并执行，链接可以执行于编译时，也就是在源代码被译为机器代码时，也可以执行于加载时，甚至可以执行于运行时。早期链接是手动执行的，而在现代系统中，链接是由链接器自动执行的。<br>$\quad$ 链接器使得分离编译成为可能。</p><p>$\quad$ 编译器驱动程序先运行C预处理器cpp，把源程序翻译成一个ASCII码的中间程序main.i，然后运行C编译器ccl把main.i翻译成main.s,最后运行汇编器as把main.i翻译成ASCII语言汇编文件main.o，另一边同样流程生成swap.o，最后运行链接器程序ld，将main.o和swap.o以及一些必要的系统目标文件组合起来，创建一个可执行目标文件p。</p><p><img src="/../icsmg/20221119215951.png"></p><p>$\quad$ 要执行可执行文件p，shell调用操作系统中一个叫做加载器的函数，将p中的代码复制到内存，然后将控制转移到这个程序的开头。</p><h4 id="静态链接"><a href="#静态链接" class="headerlink" title="静态链接"></a>静态链接</h4><p>$\quad$ 静态链接器以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的，可以加载和运行的可执行目标文件作为输出。输出的可重定位目标文件由各种不同的代码和数据节组成，每一节都是一个连续的字节序列<br>$\quad$ 为了构造可执行性文件，链接器必须完成两个主要任务：<br>$\quad$ $\quad$ 1.符号解析：每一个符号对应于一个函数，一个全局变量或者一个静态变量（static），使得每一个符号引用恰好和每一个符号定义关联起来<br>$\quad$ $\quad$ 2.重定位：编译器和汇编器生成从地址0开始的代码和数据节，链接器通过把每个符号定义和一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用。</p><p>$\quad$ 目标文件有三种形式：<br>$\quad$ $\quad$ 1.可重定位目标文件：包含二进制代码和数据，可以在编译时和其他可重定位文件合并。<br>$\quad$  $\quad$ $\quad$ .text:已编译程序的机器代码<br>$\quad$ $\quad$ $\quad$.rodata：只读数据，比如printf语句中的格式串“%d……”和开关语句的跳转表<br>$\quad$ $\quad$ $\quad$.data：已经初始化的全局和静态C变量<br>$\quad$ $\quad$ $\quad$.bss: 未初始化的全局和静态C变量<br>$\quad$ $\quad$ $\quad$.symtab：符号表<br>$\quad$ $\quad$ $\quad$.debug：调试符号表<br>$\quad$ $\quad$ $\quad$ 其余不重要</p><p><img src="/../icsmg/20221119221349.png"><br>$\quad$ $\quad$ $\quad$ $\quad$ <strong>符号表</strong><br>$\quad$ $\quad$ $\quad$ $\quad$ $\quad$ 对于一个模块m<br>$\quad$ $\quad$ $\quad$ $\quad$ $\quad$ 非静态的局部变量不在符号表里，由栈进行管理。<br>$\quad$ $\quad$ $\quad$ $\quad$ $\quad$ $\quad$ 有以下3种不同符号：<br>$\quad$ $\quad$ $\quad$ $\quad$ $\quad$ $\quad$ 1.由模块m定义并能被其他模块引用的全局符号（GLOBAL），对应于非静态的C函数和全局变量<br>$\quad$ $\quad$ $\quad$ $\quad$ $\quad$ $\quad$ 2.有其他模块定义并能被模块m引用的全局符号，成为外部符号，对应于在其他模块定义的非静态C函数和全局变量<br>$\quad$ $\quad$ $\quad$ $\quad$ $\quad$  $\quad$ 3.只被m定义和引用的局部符号（LOCAL），对应于带static属性的C函数和全局变量<br>$\quad$ $\quad$ $\quad$ $\quad$ $\quad$ 伪节：<br>$\quad$ $\quad$ $\quad$ $\quad$ $\quad$ $\quad$ ABS：不该被重定位的表<br>$\quad$ $\quad$ $\quad$ $\quad$ $\quad$ $\quad$ UNDEF:未被定义的符号，代表在本目标模块中被引用，却在其他地方定义的符号<br>$\quad$ $\quad$ $\quad$ $\quad$ $\quad$ $\quad$ COMMON 未初始化的全局变量<br>$\quad$ $\quad$ bind表示符号是全局还是局部（GLOBAL or LOCAL），type表示类型（FUNC or OBJECT）ndx表示所在的表（由节头部表中代表的整数索引或者UND表示）</p><p>$\quad$ $\quad$ 2.可执行目标文件：可以直接被复制到内存并执行，不在需要.rel节<br>$\quad$ $\quad$ 3.共享目标文件：特殊的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接。</p><p>$\quad$ 符号解析：<br>$\quad$ $\quad$ 编译器向汇编器输出每个全局符号，或者是强或者是弱，而汇编器隐含地把这个信息编码在可重定位目标文件的符号表里。函数和已初始化的全局变量是强符号，未初始化的全局变量时弱符号。<br>$\quad$ $\quad$ 规则：不允许有多个同名的强符号，优先选择强符号，不然任意选择。<br>$\quad$ 与静态库链接：<br>$\quad$ $\quad$ 所有的编译系统都提供一种机制，把所有相关的目标文件打包成一个单独的文件，称为静态库。可以用作链接器的输入。当链接器构造一个输出的可执行文件时，它只复制静态库里被应用程序引用的目标模块。<br>$\quad$ $\quad$ 利用静态库减少了可执行文件在磁盘和内存中的大小<br><img src="/../icsmg/20230215235042.png"><br>  $\quad$ 重定位：<br>$\quad$ 重定位由两步组成<br>$\quad$ $\quad$ $\quad$ 1.重定位节和符号定义：链接器把所有相同类型的节合并为同一类型的新的聚合节，内存地址赋给新的聚合节，此时程序中的每条指令和全局变量都有唯一的运行时的内存地址了。<br>$\quad$ $\quad$ $\quad$ 2.重定位节中的符号引用：修改符号引用使其指向正确的运行地址。<br>$\quad$ $\quad$ $\quad$ 重定位类型：<br>$\quad$ $\quad$ $\quad$ $\quad$ 1.R_X86_64_PC32：PC相对引用，距离PC当前运行值的偏移量<br>$\quad$ $\quad$ $\quad$ $\quad$ 2.R_X86_64_32:绝对引用，不需要进一步修改<br>$\quad$ $\quad$ $\quad$ $\quad$ 汇编器会在后一行上告知进行何种引用<br>$\quad$ $\quad$ $\quad$ $\quad$ 重定位的计算参考书P481，分为重定位相对引用的计算和绝对引用的计算。<br>$\quad$ $\quad$ $\quad$ 相对引用：<br>$\quad$ $\quad$ $\quad$ $\quad$ ADDR（s)&#x3D;ADDR(.text)<br>$\quad$ $\quad$ $\quad$ $\quad$ ADDR(r.symbol)&#x3D;ADDR(函数\变量名)<br>$\quad$ $\quad$ $\quad$ $\quad$ 运行时地址refaddr&#x3D;ADDR(s)+r.offset<br>$\quad$ $\quad$ $\quad$ $\quad$ *refptr&#x3D;ADDR(r.symbol)+r.addend-refaddr<br>$\quad$ $\quad$ $\quad$ 绝对引用：<br>$\quad$ $\quad$ $\quad$ $\quad$ ADDR(r.symbol)&#x3D;ADDR(函数\变量名)<br>$\quad$ $\quad$ $\quad$ $\quad$ *refptr&#x3D;ADDR（r.symbol）+r.addend<br>$\quad$ 加载可执行目标文件：<br>$\quad$ $\quad$ 把程序复制到内存并运行的过程叫做加载<br>$\quad$ $\quad$ 在程序头部表的引导下，加载器把可执行文件的片复制到代码段和数据段，接着加载器跳转到程序的入口点，即_start函数的地址。</p><h4 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h4><p>$\quad$ 共享库是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来，这个过程叫做动态链接，是由一个叫做动态链接器的程序来执行的。</p><p>!<img src="/../icsmg/20221119230728.png"></p><p>$\quad$ $\quad$ 动态链接器先重定位libc.so文本和数据到某个内存段，在重定位 libvector.so的文本和数据到另一个内存段，最后重定位二者中所有对定义的符号的引用<br>$\quad$ 共享库的一个主要目的就是允许多个正在运行的进程共享内存中相同的库代码，节约宝贵的内存资源。<br>$\quad$ 可以加载无需重定位的代码叫做位置无关代码(PIC)，共享库的编译必须总是使用该选项。<br>$\quad$ 在数据段开始的地方创建全局偏移量表（GOT）。<br>$\quad$ 延迟绑定能够避免动态链接器在加载时进行不必要的重定位。<br>$\quad$ 过程链接表（PLT）PLT[0]特殊，PLT[1]调用系统启动函数，从PLT[2]开始调用用户代码调用的函数　</p><ul><li>$\quad$ GOT[0]：<code>.dynamic</code>的地址</li><li>$\quad$ GOT[1]：重定位条目的地址</li><li>$\quad$ GOT[2]：动态链接器的地址</li><li>$\quad$ GOT[3]：系统启动函数</li><li>$\quad$ GOT[4]开始：调用的函数</li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>6-存储器层次结构</title>
    <link href="/2023/02/18/6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/"/>
    <url>/2023/02/18/6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="对应-CSAPP-第六章节"><a href="#对应-CSAPP-第六章节" class="headerlink" title="对应 CSAPP 第六章节"></a>对应 CSAPP 第六章节</h2><span id="more"></span><h1 id="ICS"><a href="#ICS" class="headerlink" title="ICS"></a><a href="https://aki-yzh.github.io/2023/02/18/1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8&%E7%9B%AE%E5%BD%95">ICS</a></h1><hr><h3 id="六、存储器层次结构"><a href="#六、存储器层次结构" class="headerlink" title="六、存储器层次结构"></a>六、存储器层次结构</h3><h4 id="6-1-存储技术"><a href="#6-1-存储技术" class="headerlink" title="6.1 存储技术"></a>6.1 存储技术</h4><p>$\quad$ 随机访问存储器（RAM）分为两类：静态的和动态的</p><p>$\quad$ 静态（SRAM）具有双稳态特性，每位有6个晶体管，价格高，存取快，对光电不敏感，用于高速缓存存储器；动态（DRAM）每位一个晶体管，价格低，功耗更小，对光电敏感，用于主存和帧缓冲区。 </p><p><img src="/../icsmg/20221119152443.png"><br>$\quad$ 非易失性存储器（ROM）的发展：PROM-&gt;EPROM-&gt;EEPROM</p><p>$\quad$ RAM有电才能存储数据</p><p>磁盘存储：</p><p>$\quad$ 磁盘由盘片构成，每个盘片有2面或者称为表面，表面覆盖磁性记录材料，盘中央有一个可以旋转的主轴，使得盘片以固定的旋转速率旋转。每个表面是由一组称为磁道的同心圆组成的，每个磁道被划分为一组扇区，扇区之间由一组  间隙分隔开。</p><p>$\quad$ 抽象化成逻辑块序列。</p><p>$\quad$ 磁盘容量&#x3D;（字节数&#x2F;扇区）x（平均扇区数&#x2F;磁道）x（磁道数&#x2F;表面）x（表面数&#x2F;盘片）x（盘片数&#x2F;磁盘）</p><p><img src="/../icsmg/20221119151953.png"><br>$\quad$ 磁盘访问时间&#x3D;寻道时间+旋转时间+传送时间</p><p>$\quad$ 旋转时间&#x3D;1&#x2F;RPM x 60s&#x2F;1min x 1&#x2F;2</p><p>$\quad$ 传送时间 &#x3D; 1&#x2F;RPM x 1&#x2F;（平均扇区数&#x2F;磁道）x 60s&#x2F;1min</p><p>$\quad$ 磁盘没电也能存储数据</p><p>$\quad$ 固态硬盘（SSD）：</p><p>$\quad$ 基于闪存芯片（半导体存储器）的存储技术，读比写快，以页为单位进行读写</p><p>$\quad$ 速度： SRAM&gt;DRAM&gt;DISK</p><h4 id="6-2-局部性"><a href="#6-2-局部性" class="headerlink" title="6.2 局部性"></a>6.2 局部性</h4><p>$\quad$ 时间局部性：被引用过的内存位置在不远的将来再次被多次引用</p><p>$\quad$ 空间局部性：一个内存位置被引用，那么不远的将来引用其附近的内存位置</p><p> $\quad$ 重复引用相同变量的程序拥有良好的时间局部性</p><p>$\quad$ 步长为K的引用模式，步长越小，空间局部性越好</p><p>$\quad$ 取指令循环具有好的时间与空间局部性</p><p>存储器层次结构：<br><img src="/../icsmg/20221119152158.png"><br>$\quad$ 思想：速度快容量小的存储设备作为速度慢容量大的存储设备的缓存</p><h4 id="6-3-高速缓存（cache）"><a href="#6-3-高速缓存（cache）" class="headerlink" title="6.3 高速缓存（cache）"></a>6.3 高速缓存（cache）</h4><p>$\quad$ 第k+1层的存储器被划分成连续的数据对象组块，称为块 数据以块为单位来回复制 </p><p><img src="/../icsmg/20221119152227.png"></p><p><strong>缓存命中</strong></p><p>$\quad$ 当程序需要读取第k+1层的某个数据对象d时，首先在当前存储在k层的一个块中查找d，若d刚好存储在第k层中，那就是缓存命中。程序直接从第k层读取d。</p><p><strong>缓存不命中</strong></p><p>$\quad$ 第k层的缓存就从k+1层去除包含d的那个块，若k层已满，覆盖现存的一个块。这个过程叫做替换或者驱逐这个块。被驱逐的称为牺牲块，决定替换哪个由替换策略控制。</p><p>分类：</p><p>$\quad$ 冷不命中（强制性不命中）：第k层为空（称为冷缓存）</p><p>$\quad$ 冲突不命中：限制性的防治策略社对象映射到同一个缓存块</p><p>$\quad$ 容量不命中：缓存太小了</p><p><strong>高速缓存存储器</strong></p><p>$\quad$ 早期计算机系统的存储器层次结构只有三层：CPU寄存器，DRAM主存储器和磁盘。后插入了小的SRAM高速缓存，称为L1高速缓存</p><p>$\quad$ 对于下列只讨论仅有L1高速缓存</p><p>$\quad$ 考虑一个计算机系统，每个存储器地址有m位，形成M&#x3D;$2^m$个不同的地址。被组织成$S&#x3D;2^s$个高速缓存组的数组。每个组包含E个高速缓存行。每个行由$B&#x3D;2^b$个字节的数据块构成</p><p>$\quad$ 将m个地址分为t位的标记位，s位的组索引，b位的块偏移</p><p>$\quad$ 标记为表示取自哪个块群，有效位可以理解为是否缓存了东西<br><img src="/../icsmg/20221119152309.png"><br><img src="/../icsmg/20221119152333.png"><br>$\quad$ cache容量 （所有块的大小 ）：     C&#x3D;SxExB</p><p><strong>直接映射高速缓存</strong></p><p>$\quad$ 每个组只有一行（E&#x3D;1），称为直接映射高速缓存</p><p>$\quad$ 高速缓存确定一个请求是否命中，然后抽取出被请求的字的过程，分为三步：</p><p>1.组选择</p><p>$\quad$ 从w的地址中取出s个组索引</p><p>2.行匹配</p><p>$\quad$ 只有一行，直接比对标记是否一致</p><p>$\quad$ 最终结果：命中&#x2F;不命中</p><p>3.字抽取（缓存命中）</p><p>  $\quad$ 把块看成一个字节的数组，字节偏移是到这个数组的一个索引</p><p>$\quad$ $\quad$ 行替换（缓存不命中）</p><p>$\quad$ $\quad$ 从下一层取出被请求的块放入高速缓存行中，代替当前行</p><p><strong>组相连高速缓存</strong></p><p>$\quad$ 1&lt;EC&#x2F;B</p><p>$\quad$ 组选择：和上述一样</p><p>$\quad$ 行匹配和字选择：检查多个行的标记位与有效位</p><p>$\quad$ 行替换：空行优先，否则用策略替换LRU，FIFO（先进先出）LFU，随机替换</p><p><strong>全相连高速缓存</strong></p><p>$\quad$ E&#x3D;C&#x2F;B</p><p>$\quad$ 一个组包含所有的行</p><p>$\quad$ 组选择：只有一个组</p><p>$\quad$ 行匹配和字选择：同上</p><p><strong>写</strong>:<br>$\quad$ 只写：立即将高速缓存块协会到低一层中；写回：推迟更新</p><p>$\quad$ 写分配：加载入高速缓存。非写分配：避开高速缓存</p><p>$\quad$ 不命中率&#x3D;不命中数量&#x2F;引用数量</p><h4 id="6-5-编写高速缓存友好的代码"><a href="#6-5-编写高速缓存友好的代码" class="headerlink" title="6.5 编写高速缓存友好的代码"></a>6.5 编写高速缓存友好的代码</h4><p>$\quad$ 1.让最常见的情况运行最快</p><p>$\quad$ 2.尽量减小每个循环内部的缓存不命中数量</p><h4 id="6-6-高速缓存对程序性能的影响"><a href="#6-6-高速缓存对程序性能的影响" class="headerlink" title="6.6 高速缓存对程序性能的影响"></a>6.6 高速缓存对程序性能的影响</h4><p>$\quad$ 读吞吐量：从存储系统中读数据的速率  v&#x3D;n&#x2F;s</p><p>$\quad$ 重排列循环以提高空间局部性</p><hr><h3 id="LAB"><a href="#LAB" class="headerlink" title="LAB:"></a>LAB:</h3><p><strong>此章节后完成<a href="https://github.com/Aki-yzh/PKU-ICS-2022/tree/main/LABS/5-cachelab">cachelab(60.0&#x2F;60.0)</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>5-优化程序性能</title>
    <link href="/2023/02/18/5-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/"/>
    <url>/2023/02/18/5-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="对应-CSAPP-第五章节"><a href="#对应-CSAPP-第五章节" class="headerlink" title="对应 CSAPP 第五章节"></a>对应 CSAPP 第五章节</h2><span id="more"></span><h1 id="ICS"><a href="#ICS" class="headerlink" title="ICS"></a><a href="https://aki-yzh.github.io/2023/02/18/1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8&%E7%9B%AE%E5%BD%95">ICS</a></h1><hr><h3 id="五、优化程序性能"><a href="#五、优化程序性能" class="headerlink" title="五、优化程序性能"></a>五、优化程序性能</h3><p>$\quad$ 引入度量标准没元素的周期数CPE作为衡量程序性能的方法</p><h5 id="编译器优化："><a href="#编译器优化：" class="headerlink" title="编译器优化："></a>编译器优化：</h5><p>$\quad$ 编译器的优化必须是保守的，即不改变代码的程序级行为</p><p>$\quad$ 无法优化的情况<br>$\quad$ $\quad$ 浮点数不满足结合律（选择题中出现浮点数）<br>$\quad$ $\quad$ 无法判断地址重复引用（即选择题中出现指针）<br>$\quad$ $\quad$ 无法判断循环体中函数是否有副作用（即选择题中优化出现了未知函数）</p><h5 id="程序员优化："><a href="#程序员优化：" class="headerlink" title="程序员优化："></a>程序员优化：</h5><p><strong>1.消除循环的低效率</strong></p><p>$\quad$ 把可以只运行一次的函数调用移出循环</p><p><strong>2.减少过程调用</strong></p><p>$\quad$ 减少过程中的函数调用</p><p><strong>3.消除不必要的内存引用</strong></p><p><strong>循环展开</strong></p><p>$\quad$ 增加每次迭代计算的元素的数量，减少迭代次数</p><p><strong>优化的限制</strong></p><p>$\quad$ 寄存器溢出</p><p>$\quad$ 分支预测错误处罚</p><p>$\quad$ 内存性能限制</p><hr><h3 id="LAB"><a href="#LAB" class="headerlink" title="LAB:"></a>LAB:</h3><p><strong>此章节后完成<a href="https://github.com/Aki-yzh/PKU-ICS-2022/tree/main/LABS/4-archlab">archlab(190.0&#x2F;190.0)</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4-处理器体系结构</title>
    <link href="/2023/02/18/4-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <url>/2023/02/18/4-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="对应-CSAPP-第四章节"><a href="#对应-CSAPP-第四章节" class="headerlink" title="对应 CSAPP 第四章节"></a>对应 CSAPP 第四章节</h2><span id="more"></span><h1 id="ICS"><a href="#ICS" class="headerlink" title="ICS"></a><a href="https://aki-yzh.github.io/2023/02/18/1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8&%E7%9B%AE%E5%BD%95">ICS</a></h1><hr><h3 id="四、处理器体系结构"><a href="#四、处理器体系结构" class="headerlink" title="四、处理器体系结构"></a>四、处理器体系结构</h3><h5 id="4-1-Y86-64指令集体系结构"><a href="#4-1-Y86-64指令集体系结构" class="headerlink" title="4.1 Y86-64指令集体系结构"></a>4.1 Y86-64指令集体系结构</h5><h6 id="4-1-1-程序员可见的状态"><a href="#4-1-1-程序员可见的状态" class="headerlink" title="4.1.1 程序员可见的状态"></a>4.1.1 程序员可见的状态</h6><p>$\quad$ 程序员：用汇编代码写程序的人或产生机器级代码的编译器</p><p>$\quad$ 可见状态：每条指令都会读取或修改处理器状态的某些部分<br>    <br><img src="/../icsmg/20221119152952.png"><br>    <br>$\quad$ 15个程序寄存器，每个程序寄存器存储一个64位的字（8字节），寄存器%rsp被出栈，入栈，调用和返回指令作为栈指针。3个1位的条件码ZF，OF，SF，程序计数器PC存放当前正在执行指令的地址</p><h6 id="4-1-2-Y86-64指令"><a href="#4-1-2-Y86-64指令" class="headerlink" title="4.1.2 Y86-64指令"></a>4.1.2 Y86-64指令</h6><p>$\quad$ movq指令被分成了4个不同的指令：irmovq，rrmovq，mrmovq，rmmovq，源可以是立即数（i），寄存器（r）或内存（m）。指令的第一个字符表示源的类型，第二个表示了目的的类型。同x86-64，我们不允许将内存直接传送到另一个内存，也不允许将立即数传送到内存。<br>    <br><img src="/../icsmg/20221119153309.png"><br>$\quad$ halt 停止指令的执行</p><p>$\quad$ nop 空操作</p><p>$\quad$ 4个整数操作指令addq，subq，andq，xorq</p><p>$\quad$ 7个跳转指令（图中的jxx）jmp、jle、jl、je、jne、jge、jg分支条件和x86-64一致。</p><p>$\quad$ 6个条件传送指令（图中的cmovxx）：cmovle、cmovl、cmove、cmovne、cmovge和cmovg、格式与rrmovq一样，但是只有当条件码满足约束才会更新寄存器的值。</p><p>$\quad$ call 将返回地址入栈，然后跳到目的地址。ret指令从这样的调用中返回。</p><p>$\quad$ pushq和pullq实现了入栈和出栈。</p><h6 id="4-1-3指令编码"><a href="#4-1-3指令编码" class="headerlink" title="4.1.3指令编码"></a>4.1.3指令编码</h6><p>$\quad$ 每条指令需要1～10个字节不等，每条指令的第一个字节表示指令的类型，这些字节分为两个部分，每部分4位：高四位是代码部分，低四位是功能部分（fn）。代码值位0～0x8<br><img src="/../icsmg/20221119153404.png"><br>$\quad$ rrmovq与条件传送有相同的指令代码，可以把它看作是无条件传送，功能代码都是0</p><p>寄存器标识符</p><p><img src="/../icsmg/20221119153049.png"><br>$\quad$ rA和rB被称为寄存器指示符字节，指定标识符对应的寄存器。不需要寄存器的则将r设置为0xF。</p><p>$\quad$ 有些指令需要一个附加的8字节常数字，这个字能作为irmovq的立即数，rmmovq和mrmovq的地址指示符的偏移量，以及分支指令和调用指令的目的地址。（分支指令和调用指令的目的是一个绝对地址，而非相对寻址）</p><p>$\quad$ 比如对 rmmovq %rsp，0x123456789abcd（%rdx）；先填充为8字节得00 01 23 45 67 89 ab cd在小断法反序成cd ab 89 67 45 23 01 00，连起来得指令的编码为40 42 cd ab 89 67 45 23 01 00.</p><p>$\quad$ 字节编码有唯一的解释。</p><h6 id="旁注-RISC和CISC"><a href="#旁注-RISC和CISC" class="headerlink" title="旁注  RISC和CISC"></a>旁注  RISC和CISC</h6><p>$\quad$ 二者主要区别在于CISC指令数量很多而RISC少，RISC代码固定为4字节，RISC没有条件码，RISC寻址简单，RISC只有load和store允许内存调用，RISC细节可见。RISC指令延迟短，RISC比较简单，故代码长度一般更长</p><h6 id="4-1-4-Y86-64异常"><a href="#4-1-4-Y86-64异常" class="headerlink" title="4.1.4  Y86-64异常"></a>4.1.4  Y86-64异常</h6><p>$\quad$ 状态码Stat描述程序运行的总体状态。<br><img src="/../icsmg/20221119153452.png"></p><h6 id="4-1-5-Y86-64程序"><a href="#4-1-5-Y86-64程序" class="headerlink" title="4.1.5 Y86-64程序"></a>4.1.5 Y86-64程序</h6><p>$\quad$ 与x86-64的汇编代码相比，Y86-64需要将常数加载到寄存器。从内存中读取数值并与一个寄存器相加时，Y86-64需要两条指令，x86-64只需要一条。</p><h5 id="4-2-逻辑设计和硬件控制语言HCL"><a href="#4-2-逻辑设计和硬件控制语言HCL" class="headerlink" title="4.2 逻辑设计和硬件控制语言HCL"></a>4.2 逻辑设计和硬件控制语言HCL</h5><h6 id="逻辑门"><a href="#逻辑门" class="headerlink" title="逻辑门"></a>逻辑门</h6><p><img src="/../icsmg/20221119153513.png"><br>组合电路要求：<br>$\quad$ 1）每个逻辑门的输入必须连接到系统输入或者存储器输出或逻辑门输出上<br>$\quad$ 2） 逻辑门的输出不能连在一起<br>$\quad$ 3）网必须是无环的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c">HCL：<br>数据类型：<span class="hljs-type">bool</span>, <span class="hljs-type">int</span><br>操作<br>简单的布尔表达式:    <span class="hljs-type">bool</span> out = (s&amp;&amp;a)||(!s&amp;&amp;b)<br>情况表达式（多选器） word out = [select1 : expr1, select2 : expr2 ... ]<br>集合关系 <span class="hljs-type">bool</span> s = code in &#123; item1, item2, ... &#125;<br>与C语言逻辑运算的区别<br>组合电路输出持续响应输入的变化<br>HCL无C语言中的“短路”，不会部分求值<br></code></pre></td></tr></table></figure><p>存储器<br>$\quad$ 分为时钟存储器和随机访问存储器</p><h5 id="4-3-Y86-64程序的实现"><a href="#4-3-Y86-64程序的实现" class="headerlink" title="4.3  Y86-64程序的实现"></a>4.3  Y86-64程序的实现</h5><p>$\quad$ 描述一个SEQ的处理器</p><h6 id="4-3-1-将处理组织成阶段"><a href="#4-3-1-将处理组织成阶段" class="headerlink" title="4.3.1  将处理组织成阶段"></a>4.3.1  将处理组织成阶段</h6><p>$\quad$ 1.取指（fetch）：从内存读取指令字节，地址为PC的值。从指令中抽取出指令指示符字节的两个四位部分，icode（指令代码）和ifun（指令功能）。可能取出一个寄存器指示符字节，指明一个或两个寄存器操作数指示符rA和rB。还可能取出个8字节常数字valC，计算出下一条指令地址valP。即valP等于PC+已执行操作的字节</p><p>$\quad$ 2.译码（decode）：从寄存器文件读入最多两个操作数，得到valA和&#x2F;或valB</p><p>$\quad$ 3.执行（execute）ALU进行指令指明的操作或对栈指针进行增减，同时可能设置条件码</p><p>$\quad$ 4.访存（memory） 将数据写入内存或读出数据</p><p>$\quad$ 5.写回（write back）将结果写回寄存器文件</p><p>$\quad$ 6.更新PC（PCupdate）将PC设置成下一条指令的地址</p><p>例：<br><img src="/../icsmg/20221119153959.png"><br><img src="/../icsmg/20221119155842.png"><br><img src="/../icsmg/20221119155911.png"><br><img src="/../icsmg/20221119155923.png"><br>$\quad$ 其中PC 、rA、rB、OP等在运算中都是具体的值。</p><p>$\quad$ 整数操作指令遵循上面列出的通用模式。</p><p>如<br><img src="/../icsmg/20221119155946.png"><br>$\quad$ 其他的操作同理。</p><h6 id="4-3-2-SEQ硬件结构"><a href="#4-3-2-SEQ硬件结构" class="headerlink" title="4.3.2  SEQ硬件结构"></a>4.3.2  SEQ硬件结构</h6><p><img src="/../icsmg/20221119160543.png"></p><p>$\quad$ 取指：将程序计数器寄存器作为地址</p><p>$\quad$ 译码：寄存器文件有两个读端口A和B，从这两个端口分别读取寄存器值valA和valB</p><p>$\quad$ 执行：ALU执行，CC为条件码寄存器</p><p>$\quad$ 访存：访问内存，进行写入或者读</p><p>$\quad$ 写回：寄存器文件有两个写端口，E用来写入ALU计算出的值，M用来写从数据内存中读出来的值</p><p>$\quad$ PC更新：valP：下一条指令的地址；valC：调用指令或跳转指令制定的目标地址；valM：从内存读取的返回地址</p><h6 id="4-3-3-SEQ的时序"><a href="#4-3-3-SEQ的时序" class="headerlink" title="4.3.3 SEQ的时序"></a>4.3.3 SEQ的时序</h6><p>$\quad$ 原则：从不回读（处理器从来不需要为了完成一条指令的执行而去读由该指令更新了的状态）<br>例：没有指令既设置又读取条件码</p><h6 id="4-3-4-SEQ阶段的实现"><a href="#4-3-4-SEQ阶段的实现" class="headerlink" title="4.3.4 SEQ阶段的实现"></a>4.3.4 SEQ阶段的实现</h6><p><img src="/../icsmg/20221119160132.png"><br>$\quad$ 1.取指阶段：以PC作为字节0的地址，一次从内存读出10个字节。第一个字节被解释成指令字节，然后icode和ifun的控制逻辑块计算指令和功能码。</p><p>$\quad$ instr_valid：指令非法</p><p>$\quad$ need_regids:包含寄存器指示符字节</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs hcl">bool need_regids=&#123;<br>    icode in&#123;IRRMOVLQ,IOPQ,IPUSHQ,IPOPQ,<br>        IIRMOVQ,IRMMOVQ,IMRMOVQ&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>$\quad$ need_valC:包含常数字节</p><p> $\quad$ 剩下9个字节是寄存器指示符字节和常数字节的组合编码。</p><p>$\quad$ 若need_regids为1，则字节1被分开装入rA和rB中，否则设为0xFF</p><p>$\quad$ 产生常数valC根据need_regids的值由2～9或者1～8产生<br><img src="/../icsmg/20221119160213.png"><br>$\quad$ PC值为p+1+r+8i（r为need_regids的值，i为need_valC的值，p为初始PC）</p><p>$\quad$ 2.译码和写回阶段：从寄存器文件中读取数据，寄存器文件有四个端口，读端口的地址输入为srcA和srcB，写端口的地址输入为dstE和dstM。读出的数值通过valA和valB输出，写入的数值通过valM和valE</p><p><img src="/../icsmg/20221119160237.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs hcl">word srcA=&#123;<br>    icode in &#123;IRRMOVQ,IRMMOVQ,IOPQ,IPUSHQ&#125;:rA;<br>    icode in&#123;IPOPQ,IRET&#125;:RRSP;<br>    1:RNONE;#Don&#x27;t need register<br>&#125;<br>#warning :conditional move not implemented correctly here<br>word destE=&#123;<br>    icode in&#123;IRRMOVQ&#125;:rB;<br>    icode in &#123;IIRMOVQ,IOPQ&#125;:rB;<br>    icode in &#123; IPUSHQ,IPOPQ,ICALL,IRET&#125;:RRSP;<br>    1:RNONE;#Don&#x27;t need register<br>&#125;<br></code></pre></td></tr></table></figure><p> 3.执行阶段：</p><p>$\quad$ 对输入的aluA和aluB进行算数与逻辑运算<br><img src="/../icsmg/20221119160348.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs hcl">word aluA=&#123;<br>    icode in&#123;IRRMOVQ,IOPQ &#125;:valA;<br>    icode in&#123;IIRMOVQ,IRMMOVQ,IMRMOVQ&#125;:valC;<br>    icode in &#123;ICALL,IPUShQ&#125;:-8;<br>    icode in &#123;IRET,IPOPQ&#125;:8;<br>    #other instructions don&#x27;t need ALU<br>&#125;<br>bool set_cc = icode in &#123;IOPQ&#125;;//仅运算改变条件码寄存器<br></code></pre></td></tr></table></figure><p>4.访存阶段</p><p>$\quad$ 从内存读入或者把数据写入内存中</p><p>$\quad$ 进行读时产生valM<br><img src="/../icsmg/20221119160328.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs hcl">word mem_addr=[<br>    icode in &#123;IRMMOVQ,IPUSHQ,ICALL,IMRMOVQ&#125;:valE;<br>    icode in&#123;IPOPQ,IRET&#125;:valA;<br>#Other instructions don&#x27;t need address<br><br>];<br>bool mem_read=[<br>    icode in&#123;IMRMOVQ,IPOPQ,IRET&#125;;<br>]//只读数据<br></code></pre></td></tr></table></figure><p>5.更新PC状态<br><img src="/../icsmg/20221119160424.png"><br>新PC可能是valC，valM或valP</p><p>$\quad$ 当正在执行call或者满足跳转条件即将跳转时，PC为valC，正在执行RET，valM，其他为当前PC加当前指令长度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs hcl">word new_PC=[<br>    icode == ICALL:valC;<br>    icode == IJXX&amp;&amp;Cnd:valC;<br>    icode == IRET:valM;<br>    #default <br>    1:valP;<br>]<br></code></pre></td></tr></table></figure><p>总结<br><img src="/../icsmg/20221119160037.png"></p><h5 id="4-4-流水线的通用原理"><a href="#4-4-流水线的通用原理" class="headerlink" title="4.4 流水线的通用原理"></a>4.4 流水线的通用原理</h5><p>$\quad$ 我们用每秒千兆条指令（GIPS），也就是每秒十亿条指令，为单位来描述吞吐量。延迟为吞吐量的倒数。</p><p>$\quad$ 吞吐量&#x3D;1&#x2F;（执行时间+延迟）</p><p>$\quad$ 画出流程图进行分析</p><p>v指令的转移由时钟信号决定</p><h5 id="4-5-Y86-64的流水线实现"><a href="#4-5-Y86-64的流水线实现" class="headerlink" title="4.5 Y86-64的流水线实现"></a>4.5 Y86-64的流水线实现</h5><p>$\quad$ 将更新PC放在一个时钟周期的开始时执行</p><p> $\quad$ 实现方法：创建一个寄存器来保存指令在执行过程中产生的信号，标号为前面加个p：电路重定时</p><p> $\quad$ 流水线寄存器：</p><p>$\quad$ F：保存程序计数器的预测值</p><p>$\quad$ D：位于取指和译码之间，保存最新取出的指令的信息</p><p>$\quad$ E：位于译码和执行之间，保存关于最新译码的指令和从寄存器文件中读出的值的信息</p><p>$\quad$ M ：位于执行和访存之间，保存最新执行的指令的结果</p><p>$\quad$ W：位于访存和反馈路径之间<br><img src="/../icsmg/20221119160847.png"><br> $\quad$ 流水线冒险<br><img src="/../icsmg/20221119161037.png"></p><p>$\quad$ 存在数据相关或者控制相关，会产生错误的结果</p><p>$\quad$ 指令在译码阶段读取寄存器时， 寄存器的ID分别与执行阶段，访存阶段以及写回阶段的目的寄存器进行比较 ，若相等则存在数据相关。</p><p>$\quad$ 1.用暂停来避免数据冒险</p><p>         stalling； 让一条指令停止在译码阶段，直到产生它的源操作数的指令通过了写回阶段</p><p>$\quad$ 方法：插入气泡（bubble）气泡会占据周期<br><img src="/../icsmg/20221119161100.png"><br>$\quad$ 用暂停实现会严重降低流水线的吞吐量</p><p>$\quad$ 2.用转发来避免数据冒险</p><p>$\quad$   $\quad$ 转发在基本的硬件结构里添加了额外的数据链接与控制逻辑</p><p>$\quad$ 增加逻辑块Sel+FwdA和FwdB<br><img src="/../icsmg/20221119161146.png"><br>$\quad$ 不能单用转发解决的，暂停和转发结合使用</p><p>控制冒险：</p><p>$\quad$ 取指出现ret指令（暂停处理新指令直到ret到达写回阶段）</p><p>$\quad$ 出现jxx指令：分支预测</p><p>$\quad$ 假设总是进行跳转；若到达执行阶段发现预测错误则取消这些指令</p><p><strong>PIPE各阶段的实现</strong></p><p>$\quad$ 1.PC选择和取指阶段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs hcl">word f_pc&#123;<br>    M_icode == IJXX &amp;&amp; !M_Cnd:M_valA;<br>    W_icode == IRET :W_valM;<br>    1：F_predPC;<br>&#125;;<br>word f_predPC =[<br>    f_icode in &#123;IJXX,ICALL&#125;:f_valC;<br>    1:f_valP;<br>];<br></code></pre></td></tr></table></figure><p>$\quad$ 2.译码和写回阶段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs hcl">//译码阶段由于加入了转发变得复杂<br>word d_valA =[<br>    D_icode in &#123;ICALL,IJXX&#125;:D_valP;<br>    d_srcA == e_dstE :e_valE ;//优先级执行优先<br>    d_srcA == M_dstM : m_valM ;//访存次之<br>    d_srcA == M_dstE : M_valE;<br>    d_srcA == W_dstM : W_valM;//写回最次，先M后E<br>    d_secA == W_dstE :W_valE;<br>    1:d_rvalA;<br>]<br></code></pre></td></tr></table></figure><p>$\quad$ 3.执行阶段</p><p>$\qquad$ 与SEQ差别不大</p><p>$\quad$ 4.访存阶段</p><p>$\qquad$ 差别不大</p><p><strong>性能分析</strong></p><p>$\quad$ 一个阶段处理了$C_i$条指令和$C_b$个气泡</p><p>$\quad$ CPI &#x3D; 1+Cb&#x2F;Ci</p><p>估算：</p><p>$\quad$ 加载指令（mrmovq和popq）占执行指令的25%，20%会导致冒险1气泡</p><p>$\quad$ 条件分支指令占20%，40%不选择分支，2气泡</p><p>$\quad$ 返回指令占2% 3气泡</p><p>$\quad$ CPI&#x3D;1+$\sum$ 指令频率x条件频率x气泡数</p><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3-程序的机器级表示</title>
    <link href="/2023/02/18/3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/"/>
    <url>/2023/02/18/3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="对应-CSAPP-第三章节"><a href="#对应-CSAPP-第三章节" class="headerlink" title="对应 CSAPP 第三章节"></a>对应 CSAPP 第三章节</h2><span id="more"></span><h1 id="ICS"><a href="#ICS" class="headerlink" title="ICS"></a><a href="https://aki-yzh.github.io/2023/02/18/1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8&%E7%9B%AE%E5%BD%95">ICS</a></h1><hr><h3 id="三、程序的机器级表示"><a href="#三、程序的机器级表示" class="headerlink" title="三、程序的机器级表示"></a>三、程序的机器级表示</h3><p>$\quad$ 忽略以.开头的伪指令</p><p>$\quad$ 指令分为 操作码与操作数两部分 </p><p>$\quad$ PC    用%rip表示，给出将要执行的下一条指令在内存中的地址</p><p>$\quad$ 整数寄存器文件用来存放整数数据和指针<br><img src="/../icsmg/20221119161455.png"><br>$\quad$ 条件码寄存器 存储算数或逻辑指令的状态信息</p><p>$\quad$ 调用者保存（caller）：调用函数前保存寄存器的值</p><p>$\quad$ 被调用者保存（callee）：在调用函数时保存寄存器的值<br><img src="/../icsmg/20221119161346.png"><br>$\quad$ 一般用开头的pushq和结尾的popq实现</p><p>数据大小：</p><p>$\quad$ 用字表示16位的数据类型大小，用双字表示32位，四字表示64位。<br><img src="/../icsmg/20221119161430.png"><br><strong>寄存器</strong><br><img src="/../icsmg/20221119161646.png"><br>$\quad$ r8～r15 无后缀64位，后缀b8位，w16位，d32位</p><p>$\quad$ rax用来保存函数的返回值，rsp保存程序栈的结束位置，其他六个用于传参，rbx和rbp保存被调用者，rdi，rsi，rdx，rcx用于第1，2，3，4个参数的保存。</p><p>$\quad$ 描述中用R[%r]表示寄存器%r的值</p><p>$\quad$ 当指令以寄存器作为操作目标时，对于生成小于8字节结果的指令：生成1字节和2字节数字的指令会保持剩下的字节不变，生成4字节数字的指令会把高位4个字节设置为0</p><h4 id="操作数"><a href="#操作数" class="headerlink" title="操作数"></a>操作数</h4><p>$\quad$ 大致分为3类：立即数（$接整数），寄存器，内存引用（比如寄存器外加小括号(%rdi)等）</p><p>$\quad$ 一般用M[addr]表示从addr开始b个字节值的引用</p><p>$\quad$ 常用$Imm(r_b,r_i.s)$表示，Imm表示立即数，rb是基址寄存器，ri是变址寄存器，s是比例因子，必须为1，2，4或者8。rb和ri都必须是<strong>64位寄存器</strong>&#x2F;&#x2F;考察点</p><p>$\quad$ 有效地址计算为 Imm+rb+ri*s；<br><img src="/../icsmg/20221119161822.png"><br>$\quad$ 需要特别注意不带$的立即数和带了括号的寄存器都是内存引用</p><h4 id="数据传输指令"><a href="#数据传输指令" class="headerlink" title="数据传输指令"></a>数据传输指令</h4><p> $\quad$ 将数据从一个位置移动到另一个位置的指令</p><p>$\quad$ 有movb，movw，movl，movq四种，区别在于移动数据的大小不同。<br><img src="/../icsmg/20221119162028.png"><br>$\quad$ 含有两个操作数：源操作数与目的操作数</p><p>$\quad$ MOV            源操作数 （立即数，寄存器或内存）          目的操作数（寄存器或内存引用，用于存放源操作数）</p><p>$\quad$ 源操作数和目的操作数不能都是内存引用</p><p>$\quad$ MOV指令只会改变目的操作数，movl除外，会把源操作数高位4字节设为0</p><p>$\quad$ $\quad$ movq移动32位补码数的立即数时先符号扩展再进行移动</p><p>$\quad$ $\quad$ movavsq 移动64位立即数，目的操作数只能是寄存器。</p><p>MOVZ类：</p><p>$\quad$ 两个字母一个表示源操作数的大小，第二个表示目的操作数的大小，做0扩展</p><p>MOVS类同理，做符号位扩展                </p><h4 id="栈指令"><a href="#栈指令" class="headerlink" title="栈指令"></a>栈指令</h4><p>$\quad$ popq 将四字弹栈，栈指针加8，相当于subq $8 ,%rsp    movq %rbp  ,(%rsp)</p><p>$\quad$ pushq 将四字压栈，栈指针减8,相当于 movq (%rsp),%rax  addq $8,%rsp</p><p>$\quad$ 栈放在内存的某个区域</p><h4 id="算数和逻辑操作"><a href="#算数和逻辑操作" class="headerlink" title="算数和逻辑操作"></a>算数和逻辑操作</h4><p>$\quad$ 大写表示一个操作类 操作码为后面加上一个字母表示操作数的大小</p><p>     加载有效地址  leaq</p><p>leaq    S，D  实际上是movq指令的变形 效果D&#x3D;&amp;S</p><p>$\quad$ 并不是从内存地址读取数据，直接赋予有效地址给D就行</p><p>$\quad$ 如  leaq 7（%rdx,%rdx,2),%rax  （若%rdx值为x）表示 将%rax赋值为7+3x</p><p>leaq用于实现加法与有限形式的乘法</p><p>一元操作：<br><img src="/../icsmg/20221119162119.png"><br>二元操作：<br><img src="/../icsmg/20221119162128.png"><br>移位操作：<br><img src="/../icsmg/20221119162143.png"><br>$\quad$ &#x2F;&#x2F;A代表arithmetical代表算数<br>特殊的算数操作<br><img src="/../icsmg/20221119162241.png"></p><h4 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h4><p>条件码    长度只有1个bit</p><p>CF：最近的操作使最高位产生了进位，可以检查无符号操作的溢出</p><p>ZF：0标志，最近操作结果为0</p><p>SF：符号标志，最近操作结果为负数</p><p>OF：溢出标志，最近操作使补码溢出</p><p>$\quad$ 以下算数逻辑运算会改变条件码寄存器的值<br><img src="/../icsmg/20221119162507.png"><br>还有两类指令能设置条件码寄存器<br>CMP指令和TEST指令</p><p>$\quad$ CMP根据两个操作数的差来设置条件码寄存器，和减法指令区别在不会改变操作数的值</p><p>$\quad$ TEXT指令则比较两个数是否一样，同样是只设置条件码</p><p>SET指令调用条件码</p><p>$\quad$ set D    D被设为为1或0</p><p>$\quad$ SET前常接CMP指令</p><p>$\quad$ SET后接的字母         l：less（有符号）    g：greater  （有符号） e:equal      n:not     s:负数    a:above无符号大于    b：below无符号小于</p><h4 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h4><p>$\quad$ jmp无条件跳转</p><p>$\quad$ jmp后直接接地址表示直接跳转，接*表示间接跳转</p><p>$\quad$ 其他的j后接跳转条件，字母与set后接的代表一致</p><p>$\quad$ 跳转指令勇于实现跳转与分支，循环（将循环化成goto再化成汇编）</p><p>$\quad$ switch的实现通过跳转表实现。jmp  * .Ln（，%r，k   ）        .Ln表示跳转表的名称，%r标志switch的n所在的寄存器，k一般为8以模拟case0<br><img src="/../icsmg/20221119162325.png"></p><h4 id="条件传送指令"><a href="#条件传送指令" class="headerlink" title="条件传送指令"></a>条件传送指令</h4><p>$\quad$ cmov后接字母，表示与上述一致，对所有的操作数长度适用。<br><img src="/../icsmg/20221119162341.png"></p><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><p><img src="/../icsmg/20221119162850.png"><br>$\quad$ call    调用函数</p><p>$\quad$ ret 从过程调用中返回</p><p>$\quad$ 如果一个函数有大于6个整型参数，超出6个的部分则需要通过栈来传递。</p><p>$\quad$ 局部变量不需要对齐，而传递的参数需要对齐<br><img src="/../icsmg/20221119162822.png"></p><h4 id="数组的分配和访问"><a href="#数组的分配和访问" class="headerlink" title="数组的分配和访问"></a>数组的分配和访问</h4><p>$\quad$ 起始地址为 $x_0$ ,数组元素i被存放在 $x_0$ +L*i处</p><p>$\quad$ *可以理解为从地址中取数据</p><p>$\quad$ 嵌套数组：a[i][j]看作是有i个元素的数组，每个元素都是j个int的数组，线性排列</p><h4 id="异质的数据结构"><a href="#异质的数据结构" class="headerlink" title="异质的数据结构"></a>异质的数据结构</h4><p>$\quad$ struct结构体：每个元素各占一个区域</p><p>$\quad$ union联合:所有字段共享存储区域，联合体的大小取决于最大字段的大小，应用于事先知道几个字段的存在是互斥的</p><p>数据对齐</p><table><thead><tr><th>K</th><th>type</th></tr></thead><tbody><tr><td>1</td><td>char</td></tr><tr><td>2</td><td>short</td></tr><tr><td>4</td><td>int ,float</td></tr><tr><td>8</td><td>long,double,char*</td></tr></tbody></table><p>$\quad$ .align 8表示使其后面的数据起始地址是8的倍数</p><p>$\quad$ 对于结构体，每个元素后要满足下一个元素的对齐要求，（即下一个元素的起始地址必须是其对应的K的倍数）总的内存长度要满足所有元素的对齐要求。</p><h4 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h4><p>$\quad$ 解决方法：栈随机化，栈破坏检测（金丝雀值：在底部存储一个特殊值），限制可执行代码区域</p><p><img src="/../icsmg/20221119162958.png"></p><hr><h3 id="LAB"><a href="#LAB" class="headerlink" title="LAB:"></a>LAB:</h3><p><strong>此章节后完成<a href="https://github.com/Aki-yzh/PKU-ICS-2022/tree/main/LABS/2-bomblab">bomblab(70.0&#x2F;70.0)</a>与<a href="https://github.com/Aki-yzh/PKU-ICS-2022/tree/main/LABS/3-attacklab">attacklab(105.0&#x2F;105.0)</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2-信息的表示与处理</title>
    <link href="/2023/02/18/2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/"/>
    <url>/2023/02/18/2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="对应-CSAPP-第二章节"><a href="#对应-CSAPP-第二章节" class="headerlink" title="对应 CSAPP 第二章节"></a>对应 CSAPP 第二章节</h2><span id="more"></span><h1 id="ICS"><a href="#ICS" class="headerlink" title="ICS"></a><a href="https://aki-yzh.github.io/2023/02/18/1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8&%E7%9B%AE%E5%BD%95">ICS</a></h1><hr><h3 id="二、信息的表示与处理"><a href="#二、信息的表示与处理" class="headerlink" title="二、信息的表示与处理"></a>二、信息的表示与处理</h3><h4 id="1-信息的存储"><a href="#1-信息的存储" class="headerlink" title="1.信息的存储"></a>1.信息的存储</h4><p>$\quad$ 机器级程序将内存视为一个非常大的字节数组，称为虚拟内存。所有可能地址的集合称为虚拟地址空间。</p><p>$\quad$ 字节：信息存储的基本单元，由8个位组成，每个位为0或1。</p><p>$\quad$ 十六进制数 ：0x开头，数字0～9，字母A～F可大写可小写。</p><p>进制间的转换</p><p>$\quad$ 对于一个字长为w的机器来说，虚拟地址的范围为0～$2^w-1$ ,程序最多访问$2^w$个字节</p><p>$\quad$ 32位字长限制虚拟地址空间位4GB，扩展到64位有16EB</p><p>$\quad$ 64位机器做了向后兼容，能运行32位机器程序，32位则不能反之。</p><p><img src="/../icsmg/20221119163733.png"></p><p>寻址和字节顺序</p><p><img src="/../icsmg/20221119163748.png"><br>$\quad$ 大端法：顺着读</p><p>$\quad$ 小端法：以字节为单位倒着读</p><p>$\quad$ 大多数Intel兼容机、Andriod、IOS都适用小端法，IBM和Oracle按照大端法。</p><p>位运算（返回一个数）</p><p>$\quad$ ～取反           ｜或          &amp;与      ^异或</p><p>逻辑运算（返回0x01或0x00）</p><p>$\quad$ &amp;&amp; 且     ｜｜或       ！非</p><p>移位运算</p><p>$\quad$ &lt;&lt;左移             &gt;&gt;右移（分为逻辑右移和算数右移，逻辑右移直接移，算数右移高位补k个最高有效位的值。（有符号数算数右移，无符号数逻辑右移））</p><h4 id="2-整数-Integer"><a href="#2-整数-Integer" class="headerlink" title="2. 整数 Integer"></a>2. 整数 Integer</h4><p>$\quad$ Java只支持有符号整数</p><p><strong>无符号数的编码</strong></p><p>$\quad$ B2U&#x3D;$\sum_{i&#x3D;0}^{w-1}x_i*2^i$</p><p>$\quad$ 函数B2U是一个双射</p><p><strong>补码编码</strong></p><p>$\quad$ $B2T_w&#x3D;-x_{w-1}2^{w-1}+\sum_{i&#x3D;0}^{w-2}x_i2^i$</p><p>$\quad$ 最高位$x^{w-1}$也称为符号位，若符号位为0则和无符号数编码表示差不多</p><p>$\quad$ B2$T_w$也是个双射，补码的范围是不对称的<br><img src="/../icsmg/20221119163707.png"><br> <strong>有符号数与无符号数之间的转换</strong></p><p> $\quad$ 强制类型转换的结果保持位值不变，只是改变了这些位的解释方式。</p><p>$\quad$ 无符号数与补码的转换关系：</p><p>$\quad$ U表示无符号数<br><img src="/../icsmg/20221119163815.png"><br>对于C语言中： </p><p>$\quad$ 若双方中同时存有无符号数与有符号数，C语言会隐式的将有符号数强制转换成无符号数来执行运算比如&gt;和&lt;运算。若双方都是U或都是T则用原来的处理。</p><p> <strong>数字的扩展</strong></p><p>$\quad$ 无符号数零扩展：在表示的开头补0</p><p>$\quad$ 有符号数的符号扩展：扩展的数位补符号位</p><p><strong>截断数字</strong></p><p>$\quad$ 直接把前k位舍弃</p><p>数值上：</p><p>$\quad$ 截断无符号数：（相当于取模$2^k$)</p><p>$\quad$ 截断有符号数：相当于视为无符号数处理后再转换为无符号数。</p><p><strong>整数的运算</strong></p><p>$\quad$ 无符号数加法<br><img src="/../icsmg/20221119163843.png"><br>$\quad$ 正常：直接相加                        溢出：减去$2^w$（即为扔去溢出位）</p><p>$\quad$ 判断无符号加法溢出：return sum&gt;&#x3D;x;(true 表示未溢出)</p><p>求反：<br><img src="/../icsmg/20221119163857.png"></p><p>$\quad$ 有符号数的加法</p><p>$\quad$ 分为正溢出和负溢出<br><img src="/../icsmg/20221119163911.png"><br>$\quad$ 补码加法和无符号加法有完全相同的位级表示</p><p>取反：<br><img src="/../icsmg/20221119163935.png"><br>$\quad$ Tmin&#x3D;0x8000000</p><p>无符号乘法：</p><p>$\quad$ 截取运行结果的低w位$(x·y)mod2^w$</p><p>补码乘法：</p><p>$\quad$ 与无符号乘法位级表示一样，数值上多一步转换成无符号数</p><p>$\quad$ 乘2的幂相当于左移操作，乘常数就可以分解成移位和加法</p><p>除法</p><p>$\quad$ 除以2的幂：</p><p>$\quad$ 采用右移，无符号数逻辑右移，朝着向0的方向进行舍入。有符号数算数右移，也朝0舍入，所以会在移位之前加入一个偏置来修正。偏置的值等于1左移k位减1。&#x2F;&#x2F;只有负数需要用偏置</p><p>$\quad$ 不能推广到任意常数。</p><h4 id="3-浮点数"><a href="#3-浮点数" class="headerlink" title="3.  浮点数"></a>3.  浮点数</h4><p>$\quad$ 二进制小数：.后为2的负幂如（1&#x2F;8）&#x3D; $（0.001）_2$</p><p>IEEE浮点表示：</p><p>$V&#x3D;(-1)^s<em>M</em>2^E$</p><p>$\quad$ s为符号位；M是尾数，是二进制小数；E是阶码<br><img src="/../icsmg/20221119164129.png"><br>$\quad$ float 1-8-23</p><p>$\quad$ double 1-11-52</p><p>$\quad$ exp是无符号数</p><p>分类<br><img src="/../icsmg/20221119164142.png"></p><p>$\quad$ 规格化的值：exp不为0或255</p><p>$\quad$ 非规格化的值：exp为0</p><p>$\quad$ 无穷大：exp为255（全是1），frac全为0</p><p>$\quad$ NaN：exp为255，frac不为0</p><p><strong>表示规格化的值时：</strong></p><p>$\quad$ 阶码字段为以偏置形式表示的有符号整数，E&#x3D;e-Bias</p><p>$\quad$ $e\in[1,254],Bias&#x3D;2^{k-1}-1$(单精度为127，双精度为1023)</p><p> $\quad$ $E\in[-126,127]$ (float),$E\in<a href="double">-1022,1023</a>$，$M\in[1,2)$<br><img src="/../icsmg/20221119164220.png"></p><p><strong>表示非规格化的值时：</strong></p><p>$\quad$ exp，s，frac全为0，表示+0，s&#x3D;1，frac，exp为0，表示-0</p><p>$\quad$ 此时M&#x3D;f；E&#x3D;1-Bias</p><p><strong>特殊值</strong>： 表示无穷大</p><p><strong>浮点数舍入</strong></p><p>$\quad$ 1. 向偶数舍入</p><p>   $\quad$ 向最近值进行舍入，为0.5则遵循最低有效数位是偶数</p><p>$\quad$ 2. 向0舍入</p><p>$\quad$ 3. 向下舍入</p><p>$\quad$ 4. 向上舍入</p><p>  $\quad$ 浮点数运算不具有结合性与分配性，因为可能出现溢出和舍入。</p><hr><h3 id="LAB"><a href="#LAB" class="headerlink" title="LAB:"></a>LAB:</h3><p><strong>此章节后完成<a href="https://github.com/Aki-yzh/PKU-ICS-2022/tree/main/LABS/1-datalab">datalab（80.0&#x2F;80.0）</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1-计算机系统漫游&amp;目录</title>
    <link href="/2023/02/18/1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8&amp;%E7%9B%AE%E5%BD%95/"/>
    <url>/2023/02/18/1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%BC%AB%E6%B8%B8&amp;%E7%9B%AE%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="对应-CSAPP-第一章节"><a href="#对应-CSAPP-第一章节" class="headerlink" title="对应 CSAPP 第一章节"></a>对应 CSAPP 第一章节</h2><span id="more"></span><h1 id="ICS"><a href="#ICS" class="headerlink" title="ICS"></a>ICS</h1><hr><h2 id="计算机系统漫游"><a href="#计算机系统漫游" class="headerlink" title="计算机系统漫游"></a>计算机系统漫游</h2><p>$\quad$ 对32位机器，一个word占4字节；对64位机器，一个word占8个字节*</p><p>$\quad$ 8个位为1字节即对16进制编码00为一个字节</p><h4 id="Amahl定律"><a href="#Amahl定律" class="headerlink" title="Amahl定律"></a>Amahl定律</h4><p>$\quad$ 加速比$S&#x3D;T_{old}&#x2F;T_{new}&#x3D;1&#x2F;((1-\alpha)+\alpha&#x2F;k)$  </p><p>$\quad$ $\alpha$为某部分执行时间与$T_{old}$的比，k为该部分性能提升比例</p><hr><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><h3 id="一、程序结构与执行"><a href="#一、程序结构与执行" class="headerlink" title="一、程序结构与执行"></a>一、程序结构与执行</h3><h4 id="2-信息的表示与处理"><a href="#2-信息的表示与处理" class="headerlink" title="2. 信息的表示与处理"></a>2. <a href="https://aki-yzh.github.io/2023/02/18/2-%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E4%B8%8E%E5%A4%84%E7%90%86">信息的表示与处理</a></h4><h4 id="3-程序的机器级别表示"><a href="#3-程序的机器级别表示" class="headerlink" title="3. 程序的机器级别表示"></a>3. <a href="https://aki-yzh.github.io/2023/02/18/3-%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA">程序的机器级别表示</a></h4><h4 id="4-处理器体系结构"><a href="#4-处理器体系结构" class="headerlink" title="4. 处理器体系结构"></a>4. <a href="https://aki-yzh.github.io/2023/02/18/4-%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">处理器体系结构</a></h4><h4 id="5-优化程序性能"><a href="#5-优化程序性能" class="headerlink" title="5. 优化程序性能"></a>5. <a href="https://aki-yzh.github.io/2023/02/18/5-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD">优化程序性能</a></h4><h4 id="6-存储器层次结构"><a href="#6-存储器层次结构" class="headerlink" title="6. 存储器层次结构 "></a>6. <a href="https://aki-yzh.github.io/2023/02/18/6-%E5%AD%98%E5%82%A8%E5%99%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84">存储器层次结构 </a></h4><h3 id="二、在系统上运行程序"><a href="#二、在系统上运行程序" class="headerlink" title="二、在系统上运行程序"></a>二、在系统上运行程序</h3><h4 id="7-链接"><a href="#7-链接" class="headerlink" title="7. 链接"></a>7. <a href="https://aki-yzh.github.io/2023/02/18/7-%E9%93%BE%E6%8E%A5">链接</a></h4><h4 id="8-异常控制流"><a href="#8-异常控制流" class="headerlink" title="8. 异常控制流"></a>8. <a href="https://aki-yzh.github.io/2023/02/18/8-%E5%BC%82%E5%B8%B8%E6%8E%A7%E5%88%B6%E6%B5%81">异常控制流</a></h4><h4 id="9-虚拟内存"><a href="#9-虚拟内存" class="headerlink" title="9. 虚拟内存"></a>9. <a href="https://aki-yzh.github.io/2023/02/18/9-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98">虚拟内存</a></h4><h3 id="三、程序间的交互和通信"><a href="#三、程序间的交互和通信" class="headerlink" title="三、程序间的交互和通信"></a>三、程序间的交互和通信</h3><h4 id="10-系统级I-x2F-O"><a href="#10-系统级I-x2F-O" class="headerlink" title="10. 系统级I&#x2F;O"></a>10. <a href="https://aki-yzh.github.io/2023/02/18/10-%E7%B3%BB%E7%BB%9F%E7%BA%A7IO">系统级I&#x2F;O</a></h4><h4 id="11-网络编程"><a href="#11-网络编程" class="headerlink" title="11. 网络编程"></a>11. <a href="https://aki-yzh.github.io/2023/02/18/11-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B">网络编程</a></h4><h4 id="12-并发编程"><a href="#12-并发编程" class="headerlink" title="12. 并发编程"></a>12. <a href="https://aki-yzh.github.io/2023/02/18/12-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B">并发编程</a></h4><hr>]]></content>
    
    
    <categories>
      
      <category>CS学习</category>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSAPP</tag>
      
      <tag>目录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Helloworld</title>
    <link href="/2023/01/22/hello-world/"/>
    <url>/2023/01/22/hello-world/</url>
    
    <content type="html"><![CDATA[<p>This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>$i_8$</p><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
